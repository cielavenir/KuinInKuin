"use strict";function kuin(O_){
let m=0;
let s=false;
let x=false;
let y=null;
let F=false;
let I=null;
let J=null;
let K=null;
let L=null;
let M=null;
let N=null;
let O=null;
let P=null;
let Q=null;
let R=null;
let S=null;
let T=null;
let U=null;
let V=null;
let W=null;
let X=null;
let Y=null;
let Z=null;
let aa=null;
let ab=null;
let ac=null;
let ad=null;
let ae=null;
let af=null;
let ag=null;
let ah=null;
let ai=null;
let aj=null;
let ak=null;
let al=null;
let am=null;
let an=null;
let ao=null;
let ap=null;
let aW=false;
let b5=false;
let bL=0;
let bW=0;
let c0=0;
let eT=0;
let pH=0;
let pI=0;
let pJ=0;
let pK=0;
let pL=false;
let pM=0;
// $
function a(){
let c=0; // $
try{
(e)();
(f)();
(g)();
}catch(c){
if((0)<=c&&c<=(4294967295)){
(i)((c));
}
else{
throw c;
}
}
finally{
(k)();
(l)();
}
}
// _init
function e(){
}
// _initVars
function f(){
(m)=(1);
}
// main
function g(){
if(!((o)())){
(q)((1));
return;
}
if(s){
(u)(({S:({S:({S:"Kuin Programming Language v."}).S+((v)((2019),([0]))).S}).S+({S:({S:({S:"."}).S+((v)((10),([0]))).S}).S+({S:({S:({S:"."}).S+((v)((17),([0]))).S}).S+({S:"\u000A"}).S}).S}).S}));
(u)(({S:"(C)Kuina-chan\u000A"}));
(q)((0));
return;
}
if((x)||((y)===(null))){
(u)(({S:"Usage: kuincl [-i input.kn] [-o output.kn] [-s \'sys\' directory] [-c icon.ico] [-e environment] [-a appcode] [-r] [-h] [-v] [-q]\u000A"}));
(q)((0));
return;
}
if((B)()){
(D)((196609),(null),(null));
(q)((0));
return;
}
if(!(F)){
(D)((196610),(null),(null));
}
(q)((1));
}
// _err
function i(H /*excpt*/){
}
// _finVars
function k(){
(I)=(null);
(J)=(null);
(K)=(null);
(L)=(null);
(M)=(null);
(N)=(null);
(O)=(null);
(P)=(null);
(Q)=(null);
(R)=(null);
(S)=(null);
(T)=(null);
(U)=(null);
(y)=(null);
(V)=(null);
(W)=(null);
(X)=(null);
(Y)=(null);
(Z)=(null);
(aa)=(null);
(ab)=(null);
(ac)=(null);
(ad)=(null);
(ae)=(null);
(af)=(null);
(ag)=(null);
(ah)=(null);
(ai)=(null);
(aj)=(null);
(ak)=(null);
(al)=(null);
(am)=(null);
(an)=(null);
(ao)=(null);
(ap)=(null);
}
// _fin
function l(){
}
// acquireOption
function o(){
let aq=null; // cmdLines
let au=0;
let aw=null; // cmdLine
let a1=0;
let bc=null; // envStr
let by=null; // appCodeStr
let bB=null; // extra
let bO=null;
let cc=false; // success
let av=0;
let a4=false;
let a6=null;
let a7=0;
let aB=false;
let aC=null;
let aD=0;
let aH=false;
let aI=null;
let aJ=0;
let aN=false;
let aO=null;
let aP=0;
let aT=false;
let aV=false;
let ba=false;
let bb=null;
let bd=0;
let bh=false;
let bi=false;
let bm=false;
let bn=false;
let br=false;
let bs=false;
let bw=false;
let bx=null;
let bz=0;
let b3=false;
let b4=false;
let b9=false;
let bA=null;
let bC=0;
let bZ=0;
let cb=false;
(aq)=((ar)());
(Y)=(new Map());
at:
for(au=(0),av=(((aq).length)-(1));au<=av;au+=(1)){
(aw)=((aq)[au]);
if((((aw).S.length)===(2))&&(((aw).S.charCodeAt(0))===(0x002D))){
a0:
switch((aw).S.charCodeAt(1)){
case 0x0069:
if(!((a4=(a5)((a6={$:(y)},a6),(aq),(a7={$:(au)},a7),(a1)),(y)=a6.$,(au)=a7.$,a4))){
return false;
}
break;
case 0x006F:
if(!((aB=(a5)((aC={$:(V)},aC),(aq),(aD={$:(au)},aD),(a1)),(V)=aC.$,(au)=aD.$,aB))){
return false;
}
break;
case 0x0073:
if(!((aH=(a5)((aI={$:(W)},aI),(aq),(aJ={$:(au)},aJ),(a1)),(W)=aI.$,(au)=aJ.$,aH))){
return false;
}
break;
case 0x0063:
if(!((aN=(a5)((aO={$:(X)},aO),(aq),(aP={$:(au)},aP),(a1)),(X)=aO.$,(au)=aP.$,aN))){
return false;
}
break;
case 0x0072:
if(!((aT=(aU)((aV={$:(aW)},aV),(a1)),(aW)=aV.$,aT))){
return false;
}
break;
case 0x0065:
if(!((ba=(a5)((bb={$:(bc)},bb),(aq),(bd={$:(au)},bd),(a1)),(bc)=bb.$,(au)=bd.$,ba))){
return false;
}
break;
case 0x0068:
if(!((bh=(aU)((bi={$:(x)},bi),(a1)),(x)=bi.$,bh))){
return false;
}
break;
case 0x0076:
if(!((bm=(aU)((bn={$:(s)},bn),(a1)),(s)=bn.$,bm))){
return false;
}
break;
case 0x0071:
if(!((br=(aU)((bs={$:(F)},bs),(a1)),(F)=bs.$,br))){
return false;
}
break;
case 0x0061:
if(!((bw=(a5)((bx={$:(by)},bx),(aq),(bz={$:(au)},bz),(a1)),(by)=bx.$,(au)=bz.$,bw))){
return false;
}
break;
case 0x0064:
if(!((b3=(aU)((b4={$:(b5)},b4),(a1)),(b5)=b4.$,b3))){
return false;
}
break;
case 0x0078:
if(!((b9=(a5)((bA={$:(bB)},bA),(aq),(bC={$:(au)},bC),(a1)),(bB)=bA.$,(au)=bC.$,b9))){
return false;
}
(bE)((Y),([133,129,2,3]),(bB),(true));
break;
default:
(D)((2),(null),([({S:({S:({S:"-"}).S+((v)((a1),([2]))).S}).S+({S:""}).S})]));
return false;
break;
}
}
else{
(D)((2),(null),([({S:({S:({S:""}).S+((v)((aw),([129,2]))).S}).S+({S:""}).S})]));
return false;
}
}
if((y)===(null)){
return true;
}
if((bc)===(null)){
(bL)=(0);
}
else{
bO=bc;
if(bO.S===({S:"cui"}).S){
(bL)=(0);
}
else if(bO.S===({S:"wnd"}).S){
(bL)=(1);
}
else if(bO.S===({S:"web"}).S){
(bL)=(2);
}
else if(bO.S===({S:"cpp"}).S){
(bL)=(3);
}
else{(D)((1),(null),([({S:"-e"})]));
}
}
if((by)===(null)){
(bW)=((bX)((1),(4294967295)));
}
else{
(bW)=((bZ=(ca)((by),(cb={$:(cc)},cb)),(cc)=cb.$,bZ));
if(!(cc)){
(D)((1),(null),([({S:"-a"})]));
return false;
}
}
if((V)===(null)){
(V)=({S:((ch)((y))).S+({S:"out"}).S});
}
else{
(V)=((cj)((V)));
}
if((W)===(null)){
(W)=({S:"sys/"});
}
if((X)===(null)){
(X)=({S:(W).S+({S:"default.ico"}).S});
}
(Z)=((ch)((y)));
(aa)=((cj)(((co)((y)))));
(ab)=((ch)((V)));
if(((cq)((y))).S!==({S:"kn"}).S){
(D)((3),(null),([(aa)]));
}
return true;
}
// exitCode
function q(cs /*code*/){
if(((cs)<(0))||((4294967295)<(cs))){
throw 3910598662;
}
}
// print
function u(cx /*str*/){
if(O_&&O_.print){O_.print(cx.S);return;}
console.log(cx.S);
}
// _toStr
function v(cy /*me_*/,cz /*type*/){
switch(cz[0]){
case 0:
case 1:
case 9:
return{S:cy.toString(10)};
case 2:
return{S:String.fromCharCode(cy)};
case 3:
return{S:cy?"true":"false"};
case 4:
return{S:"0x"+("00"+cy.toString(16)).slice(-2).toUpperCase()};
case 5:
return{S:"0x"+("0000"+cy.toString(16)).slice(-4).toUpperCase()};
case 6:
return{S:"0x"+("00000000"+cy.toString(16)).slice(-8).toUpperCase()};
case 7:
return{S:"0x"+("0000000000000000"+cy.toString(16)).slice(-16).toUpperCase()};
case 129:
if(cz[1]===2)
return cy;
}
}
// build
function B(){
let c1=0; // beginTime
let c3=null; // asts
let c5=null; // entry
let cD=null; // resDir
let cE=null; // resFiles
let cN=0;
(c0)=(0);
(c1)=((c2)());
(D)((196611),(null),([((v)(((((c2)())-(c1))/(1000)),([1])))]));
(c3)=((c4)());
(D)((196612),(null),([((v)(((((c2)())-(c1))/(1000)),([1])))]));
(c5)=((c6)((c3)));
(D)((196613),(null),([((v)(((((c2)())-(c1))/(1000)),([1])))]));
if((c0)>(0)){
return false;
}
(cD)=({S:(Z).S+({S:"res/"}).S});
(cE)=(new cF());
((cE).cG)=({L:0,H:null,T:null,P:null});
if((cI)((cD))){
(cK)((cD),(true),(cL),(cE));
}
switch(bL){
case 3:
if(!((cQ)((c5),((cE).cG)))){
return false;
}
break;
case 2:
if(!((cU)((c5),((cE).cG)))){
return false;
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(D)((196614),(null),([((v)(((((c2)())-(c1))/(1000)),([1])))]));
return true;
}
// err
function D(cX /*id*/,cY /*pos*/,cZ /*args*/){
let dc=null; // msg
if(((cX)<(196608))&&((c0)>=(100))){
return;
}
(dc)=((dd)((cX),(cZ)));
(u)(({S:((v)((cX),([6]))).S+({S:": "}).S}));
if((cY)!==(null)){
(u)(({S:({S:({S:"["}).S+((v)(((cY).dh),([129,2]))).S}).S+({S:({S:({S:": "}).S+((v)(((cY).di),([0]))).S}).S+({S:({S:({S:", "}).S+((v)(((cY).dj),([0]))).S}).S+({S:"]"}).S}).S}).S}));
}
(u)(({S:(dc).S+({S:"\u000A"}).S}));
if((cX)<(196608)){
(c0)=((c0)+(1));
}
}
// cmdLine
function ar(){
let r_=(O_&&O_.cmdLine)?O_.cmdLine:location.search.slice(1).split("&");
if(r_.length===1&&r_[0]==="")return[];
for(let i_=0;i_<r_.length;i_++)
r_[i_]={S:r_[i_]};
return r_;
}
// getArg1
function a5(dn /*out*/,dp /*cmdLines*/,dq /*idx*/,dr /*option*/){
if(((dn.$)!==(null))||(((dq.$)+(1))>=((dp).length))){
(D)((1),(null),([({S:({S:({S:"-"}).S+((v)((dr),([2]))).S}).S+({S:""}).S})]));
return false;
}
(dn.$)=((dp)[(dq.$)+(1)]);
(dq.$)=((dq.$)+(1));
return true;
}
// getArg0
function aU(dv /*out*/,dw /*option*/){
if((dv.$)!==(false)){
(D)((1),(null),([({S:({S:({S:"-"}).S+((v)((dw),([2]))).S}).S+({S:""}).S})]));
return false;
}
(dv.$)=(true);
return true;
}
// _addDict
function bE(dz /*me_*/,d0 /*type*/,d1 /*key*/,d2 /*item*/){
if(d0[1]===129&&d0[2]===2)
dz.set(d1.S, d2);
else
dz.set(d1, d2);
}
// rnd
function bX(d3 /*min*/,d4 /*max*/){
return ~~(Math.random()*(d4-d3+1))+d3;
}
// _toInt
function ca(d5 /*me_*/,d6 /*success*/){
if(d5.S.length>=2&&d5.S[0]==="0"&&d5.S[1]==="x"){
let s_=d5.S.slice(2),r_=Number(d5.S);
d6.$=!isNaN(r_);
return parseInt(s_,16);
}else{
let r_=Number(d5.S);
d6.$=!isNaN(r_);
return parseInt(d5.S,10);
}
}
// dir
function ch(d7 /*path*/){
let d8=0; // p
let dE=null; // r
let dH=0;
let dI=0;
let dJ=0;
let dK=0;
if(!((d7)!==(null))){throw 0xE9170000;}
(d8)=(((d7).S.length)-(1));
while((((d8)>=(0))&&(((d7).S.charCodeAt(d8))!==(0x002F)))&&(((d7).S.charCodeAt(d8))!==(0x005C))){
(d8)=((d8)-(1));
}
if((d8)<(0)){
return {S:"./"};
}
else{
(dE)=({S:"\0".repeat((d8)+(1))});
dG:
for(dH=(0),dI=(d8);dH<=dI;dH+=(1)){
(dE).S=(dJ=(dH),(dE).S.slice(0,dJ)+String.fromCharCode((((d7).S.charCodeAt(dH))===(0x005C))?(0x002F):((d7).S.charCodeAt(dH)))+(dE).S.slice(dJ+1));
}
return dE;
}
}
// delExt
function cj(dL /*path*/){
let dM=0; // p
let dR=null; // r
let dU=0;
let dV=0;
let dW=0;
let dX=0;
if(!((dL)!==(null))){throw 0xE9170000;}
(dM)=(((dL).S.length)-(1));
while(((((dM)>=(0))&&(((dL).S.charCodeAt(dM))!==(0x002F)))&&(((dL).S.charCodeAt(dM))!==(0x005C)))&&(((dL).S.charCodeAt(dM))!==(0x002E))){
(dM)=((dM)-(1));
}
if(((dM)<(0))||(((dL).S.charCodeAt(dM))!==(0x002E))){
return dL;
}
(dR)=({S:"\0".repeat(dM)});
dT:
for(dU=(0),dV=((dM)-(1));dU<=dV;dU+=(1)){
(dR).S=(dW=(dU),(dR).S.slice(0,dW)+String.fromCharCode((((dL).S.charCodeAt(dU))===(0x005C))?(0x002F):((dL).S.charCodeAt(dU)))+(dR).S.slice(dW+1));
}
return dR;
}
// fileName
function co(dY /*path*/){
let dZ=0; // p
let ef=null; // r
let ei=0;
let ej=0;
let ek=0;
let el=0;
if(!((dY)!==(null))){throw 0xE9170000;}
(dZ)=(((dY).S.length)-(1));
while((((dZ)>=(0))&&(((dY).S.charCodeAt(dZ))!==(0x002F)))&&(((dY).S.charCodeAt(dZ))!==(0x005C))){
(dZ)=((dZ)-(1));
}
if((dZ)<(0)){
return dY;
}
(dZ)=((dZ)+(1));
(ef)=({S:"\0".repeat(((dY).S.length)-(dZ))});
eh:
for(ei=(0),ej=((((dY).S.length)-(dZ))-(1));ei<=ej;ei+=(1)){
(ef).S=(ek=(ei),(ef).S.slice(0,ek)+String.fromCharCode((dY).S.charCodeAt((dZ)+(ei)))+(ef).S.slice(ek+1));
}
return ef;
}
// ext
function cq(em /*path*/){
let en=0; // p
let eu=null; // r
let ex=0;
let ey=0;
let ez=0;
let e0=0;
if(!((em)!==(null))){throw 0xE9170000;}
(en)=(((em).S.length)-(1));
while(((((en)>=(0))&&(((em).S.charCodeAt(en))!==(0x002F)))&&(((em).S.charCodeAt(en))!==(0x005C)))&&(((em).S.charCodeAt(en))!==(0x002E))){
(en)=((en)-(1));
}
if(((em).S.charCodeAt(en))!==(0x002E)){
return {S:""};
}
else{
(en)=((en)+(1));
(eu)=({S:"\0".repeat(((em).S.length)-(en))});
ew:
for(ex=(0),ey=((((em).S.length)-(en))-(1));ex<=ey;ex+=(1)){
(eu).S=(ez=(ex),(eu).S.slice(0,ez)+String.fromCharCode((em).S.charCodeAt((en)+(ex)))+(eu).S.slice(ez+1));
}
return eu;
}
}
// sysTime
function c2(){
return new Date().getTime();
}
// parse
function c4(){
let e1=null; // endFlag
(ad)=(new Map());
(bE)((ad),([133,129,2,134]),({S:({S:"\\"}).S+(aa).S}),(null));
(bE)((ad),([133,129,2,134]),({S:"kuin"}),(null));
(e1)=(new e2());
((e1).e3)=(false);
while(!((e1).e3)){
((e1).e3)=(true);
(ae)=(new Map());
(e5)((ad),([133,129,2,134]),(e6),(e1));
(ad)=(ae);
}
return ad;
}
// analyze
function c6(e7 /*asts*/){
let e8=null; // mainFunc
(I)=(e7);
(e8)=((e9)());
if((e8)===(null)){
return null;
}
(e5)((e7),([133,129,2,134]),(eC),(null));
return (eD)((e8));
}
// exist
function cI(eE /*path*/){
return false;
}
// forEach
function cK(eF /*path*/,eG /*recursion*/,eH /*callback*/,eI /*data*/){
return false;
}
// searchResFiles
function cL(eJ /*path*/,eK /*isDir*/,eL /*data*/){
let eO=null; // data2
if(!(eK)){
(eO)=(eL);
(eP)(((eO).cG),([130,129,2]),(eJ));
}
return true;
}
// output
function cQ(eQ /*entry*/,eR /*resFiles*/){
let eW=null; // func_
let fa=null; // class_
(K)=([]);
(eS)((K),([132,134]),(eQ));
(L)=([]);
(M)=({S:"a"});
(N)=({L:0,H:null,T:null,P:null});
(O)=({L:0,H:null,T:null,P:null});
(P)=({L:0,H:null,T:null,P:null});
(Q)=({L:0,H:null,T:null,P:null});
(R)=({L:0,H:null,T:null,P:null});
(S)=({L:0,H:null,T:null,P:null});
(T)=({L:0,H:null,T:null,P:null});
(eT)=(0);
(U)=({L:0,H:null,T:null,P:null});
while((((K).length)>(0))||(((L).length)>(0))){
while(((K).length)>(0)){
(eW)=((eX)((K),([132,134])));
(eY)((eW));
}
while(((L).length)>(0)){
(fa)=((eX)((L),([132,134])));
(fc)((fa));
}
}
(fd)((eR));
return true;
}
// output
function cU(fe /*entry*/,ff /*resFiles*/){
let fi=null; // func_
let fl=null; // class_
(aj)=([]);
(eS)((aj),([132,134]),(fe));
(ak)=([]);
(al)=({S:"a"});
(am)=({L:0,H:null,T:null,P:null});
(an)=({L:0,H:null,T:null,P:null});
(ao)=({L:0,H:null,T:null,P:null});
(ap)=({L:0,H:null,T:null,P:null});
while((((aj).length)>(0))||(((ak).length)>(0))){
while(((aj).length)>(0)){
(fi)=((eX)((aj),([132,134])));
(fj)((fi));
}
while(((ak).length)>(0)){
(fl)=((eX)((ak),([132,134])));
(fm)((fl));
}
}
(fn)((ff));
return true;
}
// get
function dd(fo /*id*/,fp /*args*/){
let fr=0;
let fu=0;
let fz=0;
let f4=0;
let f9=0;
let fE=0;
let fJ=0;
let fO=0;
let fT=0;
let fY=0;
let gd=0;
let gi=0;
let gn=0;
let gs=0;
let gx=0;
let g2=0;
let g7=0;
let gC=0;
let gH=0;
let gM=0;
let gR=0;
let gW=0;
let hb=0;
let hg=0;
let hl=0;
let hq=0;
let hv=0;
let h0=0;
let h5=0;
let hA=0;
let hF=0;
let hK=0;
let hP=0;
let hU=0;
let hZ=0;
let ie=0;
let ik=0;
let iq=0;
let iv=0;
let i0=0;
let i5=0;
let iA=0;
let iF=0;
let iK=0;
let iP=0;
let iU=0;
let iZ=0;
let je=0;
let jj=0;
let jo=0;
let jt=0;
let jy=0;
let j3=0;
let j8=0;
let jD=0;
let jI=0;
let jN=0;
let jS=0;
let jX=0;
let kc=0;
let kh=0;
let km=0;
let kr=0;
let kw=0;
let k1=0;
let k6=0;
let kB=0;
let kG=0;
let kL=0;
let kQ=0;
let kV=0;
let la=0;
let lf=0;
let lk=0;
let lp=0;
let lu=0;
let lz=0;
let l4=0;
let l9=0;
let lE=0;
let lJ=0;
let lO=0;
let lT=0;
let lY=0;
let md=0;
let mi=0;
let mn=0;
let ms=0;
let mx=0;
let m2=0;
let m7=0;
let mC=0;
let mH=0;
let mM=0;
let mR=0;
let mW=0;
let nb=0;
let ng=0;
let nl=0;
let nq=0;
let nv=0;
let n0=0;
let n5=0;
let nA=0;
let nF=0;
let nK=0;
let nP=0;
let nU=0;
let nZ=0;
let oe=0;
let oj=0;
let oo=0;
let ot=0;
let oy=0;
let o3=0;
let o8=0;
let oD=0;
let oI=0;
let oN=0;
let oS=0;
let oX=0;
let pc=0;
let ph=0;
let pm=0;
let pr=0;
switch(fo){
case 1:
switch(m){
case 0:
return {S:({S:({S:"\u30AA\u30D7\u30B7\u30E7\u30F3\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u4F7F\u308F\u308C\u65B9\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The option \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' was used incorrectly."}).S};
break;
}
break;
case 2:
switch(m){
case 0:
return {S:({S:({S:"\u4E0D\u660E\u306A\u30AA\u30D7\u30B7\u30E7\u30F3\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u6307\u5B9A\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"Unexpected option: \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 3:
switch(m){
case 0:
return {S:({S:({S:"\u5165\u529B\u30D5\u30A1\u30A4\u30EB\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u62E1\u5F35\u5B50\u306F\u300C.kn\u300D\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The extension of the input file \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' must be \'.kn\'."}).S};
break;
}
break;
case 4:
switch(m){
case 0:
return {S:({S:({S:"\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u540D\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u306B\u4F7F\u3048\u306A\u3044\u6587\u5B57\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The source file name \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' contains characters that cannot be used."}).S};
break;
}
break;
case 5:
switch(m){
case 0:
return {S:({S:({S:"\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u958B\u3051\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"Cannot open source file \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 6:
switch(m){
case 0:
return {S:({S:({S:"\u30B7\u30B9\u30C6\u30E0\u30D5\u30A1\u30A4\u30EB\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u958B\u3051\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The system file \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' could not be opened."}).S};
break;
}
break;
case 7:
switch(m){
case 0:
return {S:({S:({S:"\u30B7\u30B9\u30C6\u30E0\u30D5\u30A1\u30A4\u30EB\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u58CA\u308C\u3066\u3044\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The system file \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' is broken."}).S};
break;
}
break;
case 65537:
switch(m){
case 0:
return {S:({S:({S:"\u540C\u3058\u30B9\u30B3\u30FC\u30D7\u5185\u306B\u65E2\u306B\u540C\u3058\u8B58\u5225\u5B50\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u5B58\u5728\u3057\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The same identifier \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' already exists in the same scope."}).S};
break;
}
break;
case 65538:
switch(m){
case 0:
return {S:({S:({S:"\u4E0A\u4F4D\u306E\u30B9\u30B3\u30FC\u30D7\u5185\u306B\u65E2\u306B\u540C\u3058\u8B58\u5225\u5B50\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u5B58\u5728\u3057\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The same identifier \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' already exists in the upper scope."}).S};
break;
}
break;
case 65539:
switch(m){
case 0:
return {S:"\u30B3\u30E1\u30F3\u30C8\u306E\u300C{\u300D\u306B\u5BFE\u5FDC\u3059\u308B\u300C}\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"There is no \'}\' corresponding to \'{\' for comment."};
break;
}
break;
case 65540:
switch(m){
case 0:
return {S:"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3084\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u4E2D\u306B\u30BF\u30D6\u6587\u5B57\u306F\u8A18\u8FF0\u3067\u304D\u307E\u305B\u3093\u3002 \u30A8\u30B9\u30B1\u30FC\u30D7\u30B7\u30FC\u30B1\u30F3\u30B9\u300C\\t\u300D\u3092\u4EE3\u7528\u3057\u3066\u304F\u3060\u3055\u3044\u3002"};
break;
default:
return {S:"Tab characters cannot be written in character literals and string literals. Use the escape sequence \'\\t\' instead."};
break;
}
break;
case 65541:
switch(m){
case 0:
return {S:"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3084\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u4E2D\u3067\u306F\u6539\u884C\u3067\u304D\u307E\u305B\u3093\u3002 \u30A8\u30B9\u30B1\u30FC\u30D7\u30B7\u30FC\u30B1\u30F3\u30B9\u300C\\n\u300D\u3092\u4EE3\u7528\u3057\u3066\u304F\u3060\u3055\u3044\u3002"};
break;
default:
return {S:"Line breaks are not allowed in character literals and string literals. Use the escape sequence \'\\n\' instead."};
break;
}
break;
case 65542:
switch(m){
case 0:
return {S:({S:({S:"\u8B58\u5225\u5B50\u306B\u306F\u4F7F\u3048\u306A\u3044\u6587\u5B57\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The character \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' that cannot be used in identifiers was written."}).S};
break;
}
break;
case 65543:
switch(m){
case 0:
return {S:"\u8B58\u5225\u5B50\u306B\u6B63\u3057\u304F\u306A\u3044\u5F62\u5F0F\u3067\u300C@\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"Incorrect \'@\' was written in an identifier."};
break;
}
break;
case 65544:
switch(m){
case 0:
return {S:({S:({S:"\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u540D\u306E\u6307\u5B9A\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u306B\u5927\u6587\u5B57\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"A source file name description \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' contains uppercase letters."}).S};
break;
}
break;
case 65545:
switch(m){
case 0:
return {S:"\u8B58\u5225\u5B50\u306B\u6B63\u3057\u304F\u306A\u3044\u5F62\u5F0F\u3067\u300C\\\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"Incorrect \'\\\' was written in an identifier."};
break;
}
break;
case 65546:
switch(m){
case 0:
return {S:({S:({S:"\u8B58\u5225\u5B50\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 128\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The identifier \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"...\' is too long. Must be 128 characters or less."}).S};
break;
}
break;
case 65547:
switch(m){
case 0:
return {S:({S:({S:"\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u30D6\u30ED\u30C3\u30AF\u3082\u3057\u304F\u306F\u6587\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"An incorrect block or sentence \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' was written."}).S};
break;
}
break;
case 65548:
switch(m){
case 0:
return {S:({S:({S:"\u95A2\u6570\u5C5E\u6027\u306B\u306F\u4F7F\u3048\u306A\u3044\u6587\u5B57\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The character \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' that cannot be used in function attributes was written."}).S};
break;
}
break;
case 65549:
switch(m){
case 0:
return {S:({S:({S:"\u95A2\u6570\u5C5E\u6027\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 128\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The function attribute \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"...\' is too long. Must be 128 characters or less."}).S};
break;
}
break;
case 65550:
switch(m){
case 0:
return {S:({S:({S:"\u6587\u5B57\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u308B\u3079\u304D\u7B87\u6240\u306B\u3001\u4E0D\u6B63\u306A\u6587\u5B57\u300C"}).S+((v)(((fp)[1]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S}).S};
break;
default:
return {S:({S:({S:"An invalid character \'"}).S+((v)(((fp)[1]),([129,2]))).S}).S+({S:({S:({S:"\' was written in a place where the character \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' should be written."}).S}).S};
break;
}
break;
case 65551:
switch(m){
case 0:
return {S:({S:({S:"\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u306B\u5BFE\u5FDC\u3059\u308B\u300Cend "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002"}).S}).S};
break;
default:
return {S:({S:({S:"There is no \'end "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:({S:({S:"\' corresponding to \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\'."}).S}).S};
break;
}
break;
case 65552:
switch(m){
case 0:
return {S:({S:({S:"\u95A2\u6570\u4EE5\u5916\u306E\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"Overridden non-function member \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 65553:
switch(m){
case 0:
return {S:({S:({S:"\u95A2\u6570\u304A\u3088\u3073\u5909\u6570\u4EE5\u5916\u306E\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u3092\u516C\u958B\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The member \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' other than functions and variables has been released."}).S};
break;
}
break;
case 65554:
switch(m){
case 0:
return {S:({S:({S:"\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u304C\u300Cend "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u3067\u306F\u306A\u304F\u4E0D\u6B63\u306A\u300Cend "}).S+((v)(((fp)[1]),([129,2]))).S}).S+({S:"\u300D\u3067\u9589\u3058\u3089\u308C\u307E\u3057\u305F\u3002"}).S}).S}).S};
break;
default:
return {S:({S:({S:"\'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:({S:({S:"\' was closed with invalid \'end "}).S+((v)(((fp)[1]),([129,2]))).S}).S+({S:({S:({S:"\' instead of \'end "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\'."}).S}).S}).S};
break;
}
break;
case 65555:
switch(m){
case 0:
return {S:({S:({S:"\u6B63\u3057\u304F\u306A\u3044\u5F62\u5F0F\u306E\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"Incorrectly formatted member \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' was written."}).S};
break;
}
break;
case 65556:
switch(m){
case 0:
return {S:"\u5F15\u6570\u4EE5\u5916\u306E\u5909\u6570\u306B\u4E0D\u6B63\u306A\u300C&\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"An invalid \'&\' was written in other than an argument."};
break;
}
break;
case 65557:
switch(m){
case 0:
return {S:"\u5F15\u6570\u306B\u521D\u671F\u5316\u5B50\u300C::\u300D\u3092\u8A18\u8FF0\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The initializer \'::\' cannot be written in arguments."};
break;
}
break;
case 65558:
switch(m){
case 0:
return {S:"\u30E1\u30F3\u30D0\u306B\u521D\u671F\u5316\u5B50\u300C::\u300D\u3092\u8A18\u8FF0\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The initializer \'::\' cannot be written in members."};
break;
}
break;
case 65559:
switch(m){
case 0:
return {S:"const\u6587\u306B\u306F\u521D\u671F\u5316\u5B50\u300C::\u300D\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The initializer \'::\' must be written in const statements."};
break;
}
break;
case 65560:
switch(m){
case 0:
return {S:"\u30D6\u30ED\u30C3\u30AF\u306B\u5BFE\u5FDC\u3059\u308B\u300Cend\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"There is no \'end\' corresponding to a block."};
break;
}
break;
case 65561:
switch(m){
case 0:
return {S:({S:({S:"\u300Cend "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u306F\u4E0D\u6B63\u306A\u5F62\u5F0F\u3067\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"\'end "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' is incorrectly formatted."}).S};
break;
}
break;
case 65562:
switch(m){
case 0:
return {S:({S:({S:"\u30D6\u30ED\u30C3\u30AF\u3068\u5BFE\u5FDC\u3057\u306A\u3044\u4E0D\u6B63\u306A\u300Cend "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u3067\u9589\u3058\u3089\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"Closed with invalid \'end "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' that does not correspond to the block."}).S};
break;
}
break;
case 65563:
switch(m){
case 0:
return {S:"\u300Cif\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Celse\u300D\u7BC0\u306E\u5F8C\u306B\u4E0D\u6B63\u306A\u300Celif\u300D\u7BC0\u3084\u300Celse\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"In an \'if\' block, an invalid \'elif\' or \'else\' clauses is written after an \'else\' clause."};
break;
}
break;
case 65564:
switch(m){
case 0:
return {S:"\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Cdefault\u300D\u7BC0\u306E\u5F8C\u306B\u4E0D\u6B63\u306A\u300Ccase\u300D\u7BC0\u3084\u300Cdefault\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"In a \'switch\' block, an invalid \'case\' or \'default\' clauses is written after a \'default\' clause."};
break;
}
break;
case 65565:
switch(m){
case 0:
return {S:"\u300Ctry\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Cfinally\u300D\u7BC0\u306E\u5F8C\u306B\u4E0D\u6B63\u306A\u300Ccatch\u300D\u7BC0\u3084\u300Cfinally\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"In a \'try\' block, an invalid \'catch\' or \'finally\' clauses is written after a \'finally\' clause."};
break;
}
break;
case 65566:
switch(m){
case 0:
return {S:({S:({S:"\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u30D6\u30ED\u30C3\u30AF\u4EE5\u5916\u3067\u4E0D\u6B63\u306A\u300C"}).S+((v)(((fp)[1]),([129,2]))).S}).S+({S:"\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S}).S};
break;
default:
return {S:({S:({S:"A invalid \'"}).S+((v)(((fp)[1]),([129,2]))).S}).S+({S:({S:({S:"\' clause was written outside \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' blocks."}).S}).S};
break;
}
break;
case 65567:
switch(m){
case 0:
return {S:"\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Ccase\u300D\u300Cdefault\u300D\u300Cend switch\u300D\u306E\u3044\u305A\u308C\u304B\u304C\u8A18\u8FF0\u3055\u308C\u308B\u3079\u304D\u7B87\u6240\u306B\u305D\u308C\u4EE5\u5916\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"In a \'switch\' block, clauses other than \'case\', \'default\' and \'end switch\' were written."};
break;
}
break;
case 65568:
switch(m){
case 0:
return {S:({S:({S:"\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u308B\u3079\u304D\u7B87\u6240\u306B\u4E0D\u6B63\u306A\u300C"}).S+((v)(((fp)[1]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S}).S};
break;
default:
return {S:({S:({S:"An invalid \'"}).S+((v)(((fp)[1]),([129,2]))).S}).S+({S:({S:({S:"\' was written where \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' should be written."}).S}).S};
break;
}
break;
case 65569:
switch(m){
case 0:
return {S:({S:({S:"\u300C\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u6F14\u7B97\u5B50\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"An incorrect operator \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' was written."}).S};
break;
}
break;
case 65570:
switch(m){
case 0:
return {S:({S:({S:"\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 1024\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The string literal \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' is too long. Must be 1024 characters or less."}).S};
break;
}
break;
case 65571:
switch(m){
case 0:
return {S:({S:({S:"\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u30A8\u30B9\u30B1\u30FC\u30D7\u30B7\u30FC\u30B1\u30F3\u30B9\u300C\\"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"A invalid escape sequence \'\\"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' was written."}).S};
break;
}
break;
case 65572:
switch(m){
case 0:
return {S:"\u6587\u5B57\u30B3\u30FC\u30C9\u8868\u8A18\u306F\u300C\\u\u300D\u306B\u7D9A\u3044\u3066\u3001\u6570\u5B57\u307E\u305F\u306F\u5927\u6587\u5B57\u30A2\u30EB\u30D5\u30A1\u30D9\u30C3\u30C8\u30674\u6841\u306E16\u9032\u6570\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"Character code representations must be \'\\u\' followed by a 4-digit hexadecimal number in numbers or capital letters."};
break;
}
break;
case 65573:
switch(m){
case 0:
return {S:"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3082\u3057\u304F\u306F\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u304C\u9589\u3058\u3089\u308C\u3066\u3044\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"A character literal or string literal is not closed."};
break;
}
break;
case 65574:
switch(m){
case 0:
return {S:({S:({S:"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 1\u6587\u5B57\u5206\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The character literal \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"...\' is too long. A character literal must contain one character."}).S};
break;
}
break;
case 65575:
switch(m){
case 0:
return {S:"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u304C\u7A7A\u3067\u3059\u3002 1\u6587\u5B57\u5206\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"There is an empty character literal. A character literal must contain one character."};
break;
}
break;
case 65576:
switch(m){
case 0:
return {S:"\u62EC\u5F27\u300C(\u300D\u306B\u5BFE\u5FDC\u3059\u308B\u300C)\u300D\u304C\u3001\u3042\u308B\u3079\u304D\u5834\u6240\u306B\u5B58\u5728\u3057\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The \')\' corresponding to the parenthesis \'(\' does not exist where it should be."};
break;
}
break;
case 65577:
switch(m){
case 0:
return {S:({S:({S:"\u6570\u5024\u30EA\u30C6\u30E9\u30EB\u306B\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"An invalid \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' was written in a numeric literal."}).S};
break;
}
break;
case 65578:
switch(m){
case 0:
return {S:({S:({S:"\u6570\u5024\u30EA\u30C6\u30E9\u30EB\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 1024\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The numeric literal \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' is too long. Must be 1024 characters or less."}).S};
break;
}
break;
case 65579:
switch(m){
case 0:
return {S:"16\u9032\u6570\u30EA\u30C6\u30E9\u30EB\u306F\u300C0x\u300D\u304B\u3089\u59CB\u3081\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"Hexadecimal literals must start with \'0x\'."};
break;
}
break;
case 65580:
switch(m){
case 0:
return {S:"\u6307\u6570\u8868\u8A18\u30EA\u30C6\u30E9\u30EB\u306F\u300Ce+\u300D\u3082\u3057\u304F\u306F\u300Ce-\u300D\u304B\u3089\u59CB\u3081\u3066\u6307\u6570\u90E8\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"Exponential notation literals must start with \'e+\' or \'e-\' and write the exponent part."};
break;
}
break;
case 65581:
switch(m){
case 0:
return {S:({S:({S:"\u6D6E\u52D5\u5C0F\u6570\u70B9\u30EA\u30C6\u30E9\u30EB\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u89E3\u91C8\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002 \u5024\u304C\u5927\u304D\u3059\u304E\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The floating point literal \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' could not be interpreted. The value may be too large."}).S};
break;
}
break;
case 65582:
switch(m){
case 0:
return {S:({S:({S:"\u30D3\u30C3\u30C8\u578B\u30EA\u30C6\u30E9\u30EB\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u63A5\u5C3E\u8F9E\u306F\u300Cb8\u300D\u300Cb16\u300D\u300Cb32\u300D\u300Cb64\u300D\u306E\u3044\u305A\u308C\u304B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The suffix of bit type literal \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' must be either \'b8\', \'b16\', \'b32\' or \'b64\'."}).S};
break;
}
break;
case 65583:
switch(m){
case 0:
return {S:({S:({S:"\u6574\u6570\u30EA\u30C6\u30E9\u30EB\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u30AA\u30FC\u30D0\u30FC\u30D5\u30ED\u30FC\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The integer literal \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' has overflowed."}).S};
break;
}
break;
case 131073:
switch(m){
case 0:
return {S:"\u300Cmain\u300D\u95A2\u6570\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002 \u30B3\u30F3\u30D1\u30A4\u30EB\u3059\u308B\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u306B\u300Cfunc main()\u300D\u3092\u5B9A\u7FA9\u3057\u3066\u304F\u3060\u3055\u3044\u3002"};
break;
default:
return {S:"\'main\' function does not exist. Define \'func main()\' in the source files to be compiled."};
break;
}
break;
case 131074:
switch(m){
case 0:
return {S:"\u300Cmain\u300D\u95A2\u6570\u306E\u5B9A\u7FA9\u306F\u300Cfunc main()\u300D\u3068\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The definition of the \'main\' function must be \'func main()\'."};
break;
}
break;
case 131075:
switch(m){
case 0:
return {S:({S:({S:"\u30E1\u30F3\u30D0\u3082\u3057\u304F\u306F\u5909\u6570\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u306B\u3001\u300Cme\u300D\u3092\u4ECB\u3055\u305A\u76F4\u63A5\u30A2\u30AF\u30BB\u30B9\u3057\u305F\u304B\u3001\u95A2\u6570\u3092\u8D85\u3048\u3066\u30A2\u30AF\u30BB\u30B9\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The member or variable \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' was accessed directly without \'me\', or accessed beyond the function."}).S};
break;
}
break;
case 131076:
switch(m){
case 0:
return {S:({S:({S:"\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"@\u300D\u306B\u3064\u3044\u3066\u3001\u81EA\u8EAB\u306E\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u306E\u30B0\u30ED\u30FC\u30D0\u30EB\u8981\u7D20\u3092\u53C2\u7167\u3059\u308B\u3068\u304D\u306F\u3001\u300C@\u300D\u306E\u524D\u306E\u30BD\u30FC\u30B9\u540D\u3092\u7701\u7565\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"For \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"@\', when referring to global elements in its own source file, the source name before the \'@\' must be omitted."}).S};
break;
}
break;
case 131077:
switch(m){
case 0:
return {S:({S:({S:"\u4ED6\u306E\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u306E\u516C\u958B\u3055\u308C\u3066\u3044\u306A\u3044\u8981\u7D20\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u3092\u53C2\u7167\u3057\u307E\u3057\u305F\u3002\u8981\u7D20\u306E\u5148\u982D\u306B\u300C+\u300D\u304C\u4ED8\u3044\u3066\u3044\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"A non-public element \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' in another souce file was referenced. The element must start with a \'+\'."}).S};
break;
}
break;
case 131078:
switch(m){
case 0:
return {S:({S:({S:"\u8B58\u5225\u5B50\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u5B9A\u7FA9\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002\u540D\u524D\u3092\u9593\u9055\u3048\u3066\u3044\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The definition of identifier \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' was not be found. The name may have been written incorrectly."}).S};
break;
}
break;
case 131079:
switch(m){
case 0:
return {S:({S:({S:"\u300Calias "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u5B9A\u7FA9\u304C\u5FAA\u74B0\u3057\u3066\u3044\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The definition of \'alias "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' is circulating."}).S};
break;
}
break;
case 131080:
switch(m){
case 0:
return {S:({S:({S:"\u300Cclass "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u7D99\u627F\u304C\u5FAA\u74B0\u3057\u3066\u3044\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The inheritance of \'class "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' is circulating."}).S};
break;
}
break;
case 131081:
switch(m){
case 0:
return {S:({S:({S:"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B\u89AA\u30AF\u30E9\u30B9\u306E\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The member \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' of the parent class to override cannot be found."}).S};
break;
}
break;
case 131082:
switch(m){
case 0:
return {S:({S:({S:"\u30E1\u30F3\u30D0\u540D\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u89AA\u30AF\u30E9\u30B9\u306E\u3082\u306E\u3068\u91CD\u8907\u3057\u3066\u3044\u307E\u3059\u3002 \u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B\u5834\u5408\u306F\u300C*\u300D\u3092\u4ED8\u3051\u3066\u304F\u3060\u3055\u3044\u3002"}).S};
break;
default:
return {S:({S:({S:"The member name \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' is duplicated with that of the parent class. Add \'*\' when overriding."}).S};
break;
}
break;
case 131083:
switch(m){
case 0:
return {S:({S:({S:"\u95A2\u6570\u4EE5\u5916\u306E\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"Overridden non-function member \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 131084:
switch(m){
case 0:
return {S:({S:({S:"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u305F\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u3068\u30A2\u30AF\u30BB\u30B9\u4FEE\u98FE\u5B50\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The access modifier does not match that of the overridden member \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 131085:
switch(m){
case 0:
return {S:({S:({S:"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u305F\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u3068\u578B\u3082\u3057\u304F\u306F\u5F15\u6570\u540D\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The types or argument names do not match that of the overridden member \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 131086:
switch(m){
case 0:
return {S:({S:({S:"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u304C\u8A31\u53EF\u3055\u308C\u3066\u3044\u306A\u3044\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The member \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' that is not allowed to be overridden was overridden."}).S};
break;
}
break;
case 131087:
switch(m){
case 0:
return {S:({S:({S:"\u5217\u6319\u578B\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u306E\u8981\u7D20\u300C%"}).S+((v)(((fp)[1]),([129,2]))).S}).S+({S:"\u300D\u306E\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u300Cint\u300D\u578B\u306E\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S}).S};
break;
default:
return {S:({S:({S:"The value of the element \'%"}).S+((v)(((fp)[1]),([129,2]))).S}).S+({S:({S:({S:"\' of enumeration type \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' must be an \'int\' value that can be made a constant at compile time."}).S}).S};
break;
}
break;
case 131088:
switch(m){
case 0:
return {S:({S:({S:"\u5217\u6319\u578B\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u306E\u8981\u7D20\u300C%"}).S+((v)(((fp)[1]),([129,2]))).S}).S+({S:"\u300D\u306E\u5024\u304C\u300Cint\u300D\u578B\u306E\u6709\u52B9\u7BC4\u56F2\u3092\u8D85\u3048\u307E\u3057\u305F\u3002"}).S}).S};
break;
default:
return {S:({S:({S:"The value of the element \'%"}).S+((v)(((fp)[1]),([129,2]))).S}).S+({S:({S:({S:"\' of enumeration type \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' exceeds the valid range of \'int\' type."}).S}).S};
break;
}
break;
case 131089:
switch(m){
case 0:
return {S:({S:({S:"\u5217\u6319\u578B\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u306E\u8981\u7D20\u300C%"}).S+((v)(((fp)[1]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u306E\u5024\u300C"}).S+((v)(((fp)[2]),([129,2]))).S}).S+({S:"\u300D\u304C\u5225\u306E\u8981\u7D20\u306E\u5024\u3068\u91CD\u8907\u3057\u3066\u3044\u307E\u3059\u3002"}).S}).S}).S};
break;
default:
return {S:({S:({S:"The value \'"}).S+((v)(((fp)[2]),([129,2]))).S}).S+({S:({S:({S:"\' of the element \'%"}).S+((v)(((fp)[1]),([129,2]))).S}).S+({S:({S:({S:"\' of enumeration type \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' is duplicated with the value of another element."}).S}).S}).S};
break;
}
break;
case 131090:
switch(m){
case 0:
return {S:({S:({S:"\u5217\u6319\u578B\u5185\u306B\u5B58\u5728\u3057\u306A\u3044\u8981\u7D20\u540D\u300C%"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The element name \'%"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' that does not exist in the enumeration type was written."}).S};
break;
}
break;
case 131091:
switch(m){
case 0:
return {S:({S:({S:"\u30B0\u30ED\u30FC\u30D0\u30EB\u5909\u6570\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The value of global variable \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' must be a constant at compile time."}).S};
break;
}
break;
case 131092:
switch(m){
case 0:
return {S:({S:({S:"\u300Cconst\u300D\u6587\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The value of \'const\' statement \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' must be a constant at compile time."}).S};
break;
}
break;
case 131093:
switch(m){
case 0:
return {S:({S:({S:"\u5909\u6570\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u578B\u3068\u5024\u306E\u578B\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The type of the variable \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' does not match the value type."}).S};
break;
}
break;
case 131094:
switch(m){
case 0:
return {S:"\u300Cif\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The conditional expression of the \'if\' block must be \'bool\' type."};
break;
}
break;
case 131095:
switch(m){
case 0:
return {S:"\u300Celif\u300D\u7BC0\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The conditional expression of the \'elif\' clause must be \'bool\' type."};
break;
}
break;
case 131096:
switch(m){
case 0:
return {S:"\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306F\u6BD4\u8F03\u53EF\u80FD\u306A\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The conditional expression of the \'switch\' block must be a comparable type."};
break;
}
break;
case 131097:
switch(m){
case 0:
return {S:"\u300Ccase\u300D\u7BC0\u306E\u578B\u304C\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306E\u578B\u3068\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The type of the \'case\' clause does not match the type of the conditional expression in the \'switch\' block."};
break;
}
break;
case 131098:
switch(m){
case 0:
return {S:"\u300Cwhile\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The conditional expression of the \'while\' block must be \'bool\' type."};
break;
}
break;
case 131099:
switch(m){
case 0:
return {S:"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u521D\u671F\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The begin value of the \'for\' block must be \'int\' type."};
break;
}
break;
case 131100:
switch(m){
case 0:
return {S:"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u7D42\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The end value of the \'for\' block must be \'int\' type."};
break;
}
break;
case 131101:
switch(m){
case 0:
return {S:"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u5897\u6E1B\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The increase / decrease value of the \'for\' block must be \'int\' type."};
break;
}
break;
case 131102:
switch(m){
case 0:
return {S:"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u5897\u6E1B\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The increase / decrease value of the \'for\' block must be a constant at compile time."};
break;
}
break;
case 131103:
switch(m){
case 0:
return {S:"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u5897\u6E1B\u5024\u306F\u300C0\u300D\u4EE5\u5916\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The increase / decrease value of the \'for\' block must be other than \'0\'."};
break;
}
break;
case 131104:
switch(m){
case 0:
return {S:"\u300Ccatch\u300D\u7BC0\u306E\u6761\u4EF6\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u300Cint\u300D\u578B\u306E\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The condition value in the \'catch\' clause must be an \'int\' value that can be a constant at compile time."};
break;
}
break;
case 131105:
switch(m){
case 0:
return {S:"\u300Cthrow\u300D\u6587\u306E\u4F8B\u5916\u30B3\u30FC\u30C9\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The exception code for the \'throw\' statement must be \'int\'."};
break;
}
break;
case 131106:
switch(m){
case 0:
return {S:"\u623B\u308A\u5024\u3092\u8FD4\u3059\u95A2\u6570\u3067\u306F\u300Cret\u300D\u6587\u306F\u5024\u3092\u8FD4\u3055\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"For functions that return a value, \'ret\' statements must return a value."};
break;
}
break;
case 131107:
switch(m){
case 0:
return {S:"\u300Cret\u300D\u6587\u306E\u5024\u306E\u578B\u304C\u95A2\u6570\u306E\u623B\u308A\u5024\u306E\u578B\u3068\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The type of the \'ret\' statement does not match the return type of the function."};
break;
}
break;
case 131108:
switch(m){
case 0:
return {S:"\u300Cdo\u300D\u6587\u3067\u6700\u5F8C\u306B\u884C\u3046\u6F14\u7B97\u306F\u300C::\u300D\u6F14\u7B97\u5B50\u3084\u95A2\u6570\u547C\u3073\u51FA\u3057\u306A\u3069\u306E\u526F\u4F5C\u7528\u306E\u3042\u308B\u6F14\u7B97\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The last operation in \'do\' statements must be with side effects such as \'::\' operator or function calls."};
break;
}
break;
case 131109:
switch(m){
case 0:
return {S:({S:({S:"\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u6587\u306B\u306F\u30D6\u30ED\u30C3\u30AF\u540D\u3092\u6307\u5B9A\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"\'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' statements must be given block names."}).S};
break;
}
break;
case 131110:
switch(m){
case 0:
return {S:"\u300Cassert\u300D\u6587\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The conditional expression of the \'assert\' statement must be \'bool\' type."};
break;
}
break;
case 131111:
switch(m){
case 0:
return {S:"\u578B\u3092\u8A18\u8FF0\u3059\u3079\u304D\u3068\u3053\u308D\u306B\u578B\u4EE5\u5916\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"A non-type was written where a type should be written."};
break;
}
break;
case 131112:
switch(m){
case 0:
return {S:"\u5024\u304C\u8A2D\u5B9A\u3055\u308C\u308B\u3079\u304D\u5834\u6240\u306B\u5024\u304C\u6E21\u3055\u308C\u307E\u305B\u3093\u3067\u3057\u305F\u3002"};
break;
default:
return {S:"No value was passed where some value should be set."};
break;
}
break;
case 131113:
switch(m){
case 0:
return {S:"\u6F14\u7B97\u5B50\u306E\u578B\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"Incorrect type for operator."};
break;
}
break;
case 131114:
switch(m){
case 0:
return {S:"\u4EE3\u5165\u6F14\u7B97\u5B50\u306E\u5DE6\u8FBA\u5024\u304C\u4EE3\u5165\u53EF\u80FD\u306A\u5909\u6570\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The left value of the assignment operator is not an assignable variable."};
break;
}
break;
case 131115:
switch(m){
case 0:
return {S:"\u300Cnull\u300D\u306F\u5024\u6BD4\u8F03\u304C\u3067\u304D\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"\'null\' cannot be compared by value."};
break;
}
break;
case 131116:
switch(m){
case 0:
return {S:({S:({S:"\u300Cenum\u300D\u306E\u8981\u7D20\u540D\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304B\u3089\u578B\u304C\u63A8\u6E2C\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The type could not be inferred from the element name \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' of \'enum\'."}).S};
break;
}
break;
case 131117:
switch(m){
case 0:
return {S:"\u300Cnull\u300D\u306F\u300C~\u300D\u6F14\u7B97\u5B50\u3067\u9023\u7D50\u3067\u304D\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"\'null\' cannot be concatenated with the \'~\' operator."};
break;
}
break;
case 131118:
switch(m){
case 0:
return {S:"0\u3067\u9664\u7B97\u3057\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"Divided by 0."};
break;
}
break;
case 131119:
switch(m){
case 0:
return {S:"\u300C:$\u300D\u6F14\u7B97\u5B50\u306E\u5DE6\u8FBA\u5024\u3082\u3057\u304F\u306F\u53F3\u8FBA\u5024\u304C\u4EE3\u5165\u53EF\u80FD\u306A\u5909\u6570\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The left or right value of the \':$\' operator is not an assignable variable."};
break;
}
break;
case 131120:
switch(m){
case 0:
return {S:"\u300C?(,)\u300D\u6F14\u7B97\u5B50\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The conditional expression for the \'?(,)\' operator must be \'bool\'."};
break;
}
break;
case 131121:
switch(m){
case 0:
return {S:"\u300C?(,)\u300D\u6F14\u7B97\u5B50\u306E\u62EC\u5F27\u5185\u306E2\u3064\u306E\u5024\u306F\u540C\u3058\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The two values in the parenthesis for the \'?(,)\' operator must be the same type."};
break;
}
break;
case 131122:
switch(m){
case 0:
return {S:"\u300C#\u300D\u6F14\u7B97\u5B50\u306F\u30AF\u30E9\u30B9\u3084\u300Clist\u300D\u300Cdict\u300D\u306A\u3069\u306E\u53C2\u7167\u578B\u306B\u3057\u304B\u4F7F\u3048\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The \'#\' operator can only be used for reference types such as classes, \'list\' and \'dict\'."};
break;
}
break;
case 131123:
switch(m){
case 0:
return {S:"\u300C#\u300D\u6F14\u7B97\u5B50\u306B\u8A18\u8FF0\u3059\u308B\u914D\u5217\u306E\u8981\u7D20\u6570\u306E\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The number of array elements written in the \'#\' operator must be \'int\'."};
break;
}
break;
case 131124:
switch(m){
case 0:
return {S:"\u95A2\u6570\u3067\u306A\u3044\u3082\u306E\u3092\u95A2\u6570\u547C\u3073\u51FA\u3057\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"A non-function was called as if it were a function."};
break;
}
break;
case 131125:
switch(m){
case 0:
return {S:({S:({S:""}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:({S:({S:"\u500B\u306E\u5F15\u6570\u3092\u53D7\u3051\u53D6\u308B\u95A2\u6570\u547C\u3073\u51FA\u3057\u306B"}).S+((v)(((fp)[1]),([129,2]))).S}).S+({S:({S:({S:"\u500B\u306E\u5F15\u6570\u304C\u6307\u5B9A\u3055\u308C\u307E\u3057\u305F\u3002 \u95A2\u6570\u306E\u578B\u306F\u300C"}).S+((v)(((fp)[2]),([129,2]))).S}).S+({S:"\u300D\u3067\u3059\u3002"}).S}).S}).S};
break;
default:
return {S:({S:({S:""}).S+((v)(((fp)[1]),([129,2]))).S}).S+({S:({S:({S:" arguments were written in the function call that received "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:({S:({S:" arguments. The function type is \'"}).S+((v)(((fp)[2]),([129,2]))).S}).S+({S:"\'"}).S}).S}).S};
break;
}
break;
case 131126:
switch(m){
case 0:
return {S:({S:({S:"\u95A2\u6570\u547C\u3073\u51FA\u3057\u306E"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u756A\u76EE\u306E\u53C2\u7167\u6E21\u3057\u306E\u5F15\u6570\u306B\u3001\u53C2\u7167\u3092\u53D6\u308C\u306A\u3044\u5024\u304C\u6E21\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"A value that cannot be referenced was passed to the "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"th/st/nd/rd argument, which is a reference argument, of the function call."}).S};
break;
}
break;
case 131127:
switch(m){
case 0:
return {S:({S:({S:"\u95A2\u6570\u547C\u3073\u51FA\u3057\u306E\u5F15\u6570\u306E\u578B\u304C\u7570\u306A\u308A\u307E\u3059\u3002 "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:({S:({S:"\u756A\u76EE\u306E\u5F15\u6570\u3067\u300C"}).S+((v)(((fp)[1]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u3092\u6307\u5B9A\u3059\u3079\u304D\u3068\u3053\u308D\u306B\u300C"}).S+((v)(((fp)[2]),([129,2]))).S}).S+({S:"\u300D\u304C\u6E21\u3055\u308C\u307E\u3057\u305F\u3002"}).S}).S}).S};
break;
default:
return {S:({S:({S:"The type of arguments of the function call is different. \'"}).S+((v)(((fp)[2]),([129,2]))).S}).S+({S:({S:({S:"\' has been passed where \'"}).S+((v)(((fp)[1]),([129,2]))).S}).S+({S:({S:({S:"\' should be written in the "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"th/st/nd/rd argument."}).S}).S}).S};
break;
}
break;
case 131128:
switch(m){
case 0:
return {S:"\u914D\u5217\u3067\u306A\u3044\u3082\u306E\u306B\u914D\u5217\u30A2\u30AF\u30BB\u30B9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"A non-array was accessed as an array."};
break;
}
break;
case 131129:
switch(m){
case 0:
return {S:"\u914D\u5217\u306E\u6DFB\u5B57\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"Array indices must be \'int\'."};
break;
}
break;
case 131130:
switch(m){
case 0:
return {S:({S:({S:"\u53C2\u7167\u5148\u306E\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The referenced member \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' does not exist."}).S};
break;
}
break;
case 131131:
switch(m){
case 0:
return {S:({S:({S:"\u516C\u958B\u3055\u308C\u3066\u3044\u306A\u3044\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u3092\u53C2\u7167\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"An unpublished member \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\' was referenced."}).S};
break;
}
break;
case 131132:
switch(m){
case 0:
return {S:"\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306E\u8981\u7D20\u306E\u578B\u304C\u4E00\u81F4\u3057\u3066\u3044\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The element types of the array initializer \'[]\' do not match."};
break;
}
break;
case 131133:
switch(m){
case 0:
return {S:"\u5024\u578B\u306E\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306B\u300Cnull\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"\'null\' was written in the value type array initializer \'[]\'."};
break;
}
break;
case 131134:
switch(m){
case 0:
return {S:"\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306E\u3059\u3079\u3066\u306E\u8981\u7D20\u304C\u300Cenum\u300D\u306E\u8981\u7D20\u540D\u306E\u305F\u3081\u3001\u578B\u304C\u6C7A\u5B9A\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002 \u3044\u305A\u308C\u304B\u306E\u8981\u7D20\u540D\u3092\u30AD\u30E3\u30B9\u30C8\u3057\u3066\u578B\u3092\u793A\u3057\u3066\u304F\u3060\u3055\u3044\u3002"};
break;
default:
return {S:"The type could not be determined because all elements of the array initializer \'[]\' are element names of \'enum\'. Cast one of the element names to indicate the type."};
break;
}
break;
case 131135:
switch(m){
case 0:
return {S:"\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306E\u3059\u3079\u3066\u306E\u8981\u7D20\u304C\u300Cnull\u300D\u306E\u305F\u3081\u3001\u578B\u304C\u6C7A\u5B9A\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002 \u3044\u305A\u308C\u304B\u306E\u300Cnull\u300D\u3092\u30AD\u30E3\u30B9\u30C8\u3057\u3066\u578B\u3092\u793A\u3057\u3066\u304F\u3060\u3055\u3044\u3002"};
break;
default:
return {S:"The type could not be determined because all elements of the array initializer \'[]\' are \'null\'. Cast one of \'null\' to indicate the type."};
break;
}
break;
case 131136:
switch(m){
case 0:
return {S:({S:({S:"\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u306A\u3044\u8981\u7D20\u300C"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u300D\u306B\u30A2\u30AF\u30BB\u30B9\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"Accessed inaccessible element \'"}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 196609:
switch(m){
case 0:
return {S:"\u6210\u529F\u3002"};
break;
default:
return {S:"Success."};
break;
}
break;
case 196610:
switch(m){
case 0:
return {S:"\u5931\u6557\u3002"};
break;
default:
return {S:"Failure."};
break;
}
break;
case 196611:
switch(m){
case 0:
return {S:({S:({S:"\u30B3\u30F3\u30D1\u30A4\u30EB\u958B\u59CB: "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u3002"}).S};
break;
default:
return {S:({S:({S:"Compilation started: "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"."}).S};
break;
}
break;
case 196612:
switch(m){
case 0:
return {S:({S:({S:"\u5B57\u53E5\u69CB\u6587\u89E3\u6790\u5B8C\u4E86: "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u3002"}).S};
break;
default:
return {S:({S:({S:"Parsing is complete: "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"."}).S};
break;
}
break;
case 196613:
switch(m){
case 0:
return {S:({S:({S:"\u610F\u5473\u89E3\u6790\u5B8C\u4E86: "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u3002"}).S};
break;
default:
return {S:({S:({S:"Semantic analysis is complete: "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"."}).S};
break;
}
break;
case 196614:
switch(m){
case 0:
return {S:({S:({S:"\u751F\u6210\u51E6\u7406\u5B8C\u4E86: "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"\u3002"}).S};
break;
default:
return {S:({S:({S:"Generation process is complete: "}).S+((v)(((fp)[0]),([129,2]))).S}).S+({S:"."}).S};
break;
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// _forEach
function e5(pv /*me_*/,pw /*type*/,px /*callback*/,py /*data*/){
let D_={F:px,D:py,C:true};
if(pw[1]===129&&pw[2]===2)
pv.forEach(function(V_,K_){if(this.C)this.C=this.F({S:K_},V_,this.D)},D_);
else
pv.forEach(function(V_,K_){if(this.C)this.C=this.F(K_,V_,this.D)},D_);
return D_.C;
}
// parseSrc
function e6(pz /*key*/,p0 /*value*/,p1 /*data*/){
let p9=null; // truePath
let pN=null; // ast
if((p0)!==(null)){
(bE)((ae),([133,129,2,134]),(pz),(p0));
return true;
}
if(!((p5)((pz)))){
(D)((4),(null),([(pz)]));
return true;
}
((p1).e3)=(false);
if(((pz).S.charCodeAt(0))===(0x005C)){
(p9)=({S:({S:(Z).S+((pA)(((pB)((pz),([129,2]),(1),(-1))))).S}).S+({S:".kn"}).S});
}
else{
(p9)=({S:({S:(W).S+((pA)((pz))).S}).S+({S:".kn"}).S});
}
(af)=((pD)((new pE()),(p9)));
if((af)===(null)){
(D)((5),(null),([(p9)]));
return true;
}
(ag)=(pz);
(pH)=(1);
(pI)=(0);
(pJ)=(0x0000);
(pK)=(0x0000);
(pL)=(false);
(ah)=([]);
(pM)=(0);
(ai)=(null);
(pN)=((pO)());
(pQ)((af));
(bE)((ae),([133,129,2,134]),(pz),(pN));
return true;
}
// searchMain
function e9(){
let pR=null; // ast
let pV=false;
let pY=null; // mainFunc
let qc=false;
let qg=null; // mainFunc2
let pS=null;
let pU=false;
let pZ=null;
let qb=false;
(pR)=((pS=(pT)((I),([133,129,2,134]),({S:({S:"\\"}).S+(aa).S}),(pU={$:(pV)},pU)),(pV)=pU.$,pS));
if((pR)===(null)){
(D)((131073),(null),(null));
return null;
}
(pY)=((pZ=(pT)(((pR).qa),([133,129,2,134]),({S:"main"}),(qb={$:(qc)},qb)),(qc)=qb.$,pZ));
if(((pY)===(null))||(((pY).qe)!==(256))){
(D)((131073),(null),(null));
return null;
}
(qg)=(pY);
if(((((((qg).qi).L)!==(0))||(((qg).qj)!==(null)))||(((qg).qk)!==(0)))||((((qg).ql).L)!==(0))){
(D)((131074),((qg).qn),(null));
}
return qg;
}
// resolveIdentifier
function eC(qo /*key*/,qp /*value*/,qq /*data*/){
let qr=null; // scopeRefedItems
let qw=null; // item
let qz=null; // ast
let q3=false; // otherFile
let q4=0; // ptrAt
let q6=null; // ptrName
let q7=null; // foundAst
let qC=null; // ptrSrc
let qG=null; // ast2
let qJ=false;
let qO=false;
let qQ=null; // scope
let qS=false; // overFunc
let re=null; // ast2
let rh=false;
let rk=false; // err
let rp=0; // kind
let qH=null;
let qI=false;
let qM=null;
let qN=false;
let rf=null;
let rg=false;
if(!((qp)instanceof pP)){throw 0xE9170000;}
(qr)=((qp).qs);
(qt)((qr),([130,134]));
while(!((qv)((qr),([130,134])))){
(qw)=((qx)((qr),([130,134])));
(qz)=((qw).q0);
if(!(((qz).q1)===(null))){throw 0xE9170000;}
if(!(((qz).q2)!==(null))){throw 0xE9170000;}
(q3)=(false);
(q4)=((q5)(((qz).q2),([129,2]),(0x0040),(-1)));
(q6)=(((q4)===(-1))?((qz).q2):((pB)(((qz).q2),([129,2]),((q4)+(1)),(-1))));
(q7)=(null);
if((q4)!==(-1)){
if((q4)===(0)){
(qC)=(qo);
}
else{
(qC)=((pB)(((qz).q2),([129,2]),(0),(q4)));
if((qC).S===(qo).S){
(D)((131076),((qz).qn),([(qC)]));
}
(q3)=(true);
}
(qG)=((qH=(pT)((I),([133,129,2,134]),(qC),(qI={$:(qJ)},qI)),(qJ)=qI.$,qH));
if((qG)!==(null)){
(q7)=((qM=(pT)(((qG).qa),([133,129,2,134]),(q6),(qN={$:(qO)},qN)),(qO)=qN.$,qM));
}
}
else{
(qQ)=((qw).qR);
(qS)=(false);
qU:
while(true){
if(((qQ).qW)===(null)){
break qU;
}
if((((qQ).qZ)!==(null))&&(((qQ).qZ).S===(q6).S)){
if((((qQ).qe)===(256))&&(((qQ).q2)!==(null))){
(D)((131075),((qz).qn),([(q6)]));
}
else{
(q7)=(qQ);
break qU;
}
}
(re)=((rf=(pT)(((qQ).qa),([133,129,2,134]),(q6),(rg={$:(rh)},rg)),(rh)=rg.$,rf));
if((re)!==(null)){
(rk)=(false);
if(qS){
if(((re).qe)===(7)){
(rp)=((re).rr);
if((((rp)===(5))||((rp)===(3)))||((rp)===(2))){
(rk)=(true);
}
}
if((!(rk))&&(((rv)(((re).qe),([9]),(66048)))===(66048))){
(rk)=(true);
}
}
if(((!(rk))&&(((re).qe)===(256)))&&(((re).q2)!==(null))){
(rk)=(true);
}
if(rk){
(D)((131075),((qz).qn),([(q6)]));
}
else{
(q7)=(re);
break qU;
}
}
if(((qQ).qe)===(256)){
(qS)=(true);
}
(qQ)=((qQ).qW);
}
}
if((q7)!==(null)){
if((q3)&&(!((q7).r7))){
(D)((131077),((qz).qn),([((qz).q2)]));
}
((qz).q1)=(q7);
}
else{
(D)((131078),((qz).qn),([((qz).q2)]));
((qz).q1)=(null);
}
(rA)((qr),([130,134]));
}
return true;
}
// rebuild
function eD(rB /*mainFunc*/){
let rD=null; // entry
let rG=null; // root
let rJ=false;
let rH=null;
let rI=false;
(rD)=((rE)((rB)));
(rF)((rD));
(rG)=((rH=(pT)((I),([133,129,2,134]),({S:({S:"\\"}).S+(aa).S}),(rI={$:(rJ)},rI)),(rJ)=rI.$,rH));
if(!((rG)instanceof pP)){throw 0xE9170000;}
(eP)(((rG).rK),([130,134]),(rD));
(e5)((I),([133,129,2,134]),(rL),(null));
return rD;
}
// _addList
function eP(rM /*me_*/,rN /*type*/,rO /*item*/){
let n_={P:null,N:null,I:rO};
if(rM.H===null){rM.H=n_;rM.T=n_}else{n_.P=rM.T;rM.T.N=n_;rM.T=n_}
rM.L++;
}
// _addQueue
function eS(rP /*me_*/,rQ /*type*/,rR /*item*/){
rP.push(rR);
}
// _getQueue
function eX(rS /*me_*/,rT /*type*/){
return rS.shift();
}
// buildFunc
function eY(rU /*ast*/){
let rV=null; // info
let sb=null; // template
let sp=null; // retType
let st=null; // arg
let sv=0; // idx
let sw=null; // items
let sy=null; // item
let s2=null; // info2
let ta=false; // hasMembers
let td=null; // arg2
let th=null; // members
let to=0; // localVarPos
let tu=null; // localVar
let tv=null; // info2
let t3=null; // tmpVar
(rV)=((rW)((rU)));
if((rV).rZ){
return;
}
((rV).rZ)=(true);
(sb)=({S:""});
if(((rv)(((rU).qk),([9]),(1)))===(1)){
if(((rv)(((rU).qk),([9]),(32)))===(32)){
(sb)=({S:"template<typename T_, typename K_, typename V_> "});
}
else if(((rv)(((rU).qk),([9]),(8)))===(8)){
if(((rv)(((rU).qk),([9]),(16)))===(16)){
(sb)=({S:"template<typename T_, typename C_, typename R_> "});
}
else{
(sb)=({S:"template<typename T_, typename C_> "});
}
}
else if(((rv)(((rU).qk),([9]),(16)))===(16)){
(sb)=({S:"template<typename T_, typename R_> "});
}
else if(((rv)(((rU).qk),([9]),(256)))===(256)){
(sb)=({S:"template<typename T_, typename K_, typename V_> "});
}
else{
(sb)=({S:"template<typename T_> "});
}
}
if(((rv)(((rU).qk),([9]),(16)))===(16)){
(sp)=({S:"R_"});
}
else if(((rv)(((rU).qk),([9]),(4)))===(4)){
(sp)=({S:"T_"});
}
else{
(sp)=((ss)(((rU).qj)));
}
(st)=({S:""});
(sv)=(0);
(sw)=((rU).qi);
(qt)((sw),([130,134]));
while(!((qv)((sw),([130,134])))){
(sy)=((qx)((sw),([130,134])));
if((sv)!==(0)){
(st)=({S:(st).S+({S:", "}).S});
}
(s2)=((rW)((sy)));
if((((rv)(((rU).qk),([9]),(1)))===(1))&&((sv)===(0))){
if(!((s5)(((sy).s6)))){throw 0xE9170000;}
(st)=({S:(st).S+({S:"T_"}).S});
}
else if((((rv)(((rU).qk),([9]),(32)))===(32))&&((sv)===(2))){
if(!((s5)(((sy).s6)))){throw 0xE9170000;}
(st)=({S:(st).S+({S:"K_"}).S});
}
else if((((rv)(((rU).qk),([9]),(32)))===(32))&&((sv)===(3))){
if(!((s5)(((sy).s6)))){throw 0xE9170000;}
(st)=({S:(st).S+({S:"V_"}).S});
}
else if((((rv)(((rU).qk),([9]),(8)))===(8))&&((sv)===(2))){
if(!((s5)(((sy).s6)))){throw 0xE9170000;}
(st)=({S:(st).S+({S:"C_"}).S});
}
else if((((rv)(((rU).qk),([9]),(2)))===(2))&&((sv)===(2))){
if(!((s5)(((sy).s6)))){throw 0xE9170000;}
(st)=({S:(st).S+({S:"T_"}).S});
}
else if((((rv)(((rU).qk),([9]),(256)))===(256))&&((sv)===(2))){
if(!((s5)(((sy).s6)))){throw 0xE9170000;}
(st)=({S:(st).S+({S:"const void*"}).S});
}
else{
(st)=({S:(st).S+({S:({S:({S:""}).S+((v)(((ss)(((sy).s6))),([129,2]))).S}).S+({S:""}).S}).S});
}
if((sy).sL){
(st)=({S:(st).S+({S:"*"}).S});
}
(st)=({S:(st).S+({S:({S:({S:" "}).S+((v)(((s2).sP),([129,2]))).S}).S+({S:""}).S}).S});
if(((sy).qZ)!==(null)){
(st)=({S:(st).S+({S:({S:({S:" /*"}).S+((v)(((sy).qZ),([129,2]))).S}).S+({S:"*/"}).S}).S});
}
(rA)((sw),([130,134]));
(sv)=((sv)+(1));
}
if(((rU).qZ)!==(null)){
(eP)((P),([130,129,2]),({S:({S:({S:"// "}).S+((v)(((rU).qZ),([129,2]))).S}).S+({S:"\u000A"}).S}));
}
(eP)((O),([130,129,2]),({S:({S:({S:""}).S+((v)((sb),([129,2]))).S}).S+({S:({S:({S:"static "}).S+((v)((sp),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((rV).sP),([129,2]))).S}).S+({S:({S:({S:"("}).S+((v)((st),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}).S}));
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)((sb),([129,2]))).S}).S+({S:({S:({S:"static "}).S+((v)((sp),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((rV).sP),([129,2]))).S}).S+({S:({S:({S:"("}).S+((v)((st),([129,2]))).S}).S+({S:"){\u000A"}).S}).S}).S}).S}));
if(((rv)(((rU).qk),([9]),(4096)))===(4096)){
if((((rU).ql).L)===(1)){
(qt)(((rU).ql),([130,129,2]));
(ta)=(false);
if((((rU).qi).L)>(0)){
(qt)(((rU).qi),([130,134]));
(td)=((qx)(((rU).qi),([130,134])));
if(((((td).s6).q1)!==(null))&&(((((td).s6).q1).qe)===(5))){
(th)=((((td).s6).q1).ti);
(tj)((P),((qx)(((rU).ql),([130,129,2]))),((rU).qi),(th));
(ta)=(true);
}
}
if(!(ta)){
(tj)((P),((qx)(((rU).ql),([130,129,2]))),((rU).qi),(null));
}
(eP)((P),([130,129,2]),({S:"}\u000A"}));
}
}
else{
(tn)((P),([130,129,2]));
(to)=((tp)((P),([130,129,2])));
(tq)(((rU).tr),(null),(null));
(eP)((P),([130,129,2]),({S:"}\u000A"}));
(qt)((P),([130,129,2]));
(ts)((P),([130,129,2]),(to));
(rA)((P),([130,129,2]));
(qt)((T),([130,134]));
while(!((qv)((T),([130,134])))){
(tu)=((qx)((T),([130,134])));
(tv)=((rW)((tu)));
if(((tu).qZ)===(null)){
(ty)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((ss)(((tu).s6))),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((tv).sP),([129,2]))).S}).S+({S:({S:({S:" = "}).S+((v)(((tz)(((tu).s6))),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
}
else{
(ty)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((ss)(((tu).s6))),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((tv).sP),([129,2]))).S}).S+({S:({S:({S:" = "}).S+((v)(((tz)(((tu).s6))),([129,2]))).S}).S+({S:({S:({S:"; // "}).S+((v)(((tu).qZ),([129,2]))).S}).S+({S:"\u000A"}).S}).S}).S}).S}));
}
(t1)((T),([130,134]));
}
(qt)((R),([130,134]));
while(!((qv)((R),([130,134])))){
(t3)=((qx)((R),([130,134])));
(ty)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((ss)(((t3).t5))),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((t3).t6),([129,2]))).S}).S+({S:({S:({S:" = "}).S+((v)(((tz)(((t3).t5))),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
(t1)((R),([130,134]));
}
}
}
// buildClass
function fc(t7 /*ast*/){
let t8=null; // parentId
let tE=null; // info
let tJ=0; // parentOffset
let tL=null; // parentInfo
let tP=null; // items
let tR=null; // item
let tW=null; // var_
let tY=null; // info2
let ub=null; // ctor
let uf=null; // ctorInfo
let uh=null; // cmp
let uk=null; // cmpInfo
let ul=null; // copy
let un=null; // copyInfo
let up=null; // items
let ur=null; // item
let uu=null; // var_
let uv=null; // info2
(t8)=(null);
if(((t7).q1)!==(null)){
(t8)=((tB)(((t7).q1)));
}
if((t8)===(null)){
(t8)=({S:"Class_"});
}
(tE)=((rW)((t7)));
if(!(((tE).tG)!==(-1))){throw 0xE9170000;}
if(((t7).q1)===(null)){
(tJ)=(0);
}
else{
(tL)=((rW)(((t7).q1)));
if(!(((tL).tG)!==(-1))){throw 0xE9170000;}
(tJ)=((tL).tG);
}
(eP)((U),([130,129,2]),({S:({S:({S:"classTable_["}).S+((v)((((tE).tG)*(2)),([0]))).S}).S+({S:({S:({S:"] = "}).S+((v)(((tJ)*(2)),([0]))).S}).S+({S:";\u000A"}).S}).S}));
if(((t7).qZ)!==(null)){
(eP)((N),([130,129,2]),({S:({S:({S:"// "}).S+((v)(((t7).qZ),([129,2]))).S}).S+({S:"\u000A"}).S}));
}
(eP)((N),([130,129,2]),({S:({S:({S:"class "}).S+((v)(((tE).sP),([129,2]))).S}).S+({S:({S:({S:" : public "}).S+((v)((t8),([129,2]))).S}).S+({S:"{\u000Apublic:\u000A"}).S}).S}));
(eP)((N),([130,129,2]),({S:({S:({S:""}).S+((v)(((tE).sP),([129,2]))).S}).S+({S:"();\u000A"}).S}));
(eP)((Q),([130,129,2]),({S:({S:({S:""}).S+((v)(((tE).sP),([129,2]))).S}).S+({S:({S:({S:"::"}).S+((v)(((tE).sP),([129,2]))).S}).S+({S:({S:({S:"(): "}).S+((v)((t8),([129,2]))).S}).S+({S:"()"}).S}).S}).S}));
(tP)=((t7).ti);
(qt)((tP),([130,134]));
while(!((qv)((tP),([130,134])))){
(tR)=((qx)((tP),([130,134])));
if((((tR).tU).qe)===(2)){
(tW)=((tR).tU);
(tY)=((rW)(((tW).tZ)));
(eP)((Q),([130,129,2]),({S:({S:({S:", "}).S+((v)(((tY).sP),([129,2]))).S}).S+({S:"()"}).S}));
}
(rA)((tP),([130,134]));
}
(eP)((Q),([130,129,2]),({S:"{\u000A"}));
(eP)((Q),([130,129,2]),({S:({S:({S:"Y = "}).S+((v)((((tE).tG)*(2)),([0]))).S}).S+({S:";\u000A"}).S}));
(ub)=((uc)((t7),({S:"ctor"})));
if((ub)!==(null)){
(uf)=((rW)((ub)));
(eP)((Q),([130,129,2]),({S:({S:({S:""}).S+((v)(((uf).sP),([129,2]))).S}).S+({S:"(this);\u000A"}).S}));
}
(eP)((Q),([130,129,2]),({S:"}\u000A"}));
(uh)=((uc)((t7),({S:"cmp"})));
if((uh)!==(null)){
(uk)=((rW)((uh)));
(eP)((N),([130,129,2]),({S:"virtual int64_t cmp_(Class_* t) override;\u000A"}));
(eP)((Q),([130,129,2]),({S:({S:({S:"int64_t "}).S+((v)(((tE).sP),([129,2]))).S}).S+({S:"::cmp_(Class_* t){\u000A"}).S}));
(eP)((Q),([130,129,2]),({S:({S:({S:""}).S+((v)(((tE).sP),([129,2]))).S}).S+({S:({S:({S:"* u = reinterpret_cast<"}).S+((v)(((tE).sP),([129,2]))).S}).S+({S:"*>(t);\u000A"}).S}).S}));
(eP)((Q),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((uk).sP),([129,2]))).S}).S+({S:"(this, u);\u000A"}).S}));
(eP)((Q),([130,129,2]),({S:"}\u000A"}));
}
(ul)=((uc)((t7),({S:"_copy"})));
if(!((ul)!==(null))){throw 0xE9170000;}
(un)=((rW)((ul)));
(eP)((N),([130,129,2]),({S:"virtual Class_* copy_(Class_* t) override;\u000A"}));
(eP)((Q),([130,129,2]),({S:({S:({S:"Class_* "}).S+((v)(((tE).sP),([129,2]))).S}).S+({S:"::copy_(Class_* t){\u000A"}).S}));
(eP)((Q),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((un).sP),([129,2]))).S}).S+({S:"(this);\u000A"}).S}));
(eP)((Q),([130,129,2]),({S:"}\u000A"}));
(up)=((t7).ti);
(qt)((up),([130,134]));
while(!((qv)((up),([130,134])))){
(ur)=((qx)((up),([130,134])));
if((((ur).tU).qe)===(2)){
(uu)=((ur).tU);
(uv)=((rW)(((uu).tZ)));
if((((uu).tZ).qZ)===(null)){
(eP)((N),([130,129,2]),({S:({S:({S:""}).S+((v)(((ss)((((uu).tZ).s6))),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((uv).sP),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else{
(eP)((N),([130,129,2]),({S:({S:({S:""}).S+((v)(((ss)((((uu).tZ).s6))),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((uv).sP),([129,2]))).S}).S+({S:({S:({S:"; // "}).S+((v)((((uu).tZ).qZ),([129,2]))).S}).S+({S:"\u000A"}).S}).S}).S}));
}
}
(rA)((up),([130,134]));
}
(eP)((N),([130,129,2]),({S:"};\u000A"}));
}
// write
function fd(uz /*resFiles*/){
let u1=null; // writer
let uA=null; // globalVar
let uB=null; // info
let uG=null; // item
(u0)(({S:(ab).S+({S:"common.h"}).S}),({S:(W).S+({S:"common.h"}).S}));
(u1)=((u2)((new u3()),({S:(V).S+({S:".cpp"}).S}),(false)));
(u4)((u1),({S:"#include \"common.h\"\u000A"}));
(u4)((u1),({S:"namespace {\u000A"}));
(qt)((N),([130,129,2]));
while(!((qv)((N),([130,129,2])))){
(u4)((u1),((qx)((N),([130,129,2]))));
(rA)((N),([130,129,2]));
}
(qt)((O),([130,129,2]));
while(!((qv)((O),([130,129,2])))){
(u4)((u1),((qx)((O),([130,129,2]))));
(rA)((O),([130,129,2]));
}
if((eT)!==(0)){
(u4)((u1),({S:({S:({S:"static int64_t classTable_["}).S+((v)(((eT)*(2)),([0]))).S}).S+({S:"];\u000A"}).S}));
}
(u4)((u1),({S:"static int64_t argc_;\u000A"}));
(u4)((u1),({S:"static char** argv_;\u000A"}));
(qt)((S),([130,134]));
while(!((qv)((S),([130,134])))){
(uA)=((qx)((S),([130,134])));
(uB)=((rW)((uA)));
(u4)((u1),({S:({S:({S:"static "}).S+((v)(((ss)(((uA).s6))),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((uB).sP),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
(rA)((S),([130,134]));
}
(qt)((Q),([130,129,2]));
while(!((qv)((Q),([130,129,2])))){
(u4)((u1),((qx)((Q),([130,129,2]))));
(rA)((Q),([130,129,2]));
}
(qt)((P),([130,129,2]));
while(!((qv)((P),([130,129,2])))){
(u4)((u1),((qx)((P),([130,129,2]))));
(rA)((P),([130,129,2]));
}
(u4)((u1),({S:"}\u000A"}));
(u4)((u1),({S:"int main(int c_, char** v_){\u000A"}));
(u4)((u1),({S:"argc_ = c_ - 1;\u000A"}));
(u4)((u1),({S:"argv_ = v_ + 1;\u000A"}));
(qt)((U),([130,129,2]));
while(!((qv)((U),([130,129,2])))){
(uG)=((qx)((U),([130,129,2])));
(u4)((u1),(uG));
(rA)((U),([130,129,2]));
}
(u4)((u1),({S:"init_();\u000A"}));
(u4)((u1),({S:"a();\u000A"}));
(u4)((u1),({S:"return 0;\u000A"}));
(u4)((u1),({S:"}\u000A"}));
(uH)((u1));
}
// buildFunc
function fj(uI /*ast*/){
let uJ=null; // info
let uP=null; // arg
let uR=false; // first
let uS=null; // items
let uU=null; // item
let uV=null; // info2
let vl=false; // hasMembers
let vo=null; // arg2
let vr=null; // members
let vw=0; // localVarPos
let vz=null; // localVar
let v0=null; // info2
let v6=null; // tmpVar
(uJ)=((uK)((uI)));
if((uJ).uN){
return;
}
((uJ).uN)=(true);
(uP)=({S:""});
(uR)=(true);
(uS)=((uI).qi);
(qt)((uS),([130,134]));
while(!((qv)((uS),([130,134])))){
(uU)=((qx)((uS),([130,134])));
(uV)=((uK)((uU)));
if(uR){
(uR)=(false);
}
else{
(uP)=({S:(uP).S+({S:","}).S});
}
(uP)=({S:(uP).S+({S:({S:({S:""}).S+((v)(((uV).vb),([129,2]))).S}).S+({S:""}).S}).S});
if(((uU).qZ)!==(null)){
(uP)=({S:(uP).S+({S:({S:({S:" /*"}).S+((v)(((uU).qZ),([129,2]))).S}).S+({S:"*/"}).S}).S});
}
(rA)((uS),([130,134]));
}
if(((uI).qZ)!==(null)){
(eP)((am),([130,129,2]),({S:({S:({S:"// "}).S+((v)(((uI).qZ),([129,2]))).S}).S+({S:"\u000A"}).S}));
}
(eP)((am),([130,129,2]),({S:({S:({S:"function "}).S+((v)(((uJ).vb),([129,2]))).S}).S+({S:({S:({S:"("}).S+((v)((uP),([129,2]))).S}).S+({S:"){\u000A"}).S}).S}));
if(((rv)(((uI).qk),([9]),(4096)))===(4096)){
if((((uI).ql).L)===(1)){
(qt)(((uI).ql),([130,129,2]));
(vl)=(false);
if((((uI).qi).L)>(0)){
(qt)(((uI).qi),([130,134]));
(vo)=((qx)(((uI).qi),([130,134])));
if(((((vo).s6).q1)!==(null))&&(((((vo).s6).q1).qe)===(5))){
(vr)=((((vo).s6).q1).ti);
(vs)((am),((qx)(((uI).ql),([130,129,2]))),((uI).qi),(vr));
(vl)=(true);
}
}
if(!(vl)){
(vs)((am),((qx)(((uI).ql),([130,129,2]))),((uI).qi),(null));
}
(eP)((am),([130,129,2]),({S:"}\u000A"}));
}
}
else{
(tn)((am),([130,129,2]));
(vw)=((tp)((am),([130,129,2])));
(vx)(((uI).tr));
(eP)((am),([130,129,2]),({S:"}\u000A"}));
(qt)((am),([130,129,2]));
(ts)((am),([130,129,2]),(vw));
(rA)((am),([130,129,2]));
(qt)((ap),([130,134]));
while(!((qv)((ap),([130,134])))){
(vz)=((qx)((ap),([130,134])));
(v0)=((uK)((vz)));
if(((vz).qZ)===(null)){
(ty)((am),([130,129,2]),({S:({S:({S:"let "}).S+((v)(((v0).vb),([129,2]))).S}).S+({S:({S:({S:"="}).S+((v)(((v3)(((vz).s6))),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else{
(ty)((am),([130,129,2]),({S:({S:({S:"let "}).S+((v)(((v0).vb),([129,2]))).S}).S+({S:({S:({S:"="}).S+((v)(((v3)(((vz).s6))),([129,2]))).S}).S+({S:({S:({S:"; // "}).S+((v)(((vz).qZ),([129,2]))).S}).S+({S:"\u000A"}).S}).S}).S}));
}
(t1)((ap),([130,134]));
}
(qt)((an),([130,134]));
while(!((qv)((an),([130,134])))){
(v6)=((qx)((an),([130,134])));
(ty)((am),([130,129,2]),({S:({S:({S:"let "}).S+((v)(((v6).v8),([129,2]))).S}).S+({S:({S:({S:"="}).S+((v)(((v3)(((v6).v9))),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
(t1)((an),([130,134]));
}
}
}
// buildClass
function fm(vA /*ast*/){
let vB=null; // parentId
let vH=null; // info
let vL=null; // ctor
let vP=null; // ctorInfo
let vR=null; // items
let vT=null; // item
(vB)=(null);
if(((vA).q1)!==(null)){
(vB)=((vE)(((vA).q1)));
}
if((vB)===(null)){
(vB)=({S:"Object"});
}
(vH)=((uK)((vA)));
if(((vA).qZ)!==(null)){
(eP)((am),([130,129,2]),({S:({S:({S:"// "}).S+((v)(((vA).qZ),([129,2]))).S}).S+({S:"\u000A"}).S}));
}
(vL)=((vM)((vA),({S:"ctor"})));
(eP)((am),([130,129,2]),({S:({S:({S:"function "}).S+((v)(((vH).vb),([129,2]))).S}).S+({S:"(){\u000A"}).S}));
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)((vB),([129,2]))).S}).S+({S:".call(this);\u000A"}).S}));
if((vL)!==(null)){
(vP)=((uK)((vL)));
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((vP).vb),([129,2]))).S}).S+({S:"(this);\u000A"}).S}));
}
(eP)((am),([130,129,2]),({S:"}\u000A"}));
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((vH).vb),([129,2]))).S}).S+({S:({S:({S:".prototype = Object.create("}).S+((v)((vB),([129,2]))).S}).S+({S:".prototype);\u000A"}).S}).S}));
(vR)=((vA).ti);
(qt)((vR),([130,134]));
while(!((qv)((vR),([130,134])))){
(vT)=((qx)((vR),([130,134])));
if((((vT).tU).qe)===(256)){
(eS)((aj),([132,134]),((vT).tU));
}
(rA)((vR),([130,134]));
}
}
// write
function fn(vW /*resFiles*/){
let vX=null; // writer
let vY=false; // static
let wb=false;
let wg=null; // globalVar
let wh=null; // info
let wk=false; // first
let wm=null; // resFile
let wn=null; // reader
let wt=0;
let wy=null; // line
let w2=0;
let wA=null; // fileName
let vZ=false;
let wa=false;
let wu=0;
let w3=0;
(vX)=((u2)((new u3()),({S:(V).S+({S:".js"}).S}),(false)));
(vY)=((vZ=(pT)((Y),([133,129,2,3]),({S:"static"}),(wa={$:(wb)},wa)),(wb)=wa.$,vZ));
if(vY){
(u4)((vX),({S:({S:({S:"\"use strict\";function "}).S+((v)(((co)((V))),([129,2]))).S}).S+({S:"(O_){\u000A"}).S}));
}
else{
(u4)((vX),({S:"\"use strict\";!function(f){let d=document;function h(){d.removeEventListener(\"DOMContentLoaded\",h);removeEventListener(\"load\",h);f()}\"complete\"===d.readyState||\"loading\"!==d.readyState&&!d.documentElement.doScroll?setTimeout(f):(d.addEventListener(\"DOMContentLoaded\",h),addEventListener(\"load\",h))}(function(){\u000A"}));
(u4)((vX),({S:"let O_;\u000A"}));
}
(qt)((ao),([130,134]));
while(!((qv)((ao),([130,134])))){
(wg)=((qx)((ao),([130,134])));
(wh)=((uK)((wg)));
(u4)((vX),({S:({S:({S:"let "}).S+((v)(((wh).vb),([129,2]))).S}).S+({S:({S:({S:"="}).S+((v)(((v3)(((wg).s6))),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
(rA)((ao),([130,134]));
}
(qt)((am),([130,129,2]));
while(!((qv)((am),([130,129,2])))){
(u4)((vX),((qx)((am),([130,129,2]))));
(rA)((am),([130,129,2]));
}
(u4)((vX),({S:"function C_(t,v){\u000A"}));
(u4)((vX),({S:"switch(t[0]){\u000A"}));
(u4)((vX),({S:({S:({S:"case "}).S+((v)((0),([0]))).S}).S+({S:":\u000A"}).S}));
(u4)((vX),({S:({S:({S:"case "}).S+((v)((1),([0]))).S}).S+({S:":\u000A"}).S}));
(u4)((vX),({S:({S:({S:"case "}).S+((v)((2),([0]))).S}).S+({S:":\u000A"}).S}));
(u4)((vX),({S:({S:({S:"case "}).S+((v)((3),([0]))).S}).S+({S:":\u000A"}).S}));
(u4)((vX),({S:({S:({S:"case "}).S+((v)((4),([0]))).S}).S+({S:":\u000A"}).S}));
(u4)((vX),({S:({S:({S:"case "}).S+((v)((5),([0]))).S}).S+({S:":\u000A"}).S}));
(u4)((vX),({S:({S:({S:"case "}).S+((v)((6),([0]))).S}).S+({S:":\u000A"}).S}));
(u4)((vX),({S:({S:({S:"case "}).S+((v)((7),([0]))).S}).S+({S:":\u000A"}).S}));
(u4)((vX),({S:({S:({S:"case "}).S+((v)((8),([0]))).S}).S+({S:":\u000A"}).S}));
(u4)((vX),({S:({S:({S:"case "}).S+((v)((9),([0]))).S}).S+({S:":\u000A"}).S}));
(u4)((vX),({S:"return v;\u000A"}));
(u4)((vX),({S:({S:({S:"case "}).S+((v)((129),([0]))).S}).S+({S:":\u000A"}).S}));
(u4)((vX),({S:({S:({S:"if(t[1]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}));
(u4)((vX),({S:"return v===null?null:{S:v.S};\u000A"}));
(u4)((vX),({S:"else{\u000A"}));
(u4)((vX),({S:"let a=new Array(v.length);\u000A"}));
(u4)((vX),({S:"for(let i=0;i<v.length;i++)a[i]=C_(t.slice(1),v[i]);\u000A"}));
(u4)((vX),({S:"return a;\u000A"}));
(u4)((vX),({S:"}\u000A"}));
(u4)((vX),({S:({S:({S:"case "}).S+((v)((130),([0]))).S}).S+({S:":\u000A"}).S}));
(u4)((vX),({S:({S:({S:"case "}).S+((v)((131),([0]))).S}).S+({S:":\u000A"}).S}));
(u4)((vX),({S:({S:({S:"case "}).S+((v)((132),([0]))).S}).S+({S:":\u000A"}).S}));
(u4)((vX),({S:({S:({S:"case "}).S+((v)((133),([0]))).S}).S+({S:":\u000A"}).S}));
(u4)((vX),({S:({S:({S:"case "}).S+((v)((134),([0]))).S}).S+({S:":\u000A"}).S}));
(u4)((vX),({S:"}\u000A"}));
(u4)((vX),({S:"}\u000A"}));
(u4)((vX),({S:"function F_(p){\u000A"}));
(wk)=(true);
(qt)((vW),([130,129,2]));
while(!((qv)((vW),([130,129,2])))){
(wm)=((qx)((vW),([130,129,2])));
(wn)=((pD)((new pE()),(wm)));
if(wk){
(wk)=(false);
(u4)((vX),({S:"if(p===\""}));
}
else{
(u4)((vX),({S:"else if(p===\""}));
}
ws:
for(wt=((Z).S.length),wu=(((wm).S.length)-(1));wt<=wu;wt+=(1)){
(u4)((vX),((wv)(((wm).S.charCodeAt(wt)))));
}
(u4)((vX),({S:"\")\u000A"}));
(u4)((vX),({S:"return \""}));
while(!((wx)((wn)))){
(wy)=((wz)((wn)));
w1:
for(w2=(0),w3=(((wy).S.length)-(1));w2<=w3;w2+=(1)){
(u4)((vX),((wv)(((wy).S.charCodeAt(w2)))));
}
(u4)((vX),({S:"\\n"}));
}
(u4)((vX),({S:"\";\u000A"}));
(pQ)((wn));
(rA)((vW),([130,129,2]));
}
if(((vW).L)>(0)){
(u4)((vX),({S:"else return null;\u000A"}));
}
else{
(u4)((vX),({S:"return null;\u000A"}));
}
(u4)((vX),({S:"}\u000A"}));
(u4)((vX),({S:"a();\u000A"}));
if(vY){
(u4)((vX),({S:"}\u000A"}));
}
else{
(u4)((vX),({S:"})\u000A"}));
}
(uH)((vX));
(wA)=((co)((V)));
(vX)=((u2)((new u3()),({S:(V).S+({S:".html"}).S}),(false)));
(u4)((vX),({S:"<!DOCTYPE html>\u000A"}));
(u4)((vX),({S:"<html>\u000A"}));
(u4)((vX),({S:"\u0009<head>\u000A"}));
(u4)((vX),({S:"\u0009\u0009<meta charset=\"utf-8\" />\u000A"}));
(u4)((vX),({S:({S:({S:"\u0009\u0009<script src=\""}).S+((v)((wA),([129,2]))).S}).S+({S:".js\" type=\"text/javascript\"></script>\u000A"}).S}));
(u4)((vX),({S:({S:({S:"\u0009\u0009<title>"}).S+((v)((wA),([129,2]))).S}).S+({S:"</title>\u000A"}).S}));
(u4)((vX),({S:"\u0009</head>\u000A"}));
(u4)((vX),({S:"\u0009<body>\u000A"}));
(u4)((vX),({S:"\u0009</body>\u000A"}));
(u4)((vX),({S:"</html>\u000A"}));
(uH)((vX));
}
// isCorrectSrcName
function p5(wB /*name*/){
let wC=0; // idx
(wC)=(0);
if(((wC)<((wB).S.length))&&(((wB).S.charCodeAt(wC))===(0x005C))){
(wC)=((wC)+(1));
}
while(true){
if(((wC)>=((wB).S.length))||(!((((0x0061)<=((wB).S.charCodeAt(wC)))&&(((wB).S.charCodeAt(wC))<=(0x007A)))||(((wB).S.charCodeAt(wC))===(0x005F))))){
return false;
}
wK:
while(true){
(wC)=((wC)+(1));
if((wC)>=((wB).S.length)){
return true;
}
if(((((0x0061)<=((wB).S.charCodeAt(wC)))&&(((wB).S.charCodeAt(wC))<=(0x007A)))||(((wB).S.charCodeAt(wC))===(0x005F)))||(((0x0030)<=((wB).S.charCodeAt(wC)))&&(((wB).S.charCodeAt(wC))<=(0x0039)))){
continue wK;
}
if(((wB).S.charCodeAt(wC))===(0x005C)){
(wC)=((wC)+(1));
break wK;
}
return false;
}
}
}
// replacePath
function pA(wT /*path*/){
let wU=null; // r
let wX=0;
let wY=0;
let wZ=0;
let xa=0;
(wU)=({S:"\0".repeat((wT).S.length)});
wW:
for(wX=(0),wY=(((wT).S.length)-(1));wX<=wY;wX+=(1)){
(wU).S=(wZ=(wX),(wU).S.slice(0,wZ)+String.fromCharCode((((wT).S.charCodeAt(wX))===(0x005C))?(0x002F):((wT).S.charCodeAt(wX)))+(wU).S.slice(wZ+1));
}
return wU;
}
// _sub
function pB(xb /*me_*/,xc /*type*/,xd /*start*/,xe /*len*/){
if(xc[0]===129&&xc[1]===2)
return {S:xe===-1?xb.S.slice(xd):xb.S.slice(xd,xd+xe)};
else
return xe===-1?xb.slice(xd):xb.slice(xd,xd+xe);
}
// makeReader
function pD(xf /*me2*/,xg /*path*/){
let f_=null,p_=xg.S;
if(O_&&O_.readFile)f_=O_.readFile(p_);
if(f_===null){
if(p_.length>=4&&p_[0]==="r"&&p_[1]==="e"&&p_[2]==="s"&&p_[3]==="/")
f_=F_(p_);
else{
}
}
if(f_===null)return null;
xf.xh={F:f_,I:0};
return xf;
}
// parseRoot
function pO(){
let xi=null; // ast
let xp=0; // c
let xu=false; // itemPublic
let xz=0; // row
let x0=0; // col
let x1=null; // id
let x4=null;
let x6=null; // item
(xi)=(new pP());
(xj)((xi),(1),((xk)((ag),(1),(1))),(null),(false));
((xi).qs)=({L:0,H:null,T:null,P:null});
((xi).rK)=({L:0,H:null,T:null,P:null});
(ai)=((xi).qs);
((xi).qa)=(new Map());
(xl)((ah),([131,134]),(xi));
(pJ)=(0x000A);
(pJ)=((xm)());
xo:
while(true){
(xp)=((xm)());
if((xp)===(0x0000)){
break xo;
}
if((xp)===(0x000A)){
continue xo;
}
(xu)=(false);
if((xp)===(0x002B)){
(xu)=(true);
}
else{
(pJ)=(xp);
}
(xz)=(pH);
(x0)=(pI);
(x1)=((x2)((true),(false)));
x4=x1;
if(x4.S===({S:"func"}).S){
(x6)=((x7)((null),(false)));
}
else if(x4.S===({S:"var"}).S){
(x6)=((x9)((1),(null)));
}
else if(x4.S===({S:"const"}).S){
(x6)=((xB)());
}
else if(x4.S===({S:"alias"}).S){
(x6)=((xE)());
}
else if(x4.S===({S:"include"}).S){
}
else if(x4.S===({S:"class"}).S){
(x6)=((xI)());
}
else if(x4.S===({S:"enum"}).S){
(x6)=((xK)());
}
else{(D)((65547),((xk)((ag),(xz),(x0))),([(x1)]));
(xN)(((xO)()));
continue xo;
}
if(((x6).qe)===(2)){
(((x6).tZ).r7)=(xu);
}
else if(((x6).qe)===(3)){
(((x6).xS).r7)=(xu);
}
else{
((x6).r7)=(xu);
}
(eP)(((xi).rK),([130,134]),(x6));
}
(xU)((ah),([131,134]));
return xi;
}
// _getDict
function pT(xV /*me_*/,xW /*type*/,xX /*key*/,xY /*existed*/){
let r_;
if(xW[1]===129&&xW[2]===2)
r_=xV.get(xX.S);
else
r_=xV.get(xX);
if(!(xY.$=r_!==undefined)){
switch(xW){
case 0:
case 1:
case 2:
case 4:
case 5:
case 6:
case 7:
case 9:
return 0;
case 3:
return false;
default:
return null;
}
}
return r_;
}
// _head
function qt(xZ /*me_*/,ya /*type*/){
xZ.P=xZ.H;
}
// _term
function qv(yb /*me_*/,yc /*type*/){
return yb.P===null;
}
// _getList
function qx(yd /*me_*/,ye /*type*/){
return yd.P.I;
}
// _findArray
function q5(yf /*me_*/,yg /*type*/,yh /*item*/,yi /*start*/){
if(yg[0]===129&&yg[1]===2)
return yf.S.indexOf(String.fromCharCode(yh),yi===-1?0:yi);
else
return yf.indexOf(yh,yi===-1?0:yi);
}
// _and
function rv(yj /*me_*/,yk /*type*/,yl /*n*/){
return yj&yl;
}
// _next
function rA(ym /*me_*/,yn /*type*/){
ym.P=ym.P.N;
}
// makeEntryPoint
function rE(yo /*mainFunc*/){
let yp=null; // pos
let yq=null; // entry
let yt=null; // try_
let yy=null; // var_
let y0=null; // type
let y6=null; // block_
let yC=null; // block_
let yF=null; // funcs
let yJ=null; // do_
let yM=null; // call
let yS=null; // ref
let yW=null; // catch_
let za=null; // block_
let zd=null; // exprs
let zg=null; // expr
let zm=null; // type
let zq=null; // expr
let zs=null; // type
let zv=null; // do_
let zx=null; // call
let zz=null; // ref_
let z1=null; // excpt
let z6=null; // ref_
let z9=null; // funcs
let zC=null; // do_
let zE=null; // call
let zG=null; // ref
(yp)=((xk)(({S:"kuin"}),(1),(1)));
(yq)=(new c7());
(yr)((yq),(256),(yp));
((yq).qZ)=({S:"$"});
((yq).qk)=(0);
((yq).ql)=({L:0,H:null,T:null,P:null});
((yq).qi)=({L:0,H:null,T:null,P:null});
((yq).qj)=(null);
((yq).tr)=({L:0,H:null,T:null,P:null});
(yt)=(new yu());
(yr)((yt),(66051),(yp));
(yy)=(new rq());
(yr)((yy),(7),(yp));
((yy).qZ)=({S:"$"});
((yy).rr)=(3);
((yy).sL)=(false);
(y0)=(new y1());
(yr)((y0),(1026),(yp));
((y0).y2)=(0);
((yy).s6)=(y0);
((yy).y3)=(null);
((yt).y4)=(yy);
(y6)=(new y7());
(yr)((y6),(66052),(yp));
((y6).qZ)=({S:"$"});
((y6).y4)=(null);
((y6).y8)=({L:0,H:null,T:null,P:null});
((yt).y9)=(y6);
((yt).yA)=({L:0,H:null,T:null,P:null});
(yC)=(new y7());
(yr)((yC),(66052),(yp));
((yC).qZ)=({S:"$"});
((yC).y4)=(null);
((yC).y8)=({L:0,H:null,T:null,P:null});
((yt).yD)=(yC);
(yF)=({L:0,H:null,T:null,P:null});
(eP)((yF),([130,134]),((yG)(({S:"kuin"}),({S:"_init"}),(false))));
(eP)((yF),([130,134]),((yG)(({S:"kuin"}),({S:"_initVars"}),(false))));
(eP)((yF),([130,134]),(yo));
(qt)((yF),([130,134]));
while(!((qv)((yF),([130,134])))){
(yJ)=(new yK());
(yr)((yJ),(528),(yp));
(yM)=(new yN());
(yP)((yM),(2057),(yp));
((yM).yQ)=({L:0,H:null,T:null,P:null});
(yS)=(new yO());
(yP)((yS),(2062),(yp));
((yS).q1)=((qx)((yF),([130,134])));
((yM).yT)=(yS);
((yJ).yU)=(yM);
(eP)((((yt).y9).y8),([130,134]),(yJ));
(rA)((yF),([130,134]));
}
(yW)=(new yX());
(yr)((yW),(524),(yp));
((yW).yY)=({L:0,H:null,T:null,P:null});
(za)=(new y7());
(yr)((za),(66052),(yp));
((za).qZ)=({S:"$"});
((za).y4)=(null);
((za).y8)=({L:0,H:null,T:null,P:null});
((yW).zb)=(za);
(zd)=(new ze());
(zg)=(new zh());
(yP)((zg),(67585),(yp));
((zg).zj)=(1);
((zg).zk)=(0x0000000000000000);
(zm)=(new y1());
(yr)((zm),(1026),(yp));
((zm).y2)=(0);
((zg).zn)=(zm);
((zd).zo)=(zg);
(zq)=(new zh());
(yP)((zq),(67585),(yp));
((zq).zj)=(1);
((zq).zk)=(0x00000000FFFFFFFF);
(zs)=(new y1());
(yr)((zs),(1026),(yp));
((zs).y2)=(0);
((zq).zn)=(zs);
((zd).zt)=(zq);
(eP)(((yW).yY),([130,134]),(zd));
(zv)=(new yK());
(yr)((zv),(528),(yp));
(zx)=(new yN());
(yP)((zx),(2057),(yp));
((zx).yQ)=({L:0,H:null,T:null,P:null});
(zz)=(new yO());
(yP)((zz),(2062),(yp));
((zz).q1)=((yG)(({S:"kuin"}),({S:"_err"}),(false)));
((zx).yT)=(zz);
(z1)=(new z2());
((z1).z3)=(false);
((z1).z4)=(false);
(z6)=(new yO());
(yP)((z6),(2062),(yp));
((z6).q1)=((yt).y4);
((z1).z7)=(z6);
(eP)(((zx).yQ),([130,134]),(z1));
((zv).yU)=(zx);
(eP)((((yW).zb).y8),([130,134]),(zv));
(eP)(((yt).yA),([130,134]),(yW));
(z9)=({L:0,H:null,T:null,P:null});
(eP)((z9),([130,134]),((yG)(({S:"kuin"}),({S:"_finVars"}),(false))));
(eP)((z9),([130,134]),((yG)(({S:"kuin"}),({S:"_fin"}),(false))));
(qt)((z9),([130,134]));
while(!((qv)((z9),([130,134])))){
(zC)=(new yK());
(yr)((zC),(528),(yp));
(zE)=(new yN());
(yP)((zE),(2057),(yp));
((zE).yQ)=({L:0,H:null,T:null,P:null});
(zG)=(new yO());
(yP)((zG),(2062),(yp));
((zG).q1)=((qx)((z9),([130,134])));
((zE).yT)=(zG);
((zC).yU)=(zE);
(eP)((((yt).yD).y8),([130,134]),(zC));
(rA)((z9),([130,134]));
}
(eP)(((yq).tr),([130,134]),(yt));
return yq;
}
// rebuildFunc
function rF(zH /*ast*/){
let zL=null; // items
if(((zH).zJ)!==(null)){
return;
}
((zH).zJ)=(zH);
(zL)=((zH).qi);
(qt)((zL),([130,134]));
while(!((qv)((zL),([130,134])))){
(zN)(((qx)((zL),([130,134]))));
(rA)((zL),([130,134]));
}
if(((zH).qj)!==(null)){
((zH).qj)=((zQ)(((zH).qj),(null)));
}
((zH).tr)=((zR)(((zH).tr),((zH).qj),(zH)));
}
// rebuildRoot
function rL(zS /*key*/,zT /*value*/,zU /*data*/){
let zV=null; // ast
let zY=null; // initVarsFunc
let zZ=null; // finVarsFunc
let Aa=null; // items
let Ac=null; // item
let Ag=null; // var_
let Ak=null; // do_
let Am=null; // assign
let Aq=null; // ref
let Ax=null; // do_
let Az=null; // assign
let A1=null; // ref
(zV)=(zT);
if(((zV).zJ)!==(null)){
return true;
}
((zV).zJ)=(zV);
(zY)=((yG)(({S:"kuin"}),({S:"_initVars"}),(false)));
(zZ)=((yG)(({S:"kuin"}),({S:"_finVars"}),(false)));
(Aa)=((zV).rK);
(qt)((Aa),([130,134]));
while(!((qv)((Aa),([130,134])))){
(Ac)=((qx)((Aa),([130,134])));
if(((Ac).qe)===(256)){
(rF)((Ac));
}
else if(((Ac).qe)===(2)){
(Ag)=(Ac);
if(!((((Ag).tZ).rr)===(1))){throw 0xE9170000;}
if((((Ag).tZ).y3)!==(null)){
(((Ag).tZ).y3)=((Aj)((((Ag).tZ).y3),(false)));
(Ak)=(new yK());
(yr)((Ak),(528),((zV).qn));
(Am)=(new An());
(yP)((Am),(2050),((zV).qn));
((Am).Ao)=(0);
(Aq)=(new yO());
(yP)((Aq),(2062),((zV).qn));
((Aq).zn)=(((Ag).tZ).s6);
((Aq).q1)=((Ag).tZ);
((Am).Ar)=(Aq);
((Am).As)=(((Ag).tZ).y3);
((Ak).yU)=(Am);
(eP)(((zY).tr),([130,134]),((At)((Ak),(null),(null))));
}
if(((((Ag).tZ).s6)!==(null))&&((Av)((((Ag).tZ).s6)))){
(Ax)=(new yK());
(yr)((Ax),(528),((zV).qn));
(Az)=(new An());
(yP)((Az),(2050),((zV).qn));
((Az).Ao)=(0);
(A1)=(new yO());
(yP)((A1),(2062),((zV).qn));
((A1).zn)=(((Ag).tZ).s6);
((A1).q1)=((Ag).tZ);
((Az).Ar)=(A1);
((Az).As)=((A2)(((zV).qn)));
((Ax).yU)=(Az);
(eP)(((zZ).tr),([130,134]),((At)((Ax),(null),(null))));
}
}
else{
if(!((((((Ac).qe)===(3))||(((Ac).qe)===(4)))||(((Ac).qe)===(5)))||(((Ac).qe)===(6)))){throw 0xE9170000;}
}
(rA)((Aa),([130,134]));
}
return true;
}
// getInfo
function rW(A4 /*ast*/){
let A7=null; // info
if((((A4).zJ)===(null))||((((A4).zJ).qe)!==(268435456))){
(A7)=(new rX());
((A7).qe)=(268435456);
((A7).sP)=((A8)());
if(((((rv)(((A4).qe),([9]),(66048)))===(66048))&&(((A4).qZ)!==(null)))&&(((A4).qZ).S!==({S:"$"}).S)){
((A7).AB)=((A8)());
if(((rv)(((A4).qe),([9]),(16843264)))===(16843264)){
((A7).AE)=((A8)());
}
else{
((A7).AE)=(null);
}
}
else{
((A7).AB)=(null);
((A7).AE)=(null);
}
((A7).tG)=(-1);
((A7).rZ)=(false);
((A7).AH)=(false);
((A7).AI)=(false);
((A4).zJ)=(A7);
}
return (A4).zJ;
}
// getType
function ss(AJ /*type*/){
let AN=0;
let AW=null; // func_
let AY=null; // id
let Bb=null; // arg
let Bc=false; // first
let Bd=null; // items
let Bg=null; // item
let Bt=null; // gen
let Bw=0;
let B4=null; // dict_
let B9=null; // prim
let BB=0;
let BI=null; // ref
let BL=null; // info
if((AJ)===(null)){
return {S:"void"};
}
switch((AJ).qe){
case 66561:
return {S:({S:({S:"Array_<"}).S+((v)(((ss)(((AJ).AR))),([129,2]))).S}).S+({S:">*"}).S};
break;
case 1025:
return {S:({S:({S:"uint"}).S+((v)((((AJ).AU)*(8)),([0]))).S}).S+({S:"_t"}).S};
break;
case 66562:
(AW)=(AJ);
(AY)=((A8)());
(eP)((O),([130,129,2]),({S:({S:({S:"typedef "}).S+((v)(((ss)(((AW).AZ))),([129,2]))).S}).S+({S:({S:({S:"(*"}).S+((v)((AY),([129,2]))).S}).S+({S:")("}).S}).S}));
(Bb)=({S:""});
(Bc)=(true);
(Bd)=((AW).Be);
(qt)((Bd),([130,134]));
while(!((qv)((Bd),([130,134])))){
(Bg)=((qx)((Bd),([130,134])));
if(Bc){
(Bc)=(false);
}
else{
(Bb)=({S:(Bb).S+({S:", "}).S});
}
(Bb)=({S:(Bb).S+({S:({S:({S:""}).S+((v)(((ss)(((Bg).Bn))),([129,2]))).S}).S+({S:""}).S}).S});
if((Bg).Bp){
(Bb)=({S:(Bb).S+({S:"*"}).S});
}
(rA)((Bd),([130,134]));
}
(eP)((O),([130,129,2]),({S:({S:({S:""}).S+((v)((Bb),([129,2]))).S}).S+({S:");\u000A"}).S}));
return AY;
break;
case 66563:
(Bt)=(AJ);
switch((Bt).Bx){
case 0:
return {S:({S:({S:"List_<"}).S+((v)(((ss)(((Bt).Bz))),([129,2]))).S}).S+({S:">*"}).S};
break;
case 1:
return {S:({S:({S:"Stack_<"}).S+((v)(((ss)(((Bt).Bz))),([129,2]))).S}).S+({S:">*"}).S};
break;
case 2:
return {S:({S:({S:"Queue_<"}).S+((v)(((ss)(((Bt).Bz))),([129,2]))).S}).S+({S:">*"}).S};
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
break;
case 66564:
(B4)=(AJ);
return {S:({S:({S:"Dict_<"}).S+((v)(((ss)(((B4).B6))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((ss)(((B4).B7))),([129,2]))).S}).S+({S:">*"}).S}).S};
break;
case 1026:
(B9)=(AJ);
switch((B9).y2){
case 0:
return {S:"int64_t"};
break;
case 1:
return {S:"double"};
break;
case 2:
return {S:"char16_t"};
break;
case 3:
return {S:"bool"};
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
break;
case 66565:
(BI)=((AJ).q1);
if(((BI).qe)===(5)){
(tB)((BI));
(BL)=((rW)((BI)));
return {S:((BL).sP).S+({S:"*"}).S};
}
else{
if(!(((BI).qe)===(6))){throw 0xE9170000;}
return {S:"int64_t"};
}
break;
case 1027:
if(!(false)){throw 0xE9170000;}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// isInt
function s5(BP /*type*/){
return (((BP).qe)===(1026))&&(((BP).y2)===(0));
}
// write
function tj(BQ /*codes*/,BR /*attr*/,BS /*args*/,BT /*members*/){
let BV=null;
let BX=null; // class_
let BZ=null; // me_
let Ca=null; // key
let Cb=null; // item
let Cd=null; // me_
let Ce=null; // item
let Cg=null; // me_
let Ch=null; // item
let Cj=null; // me_
let Ck=null; // item
let Cm=null; // me_
let Cn=null; // n
let Cq=null; // me_
let Cs=null; // me_
let Ct=null; // value
let Cv=null; // me_
let Cw=null; // item
let Cx=null; // start
let Cz=null; // me_
let C0=null; // item
let C2=null; // me_
let C3=null; // callback
let C4=null; // data
let C6=null; // me_
let C7=null; // key
let C8=null; // existed
let CA=null; // me_
let CC=null; // me_
let CE=null; // me_
let CG=null; // me_
let CI=null; // me_
let CK=null; // me_
let CL=null; // item
let CN=null; // me_
let CO=null; // offset
let CQ=null; // me_
let CS=null; // me_
let CT=null; // n
let CV=null; // me_
let CX=null; // me_
let CZ=null; // min
let Da=null; // max
let Dc=null; // min
let Dd=null; // max
let Df=null; // me_
let Dg=null; // start
let Dh=null; // len
let Dk=null; // me_
let Dm=null; // me_
let Do=null; // me_
let Dp=null; // success
let Dr=null; // me_
let Ds=null; // success
let Du=null; // me_
let Dv=null; // success
let Dx=null; // me_
let Dz=null; // str
let D1=null; // dst
let D2=null; // src
let D4=null; // path
let D6=null; // path
let D7=null; // recursion
let D8=null; // callback
let D9=null; // data
let DB=null; // me_
let DC=null; // path
let DD=null; // handle
let DG=null; // me_
let DH=null; // path
let DI=null; // append
let DJ=null; // handle
let DL=null; // me_
let DM=null; // handle
let DO=null; // me_
let DP=null; // handle
let DR=null; // me_
let DS=null; // handle
let DU=null; // me_
let DV=null; // origin
let DW=null; // pos
let DX=null; // handle
let DZ=null; // me_
let Ea=null; // handle
let Ec=null; // me_
let Ed=null; // handle
let Ef=null; // me_
let Eg=null; // handle
let Ei=null; // me_
let Ej=null; // origin
let Ek=null; // pos
let El=null; // handle
let En=null; // me_
let Eo=null; // n
let Ep=null; // handle
let Er=null; // me_
let Es=null; // n
let Et=null; // handle
BV=BR;
if(BV.S===({S:"addr"}).S){
(qt)((BS),([130,134]));
(BX)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"return reinterpret_cast<uint64_t>("}).S+((v)(((BX).sP),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(BV.S===({S:"addDict"}).S){
(qt)((BS),([130,134]));
(BZ)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(rA)((BS),([130,134]));
(Ca)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(Cb)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:""}).S+((v)(((BZ).sP),([129,2]))).S}).S+({S:({S:({S:"->Add("}).S+((v)(((Ca).sP),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((Cb).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
}
else if(BV.S===({S:"addList"}).S){
(qt)((BS),([130,134]));
(Cd)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(rA)((BS),([130,134]));
(Ce)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:""}).S+((v)(((Cd).sP),([129,2]))).S}).S+({S:({S:({S:"->B.push_back("}).S+((v)(((Ce).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(BV.S===({S:"addQueue"}).S){
(qt)((BS),([130,134]));
(Cg)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(rA)((BS),([130,134]));
(Ch)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:""}).S+((v)(((Cg).sP),([129,2]))).S}).S+({S:({S:({S:"->B.push("}).S+((v)(((Ch).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(BV.S===({S:"addStack"}).S){
(qt)((BS),([130,134]));
(Cj)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(rA)((BS),([130,134]));
(Ck)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:""}).S+((v)(((Cj).sP),([129,2]))).S}).S+({S:({S:({S:"->B.push("}).S+((v)(((Ck).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(BV.S===({S:"and"}).S){
(qt)((BS),([130,134]));
(Cm)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(rA)((BS),([130,134]));
(Cn)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Cm).sP),([129,2]))).S}).S+({S:({S:({S:" & "}).S+((v)(((Cn).sP),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(BV.S===({S:"cmdLine"}).S){
(eP)((BQ),([130,129,2]),({S:"Array_<Array_<char16_t>*>* a_ = new Array_<Array_<char16_t>*>();\u000A"}));
(eP)((BQ),([130,129,2]),({S:"a_->L = argc_;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"a_->B = new Array_<char16_t>*[static_cast<size_t>(argc_)];\u000A"}));
(eP)((BQ),([130,129,2]),({S:"for (int64_t i_ = 0; i_ < argc_; i_++){\u000A"}));
(eP)((BQ),([130,129,2]),({S:"std::string s_ = argv_[i_];\u000A"}));
(eP)((BQ),([130,129,2]),({S:"const std::u16string t_ = utf8ToUtf16_(s_);\u000A"}));
(eP)((BQ),([130,129,2]),({S:"a_->B[i_] = new Array_<char16_t>();\u000A"}));
(eP)((BQ),([130,129,2]),({S:"a_->B[i_]->L = static_cast<int64_t>(t_.size());\u000A"}));
(eP)((BQ),([130,129,2]),({S:"a_->B[i_]->B = new char16_t[t_.size() + 1];\u000A"}));
(eP)((BQ),([130,129,2]),({S:"std::memcpy(a_->B[i_]->B, t_.c_str(), sizeof(char16_t) * (t_.size() + 1));\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}\u000A"}));
(eP)((BQ),([130,129,2]),({S:"return a_;\u000A"}));
}
else if(BV.S===({S:"del"}).S){
(qt)((BS),([130,134]));
(Cq)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"auto& i_ = "}).S+((v)(((Cq).sP),([129,2]))).S}).S+({S:"->I++;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:({S:({S:""}).S+((v)(((Cq).sP),([129,2]))).S}).S+({S:"->B.erase(i_);\u000A"}).S}));
}
else if(BV.S===({S:"fill"}).S){
(qt)((BS),([130,134]));
(Cs)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(rA)((BS),([130,134]));
(Ct)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"for(int64_t i_ = 0; i_ < "}).S+((v)(((Cs).sP),([129,2]))).S}).S+({S:({S:({S:"->L; i_++) "}).S+((v)(((Cs).sP),([129,2]))).S}).S+({S:({S:({S:"->B[i_] = "}).S+((v)(((Ct).sP),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
}
else if(BV.S===({S:"findArray"}).S){
(qt)((BS),([130,134]));
(Cv)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(rA)((BS),([130,134]));
(Cw)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(Cx)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Cx).sP),([129,2]))).S}).S+({S:({S:({S:" == -1) "}).S+((v)(((Cx).sP),([129,2]))).S}).S+({S:" = 0;\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Cx).sP),([129,2]))).S}).S+({S:" < 0) return -1;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"for(int64_t i_ = "}).S+((v)(((Cx).sP),([129,2]))).S}).S+({S:({S:({S:"; i_ < "}).S+((v)(((Cv).sP),([129,2]))).S}).S+({S:"->L; i_++){\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Cv).sP),([129,2]))).S}).S+({S:({S:({S:"->B[i_] == "}).S+((v)(((Cw).sP),([129,2]))).S}).S+({S:") return i_;\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:"}\u000A"}));
(eP)((BQ),([130,129,2]),({S:"return -1;\u000A"}));
}
else if(BV.S===({S:"findBin"}).S){
(qt)((BS),([130,134]));
(Cz)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(rA)((BS),([130,134]));
(C0)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"int64_t a_ = 0, b_ = "}).S+((v)(((Cz).sP),([129,2]))).S}).S+({S:"->L - 1;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"while (a_ <= b_) {\u000A"}));
(eP)((BQ),([130,129,2]),({S:"int64_t c_ = (a_ + b_) / 2;\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"int64_t m_ = cmp_("}).S+((v)(((C0).sP),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((Cz).sP),([129,2]))).S}).S+({S:"->B[c_]);\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:"if(m_ < 0) b_ = c_ - 1;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"else if(m_ > 0) a_ = c_ + 1;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"else return c_;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}\u000A"}));
(eP)((BQ),([130,129,2]),({S:"return -1;\u000A"}));
}
else if(BV.S===({S:"forEach"}).S){
(qt)((BS),([130,134]));
(C2)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(rA)((BS),([130,134]));
(C3)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(C4)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"return dictForEach_("}).S+((v)(((C2).sP),([129,2]))).S}).S+({S:({S:({S:"->B, static_cast<bool(*)(K_, V_, Class_*)>("}).S+((v)(((C3).sP),([129,2]))).S}).S+({S:({S:({S:"), "}).S+((v)(((C4).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
}
else if(BV.S===({S:"getDict"}).S){
(qt)((BS),([130,134]));
(C6)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(rA)((BS),([130,134]));
(C7)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(C8)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"return dictSearch_("}).S+((v)(((C6).sP),([129,2]))).S}).S+({S:({S:({S:"->B, "}).S+((v)(((C7).sP),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((C8).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
}
else if(BV.S===({S:"getList"}).S){
(qt)((BS),([130,134]));
(CA)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"return *"}).S+((v)(((CA).sP),([129,2]))).S}).S+({S:"->I;\u000A"}).S}));
}
else if(BV.S===({S:"getQueue"}).S){
(qt)((BS),([130,134]));
(CC)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"R_ r_ = "}).S+((v)(((CC).sP),([129,2]))).S}).S+({S:"->B.front();\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:({S:({S:""}).S+((v)(((CC).sP),([129,2]))).S}).S+({S:"->B.pop();\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"return r_;\u000A"}));
}
else if(BV.S===({S:"getStack"}).S){
(qt)((BS),([130,134]));
(CE)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"R_ r_ = "}).S+((v)(((CE).sP),([129,2]))).S}).S+({S:"->B.top();\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:({S:({S:""}).S+((v)(((CE).sP),([129,2]))).S}).S+({S:"->B.pop();\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"return r_;\u000A"}));
}
else if(BV.S===({S:"head"}).S){
(qt)((BS),([130,134]));
(CG)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:""}).S+((v)(((CG).sP),([129,2]))).S}).S+({S:({S:({S:"->I = "}).S+((v)(((CG).sP),([129,2]))).S}).S+({S:"->B.begin();\u000A"}).S}).S}));
}
else if(BV.S===({S:"idx"}).S){
(qt)((BS),([130,134]));
(CI)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:"int64_t i_ = 0;\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"for(auto& t_ = "}).S+((v)(((CI).sP),([129,2]))).S}).S+({S:({S:({S:"->B.begin(); t_ != "}).S+((v)(((CI).sP),([129,2]))).S}).S+({S:"->B.end(); ++t_){\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"if(t_ == "}).S+((v)(((CI).sP),([129,2]))).S}).S+({S:"->I) return i_;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"i_++;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}\u000A"}));
(eP)((BQ),([130,129,2]),({S:"return -1;\u000A"}));
}
else if(BV.S===({S:"ins"}).S){
(qt)((BS),([130,134]));
(CK)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(rA)((BS),([130,134]));
(CL)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:""}).S+((v)(((CK).sP),([129,2]))).S}).S+({S:({S:({S:"->B.insert("}).S+((v)(((CK).sP),([129,2]))).S}).S+({S:({S:({S:"->I, "}).S+((v)(((CL).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
}
else if(BV.S===({S:"moveOffset"}).S){
(qt)((BS),([130,134]));
(CN)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(rA)((BS),([130,134]));
(CO)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((CO).sP),([129,2]))).S}).S+({S:" >= 0){\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"for(int64_t i_ = 0; i_ < "}).S+((v)(((CO).sP),([129,2]))).S}).S+({S:"; i_++){\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((CN).sP),([129,2]))).S}).S+({S:({S:({S:"->I == "}).S+((v)(((CN).sP),([129,2]))).S}).S+({S:"->B.end()) break;\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"++"}).S+((v)(((CN).sP),([129,2]))).S}).S+({S:"->I;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"}\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}else{\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"for(int64_t i_ = 0; i_ > "}).S+((v)(((CO).sP),([129,2]))).S}).S+({S:"; i_--){\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((CN).sP),([129,2]))).S}).S+({S:({S:({S:"->I == "}).S+((v)(((CN).sP),([129,2]))).S}).S+({S:"->B.end()) break;\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"--"}).S+((v)(((CN).sP),([129,2]))).S}).S+({S:"->I;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"}\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}\u000A"}));
}
else if(BV.S===({S:"next"}).S){
(qt)((BS),([130,134]));
(CQ)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"++"}).S+((v)(((CQ).sP),([129,2]))).S}).S+({S:"->I;\u000A"}).S}));
}
else if(BV.S===({S:"or"}).S){
(qt)((BS),([130,134]));
(CS)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(rA)((BS),([130,134]));
(CT)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((CS).sP),([129,2]))).S}).S+({S:({S:({S:" | "}).S+((v)(((CT).sP),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(BV.S===({S:"peekQueue"}).S){
(qt)((BS),([130,134]));
(CV)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((CV).sP),([129,2]))).S}).S+({S:"->B.front();\u000A"}).S}));
}
else if(BV.S===({S:"peekStack"}).S){
(qt)((BS),([130,134]));
(CX)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((CX).sP),([129,2]))).S}).S+({S:"->B.top();\u000A"}).S}));
}
else if(BV.S===({S:"rnd"}).S){
(qt)((BS),([130,134]));
(CZ)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(Da)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"return rnd_("}).S+((v)(((CZ).sP),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((Da).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(BV.S===({S:"rndFloat"}).S){
(qt)((BS),([130,134]));
(Dc)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(Dd)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"return rndFloat_("}).S+((v)(((Dc).sP),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((Dd).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(BV.S===({S:"sub"}).S){
(qt)((BS),([130,134]));
(Df)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(rA)((BS),([130,134]));
(Dg)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(Dh)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"return sub_("}).S+((v)(((Df).sP),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((Dg).sP),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((Dh).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
}
else if(BV.S===({S:"sysTime"}).S){
(eP)((BQ),([130,129,2]),({S:"return static_cast<int64_t>(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());\u000A"}));
}
else if(BV.S===({S:"tail"}).S){
(qt)((BS),([130,134]));
(Dk)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:""}).S+((v)(((Dk).sP),([129,2]))).S}).S+({S:({S:({S:"->I = "}).S+((v)(((Dk).sP),([129,2]))).S}).S+({S:"->B.end();\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"--"}).S+((v)(((Dk).sP),([129,2]))).S}).S+({S:"->I;\u000A"}).S}));
}
else if(BV.S===({S:"term"}).S){
(qt)((BS),([130,134]));
(Dm)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Dm).sP),([129,2]))).S}).S+({S:({S:({S:"->I == "}).S+((v)(((Dm).sP),([129,2]))).S}).S+({S:"->B.end();\u000A"}).S}).S}));
}
else if(BV.S===({S:"toBit64"}).S){
(qt)((BS),([130,134]));
(Do)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(Dp)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"std::u16string s_ = "}).S+((v)(((Do).sP),([129,2]))).S}).S+({S:"->B;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"const std::string& t_ = utf16ToUtf8_(s_);\u000A"}));
(eP)((BQ),([130,129,2]),({S:"try{\u000A"}));
(eP)((BQ),([130,129,2]),({S:"size_t s_;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"uint64_t v_ = t_.size() > 2 && t_[0] == \'0\' && t_[1] == \'x\' ? std::stoull(t_, &s_, 16) : std::stoull(t_, &s_);\u000A"}));
(eP)((BQ),([130,129,2]),({S:"if(s_ == t_.size()){\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((Dp).sP),([129,2]))).S}).S+({S:" = true;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"return v_;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}else{\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((Dp).sP),([129,2]))).S}).S+({S:" = false;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"return 0;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}catch(...){\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((Dp).sP),([129,2]))).S}).S+({S:" = false;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"return 0;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}\u000A"}));
}
else if(BV.S===({S:"toFloat"}).S){
(qt)((BS),([130,134]));
(Dr)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(Ds)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"std::u16string s_ = "}).S+((v)(((Dr).sP),([129,2]))).S}).S+({S:"->B;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"const std::string& t_ = utf16ToUtf8_(s_);\u000A"}));
(eP)((BQ),([130,129,2]),({S:"try{\u000A"}));
(eP)((BQ),([130,129,2]),({S:"size_t s_;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"double v_ = std::stod(t_, &s_);\u000A"}));
(eP)((BQ),([130,129,2]),({S:"if(s_ == t_.size()){\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((Ds).sP),([129,2]))).S}).S+({S:" = true;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"return v_;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}else{\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((Ds).sP),([129,2]))).S}).S+({S:" = false;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"return 0;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}catch(...){\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((Ds).sP),([129,2]))).S}).S+({S:" = false;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"return 0;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}\u000A"}));
}
else if(BV.S===({S:"toInt"}).S){
(qt)((BS),([130,134]));
(Du)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(Dv)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"std::u16string s_ = "}).S+((v)(((Du).sP),([129,2]))).S}).S+({S:"->B;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"const std::string& t_ = utf16ToUtf8_(s_);\u000A"}));
(eP)((BQ),([130,129,2]),({S:"try{\u000A"}));
(eP)((BQ),([130,129,2]),({S:"size_t s_;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"int64_t v_ = t_.size() > 2 && t_[0] == \'0\' && t_[1] == \'x\' ? std::stoll(t_, &s_, 16) : std::stoull(t_, &s_);\u000A"}));
(eP)((BQ),([130,129,2]),({S:"if(s_ == t_.size()){\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((Dv).sP),([129,2]))).S}).S+({S:" = true;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"return v_;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}else{\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((Dv).sP),([129,2]))).S}).S+({S:" = false;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"return 0;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}catch(...){\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((Dv).sP),([129,2]))).S}).S+({S:" = false;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"return 0;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}\u000A"}));
}
else if(BV.S===({S:"toStr"}).S){
(qt)((BS),([130,134]));
(Dx)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"return toStr_("}).S+((v)(((Dx).sP),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(BV.S===({S:"cui_print"}).S){
(qt)((BS),([130,134]));
(Dz)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"std::u16string s_ = "}).S+((v)(((Dz).sP),([129,2]))).S}).S+({S:"->B;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"const std::string& t_ = utf16ToUtf8_(s_);\u000A"}));
(eP)((BQ),([130,129,2]),({S:"std::cout << t_ << std::flush;\u000A"}));
}
else if(BV.S===({S:"file_copyFile"}).S){
(qt)((BS),([130,134]));
(D1)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(D2)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:({S:({S:"return copyFile_("}).S+((v)(((D1).sP),([129,2]))).S}).S+({S:({S:({S:"->B, "}).S+((v)(((D2).sP),([129,2]))).S}).S+({S:"->B);\u000A"}).S}).S}));
}
else if(BV.S===({S:"file_exist"}).S){
(qt)((BS),([130,134]));
(D4)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:"return false;\u000A"}));
}
else if(BV.S===({S:"file_forEach"}).S){
(qt)((BS),([130,134]));
(D6)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(D7)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(D8)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(D9)=((rW)(((qx)((BS),([130,134])))));
(eP)((BQ),([130,129,2]),({S:"return false;\u000A"}));
}
else if(BV.S===({S:"file_makeReader"}).S){
(qt)((BS),([130,134]));
(DB)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(DC)=((rW)(((qx)((BS),([130,134])))));
(DD)=((DE)((BT),({S:"handle"})));
(eP)((BQ),([130,129,2]),({S:({S:({S:""}).S+((v)(((DB).sP),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((DD).sP),([129,2]))).S}).S+({S:" = reinterpret_cast<int64_t>(new reader_());\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"std::u16string s_ = "}).S+((v)(((DC).sP),([129,2]))).S}).S+({S:"->B;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"const std::string& t_ = utf16ToUtf8_(s_);\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"reader_* r_ = reinterpret_cast<reader_*>("}).S+((v)(((DB).sP),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((DD).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:"r_->F = new std::ifstream(t_.c_str(), std::ios::in | std::ios::binary);\u000A"}));
(eP)((BQ),([130,129,2]),({S:"if(!*r_->F) return nullptr;\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((DB).sP),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
else if(BV.S===({S:"file_makeWriter"}).S){
(qt)((BS),([130,134]));
(DG)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(DH)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(DI)=((rW)(((qx)((BS),([130,134])))));
(DJ)=((DE)((BT),({S:"handle"})));
(eP)((BQ),([130,129,2]),({S:({S:({S:""}).S+((v)(((DG).sP),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((DJ).sP),([129,2]))).S}).S+({S:" = reinterpret_cast<int64_t>(new writer_());\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"std::u16string s_ = "}).S+((v)(((DH).sP),([129,2]))).S}).S+({S:"->B;\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"const std::string& t_ = utf16ToUtf8_(s_);\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"writer_* r_ = reinterpret_cast<writer_*>("}).S+((v)(((DG).sP),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((DJ).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"r_->F = new std::ofstream(t_.c_str(), std::ios::out | std::ios::binary | ("}).S+((v)(((DI).sP),([129,2]))).S}).S+({S:" ? std::ios::app : std::ios::trunc));\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"if(!*r_->F) return nullptr;\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((DG).sP),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
else if(BV.S===({S:"file_readerFin"}).S){
(qt)((BS),([130,134]));
(DL)=((rW)(((qx)((BS),([130,134])))));
(DM)=((DE)((BT),({S:"handle"})));
(eP)((BQ),([130,129,2]),({S:({S:({S:"reader_* r_ = reinterpret_cast<reader_*>("}).S+((v)(((DL).sP),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((DM).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:"r_->F->close();\u000A"}));
}
else if(BV.S===({S:"file_readerGetPos"}).S){
(qt)((BS),([130,134]));
(DO)=((rW)(((qx)((BS),([130,134])))));
(DP)=((DE)((BT),({S:"handle"})));
(eP)((BQ),([130,129,2]),({S:({S:({S:"reader_* r_ = reinterpret_cast<reader_*>("}).S+((v)(((DO).sP),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((DP).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:"return static_cast<int64_t>(r_->F->tellg());\u000A"}));
}
else if(BV.S===({S:"file_readerReadLetter"}).S){
(qt)((BS),([130,134]));
(DR)=((rW)(((qx)((BS),([130,134])))));
(DS)=((DE)((BT),({S:"handle"})));
(eP)((BQ),([130,129,2]),({S:({S:({S:"reader_* r_ = reinterpret_cast<reader_*>("}).S+((v)(((DR).sP),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((DS).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:"return readUtf8_(r_->F);\u000A"}));
}
else if(BV.S===({S:"file_readerSetPos"}).S){
(qt)((BS),([130,134]));
(DU)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(DV)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(DW)=((rW)(((qx)((BS),([130,134])))));
(DX)=((DE)((BT),({S:"handle"})));
(eP)((BQ),([130,129,2]),({S:({S:({S:"reader_* r_ = reinterpret_cast<reader_*>("}).S+((v)(((DU).sP),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((DX).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:"std::ios_base::seekdir o_ = std::ios_base::beg;\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"switch("}).S+((v)(((DV).sP),([129,2]))).S}).S+({S:"){\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"case 0: o_ = std::ios_base::beg; break;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"case 1: o_ = std::ios_base::cur; break;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"case 2: o_ = std::ios_base::end; break;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"r_->F->seekg("}).S+((v)(((DW).sP),([129,2]))).S}).S+({S:", o_);\u000A"}).S}));
}
else if(BV.S===({S:"file_readerTerm"}).S){
(qt)((BS),([130,134]));
(DZ)=((rW)(((qx)((BS),([130,134])))));
(Ea)=((DE)((BT),({S:"handle"})));
(eP)((BQ),([130,129,2]),({S:({S:({S:"reader_* r_ = reinterpret_cast<reader_*>("}).S+((v)(((DZ).sP),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((Ea).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:"char c_;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"if(r_->F->get(c_)) {\u000A"}));
(eP)((BQ),([130,129,2]),({S:"r_->F->seekg(-1, std::ios_base::cur);\u000A"}));
(eP)((BQ),([130,129,2]),({S:"return false;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}\u000A"}));
(eP)((BQ),([130,129,2]),({S:"return true;\u000A"}));
}
else if(BV.S===({S:"file_writerFin"}).S){
(qt)((BS),([130,134]));
(Ec)=((rW)(((qx)((BS),([130,134])))));
(Ed)=((DE)((BT),({S:"handle"})));
(eP)((BQ),([130,129,2]),({S:({S:({S:"writer_* r_ = reinterpret_cast<writer_*>("}).S+((v)(((Ec).sP),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((Ed).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:"r_->F->close();\u000A"}));
}
else if(BV.S===({S:"file_writerGetPos"}).S){
(qt)((BS),([130,134]));
(Ef)=((rW)(((qx)((BS),([130,134])))));
(Eg)=((DE)((BT),({S:"handle"})));
(eP)((BQ),([130,129,2]),({S:({S:({S:"writer_* r_ = reinterpret_cast<writer_*>("}).S+((v)(((Ef).sP),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((Eg).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:"return static_cast<int64_t>(r_->F->tellp());\u000A"}));
}
else if(BV.S===({S:"file_writerSetPos"}).S){
(qt)((BS),([130,134]));
(Ei)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(Ej)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(Ek)=((rW)(((qx)((BS),([130,134])))));
(El)=((DE)((BT),({S:"handle"})));
(eP)((BQ),([130,129,2]),({S:({S:({S:"writer_* r_ = reinterpret_cast<writer_*>("}).S+((v)(((Ei).sP),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((El).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:"std::ios_base::seekdir o_ = std::ios_base::beg;\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"switch("}).S+((v)(((Ej).sP),([129,2]))).S}).S+({S:"){\u000A"}).S}));
(eP)((BQ),([130,129,2]),({S:"case 0: o_ = std::ios_base::beg; break;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"case 1: o_ = std::ios_base::cur; break;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"case 2: o_ = std::ios_base::end; break;\u000A"}));
(eP)((BQ),([130,129,2]),({S:"}\u000A"}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"r_->F->seekp("}).S+((v)(((Ek).sP),([129,2]))).S}).S+({S:", o_);\u000A"}).S}));
}
else if(BV.S===({S:"file_writerWrite"}).S){
(qt)((BS),([130,134]));
(En)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(Eo)=((rW)(((qx)((BS),([130,134])))));
(Ep)=((DE)((BT),({S:"handle"})));
(eP)((BQ),([130,129,2]),({S:({S:({S:"writer_* r_ = reinterpret_cast<writer_*>("}).S+((v)(((En).sP),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((Ep).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"r_->F->write(reinterpret_cast<char*>("}).S+((v)(((Eo).sP),([129,2]))).S}).S+({S:({S:({S:"->B), "}).S+((v)(((Eo).sP),([129,2]))).S}).S+({S:"->L);\u000A"}).S}).S}));
}
else if(BV.S===({S:"file_writerWriteChar"}).S){
(qt)((BS),([130,134]));
(Er)=((rW)(((qx)((BS),([130,134])))));
(rA)((BS),([130,134]));
(Es)=((rW)(((qx)((BS),([130,134])))));
(Et)=((DE)((BT),({S:"handle"})));
(eP)((BQ),([130,129,2]),({S:({S:({S:"writer_* r_ = reinterpret_cast<writer_*>("}).S+((v)(((Er).sP),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((Et).sP),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eP)((BQ),([130,129,2]),({S:({S:({S:"writeUtf8_(r_->F, "}).S+((v)(((Es).sP),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(BV.S===({S:"wnd_editBaseGetText"}).S){
}
else if(BV.S===({S:"wnd_makeEditMulti"}).S){
}
else{if(!(false)){throw 0xE9170000;}
}
}
// _tail
function tn(Ex /*me_*/,Ey /*type*/){
Ex.P=Ex.T;
}
// _idx
function tp(Ez /*me_*/,E0 /*type*/){
let p_=Ez.H,i_=0;
if(Ez.P===null)return -1;
while(p_!==null){
if(p_===Ez.P)return i_
i_++;
p_=p_.N;
}
return -1;
}
// buildStats
function tq(E1 /*stats*/,E2 /*breakStat*/,E3 /*skipStat*/){
let E5=null; // stat
let E7=0;
(qt)((E1),([130,134]));
while(!((qv)((E1),([130,134])))){
(E5)=((qx)((E1),([130,134])));
switch((E5).qe){
case 66049:
(E9)((E5),(E2),(E3));
break;
case 66050:
(EC)((E5),(E2),(E3));
break;
case 16843265:
(EF)((E5),(E2),(E3));
break;
case 16843266:
(EJ)((E5),(E2),(E3));
break;
case 66051:
(EM)((E5),(E2),(E3));
break;
case 526:
(EO)((E5));
break;
case 66052:
(ER)((E5),(E2),(E3));
break;
case 527:
(ET)((E5));
break;
case 528:
(EW)((E5));
break;
case 529:
(EY)((E5),(E2));
break;
case 530:
(Fa)((E5),(E3));
break;
case 531:
(Fc)((E5));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(rA)((E1),([130,134]));
}
}
// _moveOffset
function ts(Ff /*me_*/,Fg /*type*/,Fh /*offset*/){
if(Fh>=0){
for(let i_=0;i_<Fh;i_++){
if(Ff.P===null)break;
Ff.P=Ff.P.N;
}
}else{
for(let i_=0;i_>Fh;i_--){
if(Ff.P===null)break;
Ff.P=Ff.P.P;
}
}
}
// _ins
function ty(Fi /*me_*/,Fj /*type*/,Fk /*item*/){
let p_=Fi.P;
let n_={P:p_.P,N:p_,I:Fk}
if(p_.P===null)Fi.H=n_;else p_.P.N=n_;
if(Fi.T===null)Fi.T=n_;
p_.P=n_;
Fi.L++;
}
// getDefaultValue
function tz(Fl /*type*/){
let Fq=0;
let Fw=0;
if((Fn)((Fl))){
return {S:"nullptr"};
}
switch((Fl).qe){
case 66565:
if(!((Fs)((Fl)))){throw 0xE9170000;}
return {S:"0"};
break;
case 1025:
return {S:"0"};
break;
case 1026:
switch((Fl).y2){
case 0:
case 2:
return {S:"0"};
break;
case 1:
return {S:"0.0"};
break;
case 3:
return {S:"false"};
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// _del
function t1(F2 /*me_*/,F3 /*type*/){
let p_=F2.P;
if(p_.P===null)F2.H=p_.N;else p_.P.N=p_.N;
if(p_.N===null)F2.T=p_.P;else p_.N.P=p_.P;
F2.P=p_.N;
F2.L--;
}
// refClass
function tB(F4 /*ast*/){
let F5=null; // info
let FE=null; // items
let FG=null; // item
let FJ=null; // func_
let FM=null; // items2
let FO=null; // arg
let FQ=null; // var_
(F5)=((rW)((F4)));
if((F5).rZ){
return (F5).sP;
}
((F5).rZ)=(true);
if(((F4).q1)!==(null)){
(tB)(((F4).q1));
}
if(((F5).tG)===(-1)){
((F5).tG)=(eT);
(eT)=((eT)+(1));
}
(FE)=((F4).ti);
(qt)((FE),([130,134]));
while(!((qv)((FE),([130,134])))){
(FG)=((qx)((FE),([130,134])));
if((((FG).tU).qe)===(256)){
(FJ)=((FG).tU);
if(((FJ).qj)!==(null)){
(ss)(((FJ).qj));
}
(FM)=((FJ).qi);
(qt)((FM),([130,134]));
while(!((qv)((FM),([130,134])))){
(FO)=((qx)((FM),([130,134])));
(ss)(((FO).s6));
(rA)((FM),([130,134]));
}
(eS)((K),([132,134]),(FJ));
}
else if((((FG).tU).qe)===(2)){
(FQ)=((FG).tU);
(ss)((((FQ).tZ).s6));
}
(rA)((FE),([130,134]));
}
(eS)((L),([132,134]),(F4));
return (F5).sP;
}
// findFunc
function uc(FR /*ast*/,FS /*name*/){
let FT=null; // items
let FV=null; // item
(FT)=((FR).ti);
(qt)((FT),([130,134]));
while(!((qv)((FT),([130,134])))){
(FV)=((qx)((FT),([130,134])));
if(((((FV).tU).qe)===(256))&&((((FV).tU).qZ).S===(FS).S)){
return (FV).tU;
}
(rA)((FT),([130,134]));
}
return null;
}
// copyFile
function u0(FY /*dst*/,FZ /*src*/){
}
// makeWriter
function u2(Ga /*me2*/,Gb /*path*/,Gc /*append*/){
Ga.Gd={F:"",I:0,P:Gb.S};
return Ga;
}
// getInfo
function uK(Ge /*ast*/){
let Gh=null; // info
if((((Ge).zJ)===(null))||((((Ge).zJ).qe)!==(268435456))){
(Gh)=(new uL());
((Gh).qe)=(268435456);
((Gh).vb)=((Gi)());
if(((((rv)(((Ge).qe),([9]),(66048)))===(66048))&&(((Ge).qZ)!==(null)))&&(((Ge).qZ).S!==({S:"$"}).S)){
((Gh).Gl)=((Gi)());
}
else{
((Gh).Gl)=(null);
}
((Gh).uN)=(false);
((Ge).zJ)=(Gh);
}
return (Ge).zJ;
}
// write
function vs(Gn /*codes*/,Go /*attr*/,Gp /*args*/,Gq /*members*/){
let Gs=null;
let Gv=null; // me_
let Gw=null; // meType
let Gx=null; // key
let Gy=null; // item
let G0=null; // me_
let G1=null; // item
let G3=null; // me_
let G4=null; // item
let G6=null; // me_
let G7=null; // item
let G9=null; // me_
let GA=null; // n
let GD=null; // me_
let GF=null; // me_
let GG=null; // meType
let GH=null; // value
let GJ=null; // me_
let GK=null; // meType
let GL=null; // item
let GM=null; // start
let GO=null; // me_
let GP=null; // meType
let GQ=null; // item
let GS=null; // me_
let GT=null; // meType
let GU=null; // callback
let GV=null; // data
let GX=null; // me_
let GY=null; // meType
let GZ=null; // key
let Ha=null; // existed
let Hc=null; // me_
let He=null; // me_
let Hg=null; // me_
let Hi=null; // me_
let Hk=null; // me_
let Hm=null; // me_
let Hn=null; // item
let Hp=null; // me_
let Hq=null; // offset
let Hs=null; // me_
let Hu=null; // me_
let Hv=null; // n
let Hx=null; // me_
let Hz=null; // me_
let H1=null; // min
let H2=null; // max
let H4=null; // min
let H5=null; // max
let H7=null; // me_
let H8=null; // meType
let H9=null; // start
let HA=null; // len
let HD=null; // me_
let HF=null; // me_
let HH=null; // me_
let HI=null; // success
let HK=null; // me_
let HL=null; // success
let HN=null; // me_
let HO=null; // success
let HQ=null; // me_
let HR=null; // type
let HT=null; // str
let HW=null; // path
let HY=null; // path
let HZ=null; // recursion
let Ia=null; // callback
let Ib=null; // data
let Id=null; // me_
let Ie=null; // path
let If=null; // handle
let Ii=null; // me_
let Ij=null; // path
let Ik=null; // append
let Il=null; // handle
let In=null; // me_
let Io=null; // handle
let Iq=null; // me_
let Ir=null; // handle
let It=null; // me_
let Iu=null; // handle
let Iw=null; // me_
let Ix=null; // origin
let Iy=null; // pos
let Iz=null; // handle
let I1=null; // me_
let I2=null; // handle
let I4=null; // me_
let I5=null; // handle
let I7=null; // me_
let I8=null; // handle
let IA=null; // me_
let IB=null; // origin
let IC=null; // pos
let ID=null; // handle
let IF=null; // me_
let IG=null; // n
let IH=null; // handle
let IJ=null; // me_
let IK=null; // n
let IL=null; // handle
let IN=null; // me_
let IO=null; // handle
let IQ=null; // me_
let IR=null; // parent
let IS=null; // x
let IT=null; // y
let IU=null; // width
let IV=null; // height
let IW=null; // anchorX
let IX=null; // anchorY
let IY=null; // handle
Gs=Go;
if(Gs.S===({S:"addr"}).S){
}
else if(Gs.S===({S:"addDict"}).S){
(qt)((Gp),([130,134]));
(Gv)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(Gw)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(Gx)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(Gy)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Gw).vb),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((Gw).vb),([129,2]))).S}).S+({S:({S:({S:"[2]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((Gv).vb),([129,2]))).S}).S+({S:({S:({S:".set("}).S+((v)(((Gx).vb),([129,2]))).S}).S+({S:({S:({S:".S, "}).S+((v)(((Gy).vb),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
(eP)((Gn),([130,129,2]),({S:"else\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((Gv).vb),([129,2]))).S}).S+({S:({S:({S:".set("}).S+((v)(((Gx).vb),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((Gy).vb),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
}
else if(Gs.S===({S:"addList"}).S){
(qt)((Gp),([130,134]));
(G0)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(rA)((Gp),([130,134]));
(G1)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"let n_={P:null,N:null,I:"}).S+((v)(((G1).vb),([129,2]))).S}).S+({S:"};\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((G0).vb),([129,2]))).S}).S+({S:({S:({S:".H===null){"}).S+((v)(((G0).vb),([129,2]))).S}).S+({S:({S:({S:".H=n_;"}).S+((v)(((G0).vb),([129,2]))).S}).S+({S:({S:({S:".T=n_}else{n_.P="}).S+((v)(((G0).vb),([129,2]))).S}).S+({S:({S:({S:".T;"}).S+((v)(((G0).vb),([129,2]))).S}).S+({S:({S:({S:".T.N=n_;"}).S+((v)(((G0).vb),([129,2]))).S}).S+({S:".T=n_}\u000A"}).S}).S}).S}).S}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((G0).vb),([129,2]))).S}).S+({S:".L++;\u000A"}).S}));
}
else if(Gs.S===({S:"addQueue"}).S){
(qt)((Gp),([130,134]));
(G3)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(rA)((Gp),([130,134]));
(G4)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((G3).vb),([129,2]))).S}).S+({S:({S:({S:".push("}).S+((v)(((G4).vb),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(Gs.S===({S:"addStack"}).S){
(qt)((Gp),([130,134]));
(G6)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(rA)((Gp),([130,134]));
(G7)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((G6).vb),([129,2]))).S}).S+({S:({S:({S:".push("}).S+((v)(((G7).vb),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(Gs.S===({S:"and"}).S){
(qt)((Gp),([130,134]));
(G9)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(rA)((Gp),([130,134]));
(GA)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((G9).vb),([129,2]))).S}).S+({S:({S:({S:"&"}).S+((v)(((GA).vb),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(Gs.S===({S:"cmdLine"}).S){
(eP)((Gn),([130,129,2]),({S:"let r_=(O_&&O_.cmdLine)?O_.cmdLine:location.search.slice(1).split(\"&\");\u000A"}));
(eP)((Gn),([130,129,2]),({S:"if(r_.length===1&&r_[0]===\"\")return[];\u000A"}));
(eP)((Gn),([130,129,2]),({S:"for(let i_=0;i_<r_.length;i_++)\u000A"}));
(eP)((Gn),([130,129,2]),({S:"r_[i_]={S:r_[i_]};\u000A"}));
(eP)((Gn),([130,129,2]),({S:"return r_;\u000A"}));
}
else if(Gs.S===({S:"del"}).S){
(qt)((Gp),([130,134]));
(GD)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"let p_="}).S+((v)(((GD).vb),([129,2]))).S}).S+({S:".P;\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if(p_.P===null)"}).S+((v)(((GD).vb),([129,2]))).S}).S+({S:".H=p_.N;else p_.P.N=p_.N;\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if(p_.N===null)"}).S+((v)(((GD).vb),([129,2]))).S}).S+({S:".T=p_.P;else p_.N.P=p_.P;\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((GD).vb),([129,2]))).S}).S+({S:".P=p_.N;\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((GD).vb),([129,2]))).S}).S+({S:".L--;\u000A"}).S}));
}
else if(Gs.S===({S:"fill"}).S){
(qt)((Gp),([130,134]));
(GF)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(GG)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(GH)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((GG).vb),([129,2]))).S}).S+({S:({S:({S:"[0]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((GG).vb),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((GF).vb),([129,2]))).S}).S+({S:({S:({S:".S=String.fromCharCode("}).S+((v)(((GH).vb),([129,2]))).S}).S+({S:({S:({S:").repeat("}).S+((v)(((GF).vb),([129,2]))).S}).S+({S:".S.length);\u000A"}).S}).S}).S}));
(eP)((Gn),([130,129,2]),({S:"else\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((GF).vb),([129,2]))).S}).S+({S:({S:({S:".fill("}).S+((v)(((GH).vb),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(Gs.S===({S:"findArray"}).S){
(qt)((Gp),([130,134]));
(GJ)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(GK)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(GL)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(GM)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((GK).vb),([129,2]))).S}).S+({S:({S:({S:"[0]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((GK).vb),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((GJ).vb),([129,2]))).S}).S+({S:({S:({S:".S.indexOf(String.fromCharCode("}).S+((v)(((GL).vb),([129,2]))).S}).S+({S:({S:({S:"),"}).S+((v)(((GM).vb),([129,2]))).S}).S+({S:({S:({S:"===-1?0:"}).S+((v)(((GM).vb),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}).S}));
(eP)((Gn),([130,129,2]),({S:"else\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((GJ).vb),([129,2]))).S}).S+({S:({S:({S:".indexOf("}).S+((v)(((GL).vb),([129,2]))).S}).S+({S:({S:({S:","}).S+((v)(((GM).vb),([129,2]))).S}).S+({S:({S:({S:"===-1?0:"}).S+((v)(((GM).vb),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}).S}));
}
else if(Gs.S===({S:"findBin"}).S){
(qt)((Gp),([130,134]));
(GO)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(GP)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(GQ)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"let a_=0,b_="}).S+((v)(((GO).vb),([129,2]))).S}).S+({S:".length-1,c_,m_,f_;\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"switch("}).S+((v)(((GP).vb),([129,2]))).S}).S+({S:"[0]){\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((0),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((1),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((2),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((4),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((5),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((6),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((7),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((9),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:"f_=function(a,b){return a>b?1:a<b?-1:0};\u000A"}));
(eP)((Gn),([130,129,2]),({S:"break;\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((129),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:"f_=function(a,b){return a.S>b.S?1:a.S<b.S?-1:0};\u000A"}));
(eP)((Gn),([130,129,2]),({S:"break;\u000A"}));
(eP)((Gn),([130,129,2]),({S:"default:\u000A"}));
(eP)((Gn),([130,129,2]),({S:"break;\u000A"}));
(eP)((Gn),([130,129,2]),({S:"}\u000A"}));
(eP)((Gn),([130,129,2]),({S:"while (a_<=b_){\u000A"}));
(eP)((Gn),([130,129,2]),({S:"c_=~~((a_+b_)/2);\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"m_=f_("}).S+((v)(((GQ).vb),([129,2]))).S}).S+({S:({S:({S:","}).S+((v)(((GO).vb),([129,2]))).S}).S+({S:"[c_]);\u000A"}).S}).S}));
(eP)((Gn),([130,129,2]),({S:"if(m_<0)b_=c_-1;\u000A"}));
(eP)((Gn),([130,129,2]),({S:"else if(m_>0)a_=c_+1;\u000A"}));
(eP)((Gn),([130,129,2]),({S:"else return c_;\u000A"}));
(eP)((Gn),([130,129,2]),({S:"}\u000A"}));
(eP)((Gn),([130,129,2]),({S:"return -1;\u000A"}));
}
else if(Gs.S===({S:"forEach"}).S){
(qt)((Gp),([130,134]));
(GS)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(GT)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(GU)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(GV)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"let D_={F:"}).S+((v)(((GU).vb),([129,2]))).S}).S+({S:({S:({S:",D:"}).S+((v)(((GV).vb),([129,2]))).S}).S+({S:",C:true};\u000A"}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((GT).vb),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((GT).vb),([129,2]))).S}).S+({S:({S:({S:"[2]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((GS).vb),([129,2]))).S}).S+({S:".forEach(function(V_,K_){if(this.C)this.C=this.F({S:K_},V_,this.D)},D_);\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:"else\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((GS).vb),([129,2]))).S}).S+({S:".forEach(function(V_,K_){if(this.C)this.C=this.F(K_,V_,this.D)},D_);\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:"return D_.C;\u000A"}));
}
else if(Gs.S===({S:"getDict"}).S){
(qt)((Gp),([130,134]));
(GX)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(GY)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(GZ)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(Ha)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:"let r_;\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((GY).vb),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((GY).vb),([129,2]))).S}).S+({S:({S:({S:"[2]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"r_="}).S+((v)(((GX).vb),([129,2]))).S}).S+({S:({S:({S:".get("}).S+((v)(((GZ).vb),([129,2]))).S}).S+({S:".S);\u000A"}).S}).S}));
(eP)((Gn),([130,129,2]),({S:"else\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"r_="}).S+((v)(((GX).vb),([129,2]))).S}).S+({S:({S:({S:".get("}).S+((v)(((GZ).vb),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if(!("}).S+((v)(((Ha).vb),([129,2]))).S}).S+({S:".$=r_!==undefined)){\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"switch("}).S+((v)(((GY).vb),([129,2]))).S}).S+({S:"){\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((0),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((1),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((2),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((4),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((5),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((6),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((7),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((9),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:"return 0;\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((3),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:"return false;\u000A"}));
(eP)((Gn),([130,129,2]),({S:"default:\u000A"}));
(eP)((Gn),([130,129,2]),({S:"return null;\u000A"}));
(eP)((Gn),([130,129,2]),({S:"}\u000A"}));
(eP)((Gn),([130,129,2]),({S:"}\u000A"}));
(eP)((Gn),([130,129,2]),({S:"return r_;\u000A"}));
}
else if(Gs.S===({S:"getList"}).S){
(qt)((Gp),([130,134]));
(Hc)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Hc).vb),([129,2]))).S}).S+({S:".P.I;\u000A"}).S}));
}
else if(Gs.S===({S:"getQueue"}).S){
(qt)((Gp),([130,134]));
(He)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((He).vb),([129,2]))).S}).S+({S:".shift();\u000A"}).S}));
}
else if(Gs.S===({S:"getStack"}).S){
(qt)((Gp),([130,134]));
(Hg)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Hg).vb),([129,2]))).S}).S+({S:".pop();\u000A"}).S}));
}
else if(Gs.S===({S:"head"}).S){
(qt)((Gp),([130,134]));
(Hi)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((Hi).vb),([129,2]))).S}).S+({S:({S:({S:".P="}).S+((v)(((Hi).vb),([129,2]))).S}).S+({S:".H;\u000A"}).S}).S}));
}
else if(Gs.S===({S:"idx"}).S){
(qt)((Gp),([130,134]));
(Hk)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"let p_="}).S+((v)(((Hk).vb),([129,2]))).S}).S+({S:".H,i_=0;\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Hk).vb),([129,2]))).S}).S+({S:".P===null)return -1;\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:"while(p_!==null){\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if(p_==="}).S+((v)(((Hk).vb),([129,2]))).S}).S+({S:".P)return i_\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:"i_++;\u000A"}));
(eP)((Gn),([130,129,2]),({S:"p_=p_.N;\u000A"}));
(eP)((Gn),([130,129,2]),({S:"}\u000A"}));
(eP)((Gn),([130,129,2]),({S:"return -1;\u000A"}));
}
else if(Gs.S===({S:"ins"}).S){
(qt)((Gp),([130,134]));
(Hm)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(rA)((Gp),([130,134]));
(Hn)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"let p_="}).S+((v)(((Hm).vb),([129,2]))).S}).S+({S:".P;\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"let n_={P:p_.P,N:p_,I:"}).S+((v)(((Hn).vb),([129,2]))).S}).S+({S:"}\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if(p_.P===null)"}).S+((v)(((Hm).vb),([129,2]))).S}).S+({S:".H=n_;else p_.P.N=n_;\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Hm).vb),([129,2]))).S}).S+({S:({S:({S:".T===null)"}).S+((v)(((Hm).vb),([129,2]))).S}).S+({S:".T=n_;\u000A"}).S}).S}));
(eP)((Gn),([130,129,2]),({S:"p_.P=n_;\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((Hm).vb),([129,2]))).S}).S+({S:".L++;\u000A"}).S}));
}
else if(Gs.S===({S:"moveOffset"}).S){
(qt)((Gp),([130,134]));
(Hp)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(rA)((Gp),([130,134]));
(Hq)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Hq).vb),([129,2]))).S}).S+({S:">=0){\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"for(let i_=0;i_<"}).S+((v)(((Hq).vb),([129,2]))).S}).S+({S:";i_++){\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Hp).vb),([129,2]))).S}).S+({S:".P===null)break;\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((Hp).vb),([129,2]))).S}).S+({S:({S:({S:".P="}).S+((v)(((Hp).vb),([129,2]))).S}).S+({S:".P.N;\u000A"}).S}).S}));
(eP)((Gn),([130,129,2]),({S:"}\u000A"}));
(eP)((Gn),([130,129,2]),({S:"}else{\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"for(let i_=0;i_>"}).S+((v)(((Hq).vb),([129,2]))).S}).S+({S:";i_--){\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Hp).vb),([129,2]))).S}).S+({S:".P===null)break;\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((Hp).vb),([129,2]))).S}).S+({S:({S:({S:".P="}).S+((v)(((Hp).vb),([129,2]))).S}).S+({S:".P.P;\u000A"}).S}).S}));
(eP)((Gn),([130,129,2]),({S:"}\u000A"}));
(eP)((Gn),([130,129,2]),({S:"}\u000A"}));
}
else if(Gs.S===({S:"next"}).S){
(qt)((Gp),([130,134]));
(Hs)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((Hs).vb),([129,2]))).S}).S+({S:({S:({S:".P="}).S+((v)(((Hs).vb),([129,2]))).S}).S+({S:".P.N;\u000A"}).S}).S}));
}
else if(Gs.S===({S:"or"}).S){
(qt)((Gp),([130,134]));
(Hu)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(rA)((Gp),([130,134]));
(Hv)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Hu).vb),([129,2]))).S}).S+({S:({S:({S:"|"}).S+((v)(((Hv).vb),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(Gs.S===({S:"peekQueue"}).S){
(qt)((Gp),([130,134]));
(Hx)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Hx).vb),([129,2]))).S}).S+({S:"[0];\u000A"}).S}));
}
else if(Gs.S===({S:"peekStack"}).S){
(qt)((Gp),([130,134]));
(Hz)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Hz).vb),([129,2]))).S}).S+({S:({S:({S:"["}).S+((v)(((Hz).vb),([129,2]))).S}).S+({S:".length-1];\u000A"}).S}).S}));
}
else if(Gs.S===({S:"rnd"}).S){
(qt)((Gp),([130,134]));
(H1)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(H2)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return ~~(Math.random()*("}).S+((v)(((H2).vb),([129,2]))).S}).S+({S:({S:({S:"-"}).S+((v)(((H1).vb),([129,2]))).S}).S+({S:({S:({S:"+1))+"}).S+((v)(((H1).vb),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
}
else if(Gs.S===({S:"rndFloat"}).S){
(qt)((Gp),([130,134]));
(H4)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(H5)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return Math.random()*("}).S+((v)(((H5).vb),([129,2]))).S}).S+({S:({S:({S:"-"}).S+((v)(((H4).vb),([129,2]))).S}).S+({S:({S:({S:")+"}).S+((v)(((H4).vb),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
}
else if(Gs.S===({S:"sub"}).S){
(qt)((Gp),([130,134]));
(H7)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(H8)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(H9)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(HA)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((H8).vb),([129,2]))).S}).S+({S:({S:({S:"[0]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((H8).vb),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return {S:"}).S+((v)(((HA).vb),([129,2]))).S}).S+({S:({S:({S:"===-1?"}).S+((v)(((H7).vb),([129,2]))).S}).S+({S:({S:({S:".S.slice("}).S+((v)(((H9).vb),([129,2]))).S}).S+({S:({S:({S:"):"}).S+((v)(((H7).vb),([129,2]))).S}).S+({S:({S:({S:".S.slice("}).S+((v)(((H9).vb),([129,2]))).S}).S+({S:({S:({S:","}).S+((v)(((H9).vb),([129,2]))).S}).S+({S:({S:({S:"+"}).S+((v)(((HA).vb),([129,2]))).S}).S+({S:")};\u000A"}).S}).S}).S}).S}).S}).S}).S}));
(eP)((Gn),([130,129,2]),({S:"else\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((HA).vb),([129,2]))).S}).S+({S:({S:({S:"===-1?"}).S+((v)(((H7).vb),([129,2]))).S}).S+({S:({S:({S:".slice("}).S+((v)(((H9).vb),([129,2]))).S}).S+({S:({S:({S:"):"}).S+((v)(((H7).vb),([129,2]))).S}).S+({S:({S:({S:".slice("}).S+((v)(((H9).vb),([129,2]))).S}).S+({S:({S:({S:","}).S+((v)(((H9).vb),([129,2]))).S}).S+({S:({S:({S:"+"}).S+((v)(((HA).vb),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}).S}).S}).S}).S}));
}
else if(Gs.S===({S:"sysTime"}).S){
(eP)((Gn),([130,129,2]),({S:"return new Date().getTime();\u000A"}));
}
else if(Gs.S===({S:"tail"}).S){
(qt)((Gp),([130,134]));
(HD)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((HD).vb),([129,2]))).S}).S+({S:({S:({S:".P="}).S+((v)(((HD).vb),([129,2]))).S}).S+({S:".T;\u000A"}).S}).S}));
}
else if(Gs.S===({S:"term"}).S){
(qt)((Gp),([130,134]));
(HF)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((HF).vb),([129,2]))).S}).S+({S:".P===null;\u000A"}).S}));
}
else if(Gs.S===({S:"toBit64"}).S){
(qt)((Gp),([130,134]));
(HH)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(HI)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((HH).vb),([129,2]))).S}).S+({S:({S:({S:".S.length>=2&&"}).S+((v)(((HH).vb),([129,2]))).S}).S+({S:({S:({S:".S[0]===\"0\"&&"}).S+((v)(((HH).vb),([129,2]))).S}).S+({S:".S[1]===\"x\"){\u000A"}).S}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"let s_="}).S+((v)(((HH).vb),([129,2]))).S}).S+({S:({S:({S:".S.slice(2),r_=Number("}).S+((v)(((HH).vb),([129,2]))).S}).S+({S:".S);\u000A"}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((HI).vb),([129,2]))).S}).S+({S:".$=!isNaN(r_);\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:"return parseInt(s_,16);\u000A"}));
(eP)((Gn),([130,129,2]),({S:"}else{\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"let r_=Number("}).S+((v)(((HH).vb),([129,2]))).S}).S+({S:".S);\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((HI).vb),([129,2]))).S}).S+({S:".$=!isNaN(r_);\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return parseInt("}).S+((v)(((HH).vb),([129,2]))).S}).S+({S:".S,10);\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:"}\u000A"}));
}
else if(Gs.S===({S:"toFloat"}).S){
(qt)((Gp),([130,134]));
(HK)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(HL)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"let r_=Number("}).S+((v)(((HK).vb),([129,2]))).S}).S+({S:".S);\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((HL).vb),([129,2]))).S}).S+({S:".$=!isNaN(r_);\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:"return r_;\u000A"}));
}
else if(Gs.S===({S:"toInt"}).S){
(qt)((Gp),([130,134]));
(HN)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(HO)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((HN).vb),([129,2]))).S}).S+({S:({S:({S:".S.length>=2&&"}).S+((v)(((HN).vb),([129,2]))).S}).S+({S:({S:({S:".S[0]===\"0\"&&"}).S+((v)(((HN).vb),([129,2]))).S}).S+({S:".S[1]===\"x\"){\u000A"}).S}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"let s_="}).S+((v)(((HN).vb),([129,2]))).S}).S+({S:({S:({S:".S.slice(2),r_=Number("}).S+((v)(((HN).vb),([129,2]))).S}).S+({S:".S);\u000A"}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((HO).vb),([129,2]))).S}).S+({S:".$=!isNaN(r_);\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:"return parseInt(s_,16);\u000A"}));
(eP)((Gn),([130,129,2]),({S:"}else{\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"let r_=Number("}).S+((v)(((HN).vb),([129,2]))).S}).S+({S:".S);\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((HO).vb),([129,2]))).S}).S+({S:".$=!isNaN(r_);\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return parseInt("}).S+((v)(((HN).vb),([129,2]))).S}).S+({S:".S,10);\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:"}\u000A"}));
}
else if(Gs.S===({S:"toStr"}).S){
(qt)((Gp),([130,134]));
(HQ)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(HR)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"switch("}).S+((v)(((HR).vb),([129,2]))).S}).S+({S:"[0]){\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((0),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((1),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((9),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return{S:"}).S+((v)(((HQ).vb),([129,2]))).S}).S+({S:".toString(10)};\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((2),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return{S:String.fromCharCode("}).S+((v)(((HQ).vb),([129,2]))).S}).S+({S:")};\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((3),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return{S:"}).S+((v)(((HQ).vb),([129,2]))).S}).S+({S:"?\"true\":\"false\"};\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((4),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return{S:\"0x\"+(\"00\"+"}).S+((v)(((HQ).vb),([129,2]))).S}).S+({S:".toString(16)).slice(-2).toUpperCase()};\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((5),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return{S:\"0x\"+(\"0000\"+"}).S+((v)(((HQ).vb),([129,2]))).S}).S+({S:".toString(16)).slice(-4).toUpperCase()};\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((6),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return{S:\"0x\"+(\"00000000\"+"}).S+((v)(((HQ).vb),([129,2]))).S}).S+({S:".toString(16)).slice(-8).toUpperCase()};\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((7),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return{S:\"0x\"+(\"0000000000000000\"+"}).S+((v)(((HQ).vb),([129,2]))).S}).S+({S:".toString(16)).slice(-16).toUpperCase()};\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"case "}).S+((v)((129),([0]))).S}).S+({S:":\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((HR).vb),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((HQ).vb),([129,2]))).S}).S+({S:";\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:"}\u000A"}));
}
else if(Gs.S===({S:"cui_print"}).S){
(qt)((Gp),([130,134]));
(HT)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if(O_&&O_.print){O_.print("}).S+((v)(((HT).vb),([129,2]))).S}).S+({S:".S);return;}\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"console.log("}).S+((v)(((HT).vb),([129,2]))).S}).S+({S:".S);\u000A"}).S}));
}
else if(Gs.S===({S:"file_copyFile"}).S){
}
else if(Gs.S===({S:"file_exist"}).S){
(qt)((Gp),([130,134]));
(HW)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:"return false;\u000A"}));
}
else if(Gs.S===({S:"file_forEach"}).S){
(qt)((Gp),([130,134]));
(HY)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(HZ)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(Ia)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(Ib)=((uK)(((qx)((Gp),([130,134])))));
(eP)((Gn),([130,129,2]),({S:"return false;\u000A"}));
}
else if(Gs.S===({S:"file_makeReader"}).S){
(qt)((Gp),([130,134]));
(Id)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(Ie)=((uK)(((qx)((Gp),([130,134])))));
(If)=((Ig)((Gq),({S:"handle"})));
(eP)((Gn),([130,129,2]),({S:({S:({S:"let f_=null,p_="}).S+((v)(((Ie).vb),([129,2]))).S}).S+({S:".S;\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:"if(O_&&O_.readFile)f_=O_.readFile(p_);\u000A"}));
(eP)((Gn),([130,129,2]),({S:"if(f_===null){\u000A"}));
(eP)((Gn),([130,129,2]),({S:"if(p_.length>=4&&p_[0]===\"r\"&&p_[1]===\"e\"&&p_[2]===\"s\"&&p_[3]===\"/\")\u000A"}));
(eP)((Gn),([130,129,2]),({S:"f_=F_(p_);\u000A"}));
(eP)((Gn),([130,129,2]),({S:"else{\u000A"}));
(eP)((Gn),([130,129,2]),({S:"}\u000A"}));
(eP)((Gn),([130,129,2]),({S:"}\u000A"}));
(eP)((Gn),([130,129,2]),({S:"if(f_===null)return null;\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((Id).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((If).vb),([129,2]))).S}).S+({S:"={F:f_,I:0};\u000A"}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Id).vb),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
else if(Gs.S===({S:"file_makeWriter"}).S){
(qt)((Gp),([130,134]));
(Ii)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(Ij)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(Ik)=((uK)(((qx)((Gp),([130,134])))));
(Il)=((Ig)((Gq),({S:"handle"})));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((Ii).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Il).vb),([129,2]))).S}).S+({S:({S:({S:"={F:\"\",I:0,P:"}).S+((v)(((Ij).vb),([129,2]))).S}).S+({S:".S};\u000A"}).S}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Ii).vb),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
else if(Gs.S===({S:"file_readerFin"}).S){
(qt)((Gp),([130,134]));
(In)=((uK)(((qx)((Gp),([130,134])))));
(Io)=((Ig)((Gq),({S:"handle"})));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((In).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Io).vb),([129,2]))).S}).S+({S:".F=null;\u000A"}).S}).S}));
}
else if(Gs.S===({S:"file_readerGetPos"}).S){
(qt)((Gp),([130,134]));
(Iq)=((uK)(((qx)((Gp),([130,134])))));
(Ir)=((Ig)((Gq),({S:"handle"})));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Iq).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Ir).vb),([129,2]))).S}).S+({S:".I;\u000A"}).S}).S}));
}
else if(Gs.S===({S:"file_readerReadLetter"}).S){
(qt)((Gp),([130,134]));
(It)=((uK)(((qx)((Gp),([130,134])))));
(Iu)=((Ig)((Gq),({S:"handle"})));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((It).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Iu).vb),([129,2]))).S}).S+({S:({S:({S:".F.charCodeAt("}).S+((v)(((It).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Iu).vb),([129,2]))).S}).S+({S:".I++);\u000A"}).S}).S}).S}).S}));
}
else if(Gs.S===({S:"file_readerSetPos"}).S){
(qt)((Gp),([130,134]));
(Iw)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(Ix)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(Iy)=((uK)(((qx)((Gp),([130,134])))));
(Iz)=((Ig)((Gq),({S:"handle"})));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((Iw).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Iz).vb),([129,2]))).S}).S+({S:({S:({S:".I="}).S+((v)(((Iy).vb),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
}
else if(Gs.S===({S:"file_readerTerm"}).S){
(qt)((Gp),([130,134]));
(I1)=((uK)(((qx)((Gp),([130,134])))));
(I2)=((Ig)((Gq),({S:"handle"})));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((I1).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((I2).vb),([129,2]))).S}).S+({S:({S:({S:".I>="}).S+((v)(((I1).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((I2).vb),([129,2]))).S}).S+({S:".F.length;\u000A"}).S}).S}).S}).S}));
}
else if(Gs.S===({S:"file_writerFin"}).S){
(qt)((Gp),([130,134]));
(I4)=((uK)(((qx)((Gp),([130,134])))));
(I5)=((Ig)((Gq),({S:"handle"})));
(eP)((Gn),([130,129,2]),({S:({S:({S:"var d_="}).S+((v)(((I4).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((I5).vb),([129,2]))).S}).S+({S:".F.replace(\"\\n\", \"\\u000D\\n\");\u000A"}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if(O_&&O_.writeFile){O_.writeFile("}).S+((v)(((I4).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((I5).vb),([129,2]))).S}).S+({S:".P,d_);return;}\u000A"}).S}).S}));
(eP)((Gn),([130,129,2]),({S:"let b_=new Blob([d_],{type:\"text/plain\"});\u000A"}));
(eP)((Gn),([130,129,2]),({S:"let l_=document.createElement(\"a\");\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"l_.download="}).S+((v)(((I4).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((I5).vb),([129,2]))).S}).S+({S:".P;\u000A"}).S}).S}));
(eP)((Gn),([130,129,2]),({S:"l_.href=(URL||webkitURL).createObjectURL(b_);\u000A"}));
(eP)((Gn),([130,129,2]),({S:"l_.setAttribute(\"style\",\"display:none\");\u000A"}));
(eP)((Gn),([130,129,2]),({S:"document.body.appendChild(l_);\u000A"}));
(eP)((Gn),([130,129,2]),({S:"l_.click();\u000A"}));
(eP)((Gn),([130,129,2]),({S:"document.body.removeChild(l_);\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((I4).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((I5).vb),([129,2]))).S}).S+({S:".F=null;\u000A"}).S}).S}));
}
else if(Gs.S===({S:"file_writerGetPos"}).S){
(qt)((Gp),([130,134]));
(I7)=((uK)(((qx)((Gp),([130,134])))));
(I8)=((Ig)((Gq),({S:"handle"})));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((I7).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((I8).vb),([129,2]))).S}).S+({S:".I;\u000A"}).S}).S}));
}
else if(Gs.S===({S:"file_writerSetPos"}).S){
(qt)((Gp),([130,134]));
(IA)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(IB)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(IC)=((uK)(((qx)((Gp),([130,134])))));
(ID)=((Ig)((Gq),({S:"handle"})));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((IA).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((ID).vb),([129,2]))).S}).S+({S:({S:({S:".I="}).S+((v)(((IC).vb),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
}
else if(Gs.S===({S:"file_writerWrite"}).S){
(qt)((Gp),([130,134]));
(IF)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(IG)=((uK)(((qx)((Gp),([130,134])))));
(IH)=((Ig)((Gq),({S:"handle"})));
}
else if(Gs.S===({S:"file_writerWriteChar"}).S){
(qt)((Gp),([130,134]));
(IJ)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(IK)=((uK)(((qx)((Gp),([130,134])))));
(IL)=((Ig)((Gq),({S:"handle"})));
(eP)((Gn),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((IJ).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((IL).vb),([129,2]))).S}).S+({S:({S:({S:".I<"}).S+((v)(((IJ).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((IL).vb),([129,2]))).S}).S+({S:".F.length)\u000A"}).S}).S}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((IJ).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((IL).vb),([129,2]))).S}).S+({S:({S:({S:".F="}).S+((v)(((IJ).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((IL).vb),([129,2]))).S}).S+({S:({S:({S:".F.slice(0,"}).S+((v)(((IJ).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((IL).vb),([129,2]))).S}).S+({S:({S:({S:".I)+String.fromCharCode("}).S+((v)(((IK).vb),([129,2]))).S}).S+({S:({S:({S:")+"}).S+((v)(((IJ).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((IL).vb),([129,2]))).S}).S+({S:({S:({S:".F.slice("}).S+((v)(((IJ).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((IL).vb),([129,2]))).S}).S+({S:".I+1);\u000A"}).S}).S}).S}).S}).S}).S}).S}).S}).S}).S}).S}));
(eP)((Gn),([130,129,2]),({S:"else{\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((IJ).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((IL).vb),([129,2]))).S}).S+({S:({S:({S:".F+=String.fromCharCode("}).S+((v)(((IK).vb),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
(eP)((Gn),([130,129,2]),({S:"}\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((IJ).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((IL).vb),([129,2]))).S}).S+({S:".I++;\u000A"}).S}).S}));
}
else if(Gs.S===({S:"wnd_editBaseGetText"}).S){
(qt)((Gp),([130,134]));
(IN)=((uK)(((qx)((Gp),([130,134])))));
(IO)=((Ig)((Gq),({S:"handle"})));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((IN).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((IO).vb),([129,2]))).S}).S+({S:".H.value;\u000A"}).S}).S}));
}
else if(Gs.S===({S:"wnd_makeEditMulti"}).S){
(qt)((Gp),([130,134]));
(IQ)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(IR)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(IS)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(IT)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(IU)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(IV)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(IW)=((uK)(((qx)((Gp),([130,134])))));
(rA)((Gp),([130,134]));
(IX)=((uK)(((qx)((Gp),([130,134])))));
(IY)=((Ig)((Gq),({S:"handle"})));
(eP)((Gn),([130,129,2]),({S:"let h_=document.createElement(\"textarea\");\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"h_.setAttribute(\"cols\",\""}).S+((v)(((IU).vb),([129,2]))).S}).S+({S:"\");\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"h_.setAttribute(\"rows\",\""}).S+((v)(((IV).vb),([129,2]))).S}).S+({S:"\");\u000A"}).S}));
(eP)((Gn),([130,129,2]),({S:"document.body.appendChild(c_);\u000A"}));
(eP)((Gn),([130,129,2]),({S:({S:({S:""}).S+((v)(((IQ).vb),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((IY).vb),([129,2]))).S}).S+({S:"={C:c_};\u000A"}).S}).S}));
(eP)((Gn),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((IQ).vb),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
else{if(!(false)){throw 0xE9170000;}
}
}
// buildStats
function vx(Ja /*stats*/){
let Jc=null; // stat
let Je=0;
(qt)((Ja),([130,134]));
while(!((qv)((Ja),([130,134])))){
(Jc)=((qx)((Ja),([130,134])));
switch((Jc).qe){
case 66049:
(Jg)((Jc));
break;
case 66050:
(Ji)((Jc));
break;
case 16843265:
(Jk)((Jc));
break;
case 16843266:
(Jm)((Jc));
break;
case 66051:
(Jo)((Jc));
break;
case 526:
(Jq)((Jc));
break;
case 66052:
(Js)((Jc));
break;
case 527:
(Ju)((Jc));
break;
case 528:
(Jw)((Jc));
break;
case 529:
(Jy)((Jc));
break;
case 530:
(J0)((Jc));
break;
case 531:
(J2)((Jc));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(rA)((Ja),([130,134]));
}
}
// getDefaultValue
function v3(J4 /*type*/){
let J8=0;
let JD=0;
if((Fn)((J4))){
return {S:"null"};
}
switch((J4).qe){
case 66565:
if(!((Fs)((J4)))){throw 0xE9170000;}
return {S:"0"};
break;
case 1025:
return {S:"0"};
break;
case 1026:
switch((J4).y2){
case 0:
case 2:
return {S:"0"};
break;
case 1:
return {S:"0"};
break;
case 3:
return {S:"false"};
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// refClass
function vE(JJ /*ast*/){
let JK=null; // info
(JK)=((uK)((JJ)));
if((JK).uN){
return (JK).vb;
}
((JK).uN)=(true);
if(((JJ).q1)!==(null)){
(vE)(((JJ).q1));
}
(eS)((ak),([132,134]),(JJ));
return (JK).vb;
}
// findFunc
function vM(JP /*ast*/,JQ /*name*/){
let JR=null; // items
let JT=null; // item
(JR)=((JP).ti);
(qt)((JR),([130,134]));
while(!((qv)((JR),([130,134])))){
(JT)=((qx)((JR),([130,134])));
if(((((JT).tU).qe)===(256))&&((((JT).tU).qZ).S===(JQ).S)){
return (JT).tU;
}
(rA)((JR),([130,134]));
}
return null;
}
// escapeChar
function wv(JW /*c*/){
let JY=0;
JY=JW;
if(JY===(0x0022)){
return {S:"\\\""};
}
else if(JY===(0x0027)){
return {S:"\\\'"};
}
else if(JY===(0x005C)){
return {S:"\\\\"};
}
else if((0x0020)<=JY&&JY<=(0x007E)){
return (v)((JW),([2]));
}
else{return {S:({S:({S:"\\u"}).S+((v)(((pB)(((v)((JW),([5]))),([129,2]),(2),(-1))),([129,2]))).S}).S+({S:""}).S};
}
}
// initAst
function xj(Ke /*ast*/,Kf /*typeId*/,Kg /*pos*/,Kh /*name*/,Ki /*setParent*/){
if(!(!((Ke)instanceof yO))){throw 0xE9170000;}
(Kj)((Ke),(Kf),(Kg),(Kh),(Ki));
}
// make
function xk(Kk /*srcName*/,Kl /*row*/,Km /*col*/){
let Kn=null; // pos
(Kn)=(new dg());
((Kn).dh)=(Kk);
((Kn).di)=(Kl);
((Kn).dj)=(Km);
return Kn;
}
// _addStack
function xl(Ko /*me_*/,Kp /*type*/,Kq /*item*/){
Ko.push(Kq);
}
// readChar
function xm(){
let Kt=0; // c
let Kx=0;
Ks:
while(true){
(Kt)=((xO)());
if((Kt)===(0x000A)){
(Kt)=((xm)());
switch(Kt){
case 0x000A:
return 0x000A;
break;
case 0x003B:
do{
(Kt)=((K1)());
if((Kt)===(0x0000)){
return 0x0000;
}
}while((Kt)!==(0x000A));
(pJ)=(Kt);
continue Ks;
break;
case 0x007C:
return (xm)();
break;
}
(pK)=(Kt);
return 0x000A;
}
if((Kt)!==(0x0020)){
return Kt;
}
}
}
// readIdentifier
function x2(K7 /*skipSpaces*/,K8 /*refName*/){
let K9=0; // c
let KE=null; // buf
let KF=0; // pos
let KG=false; // at
let KJ=0;
let KP=null; // srcName
let KS=0;
let KU=0; // c2
let KT=0;
let Ld=0;
let Le=0;
(K9)=((K7)?((xm)()):((xO)()));
if(!((((((0x0061)<=(K9))&&((K9)<=(0x007A)))||(((0x0041)<=(K9))&&((K9)<=(0x005A))))||((K9)===(0x005F)))||((K8)&&(((K9)===(0x0040))||((K9)===(0x005C)))))){
(pJ)=(K9);
(D)((65542),((KC)()),([((KD)((K9)))]));
return {S:""};
}
(KE)=({S:"\0".repeat(128)});
(KF)=(0);
(KG)=(false);
do{
switch(K9){
case 0x0040:
if(KG){
(pJ)=(K9);
(D)((65543),((KC)()),(null));
return {S:""};
}
if((KF)!==(0)){
(KP)=((pB)((KE),([129,2]),(0),(KF)));
KR:
for(KS=(0),KT=(((KP).S.length)-(1));KS<=KT;KS+=(1)){
(KU)=((KP).S.charCodeAt(KS));
if(((0x0041)<=(KU))&&((KU)<=(0x005A))){
(pJ)=(K9);
(D)((65544),((KC)()),([(KP)]));
return {S:""};
}
}
(KX)((KP));
}
(KG)=(true);
break;
case 0x005C:
if(KG){
(pJ)=(K9);
(D)((65545),((KC)()),(null));
return {S:""};
}
break;
}
if((KF)===(128)){
(pJ)=(K9);
(D)((65546),((KC)()),([(KE)]));
return {S:""};
}
(KE).S=(Ld=(KF),(KE).S.slice(0,Ld)+String.fromCharCode(K9)+(KE).S.slice(Ld+1));
(KF)=((KF)+(1));
(K9)=((xO)());
}while(((((((0x0061)<=(K9))&&((K9)<=(0x007A)))||(((0x0041)<=(K9))&&((K9)<=(0x005A))))||((K9)===(0x005F)))||(((0x0030)<=(K9))&&((K9)<=(0x0039))))||((K8)&&(((K9)===(0x0040))||((K9)===(0x005C)))));
(pJ)=(K9);
return (pB)((KE),([129,2]),(0),(KF));
}
// parseFunc
function x7(Lg /*parentClass*/,Lh /*overritten*/){
let Li=null; // ast
let Lk=0; // c
let Lp=0; // row
let Lq=0; // col
let Lr=null; // s
let Lw=0;
let Me=null; // arg
let Mh=null; // type
let Mk=0; // c
let Mx=0; // c
let M5=null; // stat
(Li)=(new c7());
((Li).qk)=(0);
((Li).ql)=({L:0,H:null,T:null,P:null});
(Lk)=((xm)());
if((Lk)===(0x005B)){
Lo:
while(true){
(Lp)=(pH);
(Lq)=(pI);
(Lr)=((Ls)());
if(((((Lr).S.length)===(5))&&(((Lr).S.charCodeAt(0))===(0x005F)))&&(((Lr).S.charCodeAt(1))===(0x005F))){
switch((Lr).S.charCodeAt(2)){
case 0x0061:
if((((Lr).S.charCodeAt(3))===(0x006E))&&(((Lr).S.charCodeAt(4))===(0x0079))){
((Li).qk)=((L0)(((Li).qk),([9]),(1)));
}
break;
case 0x0066:
if((((Lr).S.charCodeAt(3))===(0x0072))&&(((Lr).S.charCodeAt(4))===(0x0063))){
((Li).qk)=((L0)(((Li).qk),([9]),(128)));
}
break;
case 0x006B:
if((((Lr).S.charCodeAt(3))===(0x0076))&&(((Lr).S.charCodeAt(4))===(0x0066))){
((Li).qk)=((L0)(((Li).qk),([9]),(256)));
}
break;
case 0x006D:
if((((Lr).S.charCodeAt(3))===(0x006B))&&(((Lr).S.charCodeAt(4))===(0x0069))){
((Li).qk)=((L0)(((Li).qk),([9]),(2048)));
}
break;
case 0x0072:
if((((Lr).S.charCodeAt(3))===(0x0061))&&(((Lr).S.charCodeAt(4))===(0x0077))){
((Li).qk)=((L0)(((Li).qk),([9]),(4096)));
}
else if((((Lr).S.charCodeAt(3))===(0x006D))&&(((Lr).S.charCodeAt(4))===(0x0065))){
((Li).qk)=((L0)(((Li).qk),([9]),(4)));
}
else if((((Lr).S.charCodeAt(3))===(0x0063))&&(((Lr).S.charCodeAt(4))===(0x0068))){
((Li).qk)=((L0)(((Li).qk),([9]),(16)));
}
else if(((Lr).S.charCodeAt(3))===(0x0061)){
if(((Lr).S.charCodeAt(4))===(0x0063)){
((Li).qk)=((L0)(((Li).qk),([9]),(64)));
}
else if(((Lr).S.charCodeAt(4))===(0x006B)){
((Li).qk)=((L0)(((Li).qk),([9]),(512)));
}
else if(((Lr).S.charCodeAt(4))===(0x0076)){
((Li).qk)=((L0)(((Li).qk),([9]),(1024)));
}
}
break;
case 0x0074:
if((((Lr).S.charCodeAt(3))===(0x006D))&&(((Lr).S.charCodeAt(4))===(0x0065))){
((Li).qk)=((L0)(((Li).qk),([9]),(2)));
}
else if((((Lr).S.charCodeAt(3))===(0x0063))&&(((Lr).S.charCodeAt(4))===(0x0068))){
((Li).qk)=((L0)(((Li).qk),([9]),(8)));
}
else if((((Lr).S.charCodeAt(3))===(0x006B))&&(((Lr).S.charCodeAt(4))===(0x0076))){
((Li).qk)=((L0)(((Li).qk),([9]),(32)));
}
break;
}
}
else{
(eP)(((Li).ql),([130,129,2]),(Lr));
}
(Lk)=((xm)());
if((Lk)===(0x0000)){
break Lo;
}
if((Lk)===(0x005D)){
break Lo;
}
if((Lk)!==(0x002C)){
(LW)((0x002C),(Lk));
break Lo;
}
}
}
else{
(pJ)=(Lk);
}
(xj)((Li),(256),((KC)()),((x2)((true),(false))),(true));
((Li).qi)=({L:0,H:null,T:null,P:null});
((Li).qj)=(null);
((Li).tr)=({L:0,H:null,T:null,P:null});
((Li).qa)=(new Map());
(xl)((ah),([131,134]),(Li));
if((Lg)!==(null)){
(Ma)((Li),(Lg));
}
(Mb)((0x0028),(true));
if((Lg)!==(null)){
(Me)=(new rq());
(xj)((Me),(7),((Li).qn),(null),(false));
((Me).qZ)=({S:"me"});
((Me).rr)=(2);
((Me).sL)=(false);
((Me).y3)=(null);
(Mf)((Me),(false));
(Mh)=(new Mi());
(xj)((Mh),(66565),((Li).qn),(null),(false));
(Ma)((Mh),(Lg));
((Me).s6)=(Mh);
(eP)(((Li).qi),([130,134]),(Me));
}
(Mk)=((xm)());
if((Mk)!==(0x0029)){
(pJ)=(Mk);
Mo:
while(true){
(eP)(((Li).qi),([130,134]),((Mp)((2),(null))));
(Mk)=((xm)());
if((Mk)===(0x0000)){
break Mo;
}
if((Mk)===(0x0029)){
break Mo;
}
if((Mk)!==(0x002C)){
(LW)((0x002C),(Mk));
break Mo;
}
}
}
(Mx)=((xm)());
if((Mx)===(0x003A)){
((Li).qj)=((M0)());
(Mx)=((xm)());
}
if((Mx)!==(0x000A)){
(LW)((0x000A),(Mx));
}
M4:
while(true){
(M5)=((M6)((Li)));
if((M5)===(null)){
if(pL){
break M4;
}
else{
continue M4;
}
}
if(((M5).qe)===(513)){
break M4;
}
(eP)(((Li).tr),([130,134]),(M5));
}
(xU)((ah),([131,134]));
return Li;
}
// parseVar
function x9(ME /*kind*/,MF /*parentClass*/){
let MG=null; // ast
(MG)=(new tX());
(xj)((MG),(2),((KC)()),(null),(false));
((MG).tZ)=((Mp)((ME),(MF)));
(Mb)((0x000A),(true));
return MG;
}
// parseConst
function xB(){
let MH=null; // ast
(MH)=(new xC());
(xj)((MH),(3),((KC)()),(null),(false));
((MH).xS)=((Mp)((4),(null)));
(Mb)((0x000A),(true));
return MH;
}
// parseAlias
function xE(){
let MI=null; // ast
(MI)=(new xF());
(xj)((MI),(4),((KC)()),((x2)((true),(false))),(true));
(Mb)((0x003A),(true));
((MI).MJ)=((M0)());
(Mb)((0x000A),(true));
return MI;
}
// parseClass
function xI(){
let MK=null; // ast
let MM=0; // c
let MQ=false; // kuinSrc
let MV=0; // c
let Na=0; // row
let Nb=0; // col
let Nc=null; // item
let Nm=null; // id
let Nn=null; // className
let Nz=null;
let N1=null; // id2
let N4=null; // astEndClass
(MK)=(new fb());
(xj)((MK),(5),((KC)()),((x2)((true),(false))),(true));
((MK).ti)=({L:0,H:null,T:null,P:null});
(Mb)((0x0028),(true));
(MM)=((xm)());
if((MM)!==(0x0029)){
(pJ)=(MM);
(Ma)((MK),((x2)((true),(true))));
(Mb)((0x0029),(true));
}
else{
(MQ)=((ag).S===({S:"kuin"}).S);
if(!((MQ)&&(((MK).qZ).S===({S:"Class"}).S))){
(Ma)((MK),((MQ)?({S:"@Class"}):({S:"kuin@Class"})));
}
}
(Mb)((0x000A),(true));
((MK).qa)=(new Map());
(xl)((ah),([131,134]),(MK));
MU:
while(true){
(MV)=((xm)());
if((MV)===(0x0000)){
(D)((65551),((KC)()),([({S:"class"})]));
break MU;
}
if((MV)===(0x000A)){
continue MU;
}
(Na)=(pH);
(Nb)=(pI);
(Nc)=(new tS());
((Nc).Nd)=(false);
((Nc).Ne)=(false);
((Nc).Nf)=(null);
if((MV)===(0x002B)){
((Nc).Nd)=(true);
}
else{
(pJ)=(MV);
}
(MV)=((xm)());
if((MV)===(0x002A)){
((Nc).Ne)=(true);
}
else{
(pJ)=(MV);
}
(Nm)=((x2)((true),(false)));
(Nn)=(((((MK).qW).qe)===(1))?({S:({S:"@"}).S+((MK).qZ).S}):((MK).qZ));
if((Nm).S===({S:"func"}).S){
((Nc).tU)=((x7)((Nn),((Nc).Ne)));
}
else if((Nm).S===({S:"var"}).S){
if((Nc).Ne){
(D)((65552),((xk)((ag),(Na),(Nb))),([(Nm)]));
}
((Nc).tU)=((x9)((5),(Nn)));
}
else{
if((Nc).Nd){
(D)((65553),((xk)((ag),(Na),(Nb))),([(Nm)]));
}
if((Nc).Ne){
(D)((65552),((xk)((ag),(Na),(Nb))),([(Nm)]));
}
Nz=Nm;
if(Nz.S===({S:"end"}).S){
(N1)=((x2)((true),(false)));
if((N1).S!==({S:"class"}).S){
(D)((65554),((xk)((ag),(Na),(Nb))),([({S:"class"}),(N1)]));
}
(N4)=(new c8());
(xj)((N4),(0),((xk)((ag),(Na),(Nb))),(null),(false));
(Mb)((0x000A),(true));
break MU;
}
else if(Nz.S===({S:"const"}).S){
((Nc).tU)=((xB)());
}
else if(Nz.S===({S:"alias"}).S){
((Nc).tU)=((xE)());
}
else if(Nz.S===({S:"class"}).S){
((Nc).tU)=((xI)());
}
else{(D)((65555),((xk)((ag),(Na),(Nb))),([(Nm)]));
(xN)(((xO)()));
continue MU;
}
}
(eP)(((MK).ti),([130,134]),(Nc));
}
(xU)((ah),([131,134]));
return MK;
}
// parseEnum
function xK(){
let N9=null; // ast
let ND=0; // c
let NI=null; // id
let NL=null; // id2
let NQ=null; // item
let NV=null; // expr
(N9)=(new xL());
(xj)((N9),(6),((KC)()),((x2)((true),(false))),(true));
((N9).NA)=({L:0,H:null,T:null,P:null});
(Mb)((0x000A),(true));
((N9).qa)=(new Map());
(xl)((ah),([131,134]),(N9));
NC:
while(true){
(ND)=((xm)());
if((ND)===(0x0000)){
(D)((65551),((KC)()),([({S:"enum"})]));
break NC;
}
if((ND)===(0x000A)){
continue NC;
}
(pJ)=(ND);
(NI)=((x2)((true),(false)));
if((NI).S===({S:"end"}).S){
(NL)=((x2)((true),(false)));
if((NL).S!==({S:"enum"}).S){
(D)((65554),((KC)()),([({S:"enum"}),(NL)]));
}
(Mb)((0x000A),(true));
break NC;
}
(ND)=((xm)());
if((ND)===(0x003A)){
(Mb)((0x003A),(false));
(NQ)=((NR)());
if((NQ)===(null)){
(xN)(((xO)()));
continue NC;
}
(ND)=((xm)());
}
else{
(NV)=(new zh());
(NW)((NV),(67585),((N9).qn));
((NV).zn)=(null);
((NV).zk)=(0x0000000000000000);
(NQ)=(NV);
}
((NQ).qZ)=(NI);
if((ND)!==(0x000A)){
(LW)((0x000A),(ND));
}
(eP)(((N9).NA),([130,134]),(NQ));
(Mf)((NQ),(true));
}
(xU)((ah),([131,134]));
return N9;
}
// readUntilRet
function xN(NZ /*c*/){
while(((NZ)!==(0x000A))&&((NZ)!==(0x0000))){
(NZ)=((xO)());
}
(pJ)=(NZ);
}
// read
function xO(){
let Ob=0; // c
let Od=0;
(Ob)=((K1)());
switch(Ob){
case 0x007B:
(Of)();
return 0x0020;
break;
case 0x0009:
return 0x0020;
break;
}
return Ob;
}
// _getStack
function xU(Oh /*me_*/,Oi /*type*/){
return Oh.pop();
}
// initAst
function yr(Oj /*ast*/,Ok /*typeId*/,Ol /*pos*/){
if(!(!((Oj)instanceof yO))){throw 0xE9170000;}
(Om)((Oj),(Ok),(Ol));
}
// searchStdItem
function yG(On /*src*/,Oo /*identifier*/,Op /*makeExprRef*/){
let Oq=null; // ast
let Ot=false;
let Ow=null; // ast2
let Oz=false;
let O4=null; // expr
let Or=null;
let Os=false;
let Ox=null;
let Oy=false;
(Oq)=((Or=(pT)((I),([133,129,2,134]),(On),(Os={$:(Ot)},Os)),(Ot)=Os.$,Or));
if((Oq)===(null)){
(D)((6),(null),([(On)]));
return null;
}
(Ow)=((Ox=(pT)(((Oq).qa),([133,129,2,134]),(Oo),(Oy={$:(Oz)},Oy)),(Oz)=Oy.$,Ox));
if((Oq)===(null)){
(D)((7),(null),([(On)]));
return null;
}
if(Op){
(O4)=(new yO());
(yP)((O4),(2062),((xk)(({S:"kuin"}),(1),(1))));
((O4).q1)=(Ow);
return (O5)((O4));
}
return Ow;
}
// initAstExpr
function yP(O6 /*ast*/,O7 /*typeId*/,O8 /*pos*/){
if(!((O6)instanceof yO)){throw 0xE9170000;}
(Om)((O6),(O7),(O8));
((O6).zn)=(null);
((O6).zj)=(0);
}
// rebuildArg
function zN(O9 /*ast*/){
if(((O9).zJ)!==(null)){
return;
}
((O9).zJ)=(O9);
((O9).s6)=((zQ)(((O9).s6),(null)));
if(((O9).y3)!==(null)){
((O9).y3)=((Aj)(((O9).y3),(false)));
if(((O9).y3)===(null)){
return;
}
if((((O9).rr)===(1))&&(((rv)((((O9).y3).qe),([9]),(67584)))!==(67584))){
(D)((131091),((O9).qn),([((O9).qZ)]));
}
if((((O9).rr)===(4))&&(((rv)((((O9).y3).qe),([9]),(67584)))!==(67584))){
(D)((131092),((O9).qn),([((O9).qZ)]));
}
if(!((OL)((((O9).y3).zn),((O9).s6),(false)))){
(D)((131093),((O9).qn),([((O9).qZ)]));
}
else if(((((O9).y3).zn).qe)===(1028)){
((O9).y3)=((OO)(((O9).y3),((O9).s6)));
}
}
}
// rebuildType
function zQ(OP /*ast*/,OQ /*parentAlias*/){
let OT=0; // type
let OV=0;
let OX=null; // refItem
let Pb=0;
let Pl=null; // ast2
let Pm=null; // items
let Po=null; // arg
let Pt=null; // ast2
if(((OP).zJ)!==(null)){
return (OP).zJ;
}
((OP).zJ)=(OP);
(OT)=((OP).qe);
switch(OT){
case 66565:
(OX)=((OP).q1);
if((OX)===(null)){
return null;
}
switch((OX).qe){
case 5:
(Pd)((OX));
break;
case 6:
(Pf)((OX));
break;
case 4:
(Ph)((OX),(OQ));
((OP).zJ)=((OX).MJ);
(OP)=((OX).MJ);
break;
default:
(D)((131111),((OP).qn),(null));
return null;
break;
}
break;
case 66561:
((OP).AR)=((zQ)(((OP).AR),(OQ)));
break;
case 66562:
(Pl)=(OP);
(Pm)=((Pl).Be);
(qt)((Pm),([130,134]));
while(!((qv)((Pm),([130,134])))){
(Po)=((qx)((Pm),([130,134])));
((Po).Bn)=((zQ)(((Po).Bn),(OQ)));
(rA)((Pm),([130,134]));
}
if(((Pl).AZ)!==(null)){
((Pl).AZ)=((zQ)(((Pl).AZ),(OQ)));
}
break;
case 66563:
((OP).Bz)=((zQ)(((OP).Bz),(OQ)));
break;
case 66564:
(Pt)=(OP);
((Pt).B6)=((zQ)(((Pt).B6),(OQ)));
((Pt).B7)=((zQ)(((Pt).B7),(OQ)));
break;
default:
if(!(((((OT)===(0))||((OT)===(1025)))||((OT)===(1026)))||((OT)===(1027)))){throw 0xE9170000;}
break;
}
return OP;
}
// refreshStats
function zR(Pv /*stats*/,Pw /*retType*/,Px /*parentFunc*/){
let Py=null; // stats2
let P0=null; // stat
(Py)=({L:0,H:null,T:null,P:null});
(qt)((Pv),([130,134]));
while(!((qv)((Pv),([130,134])))){
(P0)=((At)(((qx)((Pv),([130,134]))),(Pw),(Px)));
if((P0)!==(null)){
(eP)((Py),([130,134]),(P0));
}
(rA)((Pv),([130,134]));
}
return Py;
}
// rebuildExpr
function Aj(P3 /*ast*/,P4 /*nullable*/){
let P8=0;
if((P3)===(null)){
return null;
}
switch((P3).qe){
case 0:
return null;
break;
case 2049:
(P3)=((PB)((P3)));
break;
case 2050:
(P3)=((PE)((P3)));
break;
case 2051:
(P3)=((PG)((P3)));
break;
case 2052:
(P3)=((PJ)((P3)));
break;
case 2053:
(P3)=((PM)((P3)));
break;
case 2054:
(P3)=((PP)((P3)));
break;
case 2055:
(P3)=((PS)((P3)));
break;
case 2056:
(P3)=((PV)((P3)));
break;
case 2057:
(P3)=((PY)((P3)));
break;
case 2058:
(P3)=((Qa)((P3)));
break;
case 2059:
(P3)=((Qd)((P3)));
break;
case 67584:
(P3)=((Qg)((P3)));
break;
case 67585:
(P3)=((Qi)((P3)));
break;
case 67586:
(P3)=((Qk)((P3)));
break;
case 67587:
(P3)=((Qn)((P3)));
break;
case 67588:
(P3)=((Qq)((P3)));
break;
case 2060:
(P3)=((Qt)((P3)));
break;
case 2062:
(P3)=((O5)((P3)));
break;
}
if((P3)===(null)){
return null;
}
if((!(P4))&&(((P3).zn)===(null))){
(D)((131112),((P3).qn),(null));
return null;
}
return P3;
}
// rebuildStat
function At(Q0 /*ast*/,Q1 /*retType*/,Q2 /*parentFunc*/){
let Q6=0;
let Q9=null; // ast2
let QD=null; // arg
let QG=null; // args
let QH=null; // refClass
let QI=null; // items
let QL=null; // item
let QO=null; // astRef
let QS=null; // astDo
let QU=null; // astAssign
let QW=null; // astRef
if((Q0)===(null)){
return null;
}
switch((Q0).qe){
case 514:
case 516:
case 517:
case 518:
case 519:
return null;
break;
case 515:
(Q9)=(Q0);
(QB)(((Q9).QC));
(QD)=(((Q9).QC).tZ);
if((((QD).qZ)!==(null))&&(((QD).qZ).S===({S:"super"}).S)){
if(!(((Q2)!==(null))&&(((Q2).qZ)!==(null)))){throw 0xE9170000;}
if(!((((QD).s6).qe)===(66562))){throw 0xE9170000;}
(QG)=(((QD).s6).Be);
(qt)((QG),([130,134]));
(QH)=((((qx)((QG),([130,134]))).Bn).q1);
if(!(((QH).qe)===(5))){throw 0xE9170000;}
(QI)=((QH).ti);
(qt)((QI),([130,134]));
QK:
while(!((qv)((QI),([130,134])))){
(QL)=((qx)((QI),([130,134])));
if(((((QL).tU).qZ)!==(null))&&((((QL).tU).qZ).S===((Q2).qZ).S)){
if(!((QL).Ne)){throw 0xE9170000;}
(QO)=(new yO());
(yP)((QO),(2062),((Q0).qn));
((QO).q1)=(((QL).Nf).tU);
((QD).y3)=(QO);
break QK;
}
(rA)((QI),([130,134]));
}
if(!(!((qv)((QI),([130,134]))))){throw 0xE9170000;}
}
if(((QD).y3)===(null)){
return null;
}
(QS)=(new yK());
(yr)((QS),(528),((Q0).qn));
(QU)=(new An());
(yP)((QU),(2050),((Q0).qn));
((QU).Ao)=(0);
(QW)=(new yO());
(yP)((QW),(2062),((Q0).qn));
((QW).q1)=(QD);
((QU).Ar)=(QW);
((QU).As)=((QD).y3);
((QS).yU)=(QU);
((QD).y3)=(null);
(Q0)=((At)((QS),(Q1),(Q2)));
break;
case 66049:
(Q0)=((QY)((Q0),(Q1),(Q2)));
break;
case 66050:
(Q0)=((Ra)((Q0),(Q1),(Q2)));
break;
case 16843265:
(Q0)=((Rc)((Q0),(Q1),(Q2)));
break;
case 16843266:
(Q0)=((Re)((Q0),(Q1),(Q2)));
break;
case 66051:
(Q0)=((Rg)((Q0),(Q1),(Q2)));
break;
case 526:
(Q0)=((Ri)((Q0)));
break;
case 66052:
(Q0)=((Rk)((Q0),(Q1),(Q2)));
break;
case 527:
(Q0)=((Rm)((Q0),(Q1)));
break;
case 528:
(Q0)=((Ro)((Q0)));
break;
case 529:
(Q0)=((Rq)((Q0),(Q1),(Q2)));
break;
case 530:
(Q0)=((Rs)((Q0),(Q1),(Q2)));
break;
case 531:
(Q0)=((Ru)((Q0)));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
if((Q0)===(null)){
return null;
}
if(!(((Q0).zJ)!==(null))){throw 0xE9170000;}
return Q0;
}
// isRef
function Av(Ry /*type*/){
let Rz=0; // typeId
(Rz)=((Ry).qe);
return ((((Rz)===(66561))||((Rz)===(66563)))||((Rz)===(66564)))||((R0)((Ry)));
}
// makeExprNull
function A2(R1 /*pos*/){
let R2=null; // value
let R4=null; // type
(R2)=(new zi());
(yP)((R2),(67584),(R1));
(R4)=(new R5());
(yr)((R4),(1027),(R1));
((R2).zn)=(R4);
return R2;
}
// getId
function A8(){
let R6=null; // curId
let R7=null; // newId
let RA=0; // idx
let RR=0;
let RU=null;
let RY=null;
let Sc=null;
let RJ=0;
let RK=0;
let RN=0;
let RO=0;
(R6)=(M);
(R7)=(C_([129,2],(M)));
R9:
while(true){
(RA)=(((R7).S.length)-(1));
RC:
while(true){
if(((R7).S.charCodeAt(RA))===(0x007A)){
if((RA)===(0)){
(R7)=({S:"\0".repeat(((R7).S.length)+(1))});
(RH)((R7),([129,2]),(0x0061));
}
else{
(R7).S=(RJ=(RA),(R7).S.slice(0,RJ)+String.fromCharCode(0x0061)+(R7).S.slice(RJ+1));
(RA)=((RA)-(1));
continue RC;
}
}
else{
(R7).S=(RN=(RA),(R7).S.slice(0,RN)+String.fromCharCode((RP)(((R7).S.charCodeAt(RA)),(1)))+(R7).S.slice(RN+1));
}
break RC;
}
switch((R7).S.length){
case 2:
RU=R7;
if(RU.S===({S:"do"}).S||RU.S===({S:"if"}).S||RU.S===({S:"or"}).S){
continue R9;
}
break;
case 3:
RY=R7;
if(RY.S===({S:"and"}).S||RY.S===({S:"asm"}).S||RY.S===({S:"for"}).S||RY.S===({S:"int"}).S||RY.S===({S:"new"}).S||RY.S===({S:"not"}).S||RY.S===({S:"try"}).S||RY.S===({S:"xor"}).S){
continue R9;
}
break;
case 4:
Sc=R7;
if(Sc.S===({S:"auto"}).S||Sc.S===({S:"bool"}).S||Sc.S===({S:"case"}).S||Sc.S===({S:"char"}).S||Sc.S===({S:"else"}).S||Sc.S===({S:"enum"}).S||Sc.S===({S:"goto"}).S||Sc.S===({S:"long"}).S||Sc.S===({S:"main"}).S||Sc.S===({S:"this"}).S||Sc.S===({S:"true"}).S||Sc.S===({S:"void"}).S){
continue R9;
}
break;
}
break R9;
}
(M)=(R7);
return R6;
}
// search
function DE(Se /*members*/,Sf /*name*/){
let Sh=null; // def
(qt)((Se),([130,134]));
while(!((qv)((Se),([130,134])))){
(Sh)=(((qx)((Se),([130,134]))).tU);
if(((((Sh).qe)===(2))&&((((Sh).tZ).qZ)!==(null)))&&((((Sh).tZ).qZ).S===(Sf).S)){
return (rW)(((Sh).tZ));
}
(rA)((Se),([130,134]));
}
if(!(false)){throw 0xE9170000;}
return null;
}
// buildIf
function E9(Sk /*ast*/,Sl /*breakStat*/,Sm /*skipStat*/){
let Sn=null; // infoMe
let Sw=null; // items
let Sz=null; // item
(Sn)=((rW)((Sk)));
if(((Sk).Sp)===(null)){
(ER)(((Sk).Sr),(Sl),(Sm));
if((((Sn).AB)!==(null))&&((Sn).AH)){
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((Sn).AB),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
return;
}
(eP)((P),([130,129,2]),({S:"if("}));
(Su)(((Sk).Sp));
(eP)((P),([130,129,2]),({S:"){\u000A"}));
(ER)(((Sk).Sr),(Sl),(Sm));
(eP)((P),([130,129,2]),({S:"}\u000A"}));
(Sw)=((Sk).Sx);
(qt)((Sw),([130,134]));
while(!((qv)((Sw),([130,134])))){
(Sz)=((qx)((Sw),([130,134])));
(eP)((P),([130,129,2]),({S:"else if("}));
(Su)(((Sz).S1));
(eP)((P),([130,129,2]),({S:"){\u000A"}));
(ER)(((Sz).S2),(Sl),(Sm));
(eP)((P),([130,129,2]),({S:"}\u000A"}));
(rA)((Sw),([130,134]));
}
if(((Sk).S4)!==(null)){
(eP)((P),([130,129,2]),({S:"else{\u000A"}));
(ER)(((Sk).S4),(Sl),(Sm));
(eP)((P),([130,129,2]),({S:"}\u000A"}));
}
if((((Sn).AB)!==(null))&&((Sn).AH)){
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((Sn).AB),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
}
// buildSwitch
function EC(S8 /*ast*/,S9 /*breakStat*/,SA /*skipStat*/){
let SB=null; // infoMe
let SC=null; // info
let SF=false; // useSwitch
let SL=null; // items
let SO=null; // item
let SQ=null; // items2
let ST=null; // exprs
let SZ=null; // items
let Tb=null; // item
let Tc=null; // items2
let Te=null; // exprs
let Tl=false; // first
let Tm=null; // items
let To=null; // item
let Ts=false; // first2
let Tt=null; // items2
let Tv=null; // exprs
(SB)=((rW)((S8)));
(SC)=((rW)(((S8).y4)));
if(!((SC).rZ)){
((SC).rZ)=(true);
(eP)((T),([130,134]),((S8).y4));
}
(SF)=(false);
SH:
if(((((s5)((((S8).SI).zn)))||((SJ)((((S8).SI).zn))))||((Fs)((((S8).SI).zn))))||(((((S8).SI).zn).qe)===(1025))){
(SF)=(true);
(SL)=((S8).SM);
(qt)((SL),([130,134]));
while(!((qv)((SL),([130,134])))){
(SO)=((qx)((SL),([130,134])));
(SQ)=((SO).SR);
(qt)((SQ),([130,134]));
while(!((qv)((SQ),([130,134])))){
(ST)=((qx)((SQ),([130,134])));
if((((rv)((((ST).zo).qe),([9]),(67584)))!==(67584))||(((ST).zt)!==(null))){
(SF)=(false);
break SH;
}
(rA)((SQ),([130,134]));
}
(rA)((SL),([130,134]));
}
}
if(SF){
(eP)((P),([130,129,2]),({S:"switch("}));
(Su)(((S8).SI));
(eP)((P),([130,129,2]),({S:"){\u000A"}));
(SZ)=((S8).SM);
(qt)((SZ),([130,134]));
while(!((qv)((SZ),([130,134])))){
(Tb)=((qx)((SZ),([130,134])));
(Tc)=((Tb).SR);
(qt)((Tc),([130,134]));
while(!((qv)((Tc),([130,134])))){
(Te)=((qx)((Tc),([130,134])));
if(!(((Te).zt)===(null))){throw 0xE9170000;}
(eP)((P),([130,129,2]),({S:"case "}));
(Su)(((Te).zo));
(eP)((P),([130,129,2]),({S:":\u000A"}));
(rA)((Tc),([130,134]));
}
(ER)(((Tb).Tf),(S8),(SA));
(eP)((P),([130,129,2]),({S:"break;\u000A"}));
(rA)((SZ),([130,134]));
}
if(((S8).Th)!==(null)){
(eP)((P),([130,129,2]),({S:"default:\u000A"}));
(ER)(((S8).Th),(S8),(SA));
(eP)((P),([130,129,2]),({S:"break;\u000A"}));
}
(eP)((P),([130,129,2]),({S:"}\u000A"}));
}
else{
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((SC).sP),([129,2]))).S}).S+({S:" = "}).S}));
(Su)(((S8).SI));
(eP)((P),([130,129,2]),({S:";\u000A"}));
(Tl)=(true);
(Tm)=((S8).SM);
(qt)((Tm),([130,134]));
while(!((qv)((Tm),([130,134])))){
(To)=((qx)((Tm),([130,134])));
if(Tl){
(Tl)=(false);
(eP)((P),([130,129,2]),({S:"if("}));
}
else{
(eP)((P),([130,129,2]),({S:"else if("}));
}
(Ts)=(true);
(Tt)=((To).SR);
(qt)((Tt),([130,134]));
while(!((qv)((Tt),([130,134])))){
(Tv)=((qx)((Tt),([130,134])));
if(Ts){
(Ts)=(false);
}
else{
(eP)((P),([130,129,2]),({S:" || "}));
}
if(((Tv).zt)===(null)){
if((Av)((((S8).SI).zn))){
(eP)((P),([130,129,2]),({S:({S:({S:"cmp_("}).S+((v)(((SC).sP),([129,2]))).S}).S+({S:", ("}).S}));
(Su)(((Tv).zo));
(eP)((P),([130,129,2]),({S:")) == 0"}));
}
else{
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((SC).sP),([129,2]))).S}).S+({S:" == ("}).S}));
(Su)(((Tv).zo));
(eP)((P),([130,129,2]),({S:")"}));
}
}
else{
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((Tv).zo));
(eP)((P),([130,129,2]),({S:({S:({S:") <= "}).S+((v)(((SC).sP),([129,2]))).S}).S+({S:({S:({S:" && "}).S+((v)(((SC).sP),([129,2]))).S}).S+({S:" <= ("}).S}).S}));
(Su)(((Tv).zt));
(eP)((P),([130,129,2]),({S:")"}));
}
(rA)((Tt),([130,134]));
}
(eP)((P),([130,129,2]),({S:"){\u000A"}));
(ER)(((To).Tf),(S9),(SA));
(eP)((P),([130,129,2]),({S:"}\u000A"}));
(rA)((Tm),([130,134]));
}
if(((S8).Th)!==(null)){
(eP)((P),([130,129,2]),({S:"else{"}));
(ER)(((S8).Th),(S9),(SA));
(eP)((P),([130,129,2]),({S:"}\u000A"}));
}
}
if((((SB).AB)!==(null))&&((SB).AH)){
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((SB).AB),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
}
// buildWhile
function EF(T9 /*ast*/,TA /*breakStat*/,TB /*skipStat*/){
let TC=null; // infoMe
(TC)=((rW)((T9)));
if(((T9).TE)===(null)){
(eP)((P),([130,129,2]),({S:"for(;;){\u000A"}));
(tq)(((T9).TG),(T9),(T9));
if((((TC).AE)!==(null))&&((TC).AI)){
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((TC).AE),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
(eP)((P),([130,129,2]),({S:"}\u000A"}));
if((((TC).AB)!==(null))&&((TC).AH)){
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((TC).AB),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
return;
}
if((T9).TM){
(eP)((P),([130,129,2]),({S:"do{\u000A"}));
(tq)(((T9).TG),(T9),(T9));
if((((TC).AE)!==(null))&&((TC).AI)){
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((TC).AE),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
(eP)((P),([130,129,2]),({S:"}while("}));
(Su)(((T9).TE));
(eP)((P),([130,129,2]),({S:");\u000A"}));
if((((TC).AB)!==(null))&&((TC).AH)){
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((TC).AB),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
return;
}
(eP)((P),([130,129,2]),({S:"while("}));
(Su)(((T9).TE));
(eP)((P),([130,129,2]),({S:"){\u000A"}));
(tq)(((T9).TG),(T9),(T9));
if((((TC).AE)!==(null))&&((TC).AI)){
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((TC).AE),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
(eP)((P),([130,129,2]),({S:"}\u000A"}));
if((((TC).AB)!==(null))&&((TC).AH)){
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((TC).AB),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
}
// buildFor
function EJ(TW /*ast*/,TX /*breakStat*/,TY /*skipStat*/){
let TZ=null; // infoMe
let Ua=null; // info
let Ud=null; // endId
let Ui=0; // step
(TZ)=((rW)((TW)));
(Ua)=((rW)(((TW).y4)));
if(!((Ua).rZ)){
((Ua).rZ)=(true);
(eP)((T),([130,134]),((TW).y4));
}
(Ud)=((Ue)((((TW).Uf).zn)));
(eP)((P),([130,129,2]),({S:({S:({S:"for("}).S+((v)(((Ua).sP),([129,2]))).S}).S+({S:" = ("}).S}));
(Su)(((TW).Ug));
(eP)((P),([130,129,2]),({S:({S:({S:"), "}).S+((v)((Ud),([129,2]))).S}).S+({S:" = ("}).S}));
(Su)(((TW).Uf));
(eP)((P),([130,129,2]),({S:({S:({S:"); "}).S+((v)(((Ua).sP),([129,2]))).S}).S+({S:" "}).S}));
if(!(((((TW).Uh).qe)===(67585))&&((s5)((((TW).Uf).zn))))){throw 0xE9170000;}
(Ui)=(((TW).Uh).zk);
if((Ui)>(0)){
(eP)((P),([130,129,2]),({S:"<="}));
}
else{
(eP)((P),([130,129,2]),({S:">="}));
}
(eP)((P),([130,129,2]),({S:({S:({S:" "}).S+((v)((Ud),([129,2]))).S}).S+({S:({S:({S:"; "}).S+((v)(((Ua).sP),([129,2]))).S}).S+({S:" "}).S}).S}));
if((Ui)>(0)){
(eP)((P),([130,129,2]),({S:"+= ("}));
}
else{
(eP)((P),([130,129,2]),({S:"-= ("}));
}
(Su)(((TW).Uh));
(eP)((P),([130,129,2]),({S:")){\u000A"}));
(tq)(((TW).Up),(TW),(TW));
if((((TZ).AE)!==(null))&&((TZ).AI)){
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((TZ).AE),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
(eP)((P),([130,129,2]),({S:"}\u000A"}));
if((((TZ).AB)!==(null))&&((TZ).AH)){
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((TZ).AB),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
}
// buildTry
function EM(Uu /*ast*/,Uv /*breakStat*/,Uw /*skipStat*/){
let Ux=null; // infoMe
let Uy=null; // info
let U6=false; // first
let U7=null; // items
let U9=null; // item
let UD=false; // first2
let UE=null; // items2
let UG=null; // exprs
(Ux)=((rW)((Uu)));
(Uy)=((rW)(((Uu).y4)));
if(!((Uy).rZ)){
((Uy).rZ)=(true);
(eP)((T),([130,134]),((Uu).y4));
}
if(((Uu).yD)!==(null)){
(eP)((P),([130,129,2]),({S:"try{\u000A"}));
}
(eP)((P),([130,129,2]),({S:"try{\u000A"}));
(ER)(((Uu).y9),(Uv),(Uw));
if(((Uu).yD)!==(null)){
(ER)(((Uu).yD),(Uv),(Uw));
}
(eP)((P),([130,129,2]),({S:({S:({S:"}catch(int64_t "}).S+((v)(((Uy).sP),([129,2]))).S}).S+({S:"){\u000A"}).S}));
(U6)=(true);
(U7)=((Uu).yA);
(qt)((U7),([130,134]));
while(!((qv)((U7),([130,134])))){
(U9)=((qx)((U7),([130,134])));
if(U6){
(U6)=(false);
(eP)((P),([130,129,2]),({S:"if("}));
}
else{
(eP)((P),([130,129,2]),({S:"else if("}));
}
(UD)=(true);
(UE)=((U9).yY);
(qt)((UE),([130,134]));
while(!((qv)((UE),([130,134])))){
(UG)=((qx)((UE),([130,134])));
if(UD){
(UD)=(false);
}
else{
(eP)((P),([130,129,2]),({S:" || "}));
}
if(((UG).zt)===(null)){
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((Uy).sP),([129,2]))).S}).S+({S:" == ("}).S}));
(Su)(((UG).zo));
(eP)((P),([130,129,2]),({S:")"}));
}
else{
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((UG).zo));
(eP)((P),([130,129,2]),({S:({S:({S:") <= "}).S+((v)(((Uy).sP),([129,2]))).S}).S+({S:({S:({S:" && "}).S+((v)(((Uy).sP),([129,2]))).S}).S+({S:" <= ("}).S}).S}));
(Su)(((UG).zt));
(eP)((P),([130,129,2]),({S:")"}));
}
(rA)((UE),([130,134]));
}
(eP)((P),([130,129,2]),({S:"){\u000A"}));
(ER)(((U9).zb),(Uv),(Uw));
(eP)((P),([130,129,2]),({S:"}\u000A"}));
(rA)((U7),([130,134]));
}
if(U6){
(eP)((P),([130,129,2]),({S:"{\u000A"}));
}
else{
(eP)((P),([130,129,2]),({S:"else{\u000A"}));
}
(eP)((P),([130,129,2]),({S:"throw;\u000A}\u000A"}));
(eP)((P),([130,129,2]),({S:"}\u000A"}));
if(((Uu).yD)!==(null)){
(eP)((P),([130,129,2]),({S:"}\u000Acatch(...){\u000A"}));
(ER)(((Uu).yD),(Uv),(Uw));
(eP)((P),([130,129,2]),({S:"throw;\u000A}\u000A"}));
}
if((((Ux).AB)!==(null))&&((Ux).AH)){
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((Ux).AB),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
}
// buildThrow
function EO(UU /*ast*/){
(eP)((P),([130,129,2]),({S:"throw "}));
(Su)(((UU).UV));
(eP)((P),([130,129,2]),({S:";\u000A"}));
}
// buildBlock
function ER(UW /*ast*/,UX /*breakStat*/,UY /*skipStat*/){
let UZ=null; // infoMe
(UZ)=((rW)((UW)));
(tq)(((UW).y8),(UX),(UY));
if((((UZ).AB)!==(null))&&((UZ).AH)){
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((UZ).AB),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
}
// buildRet
function ET(Vc /*ast*/){
if(((Vc).Ve)===(null)){
(eP)((P),([130,129,2]),({S:"return;\u000A"}));
}
else{
(eP)((P),([130,129,2]),({S:"return "}));
(Su)(((Vc).Ve));
(eP)((P),([130,129,2]),({S:";\u000A"}));
}
}
// buildDo
function EW(Vh /*ast*/){
(Su)(((Vh).yU));
(eP)((P),([130,129,2]),({S:";\u000A"}));
}
// buildBreak
function EY(Vi /*ast*/,Vj /*breakStat*/){
let Vn=null; // info
if(!(((rv)((((Vi).q1).qe),([9]),(66048)))===(66048))){throw 0xE9170000;}
if(((Vi).q1)===(Vj)){
(eP)((P),([130,129,2]),({S:"break;\u000A"}));
}
else{
(Vn)=((rW)(((Vi).q1)));
((Vn).AH)=(true);
(eP)((P),([130,129,2]),({S:({S:({S:"goto "}).S+((v)(((Vn).AB),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
}
// buildSkip
function Fa(Vo /*ast*/,Vp /*skipStat*/){
let Vt=null; // info
if(!(((rv)((((Vo).q1).qe),([9]),(16843264)))===(16843264))){throw 0xE9170000;}
if(((Vo).q1)===(Vp)){
(eP)((P),([130,129,2]),({S:"continue;\u000A"}));
}
else{
(Vt)=((rW)(((Vo).q1)));
((Vt).AI)=(true);
(eP)((P),([130,129,2]),({S:({S:({S:"goto "}).S+((v)(((Vt).AE),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
}
// buildAssert
function Fc(Vu /*ast*/){
(eP)((P),([130,129,2]),({S:"if(!("}));
(Su)(((Vu).Vv));
(eP)((P),([130,129,2]),({S:({S:({S:")){\u000Athrow "}).S+((v)((0xE9170000),([6]))).S}).S+({S:"U;\u000A}\u000A"}).S}));
}
// isNullable
function Fn(Vw /*type*/){
return (((rv)(((Vw).qe),([9]),(66560)))===(66560))&&(!((Fs)((Vw))));
}
// isEnum
function Fs(Vx /*type*/){
return (((Vx).qe)===(66565))&&((((Vx).q1).qe)===(6));
}
// getId
function Gi(){
let Vy=null; // curId
let Vz=null; // newId
let V2=0; // idx
let V6=0;
let VO=0;
let VR=null;
let VV=null;
let VZ=null;
let V8=0;
let V9=0;
let VB=0;
let VC=0;
let VH=0;
let VI=0;
let VL=0;
let VM=0;
(Vy)=(al);
(Vz)=(C_([129,2],(al)));
V1:
while(true){
(V2)=(((Vz).S.length)-(1));
V4:
while(true){
switch((Vz).S.charCodeAt(V2)){
case 0x007A:
(Vz).S=(V8=(V2),(Vz).S.slice(0,V8)+String.fromCharCode(((V2)===(0))?(0x0041):(0x0030))+(Vz).S.slice(V8+1));
break;
case 0x0039:
(Vz).S=(VB=(V2),(Vz).S.slice(0,VB)+String.fromCharCode(0x0041)+(Vz).S.slice(VB+1));
break;
case 0x005A:
if((V2)===(0)){
(Vz)=({S:"\0".repeat(((Vz).S.length)+(1))});
(RH)((Vz),([129,2]),(0x0061));
}
else{
(Vz).S=(VH=(V2),(Vz).S.slice(0,VH)+String.fromCharCode(0x0061)+(Vz).S.slice(VH+1));
(V2)=((V2)-(1));
continue V4;
}
break;
default:
(Vz).S=(VL=(V2),(Vz).S.slice(0,VL)+String.fromCharCode((RP)(((Vz).S.charCodeAt(V2)),(1)))+(Vz).S.slice(VL+1));
break;
}
break V4;
}
switch((Vz).S.length){
case 2:
VR=Vz;
if(VR.S===({S:"do"}).S||VR.S===({S:"if"}).S||VR.S===({S:"in"}).S){
continue V1;
}
break;
case 3:
VV=Vz;
if(VV.S===({S:"for"}).S||VV.S===({S:"let"}).S||VV.S===({S:"new"}).S||VV.S===({S:"try"}).S||VV.S===({S:"var"}).S||VV.S===({S:"Map"}).S||VV.S===({S:"NaN"}).S||VV.S===({S:"Set"}).S){
continue V1;
}
break;
case 4:
VZ=Vz;
if(VZ.S===({S:"case"}).S||VZ.S===({S:"else"}).S||VZ.S===({S:"enum"}).S||VZ.S===({S:"eval"}).S||VZ.S===({S:"name"}).S||VZ.S===({S:"null"}).S||VZ.S===({S:"this"}).S||VZ.S===({S:"true"}).S||VZ.S===({S:"void"}).S||VZ.S===({S:"with"}).S||VZ.S===({S:"Date"}).S||VZ.S===({S:"Intl"}).S||VZ.S===({S:"JSON"}).S||VZ.S===({S:"Math"}).S){
continue V1;
}
break;
}
break V1;
}
(al)=(Vz);
return Vy;
}
// search
function Ig(Wb /*members*/,Wc /*name*/){
let We=null; // def
(qt)((Wb),([130,134]));
while(!((qv)((Wb),([130,134])))){
(We)=(((qx)((Wb),([130,134]))).tU);
if(((((We).qe)===(2))&&((((We).tZ).qZ)!==(null)))&&((((We).tZ).qZ).S===(Wc).S)){
return (uK)(((We).tZ));
}
(rA)((Wb),([130,134]));
}
if(!(false)){throw 0xE9170000;}
return null;
}
// buildIf
function Jg(Wh /*ast*/){
let Wi=null; // infoMe
let Wt=null; // items
let Wv=null; // item
(Wi)=((uK)((Wh)));
if(((Wh).Sp)===(null)){
if(((Wi).Gl)!==(null)){
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Wi).Gl),([129,2]))).S}).S+({S:":{\u000A"}).S}));
}
(Js)(((Wh).Sr));
if(((Wi).Gl)!==(null)){
(eP)((am),([130,129,2]),({S:"}\u000A"}));
}
return;
}
if(((Wi).Gl)!==(null)){
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Wi).Gl),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eP)((am),([130,129,2]),({S:"if("}));
(Wr)(((Wh).Sp));
(eP)((am),([130,129,2]),({S:"){\u000A"}));
(Js)(((Wh).Sr));
(eP)((am),([130,129,2]),({S:"}\u000A"}));
(Wt)=((Wh).Sx);
(qt)((Wt),([130,134]));
while(!((qv)((Wt),([130,134])))){
(Wv)=((qx)((Wt),([130,134])));
(eP)((am),([130,129,2]),({S:"else if("}));
(Wr)(((Wv).S1));
(eP)((am),([130,129,2]),({S:"){\u000A"}));
(Js)(((Wv).S2));
(eP)((am),([130,129,2]),({S:"}\u000A"}));
(rA)((Wt),([130,134]));
}
if(((Wh).S4)!==(null)){
(eP)((am),([130,129,2]),({S:"else{\u000A"}));
(Js)(((Wh).S4));
(eP)((am),([130,129,2]),({S:"}\u000A"}));
}
}
// buildSwitch
function Ji(Wy /*ast*/){
let Wz=null; // infoMe
let W0=null; // info
let W3=false; // useSwitch
let W7=null; // items
let W9=null; // item
let WA=null; // items2
let WC=null; // exprs
let WK=null; // items
let WM=null; // item
let WN=null; // items2
let WP=null; // exprs
let WW=false; // first
let WX=null; // items
let WZ=null; // item
let Xd=false; // first2
let Xe=null; // items2
let Xg=null; // exprs
(Wz)=((uK)((Wy)));
(W0)=((uK)(((Wy).y4)));
if(!((W0).uN)){
((W0).uN)=(true);
(eP)((ap),([130,134]),((Wy).y4));
}
(W3)=(false);
W5:
if(((((s5)((((Wy).SI).zn)))||((SJ)((((Wy).SI).zn))))||((Fs)((((Wy).SI).zn))))||(((((Wy).SI).zn).qe)===(1025))){
(W3)=(true);
(W7)=((Wy).SM);
(qt)((W7),([130,134]));
while(!((qv)((W7),([130,134])))){
(W9)=((qx)((W7),([130,134])));
(WA)=((W9).SR);
(qt)((WA),([130,134]));
while(!((qv)((WA),([130,134])))){
(WC)=((qx)((WA),([130,134])));
if((((rv)((((WC).zo).qe),([9]),(67584)))!==(67584))||(((WC).zt)!==(null))){
(W3)=(false);
break W5;
}
(rA)((WA),([130,134]));
}
(rA)((W7),([130,134]));
}
}
if(W3){
if(((Wz).Gl)!==(null)){
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Wz).Gl),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eP)((am),([130,129,2]),({S:"switch("}));
(Wr)(((Wy).SI));
(eP)((am),([130,129,2]),({S:"){\u000A"}));
(WK)=((Wy).SM);
(qt)((WK),([130,134]));
while(!((qv)((WK),([130,134])))){
(WM)=((qx)((WK),([130,134])));
(WN)=((WM).SR);
(qt)((WN),([130,134]));
while(!((qv)((WN),([130,134])))){
(WP)=((qx)((WN),([130,134])));
if(!(((WP).zt)===(null))){throw 0xE9170000;}
(eP)((am),([130,129,2]),({S:"case "}));
(Wr)(((WP).zo));
(eP)((am),([130,129,2]),({S:":\u000A"}));
(rA)((WN),([130,134]));
}
(Js)(((WM).Tf));
(eP)((am),([130,129,2]),({S:"break;\u000A"}));
(rA)((WK),([130,134]));
}
if(((Wy).Th)!==(null)){
(eP)((am),([130,129,2]),({S:"default:\u000A"}));
(Js)(((Wy).Th));
(eP)((am),([130,129,2]),({S:"break;\u000A"}));
}
(eP)((am),([130,129,2]),({S:"}\u000A"}));
}
else{
if(((Wz).Gl)!==(null)){
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Wz).Gl),([129,2]))).S}).S+({S:":{\u000A"}).S}));
}
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((W0).vb),([129,2]))).S}).S+({S:"="}).S}));
(Wr)(((Wy).SI));
(eP)((am),([130,129,2]),({S:";\u000A"}));
(WW)=(true);
(WX)=((Wy).SM);
(qt)((WX),([130,134]));
while(!((qv)((WX),([130,134])))){
(WZ)=((qx)((WX),([130,134])));
if(WW){
(WW)=(false);
(eP)((am),([130,129,2]),({S:"if("}));
}
else{
(eP)((am),([130,129,2]),({S:"else if("}));
}
(Xd)=(true);
(Xe)=((WZ).SR);
(qt)((Xe),([130,134]));
while(!((qv)((Xe),([130,134])))){
(Xg)=((qx)((Xe),([130,134])));
if(Xd){
(Xd)=(false);
}
else{
(eP)((am),([130,129,2]),({S:"||"}));
}
if(((Xg).zt)===(null)){
if((Xn)((((Wy).SI).zn))){
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((W0).vb),([129,2]))).S}).S+({S:".S===("}).S}));
(Wr)(((Xg).zo));
(eP)((am),([130,129,2]),({S:").S"}));
}
else if((Av)((((Wy).SI).zn))){
(eP)((am),([130,129,2]),({S:({S:({S:"cmp_("}).S+((v)(((W0).vb),([129,2]))).S}).S+({S:",("}).S}));
(Wr)(((Xg).zo));
(eP)((am),([130,129,2]),({S:"))==0"}));
}
else{
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((W0).vb),([129,2]))).S}).S+({S:"===("}).S}));
(Wr)(((Xg).zo));
(eP)((am),([130,129,2]),({S:")"}));
}
}
else{
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((Xg).zo));
(eP)((am),([130,129,2]),({S:({S:({S:")<="}).S+((v)(((W0).vb),([129,2]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((W0).vb),([129,2]))).S}).S+({S:"<=("}).S}).S}));
(Wr)(((Xg).zt));
(eP)((am),([130,129,2]),({S:")"}));
}
(rA)((Xe),([130,134]));
}
(eP)((am),([130,129,2]),({S:"){\u000A"}));
(Js)(((WZ).Tf));
(eP)((am),([130,129,2]),({S:"}\u000A"}));
(rA)((WX),([130,134]));
}
if(((Wy).Th)!==(null)){
(eP)((am),([130,129,2]),({S:"else{"}));
(Js)(((Wy).Th));
(eP)((am),([130,129,2]),({S:"}\u000A"}));
}
if(((Wz).Gl)!==(null)){
(eP)((am),([130,129,2]),({S:"}\u000A"}));
}
}
}
// buildWhile
function Jk(Xw /*ast*/){
let Xx=null; // infoMe
(Xx)=((uK)((Xw)));
if(((Xw).TE)===(null)){
if(((Xx).Gl)!==(null)){
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Xx).Gl),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eP)((am),([130,129,2]),({S:"for(;;){\u000A"}));
(vx)(((Xw).TG));
(eP)((am),([130,129,2]),({S:"}\u000A"}));
return;
}
if((Xw).TM){
if(((Xx).Gl)!==(null)){
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Xx).Gl),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eP)((am),([130,129,2]),({S:"do{\u000A"}));
(vx)(((Xw).TG));
(eP)((am),([130,129,2]),({S:"}while("}));
(Wr)(((Xw).TE));
(eP)((am),([130,129,2]),({S:");\u000A"}));
return;
}
if(((Xx).Gl)!==(null)){
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Xx).Gl),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eP)((am),([130,129,2]),({S:"while("}));
(Wr)(((Xw).TE));
(eP)((am),([130,129,2]),({S:"){\u000A"}));
(vx)(((Xw).TG));
(eP)((am),([130,129,2]),({S:"}\u000A"}));
}
// buildFor
function Jm(X8 /*ast*/){
let X9=null; // infoMe
let XA=null; // info
let XD=null; // endId
let XH=0; // step
(X9)=((uK)((X8)));
(XA)=((uK)(((X8).y4)));
if(!((XA).uN)){
((XA).uN)=(true);
(eP)((ap),([130,134]),((X8).y4));
}
(XD)=((XE)((((X8).Uf).zn)));
if(((X9).Gl)!==(null)){
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((X9).Gl),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eP)((am),([130,129,2]),({S:({S:({S:"for("}).S+((v)(((XA).vb),([129,2]))).S}).S+({S:"=("}).S}));
(Wr)(((X8).Ug));
(eP)((am),([130,129,2]),({S:({S:({S:"),"}).S+((v)((XD),([129,2]))).S}).S+({S:"=("}).S}));
(Wr)(((X8).Uf));
(eP)((am),([130,129,2]),({S:({S:({S:");"}).S+((v)(((XA).vb),([129,2]))).S}).S+({S:""}).S}));
if(!(((((X8).Uh).qe)===(67585))&&((s5)((((X8).Uf).zn))))){throw 0xE9170000;}
(XH)=(((X8).Uh).zk);
if((XH)>(0)){
(eP)((am),([130,129,2]),({S:"<="}));
}
else{
(eP)((am),([130,129,2]),({S:">="}));
}
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)((XD),([129,2]))).S}).S+({S:({S:({S:";"}).S+((v)(((XA).vb),([129,2]))).S}).S+({S:""}).S}).S}));
if((XH)>(0)){
(eP)((am),([130,129,2]),({S:"+=("}));
}
else{
(eP)((am),([130,129,2]),({S:"-=("}));
}
(Wr)(((X8).Uh));
(eP)((am),([130,129,2]),({S:")){\u000A"}));
(vx)(((X8).Up));
(eP)((am),([130,129,2]),({S:"}\u000A"}));
}
// buildTry
function Jo(XO /*ast*/){
let XP=null; // infoMe
let XQ=null; // info
let XW=false; // first
let XX=null; // items
let XZ=null; // item
let Yd=false; // first2
let Ye=null; // items2
let Yg=null; // exprs
(XP)=((uK)((XO)));
(XQ)=((uK)(((XO).y4)));
if(!((XQ).uN)){
((XQ).uN)=(true);
(eP)((ap),([130,134]),((XO).y4));
}
if(((XP).Gl)!==(null)){
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((XP).Gl),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eP)((am),([130,129,2]),({S:"try{\u000A"}));
(Js)(((XO).y9));
(eP)((am),([130,129,2]),({S:({S:({S:"}catch("}).S+((v)(((XQ).vb),([129,2]))).S}).S+({S:"){\u000A"}).S}));
(XW)=(true);
(XX)=((XO).yA);
(qt)((XX),([130,134]));
while(!((qv)((XX),([130,134])))){
(XZ)=((qx)((XX),([130,134])));
if(XW){
(XW)=(false);
(eP)((am),([130,129,2]),({S:"if("}));
}
else{
(eP)((am),([130,129,2]),({S:"else if("}));
}
(Yd)=(true);
(Ye)=((XZ).yY);
(qt)((Ye),([130,134]));
while(!((qv)((Ye),([130,134])))){
(Yg)=((qx)((Ye),([130,134])));
if(Yd){
(Yd)=(false);
}
else{
(eP)((am),([130,129,2]),({S:"||"}));
}
if(((Yg).zt)===(null)){
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((XQ).vb),([129,2]))).S}).S+({S:"===("}).S}));
(Wr)(((Yg).zo));
(eP)((am),([130,129,2]),({S:")"}));
}
else{
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((Yg).zo));
(eP)((am),([130,129,2]),({S:({S:({S:")<="}).S+((v)(((XQ).vb),([129,2]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((XQ).vb),([129,2]))).S}).S+({S:"<=("}).S}).S}));
(Wr)(((Yg).zt));
(eP)((am),([130,129,2]),({S:")"}));
}
(rA)((Ye),([130,134]));
}
(eP)((am),([130,129,2]),({S:"){\u000A"}));
(Js)(((XZ).zb));
(eP)((am),([130,129,2]),({S:"}\u000A"}));
(rA)((XX),([130,134]));
}
if(XW){
(eP)((am),([130,129,2]),({S:"{\u000A"}));
}
else{
(eP)((am),([130,129,2]),({S:"else{\u000A"}));
}
(eP)((am),([130,129,2]),({S:({S:({S:"throw "}).S+((v)(((XQ).vb),([129,2]))).S}).S+({S:";\u000A}\u000A"}).S}));
(eP)((am),([130,129,2]),({S:"}\u000A"}));
if(((XO).yD)!==(null)){
(eP)((am),([130,129,2]),({S:"finally{\u000A"}));
(Js)(((XO).yD));
(eP)((am),([130,129,2]),({S:"}\u000A"}));
}
}
// buildThrow
function Jq(Ys /*ast*/){
(eP)((am),([130,129,2]),({S:"throw "}));
(Wr)(((Ys).UV));
(eP)((am),([130,129,2]),({S:";\u000A"}));
}
// buildBlock
function Js(Yt /*ast*/){
let Yu=null; // infoMe
(Yu)=((uK)((Yt)));
if(((Yu).Gl)!==(null)){
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Yu).Gl),([129,2]))).S}).S+({S:":{\u000A"}).S}));
}
(vx)(((Yt).y8));
if(((Yu).Gl)!==(null)){
(eP)((am),([130,129,2]),({S:"}\u000A"}));
}
}
// buildRet
function Ju(Yz /*ast*/){
if(((Yz).Ve)===(null)){
(eP)((am),([130,129,2]),({S:"return;\u000A"}));
}
else{
(eP)((am),([130,129,2]),({S:"return "}));
(Wr)(((Yz).Ve));
(eP)((am),([130,129,2]),({S:";\u000A"}));
}
}
// buildDo
function Jw(Y3 /*ast*/){
(Wr)(((Y3).yU));
(eP)((am),([130,129,2]),({S:";\u000A"}));
}
// buildBreak
function Jy(Y4 /*ast*/){
let Y5=null; // info
if(!(((rv)((((Y4).q1).qe),([9]),(66048)))===(66048))){throw 0xE9170000;}
(Y5)=((uK)(((Y4).q1)));
(eP)((am),([130,129,2]),({S:({S:({S:"break "}).S+((v)(((Y5).Gl),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
// buildSkip
function J0(Y6 /*ast*/){
let Y7=null; // info
if(!(((rv)((((Y6).q1).qe),([9]),(16843264)))===(16843264))){throw 0xE9170000;}
(Y7)=((uK)(((Y6).q1)));
(eP)((am),([130,129,2]),({S:({S:({S:"continue "}).S+((v)(((Y7).Gl),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
// buildAssert
function J2(Y8 /*ast*/){
(eP)((am),([130,129,2]),({S:"if(!("}));
(Wr)(((Y8).Vv));
(eP)((am),([130,129,2]),({S:({S:({S:")){throw "}).S+((v)((0xE9170000),([6]))).S}).S+({S:";}\u000A"}).S}));
}
// initAstImpl
function Kj(Y9 /*ast*/,YA /*typeId*/,YB /*pos*/,YC /*name*/,YD /*setParent*/){
((Y9).qe)=(YA);
((Y9).qn)=(YB);
((Y9).qZ)=(YC);
((Y9).qW)=(null);
((Y9).qa)=(null);
((Y9).q2)=(null);
((Y9).q1)=(null);
((Y9).zJ)=(null);
((Y9).r7)=(false);
if(((Y9).qZ)!==(null)){
(Mf)((Y9),(true));
}
if(YD){
((Y9).qW)=((YI)((ah),([131,134])));
}
}
// readBuf
function K1(){
let YO=0; // c
if((pJ)===(0x0000)){
if((pK)===(0x0000)){
do{
(YO)=(((wx)((af)))?(0x0000):((YP)((af))));
}while((YO)===(0x000D));
if((YO)===(0x000A)){
(pH)=((pH)+(1));
(pI)=(0);
}
else if((YO)===(0x0000)){
if(!(pL)){
(pL)=(true);
(YO)=(0x000A);
(pH)=((pH)+(1));
(pI)=(0);
}
}
else{
(pI)=((pI)+(1));
}
}
else{
(YO)=(pK);
(pK)=(0x0000);
}
}
else{
(YO)=(pJ);
(pJ)=(0x0000);
}
return YO;
}
// makePos
function KC(){
return (xk)((ag),(pH),(pI));
}
// charToStr
function KD(Zb /*c*/){
let Zd=0;
switch(Zb){
case 0x0000:
return {S:" "};
break;
case 0x000D:
if(!(false)){throw 0xE9170000;}
break;
case 0x000A:
return {S:"(RETURN)"};
break;
case 0x0009:
case 0x0020:
return {S:"(SPACE)"};
break;
}
return (v)((Zb),([2]));
}
// addSrc
function KX(Zi /*name*/){
let Zm=false;
let Zk=null;
let Zl=false;
if(((Zk=(pT)((ae),([133,129,2,134]),(Zi),(Zl={$:(Zm)},Zl)),(Zm)=Zl.$,Zk))===(null)){
(bE)((ae),([133,129,2,134]),(Zi),(null));
}
}
// readFuncAttr
function Ls(){
let Zo=0; // c
let Zr=null; // buf
let Zs=0; // pos
let Zw=0;
let Zx=0;
(Zo)=((xm)());
if(!(((((((0x0061)<=(Zo))&&((Zo)<=(0x007A)))||(((0x0041)<=(Zo))&&((Zo)<=(0x005A))))||(((0x0030)<=(Zo))&&((Zo)<=(0x0039))))||((Zo)===(0x005F)))||((Zo)===(0x002E)))){
(D)((65548),((KC)()),([((KD)((Zo)))]));
return {S:""};
}
(Zr)=({S:"\0".repeat(128)});
(Zs)=(0);
do{
if((Zs)===(128)){
(D)((65549),((KC)()),([(Zr)]));
return {S:""};
}
(Zr).S=(Zw=(Zs),(Zr).S.slice(0,Zw)+String.fromCharCode(Zo)+(Zr).S.slice(Zw+1));
(Zs)=((Zs)+(1));
(Zo)=((xO)());
}while(((((((0x0061)<=(Zo))&&((Zo)<=(0x007A)))||(((0x0041)<=(Zo))&&((Zo)<=(0x005A))))||(((0x0030)<=(Zo))&&((Zo)<=(0x0039))))||((Zo)===(0x005F)))||((Zo)===(0x002E)));
(pJ)=(Zo);
return (pB)((Zr),([129,2]),(0),(Zs));
}
// _or
function L0(Zz /*me_*/,Z0 /*type*/,Z1 /*n*/){
return Zz|Z1;
}
// nextCharErr
function LW(Z2 /*c*/,Z3 /*c2*/){
(D)((65550),((KC)()),([((KD)((Z2))),((KD)((Z3)))]));
(xN)((Z3));
}
// addScopeRefeds
function Ma(Z4 /*ast*/,Z5 /*name*/){
let Z6=null; // scopeRefedItem
((Z4).q2)=(Z5);
(Z6)=(new qy());
((Z6).q0)=(Z4);
((Z6).qR)=((YI)((ah),([131,134])));
(eP)((ai),([130,134]),(Z6));
}
// assertNextChar
function Mb(Z7 /*c*/,Z8 /*skipSpaces*/){
let Z9=0; // c2
(Z9)=((Z8)?((xm)()):((xO)()));
if((Z7)!==(Z9)){
(LW)((Z7),(Z9));
(pJ)=(Z9);
}
}
// addScopeName
function Mf(ZC /*ast*/,ZD /*refuseReserved*/){
let ZH=null; // scope
let ZL=false;
let ZN=null; // parent
let ZO=false; // overFunc
let ZV=null; // child
let ZY=false;
let aab=false; // flag
let aag=0; // kind
let ZJ=null;
let ZK=false;
let ZW=null;
let ZX=false;
if(!(((ZC).qZ)!==(null))){throw 0xE9170000;}
if((ZD)&&((ZF)(((ZC).qZ)))){
(D)((65537),((KC)()),([((ZC).qZ)]));
return;
}
(ZH)=((YI)((ah),([131,134])));
if(((ZJ=(pT)(((ZH).qa),([133,129,2,134]),((ZC).qZ),(ZK={$:(ZL)},ZK)),(ZL)=ZK.$,ZJ))!==(null)){
(D)((65537),((KC)()),([((ZC).qZ)]));
}
(ZN)=(ZH);
(ZO)=(false);
ZQ:
while(true){
if(((ZN).qW)===(null)){
break ZQ;
}
if(((((ZN).qZ)!==(null))&&(((ZN).qZ).S===((ZC).qZ).S))&&(!((((ZN).qe)===(256))&&(((ZN).q2)!==(null))))){
(D)((65538),((KC)()),([((ZC).qZ)]));
return;
}
(ZV)=((ZW=(pT)(((ZN).qa),([133,129,2,134]),((ZC).qZ),(ZX={$:(ZY)},ZX)),(ZY)=ZX.$,ZW));
if((ZV)!==(null)){
(aab)=(false);
if(ZO){
if(((ZV).qe)===(7)){
(aag)=((ZV).rr);
if((((aag)===(5))||((aag)===(3)))||((aag)===(2))){
(aab)=(true);
}
}
if((!(aab))&&(((rv)(((ZV).qe),([9]),(66048)))===(66048))){
(aab)=(true);
}
}
if(((!(aab))&&(((ZV).qe)===(256)))&&(((ZV).q2)!==(null))){
(aab)=(true);
}
if(!(aab)){
(D)((65538),((KC)()),([((ZC).qZ)]));
return;
}
}
if(((ZN).qe)===(256)){
(ZO)=(true);
}
(ZN)=((ZN).qW);
}
(bE)(((ZH).qa),([133,129,2,134]),((ZC).qZ),(ZC));
}
// parseArg
function Mp(aar /*kind*/,aas /*parentClass*/){
let aat=null; // ast
let aax=0; // c
let aa5=0; // c
let aa9=0;
(aat)=(new rq());
(xj)((aat),(7),((KC)()),((x2)((true),(false))),(false));
((aat).rr)=(aar);
((aat).sL)=(false);
if((aas)!==(null)){
(Ma)((aat),(aas));
}
(Mb)((0x003A),(true));
(aax)=((xm)());
if((aax)===(0x0026)){
if((aar)!==(2)){
(D)((65556),((KC)()),(null));
}
else{
((aat).sL)=(true);
}
}
else{
(pJ)=(aax);
}
((aat).s6)=((M0)());
(aa5)=((xm)());
if((aa5)===(0x003A)){
(Mb)((0x003A),(false));
if(!((aar)!==(0))){throw 0xE9170000;}
switch(aar){
case 2:
(D)((65557),((KC)()),(null));
((aat).y3)=(null);
break;
case 5:
(D)((65558),((KC)()),(null));
((aat).y3)=(null);
break;
default:
((aat).y3)=((NR)());
break;
}
}
else{
if((aar)===(4)){
(D)((65559),((KC)()),(null));
}
((aat).y3)=(null);
(pJ)=(aa5);
}
return aat;
}
// parseType
function M0(){
let aaG=null; // pos
let aaH=null; // ast
let aaI=0; // c
let aaL=null; // ast2
let aaN=null; // id
let aaQ=null; // size
let aaT=null; // ast2
let aaW=false;
let aba=null;
let abc=null; // ast2
let abj=null; // arg
let aby=null; // ast2
let ab0=null; // ast2
let ab2=null; // ast2
let ab4=null; // ast2
let ab6=null; // ast2
let ab8=null; // ast2
let abA=null; // ast2
let abC=null; // ast2
let abE=null; // ast2
let aaU=0;
let aaV=false;
(aaG)=((KC)());
(aaH)=(null);
(aaI)=((xm)());
if((aaI)===(0x005B)){
(Mb)((0x005D),(true));
(aaL)=(new AP());
(xj)((aaL),(66561),(aaG),(null),(false));
((aaL).AR)=((M0)());
(aaH)=(aaL);
}
else{
(pJ)=(aaI);
(aaN)=((x2)((true),(true)));
if((((((aaN).S.length)>=(4))&&(((aaN).S.charCodeAt(0))===(0x0062)))&&(((aaN).S.charCodeAt(1))===(0x0069)))&&(((aaN).S.charCodeAt(2))===(0x0074))){
(aaQ)=((pB)((aaN),([129,2]),(3),(((aaN).S.length)-(3))));
if(((((aaQ).S===({S:"8"}).S)||((aaQ).S===({S:"16"}).S))||((aaQ).S===({S:"32"}).S))||((aaQ).S===({S:"64"}).S)){
(aaT)=(new AT());
(xj)((aaT),(1025),(aaG),(null),(false));
((aaT).AU)=(~~(((aaU=(ca)((aaQ),(aaV={$:(aaW)},aaV)),(aaW)=aaV.$,aaU))/(8)));
(aaH)=(aaT);
}
}
if((aaH)===(null)){
aba=aaN;
if(aba.S===({S:"func"}).S){
(Mb)((0x003C),(true));
(Mb)((0x0028),(true));
(abc)=(new AX());
(xj)((abc),(66562),(aaG),(null),(false));
((abc).abd)=(0);
((abc).abe)=({L:0,H:null,T:null,P:null});
((abc).Be)=({L:0,H:null,T:null,P:null});
((abc).AZ)=(null);
(aaI)=((xm)());
if((aaI)!==(0x0029)){
(pJ)=(aaI);
abi:
while(true){
(abj)=(new Bh());
(aaI)=((xm)());
if((aaI)===(0x0000)){
break abi;
}
if((aaI)===(0x0026)){
((abj).Bp)=(true);
}
else{
((abj).Bp)=(false);
(pJ)=(aaI);
}
((abj).Bn)=((M0)());
(eP)(((abc).Be),([130,134]),(abj));
(aaI)=((xm)());
if((aaI)===(0x0029)){
break abi;
}
if((aaI)!==(0x002C)){
(LW)((0x002C),(aaI));
break abi;
}
}
}
(aaI)=((xm)());
if((aaI)===(0x003A)){
((abc).AZ)=((M0)());
(aaI)=((xm)());
}
if((aaI)!==(0x003E)){
(LW)((0x003E),(aaI));
}
(aaH)=(abc);
}
else if(aba.S===({S:"list"}).S){
(Mb)((0x003C),(true));
(aby)=(new Bu());
(xj)((aby),(66563),(aaG),(null),(false));
((aby).Bx)=(0);
((aby).Bz)=((M0)());
(Mb)((0x003E),(true));
(aaH)=(aby);
}
else if(aba.S===({S:"stack"}).S){
(Mb)((0x003C),(true));
(ab0)=(new Bu());
(xj)((ab0),(66563),(aaG),(null),(false));
((ab0).Bx)=(1);
((ab0).Bz)=((M0)());
(Mb)((0x003E),(true));
(aaH)=(ab0);
}
else if(aba.S===({S:"queue"}).S){
(Mb)((0x003C),(true));
(ab2)=(new Bu());
(xj)((ab2),(66563),(aaG),(null),(false));
((ab2).Bx)=(2);
((ab2).Bz)=((M0)());
(Mb)((0x003E),(true));
(aaH)=(ab2);
}
else if(aba.S===({S:"dict"}).S){
(Mb)((0x003C),(true));
(ab4)=(new B5());
(xj)((ab4),(66564),(aaG),(null),(false));
((ab4).B6)=((M0)());
(Mb)((0x002C),(true));
((ab4).B7)=((M0)());
(Mb)((0x003E),(true));
(aaH)=(ab4);
}
else if(aba.S===({S:"int"}).S){
(ab6)=(new y1());
(xj)((ab6),(1026),(aaG),(null),(false));
((ab6).y2)=(0);
(aaH)=(ab6);
}
else if(aba.S===({S:"float"}).S){
(ab8)=(new y1());
(xj)((ab8),(1026),(aaG),(null),(false));
((ab8).y2)=(1);
(aaH)=(ab8);
}
else if(aba.S===({S:"char"}).S){
(abA)=(new y1());
(xj)((abA),(1026),(aaG),(null),(false));
((abA).y2)=(2);
(aaH)=(abA);
}
else if(aba.S===({S:"bool"}).S){
(abC)=(new y1());
(xj)((abC),(1026),(aaG),(null),(false));
((abC).y2)=(3);
(aaH)=(abC);
}
else{(abE)=(new Mi());
(xj)((abE),(66565),(aaG),(null),(false));
(Ma)((abE),(aaN));
(aaH)=(abE);
}
}
}
return aaH;
}
// parseStat
function M6(abF /*block_*/){
let abI=0; // c
let abL=0; // row
let abM=0; // col
let abN=null; // id
let abP=null;
let abR=null; // ast
do{
(abI)=((xm)());
if((abI)===(0x0000)){
(D)((65560),((KC)()),(null));
return null;
}
}while((abI)===(0x000A));
(pJ)=(abI);
(abL)=(pH);
(abM)=(pI);
(abN)=((x2)((true),(false)));
abP=abN;
if(abP.S===({S:"end"}).S){
(abR)=((abS)((abL),(abM),(abF)));
}
else if(abP.S===({S:"func"}).S){
(abR)=((abU)());
}
else if(abP.S===({S:"var"}).S){
(abR)=((abW)());
}
else if(abP.S===({S:"const"}).S){
(abR)=((abY)());
}
else if(abP.S===({S:"alias"}).S){
(abR)=((aca)());
}
else if(abP.S===({S:"class"}).S){
(abR)=((acc)());
}
else if(abP.S===({S:"enum"}).S){
(abR)=((ace)());
}
else if(abP.S===({S:"if"}).S){
(abR)=((acg)());
}
else if(abP.S===({S:"elif"}).S){
(abR)=((aci)((abL),(abM),(abF)));
}
else if(abP.S===({S:"else"}).S){
(abR)=((ack)((abL),(abM),(abF)));
}
else if(abP.S===({S:"switch"}).S){
(abR)=((acm)((abL),(abM)));
}
else if(abP.S===({S:"case"}).S){
(abR)=((aco)((abL),(abM),(abF)));
}
else if(abP.S===({S:"default"}).S){
(abR)=((acq)((abL),(abM),(abF)));
}
else if(abP.S===({S:"while"}).S){
(abR)=((acs)());
}
else if(abP.S===({S:"for"}).S){
(abR)=((acu)((abL),(abM)));
}
else if(abP.S===({S:"try"}).S){
(abR)=((acw)((abL),(abM)));
}
else if(abP.S===({S:"catch"}).S){
(abR)=((acy)((abL),(abM),(abF)));
}
else if(abP.S===({S:"finally"}).S){
(abR)=((ac0)((abL),(abM),(abF)));
}
else if(abP.S===({S:"throw"}).S){
(abR)=((ac2)());
}
else if(abP.S===({S:"block"}).S){
(abR)=((ac4)());
}
else if(abP.S===({S:"ret"}).S){
(abR)=((ac6)());
}
else if(abP.S===({S:"do"}).S){
(abR)=((ac8)());
}
else if(abP.S===({S:"break"}).S){
(abR)=((acA)());
}
else if(abP.S===({S:"skip"}).S){
(abR)=((acC)());
}
else if(abP.S===({S:"assert"}).S){
(abR)=((acE)());
}
else{(D)((65547),((xk)((ag),(abL),(abM))),([(abN)]));
(xN)(((xO)()));
return null;
}
if((abR)===(null)){
return null;
}
((abR).qn)=((xk)((ag),(abL),(abM)));
return abR;
}
// parseExpr
function NR(){
let acI=null; // ast
let acK=0; // row
let acL=0; // col
let acM=0; // c
let acP=null; // ast2
let acQ=0; // c2
let acS=0;
(acI)=((acJ)());
(acK)=(pH);
(acL)=(pI);
(acM)=((xm)());
if((acM)===(0x003A)){
(acP)=(new An());
(NW)((acP),(2050),((xk)((ag),(acK),(acL))));
(acQ)=((xO)());
switch(acQ){
case 0x003A:
((acP).Ao)=(0);
break;
case 0x002B:
((acP).Ao)=(1);
break;
case 0x002D:
((acP).Ao)=(2);
break;
case 0x002A:
((acP).Ao)=(3);
break;
case 0x002F:
((acP).Ao)=(4);
break;
case 0x0025:
((acP).Ao)=(5);
break;
case 0x005E:
((acP).Ao)=(6);
break;
case 0x007E:
((acP).Ao)=(7);
break;
case 0x0024:
((acP).Ao)=(25);
break;
default:
(D)((65569),((acP).qn),([((KD)((acQ)))]));
(xN)((acQ));
return null;
break;
}
((acP).Ar)=(acI);
((acP).As)=((NR)());
(acI)=(acP);
}
else{
(pJ)=(acM);
}
return acI;
}
// initAstExpr
function NW(ade /*ast*/,adf /*typeId*/,adg /*pos*/){
if(!((ade)instanceof yO)){throw 0xE9170000;}
(Kj)((ade),(adf),(adg),(null),(false));
((ade).zn)=(null);
((ade).zj)=(0);
}
// readComment
function Of(){
let adh=0; // row
let adi=0; // col
let adk=0; // c
let adp=false; // esc
let ad4=false; // esc
(adh)=(pH);
(adi)=(pI);
do{
(adk)=((xO)());
if((adk)===(0x0000)){
(D)((65539),((xk)((ag),(adh),(adi))),(null));
return;
}
if((adk)===(0x0022)){
(adp)=(false);
adr:
while(true){
(adk)=((ads)());
if((adk)===(0x0000)){
(D)((65539),((xk)((ag),(adh),(adi))),(null));
return;
}
if(adp){
if((adk)===(0x007B)){
(Of)();
}
(adp)=(false);
continue adr;
}
if((adk)===(0x0022)){
break adr;
}
if((adk)===(0x005C)){
(adp)=(true);
}
}
}
else if((adk)===(0x0027)){
(ad4)=(false);
ad6:
while(true){
(adk)=((ads)());
if((adk)===(0x0000)){
(D)((65539),((xk)((ag),(adh),(adi))),(null));
return;
}
if(ad4){
(ad4)=(false);
continue ad6;
}
if((adk)===(0x0027)){
break ad6;
}
if((adk)===(0x005C)){
(ad4)=(true);
}
}
}
else if((adk)===(0x003B)){
adH:
while(true){
(adk)=((K1)());
if((adk)===(0x0000)){
(D)((65539),((xk)((ag),(adh),(adi))),(null));
return;
}
if((adk)===(0x000A)){
break adH;
}
}
}
}while((adk)!==(0x007D));
}
// initAstImpl
function Om(adM /*ast*/,adN /*typeId*/,adO /*pos*/){
((adM).qe)=(adN);
((adM).qn)=(adO);
((adM).qZ)=(null);
((adM).qW)=(null);
((adM).qa)=(null);
((adM).q2)=(null);
((adM).q1)=(null);
((adM).zJ)=(null);
((adM).r7)=(false);
}
// rebuildExprRef
function O5(adP /*ast*/){
let adS=null; // refItem
let adW=0;
let adY=null; // func_
let aea=null; // type
let aec=null; // items
let aee=null; // arg
let aef=null; // arg2
let aeh=null; // arg
let aej=0;
if(((adP).zJ)!==(null)){
return (adP).zJ;
}
((adP).zJ)=(adP);
if(!(((adP).qe)===(2062))){throw 0xE9170000;}
(adS)=((adP).q1);
if((adS)===(null)){
return null;
}
switch((adS).qe){
case 256:
(adY)=((adP).q1);
(rF)((adY));
(aea)=(new AX());
(yr)((aea),(66562),((adP).qn));
((aea).abd)=((adY).qk);
((aea).abe)=((adY).ql);
((aea).Be)=({L:0,H:null,T:null,P:null});
(aec)=((adY).qi);
(qt)((aec),([130,134]));
while(!((qv)((aec),([130,134])))){
(aee)=((qx)((aec),([130,134])));
(aef)=(new Bh());
((aef).Bp)=((aee).sL);
((aef).Bn)=((aee).s6);
(eP)(((aea).Be),([130,134]),(aef));
(rA)((aec),([130,134]));
}
((aea).AZ)=((adY).qj);
((adP).zn)=(aea);
((adP).zj)=(1);
break;
case 7:
(aeh)=((adP).q1);
(zN)((aeh));
switch((aeh).rr){
case 1:
((adP).zn)=((aeh).s6);
((adP).zj)=(3);
break;
case 2:
((adP).zn)=((aeh).s6);
((adP).zj)=(((aeh).sL)?(4):(2));
break;
case 3:
((adP).zn)=((aeh).s6);
((adP).zj)=(2);
break;
case 4:
if(((aeh).y3)===(null)){
return null;
}
if(!(((rv)((((aeh).y3).qe),([9]),(67584)))===(67584))){throw 0xE9170000;}
((adP).zJ)=((aeh).y3);
return (adP).zJ;
break;
case 5:
(D)((131075),((adP).qn),([((adP).q2)]));
return null;
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
break;
case 66050:
case 16843266:
case 66051:
if(!(((adS).zJ)!==(null))){throw 0xE9170000;}
((adP).q1)=((adS).y4);
((adP).zn)=(((adS).y4).s6);
((adP).zj)=(2);
break;
default:
if(((((rv)(((adS).qe),([9]),(2048)))===(2048))&&(((adS).zJ)!==(null)))&&((Fs)((((adS).zJ).zn)))){
((adP).zJ)=((adS).zJ);
return (adP).zJ;
}
(D)((131136),((adP).qn),([((adP).q2)]));
return null;
break;
}
return adP;
}
// cmpType
function OL(aew /*type1*/,aex /*type2*/,aey /*strict*/){
let ae1=0; // typeId1
let ae2=0; // typeId2
let ae4=false; // nullable1
let ae5=false; // nullable2
let aeE=null; // func1
let aeF=null; // func2
let aeG=null; // args1
let aeH=null; // args2
let aeJ=null; // arg1
let aeK=null; // arg2
let aeZ=null; // dict1
let afa=null; // dict2
let afk=null; // class1
let afl=null; // class2
let afm=null; // ptr
if(((aew)===(null))||((aex)===(null))){
return false;
}
(ae1)=((aew).qe);
(ae2)=((aex).qe);
(ae4)=((((ae1)===(66565))&&((((aew).q1).qe)===(6)))?(false):(((rv)((ae1),([9]),(66560)))===(66560)));
(ae5)=((((ae2)===(66565))&&((((aex).q1).qe)===(6)))?(false):(((rv)((ae2),([9]),(66560)))===(66560)));
if((((ae4)&&((ae2)===(1027)))||(((ae1)===(1027))&&(ae5)))||(((ae1)===(1027))&&((ae2)===(1027)))){
return true;
}
if(((ae1)===(66561))&&((ae2)===(66561))){
return (OL)(((aew).AR),((aex).AR),(true));
}
if(((ae1)===(1025))&&((ae2)===(1025))){
return ((aew).AU)===((aex).AU);
}
if(((ae1)===(66562))&&((ae2)===(66562))){
(aeE)=(aew);
(aeF)=(aex);
(aeG)=((aeE).Be);
(aeH)=((aeF).Be);
(qt)((aeG),([130,134]));
(qt)((aeH),([130,134]));
while((!((qv)((aeG),([130,134]))))&&(!((qv)((aeH),([130,134]))))){
(aeJ)=((qx)((aeG),([130,134])));
(aeK)=((qx)((aeH),([130,134])));
if((((aeJ).Bp)!==((aeK).Bp))||(!((OL)(((aeJ).Bn),((aeK).Bn),(true))))){
return false;
}
(rA)((aeG),([130,134]));
(rA)((aeH),([130,134]));
}
if(!(((qv)((aeG),([130,134])))&&((qv)((aeH),([130,134]))))){
return false;
}
if((((aeE).AZ)===(null))&&(((aeF).AZ)===(null))){
return true;
}
if((((aeE).AZ)===(null))||(((aeF).AZ)===(null))){
return false;
}
return (OL)(((aeE).AZ),((aeF).AZ),(true));
}
if(((ae1)===(66563))&&((ae2)===(66563))){
if(((aew).Bx)!==((aex).Bx)){
return false;
}
return (OL)(((aew).Bz),((aex).Bz),(true));
}
if(((ae1)===(66564))&&((ae2)===(66564))){
(aeZ)=(aew);
(afa)=(aex);
return ((OL)(((aeZ).B6),((afa).B6),(true)))&&((OL)(((aeZ).B7),((afa).B7),(true)));
}
if(((ae1)===(1026))&&((ae2)===(1026))){
return ((aew).y2)===((aex).y2);
}
if(((ae1)===(66565))&&((ae2)===(66565))){
if(!(((((aew).q1).qe)!==(4))&&((((aex).q1).qe)!==(4)))){throw 0xE9170000;}
if(((((aew).q1).qe)===(5))&&((((aex).q1).qe)===(5))){
if(aey){
return ((aew).q1)===((aex).q1);
}
else{
(afk)=((aew).q1);
(afl)=((aex).q1);
(afm)=(afk);
while((afm)!==(null)){
if((afm)===(afl)){
return true;
}
(afm)=((afm).q1);
}
return false;
}
}
return ((aew).q1)===((aex).q1);
}
if((((((ae1)===(66565))&&((((aew).q1).qe)===(6)))||((ae1)===(1028)))&&((((ae2)===(66565))&&((((aex).q1).qe)===(6)))||((ae2)===(1028))))&&(!(((ae1)===(1028))&&((ae2)===(1028))))){
return true;
}
return false;
}
// rebuildEnumElement
function OO(afs /*enumElement*/,aft /*type*/){
let afu=null; // enumElement2
if(!(((afs).qe)===(67587))){throw 0xE9170000;}
if(!((Fs)((aft)))){throw 0xE9170000;}
(afu)=(new zh());
(yP)((afu),(67585),((afs).qn));
((afu).zk)=((afv)((afs),((aft).q1)));
((afu).zn)=(aft);
(afu)=((Qi)((afu)));
return afu;
}
// rebuildClass
function Pd(afw /*ast*/){
let afz=null; // dtor
let af0=null; // copy
let af1=null; // toBin
let af2=null; // fromBin
let af4=null;
let af5=null;
let af6=null;
let af7=null;
if(((afw).zJ)!==(null)){
return;
}
((afw).zJ)=(afw);
(afz)=(null);
(af0)=(null);
(af1)=(null);
(af2)=(null);
((af3)((afw),(af4={$:(afz)},af4),(af5={$:(af0)},af5),(af6={$:(af1)},af6),(af7={$:(af2)},af7)),(afz)=af4.$,(af0)=af5.$,(af1)=af6.$,(af2)=af7.$);
(af8)((afw),(afz),(af0),(af1),(af2));
(rF)((afz));
(rF)((af0));
(rF)((af1));
(rF)((af2));
}
// rebuildEnum
function Pf(af9 /*ast*/){
let afC=null; // type
let afD=0; // defaultNum
let afE=null; // enumValues
let afF=null; // items
let afI=null; // item
let afJ=null; // itemName
let afO=null; // item2
let afW=0; // value
let aga=false;
let afY=false;
let afZ=false;
if(((af9).zJ)!==(null)){
return;
}
((af9).zJ)=(af9);
(afC)=(new Mi());
(yr)((afC),(66565),((af9).qn));
((afC).zJ)=(afC);
((afC).q1)=(af9);
(afD)=(-1);
(afE)=(new Map());
(afF)=((af9).NA);
(qt)((afF),([130,134]));
afH:
while(!((qv)((afF),([130,134])))){
(afI)=((qx)((afF),([130,134])));
(afJ)=((afI).qZ);
(afI)=((Aj)((afI),(((afI).zn)===(null))));
if((afI)===(null)){
continue afH;
}
((afI).qZ)=(afJ);
(ty)((afF),([130,134]),(afI));
(t1)((afF),([130,134]));
if((((afI).qe)!==(67585))||((((afI).zn)!==(null))&&(!((s5)(((afI).zn)))))){
(D)((131087),((af9).qn),([((af9).qZ),((afI).qZ)]));
return;
}
(afO)=(afI);
if(((afI).zn)===(null)){
if((afD)===(9223372036854775807)){
(D)((131088),((af9).qn),([((af9).qZ),((afI).qZ)]));
return;
}
(afD)=((afD)+(1));
((afO).zk)=(afD);
}
else{
(afD)=((afO).zk);
}
(afW)=((afO).zk);
if((afY=(pT)((afE),([133,0,3]),(afW),(afZ={$:(aga)},afZ)),(aga)=afZ.$,afY)){
(D)((131089),((af9).qn),([((af9).qZ),((afI).qZ),((v)((afW),([0])))]));
return;
}
(bE)((afE),([133,0,3]),(afW),(true));
((afI).zn)=(afC);
}
}
// rebuildAlias
function Ph(agc /*ast*/,agd /*parent*/){
if(cmp_((agc),(agd))==0){
(D)((131079),((agd).qn),([((agd).qZ)]));
((agc).MJ)=(null);
return;
}
if(((agc).zJ)!==(null)){
return;
}
((agc).zJ)=(agc);
((agc).MJ)=((zQ)(((agc).MJ),(agc)));
}
// rebuildExpr1
function PB(agi /*ast*/){
let ago=null; // childType
let agq=0;
let ag5=null; // expr
let ag6=null; // expr
let agE=null; // expr
let agL=null; // type
if(((agi).zJ)!==(null)){
return (agi).zJ;
}
((agi).zJ)=(agi);
((agi).agl)=((Aj)(((agi).agl),(false)));
if(((agi).agl)===(null)){
return null;
}
if(!(((agi).zn)===(null))){throw 0xE9170000;}
(ago)=(((agi).agl).zn);
switch((agi).agr){
case 0:
if((((s5)((ago)))||((agu)((ago))))||(((ago).qe)===(1025))){
if(((rv)((((agi).agl).qe),([9]),(67584)))===(67584)){
((agi).zJ)=((agi).agl);
return (agi).zJ;
}
((agi).zn)=(ago);
}
break;
case 1:
if(((s5)((ago)))||((agu)((ago)))){
if(((rv)((((agi).agl).qe),([9]),(67584)))===(67584)){
if((s5)((ago))){
(ag5)=(new zh());
(yP)((ag5),(67585),((agi).qn));
((ag5).zn)=(ago);
((ag5).zk)=(-(((agi).agl).zk));
(ag5)=((Qi)((ag5)));
((agi).zJ)=(ag5);
return (agi).zJ;
}
if(!((agu)((ago)))){throw 0xE9170000;}
(ag6)=(new Qr());
(yP)((ag6),(67588),((agi).qn));
((ag6).zn)=(ago);
((ag6).ag7)=(-(((agi).agl).ag7));
(ag6)=((Qq)((ag6)));
((agi).zJ)=(ag6);
return (agi).zJ;
}
((agi).zn)=(ago);
}
break;
case 2:
if((agA)((ago))){
if((((agi).agl).qe)===(67585)){
(agE)=(new zh());
(yP)((agE),(67585),((agi).qn));
((agE).zn)=(ago);
((agE).zk)=(((((agi).agl).zk)!==(0x0000000000000000))?(0x0000000000000000):(0x0000000000000001));
(agE)=((Qi)((agE)));
((agi).zJ)=(agE);
return (agi).zJ;
}
((agi).zn)=(ago);
}
break;
case 3:
if(((((R0)((ago)))||(((ago).qe)===(66561)))||(((ago).qe)===(66563)))||(((ago).qe)===(66564))){
((agi).zn)=(ago);
}
break;
case 4:
if(((((ago).qe)===(66561))||(((ago).qe)===(66563)))||(((ago).qe)===(66564))){
(agL)=(new y1());
(yr)((agL),(1026),((agi).qn));
((agL).y2)=(0);
((agi).zn)=(agL);
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
if(((agi).zn)===(null)){
(D)((131113),((agi).qn),(null));
return null;
}
((agi).zj)=(1);
return agi;
}
// rebuildExpr2
function PE(agP /*ast*/){
let agZ=false; // correct
let ahb=0;
let ahh=null; // ptr
let ahs=false; // value
let ah2=null; // type
let ahB=false; // value
let ahC=null; // children0Type
let ahF=0; // n1
let ahG=0; // n2
let ahI=0;
let ahP=0; // n1
let ahQ=0; // n2
let ahS=0;
let ahZ=0; // n1
let aia=0; // n2
let aic=0;
let aij=0; // cmp
let ain=0;
let ait=null; // expr
let aiz=null; // type
let ai7=false; // value
let ai8=null; // children0Type
let aiB=0; // n1
let aiC=0; // n2
let aiE=0;
let aiJ=0; // cmp
let aiL=0;
let aiP=null; // expr
let aiT=null; // type
let ajd=null; // s1
let aje=null; // s2
let ajf=null; // expr
let ajn=0; // n1
let ajo=0; // n2
let ajq=0;
let aj6=null; // expr
let aj9=0; // n1
let ajA=0; // n2
let ajC=0;
let ajS=null; // expr
let ajU=0; // n1
let ajV=0; // n2
let ajX=0;
let akn=null; // expr
if(((agP).zJ)!==(null)){
return (agP).zJ;
}
((agP).zJ)=(agP);
((agP).Ar)=((Aj)(((agP).Ar),(false)));
if(((agP).Ar)===(null)){
return null;
}
((agP).As)=((Aj)(((agP).As),(false)));
if(((agP).As)===(null)){
return null;
}
if(!((OL)((((agP).As).zn),(((agP).Ar).zn),(false)))){
(D)((131113),((agP).qn),(null));
return null;
}
(agZ)=(false);
switch((agP).Ao){
case 0:
if((((agP).Ar).zj)===(1)){
(D)((131114),((agP).qn),(null));
return null;
}
if(((R0)((((agP).Ar).zn)))&&((R0)((((agP).As).zn)))){
(ahh)=((((agP).As).zn).q1);
while(((((agP).Ar).zn).q1)!==(ahh)){
(ahh)=((ahh).q1);
if((ahh)===(null)){
(D)((131113),((agP).qn),(null));
return null;
}
}
}
if(((((agP).As).zn).qe)===(1028)){
((agP).As)=((OO)(((agP).As),(((agP).Ar).zn)));
}
((agP).zn)=(null);
(agZ)=(true);
break;
case 8:
case 9:
if((agA)((((agP).Ar).zn))){
if((((agP).Ar).qe)===(67585)){
(ahs)=((((agP).Ar).zk)!==(0x0000000000000000));
if(((agP).Ao)===(8)){
((agP).zJ)=((ahs)?((agP).Ar):((agP).As));
}
else{
if(!(((agP).Ao)===(9))){throw 0xE9170000;}
((agP).zJ)=((!(ahs))?((agP).Ar):((agP).As));
}
return (agP).zJ;
}
((agP).zn)=(((agP).Ar).zn);
(agZ)=(true);
}
break;
case 10:
case 11:
case 12:
case 13:
if((((((agP).Ar).zn).qe)===(1027))||(((((agP).As).zn).qe)===(1027))){
(D)((131115),((agP).qn),(null));
return null;
}
if((ah0)((((agP).Ar).zn),(true))){
(ah2)=(new y1());
(yr)((ah2),(1026),((agP).qn));
((ah2).y2)=(3);
if(((((agP).Ar).zn).qe)===(1028)){
if(((((agP).As).zn).qe)===(1028)){
if(!((((agP).Ar).qe)===(67587))){throw 0xE9170000;}
(D)((131116),((agP).qn),([(((agP).Ar).ah7)]));
return null;
}
((agP).Ar)=((OO)(((agP).Ar),(((agP).As).zn)));
}
else if(((((agP).As).zn).qe)===(1028)){
((agP).As)=((OO)(((agP).As),(((agP).Ar).zn)));
}
if((((rv)((((agP).Ar).qe),([9]),(67584)))===(67584))&&(((rv)((((agP).As).qe),([9]),(67584)))===(67584))){
(ahB)=(false);
(ahC)=(((agP).Ar).zn);
if((((ahC).qe)===(1025))||((SJ)((ahC)))){
(ahF)=(((agP).Ar).zk);
(ahG)=(((agP).As).zk);
switch((agP).Ao){
case 10:
(ahB)=((ahF)<(ahG));
break;
case 11:
(ahB)=((ahF)>(ahG));
break;
case 12:
(ahB)=((ahF)<=(ahG));
break;
case 13:
(ahB)=((ahF)>=(ahG));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else if(((s5)((ahC)))||((Fs)((ahC)))){
(ahP)=(((agP).Ar).zk);
(ahQ)=(((agP).As).zk);
switch((agP).Ao){
case 10:
(ahB)=((ahP)<(ahQ));
break;
case 11:
(ahB)=((ahP)>(ahQ));
break;
case 12:
(ahB)=((ahP)<=(ahQ));
break;
case 13:
(ahB)=((ahP)>=(ahQ));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else if((agu)((ahC))){
(ahZ)=(((agP).Ar).ag7);
(aia)=(((agP).As).ag7);
switch((agP).Ao){
case 10:
(ahB)=((ahZ)<(aia));
break;
case 11:
(ahB)=((ahZ)>(aia));
break;
case 12:
(ahB)=((ahZ)<=(aia));
break;
case 13:
(ahB)=((ahZ)>=(aia));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{
if(!((Xn)((ahC)))){throw 0xE9170000;}
(aij)=((aik)((((agP).Ar).ail),(((agP).As).ail)));
switch((agP).Ao){
case 10:
(ahB)=((aij)<(0));
break;
case 11:
(ahB)=((aij)>(0));
break;
case 12:
(ahB)=((aij)<=(0));
break;
case 13:
(ahB)=((aij)>=(0));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
(ait)=(new zh());
(yP)((ait),(67585),((agP).qn));
((ait).zn)=(ah2);
((ait).zk)=((ahB)?(0x0000000000000001):(0x0000000000000000));
(ait)=((Qi)((ait)));
((agP).zJ)=(ait);
return (agP).zJ;
}
((agP).zn)=(ah2);
(agZ)=(true);
}
break;
case 14:
case 15:
if((((((agP).Ar).zn).qe)===(1027))||(((((agP).As).zn).qe)===(1027))){
(D)((131115),((agP).qn),(null));
return null;
}
if((ah0)((((agP).Ar).zn),(false))){
(aiz)=(new y1());
(yr)((aiz),(1026),((agP).qn));
((aiz).y2)=(3);
if(((((agP).Ar).zn).qe)===(1028)){
if(((((agP).As).zn).qe)===(1028)){
if(!((((agP).Ar).qe)===(67587))){throw 0xE9170000;}
(D)((131116),((agP).qn),([(((agP).Ar).ah7)]));
return null;
}
((agP).Ar)=((OO)(((agP).Ar),(((agP).As).zn)));
}
else if(((((agP).As).zn).qe)===(1028)){
((agP).As)=((OO)(((agP).As),(((agP).Ar).zn)));
}
if((((rv)((((agP).Ar).qe),([9]),(67584)))===(67584))&&(((rv)((((agP).As).qe),([9]),(67584)))===(67584))){
(ai7)=(false);
(ai8)=(((agP).Ar).zn);
if((((((((ai8).qe)===(1025))||((s5)((ai8))))||((agu)((ai8))))||((SJ)((ai8))))||((agA)((ai8))))||((Fs)((ai8)))){
(aiB)=(((agP).Ar).zk);
(aiC)=(((agP).As).zk);
switch((agP).Ao){
case 14:
(ai7)=((aiB)===(aiC));
break;
case 15:
(ai7)=((aiB)!==(aiC));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{
if(!((Xn)((ai8)))){throw 0xE9170000;}
(aiJ)=((aik)((((agP).Ar).ail),(((agP).As).ail)));
switch((agP).Ao){
case 14:
(ai7)=((aiJ)===(0));
break;
case 15:
(ai7)=((aiJ)!==(0));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
(aiP)=(new zh());
(yP)((aiP),(67585),((agP).qn));
((aiP).zn)=(aiz);
((aiP).zk)=((ai7)?(0x0000000000000001):(0x0000000000000000));
(aiP)=((Qi)((aiP)));
((agP).zJ)=(aiP);
return (agP).zJ;
}
((agP).zn)=(aiz);
(agZ)=(true);
}
break;
case 16:
case 17:
if(((Fn)((((agP).Ar).zn)))||(((((agP).Ar).zn).qe)===(1027))){
(aiT)=(new y1());
(yr)((aiT),(1026),((agP).qn));
((aiT).y2)=(3);
((agP).zn)=(aiT);
(agZ)=(true);
}
break;
case 18:
if((((((agP).Ar).zn).qe)===(1027))||(((((agP).As).zn).qe)===(1027))){
(D)((131117),((agP).qn),(null));
return null;
}
if(((((agP).Ar).zn).qe)===(66561)){
if((((rv)((((agP).Ar).qe),([9]),(67584)))===(67584))&&(((rv)((((agP).As).qe),([9]),(67584)))===(67584))){
if((Xn)((((agP).Ar).zn))){
(ajd)=(((agP).Ar).ail);
(aje)=(((agP).As).ail);
(ajf)=(new Ql());
(yP)((ajf),(67586),((agP).qn));
((ajf).zn)=(((agP).Ar).zn);
((ajf).ail)=({S:(ajd).S+(aje).S});
(ajf)=((Qk)((ajf)));
((agP).zJ)=(ajf);
return (agP).zJ;
}
}
((agP).zn)=(((agP).Ar).zn);
(agZ)=(true);
}
break;
case 19:
case 20:
case 21:
case 22:
case 23:
if(((((((agP).Ar).zn).qe)===(1025))||((s5)((((agP).Ar).zn))))||((agu)((((agP).Ar).zn)))){
if((((rv)((((agP).Ar).qe),([9]),(67584)))===(67584))&&(((rv)((((agP).As).qe),([9]),(67584)))===(67584))){
if(((((agP).Ar).zn).qe)===(1025)){
(ajn)=(((agP).Ar).zk);
(ajo)=(((agP).As).zk);
switch((agP).Ao){
case 19:
(ajn)=((ajn)+(ajo));
break;
case 20:
(ajn)=((ajn)-(ajo));
break;
case 21:
(ajn)=((ajn)*(ajo));
break;
case 22:
if((ajo)===(0x0000000000000000)){
(D)((131118),((agP).qn),(null));
return null;
}
(ajn)=(~~((ajn)/(ajo)));
break;
case 23:
if((ajo)===(0x0000000000000000)){
(D)((131118),((agP).qn),(null));
return null;
}
(ajn)=((ajn)%(ajo));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(aj6)=(new zh());
(yP)((aj6),(67585),((agP).qn));
((aj6).zn)=(((agP).Ar).zn);
((aj6).zk)=((aj7)(((((agP).Ar).zn).AU),(ajn)));
(aj6)=((Qi)((aj6)));
((agP).zJ)=(aj6);
return (agP).zJ;
}
else if((s5)((((agP).Ar).zn))){
(aj9)=(((agP).Ar).zk);
(ajA)=(((agP).As).zk);
switch((agP).Ao){
case 19:
(aj9)=((aj9)+(ajA));
break;
case 20:
(aj9)=((aj9)-(ajA));
break;
case 21:
(aj9)=((aj9)*(ajA));
break;
case 22:
if((ajA)===(0)){
(D)((131118),((agP).qn),(null));
return null;
}
(aj9)=(~~((aj9)/(ajA)));
break;
case 23:
if((ajA)===(0)){
(D)((131118),((agP).qn),(null));
return null;
}
(aj9)=((aj9)%(ajA));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(ajS)=(new zh());
(yP)((ajS),(67585),((agP).qn));
((ajS).zn)=(((agP).Ar).zn);
((ajS).zk)=(aj9);
(ajS)=((Qi)((ajS)));
((agP).zJ)=(ajS);
return (agP).zJ;
}
else{
if(!((agu)((((agP).Ar).zn)))){throw 0xE9170000;}
(ajU)=(((agP).Ar).ag7);
(ajV)=(((agP).As).ag7);
switch((agP).Ao){
case 19:
(ajU)=((ajU)+(ajV));
break;
case 20:
(ajU)=((ajU)-(ajV));
break;
case 21:
(ajU)=((ajU)*(ajV));
break;
case 22:
if(((ajU)===(0))&&((ajV)===(0))){
(D)((131118),((agP).qn),(null));
return null;
}
(ajU)=((ajU)/(ajV));
break;
case 23:
if(((ajU)===(0))&&((ajV)===(0))){
(D)((131118),((agP).qn),(null));
return null;
}
(ajU)=((ajU)%(ajV));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(akn)=(new Qr());
(yP)((akn),(67588),((agP).qn));
((akn).zn)=(((agP).Ar).zn);
((akn).ag7)=(ajU);
(akn)=((Qq)((akn)));
((agP).zJ)=(akn);
return (agP).zJ;
}
}
((agP).zn)=(((agP).Ar).zn);
(agZ)=(true);
}
break;
case 24:
if(((s5)((((agP).Ar).zn)))||((agu)((((agP).Ar).zn)))){
((agP).zn)=(((agP).Ar).zn);
(agZ)=(true);
}
break;
case 25:
if(((((agP).Ar).zj)===(1))||((((agP).As).zj)===(1))){
(D)((131119),((agP).qn),(null));
return null;
}
if((!((R0)((((agP).Ar).zn))))&&(((((agP).Ar).zn).q1)!==((((agP).As).zn).q1))){
((agP).zn)=(((agP).Ar).zn);
(agZ)=(true);
}
break;
}
if(!(agZ)){
(D)((131113),((agP).qn),(null));
return null;
}
((agP).zj)=(1);
return agP;
}
// rebuildExpr3
function PG(aky /*ast*/){
if(((aky).zJ)!==(null)){
return (aky).zJ;
}
((aky).zJ)=(aky);
((aky).ak1)=((Aj)(((aky).ak1),(false)));
if(((aky).ak1)===(null)){
return null;
}
((aky).ak4)=((Aj)(((aky).ak4),(false)));
if(((aky).ak4)===(null)){
return null;
}
((aky).ak7)=((Aj)(((aky).ak7),(false)));
if(((aky).ak7)===(null)){
return null;
}
if(!((agA)((((aky).ak1).zn)))){
(D)((131120),((aky).qn),(null));
return null;
}
if((!((OL)((((aky).ak4).zn),(((aky).ak7).zn),(false))))&&(!((OL)((((aky).ak7).zn),(((aky).ak4).zn),(false))))){
(D)((131121),((aky).qn),(null));
return null;
}
if((((aky).ak1).qe)===(67585)){
((aky).zJ)=(((((aky).ak1).zk)!==(0x0000000000000000))?((aky).ak4):((aky).ak7));
return (aky).zJ;
}
if(((((aky).ak4).zn).qe)===(1028)){
if(((((aky).ak7).zn).qe)===(1028)){
if(!((((aky).ak4).qe)===(67587))){throw 0xE9170000;}
(D)((131116),((aky).qn),([(((aky).ak4).ah7)]));
return null;
}
((aky).ak4)=((OO)(((aky).ak4),(((aky).ak7).zn)));
}
else if(((((aky).ak7).zn).qe)===(1028)){
((aky).ak7)=((OO)(((aky).ak7),(((aky).ak4).zn)));
}
if((OL)((((aky).ak4).zn),(((aky).ak7).zn),(false))){
((aky).zn)=((((((aky).ak7).zn).qe)===(1027))?(((aky).ak4).zn):(((aky).ak7).zn));
}
else{
((aky).zn)=((((((aky).ak4).zn).qe)===(1027))?(((aky).ak7).zn):(((aky).ak4).zn));
}
((aky).zj)=(1);
return aky;
}
// rebuildExprNew
function PJ(akO /*ast*/){
if(((akO).zJ)!==(null)){
return (akO).zJ;
}
((akO).zJ)=(akO);
((akO).akR)=((zQ)(((akO).akR),(null)));
if(((akO).akR)===(null)){
return null;
}
if(((R0)(((akO).akR)))&&((((akO).akR).q1)===(null))){
return null;
}
if(!((((R0)(((akO).akR)))||((((akO).akR).qe)===(66563)))||((((akO).akR).qe)===(66564)))){
(D)((131122),((akO).qn),(null));
return null;
}
((akO).zn)=((akO).akR);
((akO).zj)=(1);
return akO;
}
// rebuildExprNewArray
function PM(akY /*ast*/){
let alc=null; // items
let alg=null; // data
let alp=null; // type
let als=0;
let alu=null; // type2
let alt=0;
if(((akY).zJ)!==(null)){
return (akY).zJ;
}
((akY).zJ)=(akY);
(alc)=((akY).ald);
(qt)((alc),([130,134]));
alf:
while(!((qv)((alc),([130,134])))){
(alg)=((qx)((alc),([130,134])));
(alg)=((Aj)((alg),(false)));
if((alg)===(null)){
return null;
}
if(!((s5)(((alg).zn)))){
(D)((131123),((alg).qn),(null));
return null;
}
(ty)((alc),([130,134]),(alg));
(t1)((alc),([130,134]));
}
((akY).all)=((zQ)(((akY).all),(null)));
if(((akY).all)===(null)){
return null;
}
(alp)=((akY).all);
alr:
for(als=(0),alt=((((akY).ald).L)-(1));als<=alt;als+=(1)){
(alu)=(new AP());
(yr)((alu),(66561),((akY).qn));
((alu).AR)=(alp);
(alp)=(alu);
}
((akY).zn)=(alp);
((akY).zj)=(1);
return akY;
}
// rebuildExprAs
function PP(alv /*ast*/){
let al5=0;
let al8=null; // t1
let al9=null; // t2
let amm=0; // n
let amp=null; // expr
let amr=null; // expr
let amt=null; // expr
let amy=null; // expr
let am0=null; // expr
let am2=null; // expr
let am4=0; // n
let am7=null; // expr
let am9=null; // expr
let amD=null; // type
if(((alv).zJ)!==(null)){
return (alv).zJ;
}
((alv).zJ)=(alv);
((alv).aly)=((Aj)(((alv).aly),(false)));
if(((alv).aly)===(null)){
return null;
}
((alv).al1)=((zQ)(((alv).al1),(null)));
if(((alv).al1)===(null)){
return null;
}
if(!(((alv).zn)===(null))){throw 0xE9170000;}
switch((alv).al6){
case 0:
(al8)=(((alv).aly).zn);
(al9)=((alv).al1);
if((((al8).qe)===(1025))||((s5)((al8)))){
if((((((((al9).qe)===(1025))||((s5)((al9))))||((agu)((al9))))||((SJ)((al9))))||((agA)((al9))))||((Fs)((al9)))){
if((OL)((al8),(al9),(false))){
((alv).zJ)=((alv).aly);
return (alv).zJ;
}
((alv).zn)=(al9);
}
}
else if((agu)((al8))){
if(((((al9).qe)===(1025))||((s5)((al9))))||((agu)((al9)))){
if((OL)((al8),(al9),(false))){
((alv).zJ)=((alv).aly);
return (alv).zJ;
}
((alv).zn)=(al9);
}
}
else if((SJ)((al8))){
if(((((al9).qe)===(1025))||((s5)((al9))))||((SJ)((al9)))){
if((OL)((al8),(al9),(false))){
((alv).zJ)=((alv).aly);
return (alv).zJ;
}
((alv).zn)=(al9);
}
}
else if((agA)((al8))){
if(((((al9).qe)===(1025))||((s5)((al9))))||((agA)((al9)))){
if((OL)((al8),(al9),(false))){
((alv).zJ)=((alv).aly);
return (alv).zJ;
}
((alv).zn)=(al9);
}
}
else if((R0)((al8))){
if((R0)((al9))){
((alv).zn)=(al9);
}
}
else if((Fs)((al8))){
if(((((al9).qe)===(1025))||((s5)((al9))))||((Fs)((al9)))){
if((OL)((al8),(al9),(false))){
((alv).zJ)=((alv).aly);
return (alv).zJ;
}
((alv).zn)=(al9);
}
}
else if(((al8).qe)===(1028)){
if((Fs)((al9))){
((alv).zn)=(al9);
}
}
if(((alv).zn)!==(null)){
if(((rv)((((alv).aly).qe),([9]),(67584)))===(67584)){
if(((((((al8).qe)===(1025))||((SJ)((al8))))||((agA)((al8))))||((s5)((al8))))||((Fs)((al8)))){
(amm)=(((alv).aly).zk);
if(((al9).qe)===(1025)){
(amp)=(new zh());
(yP)((amp),(67585),((alv).qn));
((amp).zn)=((alv).zn);
((amp).zk)=((aj7)(((al9).AU),(amm)));
(amp)=((Qi)((amp)));
((alv).zJ)=(amp);
return (alv).zJ;
}
else if(((s5)((al9)))||((Fs)((al9)))){
(amr)=(new zh());
(yP)((amr),(67585),((alv).qn));
((amr).zn)=((alv).zn);
((amr).zk)=(amm);
(amr)=((Qi)((amr)));
((alv).zJ)=(amr);
return (alv).zJ;
}
else if((agu)((al9))){
(amt)=(new Qr());
(yP)((amt),(67588),((alv).qn));
((amt).zn)=((alv).zn);
if(((s5)((al8)))||((Fs)((al8)))){
((amt).ag7)=(amm);
}
else{
((amt).ag7)=(amm);
}
(amt)=((Qq)((amt)));
((alv).zJ)=(amt);
return (alv).zJ;
}
else if((SJ)((al9))){
(amy)=(new zh());
(yP)((amy),(67585),((alv).qn));
((amy).zn)=((alv).zn);
((amy).zk)=((aj7)((2),(amm)));
(amy)=((Qi)((amy)));
((alv).zJ)=(amy);
return (alv).zJ;
}
else{
if(!((agA)((al9)))){throw 0xE9170000;}
(am0)=(new zh());
(yP)((am0),(67585),((alv).qn));
((am0).zn)=((alv).zn);
((am0).zk)=(((amm)!==(0x0000000000000000))?(0x0000000000000001):(0x0000000000000000));
(am0)=((Qi)((am0)));
((alv).zJ)=(am0);
return (alv).zJ;
}
}
else if(((al8).qe)===(1028)){
if(!((((al9).q1).qe)===(6))){throw 0xE9170000;}
(am2)=(new zh());
(yP)((am2),(67585),((alv).qn));
((am2).zn)=((alv).zn);
((am2).zk)=((afv)(((alv).aly),((al9).q1)));
(am2)=((Qi)((am2)));
((alv).zJ)=(am2);
return (alv).zJ;
}
else{
if(!((agu)((al8)))){throw 0xE9170000;}
(am4)=(((alv).aly).ag7);
if(((al9).qe)===(1025)){
(am7)=(new zh());
(yP)((am7),(67585),((alv).qn));
((am7).zn)=((alv).zn);
((am7).zk)=((aj7)(((al9).AU),(~~(am4))));
(am7)=((Qi)((am7)));
((alv).zJ)=(am7);
return (alv).zJ;
}
else{
if(!((s5)((al9)))){throw 0xE9170000;}
(am9)=(new zh());
(yP)((am9),(67585),((alv).qn));
((am9).zn)=((alv).zn);
((am9).zk)=(~~(am4));
(am9)=((Qi)((am9)));
((alv).zJ)=(am9);
return (alv).zJ;
}
}
}
}
break;
case 1:
case 2:
if(((R0)((((alv).aly).zn)))&&((R0)(((alv).al1)))){
(amD)=(new y1());
(yr)((amD),(1026),((alv).qn));
((amD).y2)=(3);
((alv).zn)=(amD);
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
if(((alv).zn)===(null)){
(D)((131113),((alv).qn),(null));
return null;
}
((alv).zj)=(1);
return alv;
}
// rebuildExprToBin
function PS(amH /*ast*/){
if(((amH).zJ)!==(null)){
return (amH).zJ;
}
((amH).zJ)=(amH);
((amH).amK)=((Aj)(((amH).amK),(false)));
if(((amH).amK)===(null)){
return null;
}
if((((((amH).amK).zn).qe)===(1027))||(((((amH).amK).zn).qe)===(1028))){
(D)((131113),((amH).qn),(null));
return null;
}
if((((((amH).amQ).qe)!==(66561))||(((((amH).amQ).AR).qe)!==(1025)))||(((((amH).amQ).AR).AU)!==(1))){
(D)((131113),((amH).qn),(null));
return null;
}
((amH).zn)=((amH).amQ);
((amH).zj)=(1);
return amH;
}
// rebuildExprFromBin
function PV(amS /*ast*/){
if(((amS).zJ)!==(null)){
return (amS).zJ;
}
((amS).zJ)=(amS);
((amS).amV)=((Aj)(((amS).amV),(false)));
if(((amS).amV)===(null)){
return null;
}
if(((((((amS).amV).zn).qe)!==(66561))||((((((amS).amV).zn).AR).qe)!==(1025)))||((((((amS).amV).zn).AR).AU)!==(1))){
(D)((131113),((amS).qn),(null));
return null;
}
((amS).zn)=((amS).ana);
((amS).zj)=(1);
((amS).anb)=((Aj)(((amS).anb),(false)));
return amS;
}
// rebuildExprCall
function PY(anc /*ast*/){
let ani=null; // type
let anl=null; // valueType
let ann=null; // expr
let ant=null; // me_
let an0=null; // meType
let an2=null; // expr
let an5=null; // value
let an7=null; // prim
let anI=0; // n
let anJ=null; // itemsExpr
let anK=null; // itemsType
let anM=null; // argExpr
let anN=null; // argType
if(((anc).zJ)!==(null)){
return (anc).zJ;
}
((anc).zJ)=(anc);
((anc).yT)=((Aj)(((anc).yT),(false)));
if(((anc).yT)===(null)){
return null;
}
(ani)=(((anc).yT).zn);
if(((rv)(((ani).abd),([9]),(2048)))!==(0)){
(anl)=(new z2());
if(!(((ani).AZ)!==(null))){throw 0xE9170000;}
(ann)=(new PK());
(yP)((ann),(2052),((anc).qn));
((ann).akR)=((ani).AZ);
((anl).z7)=((Aj)((ann),(false)));
((anl).z3)=(false);
((anl).z4)=(false);
if((((anc).yQ).L)===(0)){
(eP)(((anc).yQ),([130,134]),(anl));
}
else{
(qt)(((anc).yQ),([130,134]));
(ty)(((anc).yQ),([130,134]),(anl));
}
}
if(((((anc).yT).qe)===(2059))&&(((((anc).yT).zn).qe)===(66562))){
(ant)=(new z2());
((ant).z7)=(((anc).yT).anu);
((ant).z3)=(false);
((ant).z4)=(false);
if((((anc).yQ).L)===(0)){
(eP)(((anc).yQ),([130,134]),(ant));
}
else{
(qt)(((anc).yQ),([130,134]));
(ty)(((anc).yQ),([130,134]),(ant));
}
if(((rv)(((ani).abd),([9]),(1)))!==(0)){
(an0)=(new z2());
(an2)=(new Qu());
(yP)((an2),(2060),((anc).qn));
((an2).an3)=({L:0,H:null,T:null,P:null});
(an5)=(new zh());
(yP)((an5),(67585),((anc).qn));
((an5).zk)=(0x0000000000000000);
(an7)=(new y1());
(yr)((an7),(1026),((anc).qn));
((an7).y2)=(0);
((an5).zn)=(an7);
(eP)(((an2).an3),([130,134]),(an5));
((an0).z7)=((Aj)((an2),(false)));
((an0).z3)=(false);
((an0).z4)=(false);
if((((anc).yQ).L)===(1)){
(eP)(((anc).yQ),([130,134]),(an0));
}
else{
if(!((((anc).yQ).L)>=(2))){throw 0xE9170000;}
(qt)(((anc).yQ),([130,134]));
(rA)(((anc).yQ),([130,134]));
(ty)(((anc).yQ),([130,134]),(an0));
}
}
}
else{
if(((ani).qe)!==(66562)){
(D)((131124),((anc).qn),(null));
return null;
}
(ani)=(((anc).yT).zn);
}
((anc).zn)=((ani).AZ);
if((((anc).yQ).L)!==(((ani).Be).L)){
(D)((131125),((anc).qn),([((v)((((ani).Be).L),([0]))),((v)((((anc).yQ).L),([0]))),((anG)((ani)))]));
return null;
}
(anI)=(0);
(anJ)=((anc).yQ);
(anK)=((ani).Be);
(qt)((anJ),([130,134]));
(qt)((anK),([130,134]));
while(!((qv)((anJ),([130,134])))){
(anM)=((qx)((anJ),([130,134])));
(anN)=((qx)((anK),([130,134])));
if((anM).z4){
((((anM).z7).q1).s6)=((anN).Bn);
}
((anM).z7)=((Aj)(((anM).z7),(false)));
if(((anM).z7)!==(null)){
if((((anM).z3)&&(!((anM).z4)))&&((((anM).z7).zj)===(1))){
(D)((131126),((anc).qn),([((v)(((anI)+(1)),([0])))]));
return null;
}
if((((anM).z3)!==((anN).Bp))||(!((OL)((((anM).z7).zn),((anN).Bn),(false))))){
(D)((131127),((anc).qn),([((v)(((anI)+(1)),([0]))),({S:(((anN).Bp)?({S:"&"}):({S:""})).S+((anG)(((anN).Bn))).S}),({S:(((anM).z3)?({S:"&"}):({S:""})).S+((anG)((((anM).z7).zn))).S})]));
return null;
}
if(((((anM).z7).zn).qe)===(1028)){
((anM).z7)=((OO)(((anM).z7),((anN).Bn)));
}
}
(rA)((anJ),([130,134]));
(rA)((anK),([130,134]));
(anI)=((anI)+(1));
}
((anc).zj)=(1);
return anc;
}
// rebuildExprArray
function Qa(anZ /*ast*/){
if(((anZ).zJ)!==(null)){
return (anZ).zJ;
}
((anZ).zJ)=(anZ);
((anZ).aoc)=((Aj)(((anZ).aoc),(false)));
if(((anZ).aoc)===(null)){
return null;
}
if(((((anZ).aoc).zn).qe)!==(66561)){
(D)((131128),((anZ).qn),(null));
return null;
}
((anZ).aoh)=((Aj)(((anZ).aoh),(false)));
if(((anZ).aoh)===(null)){
return null;
}
if(!((s5)((((anZ).aoh).zn)))){
(D)((131129),(((anZ).aoh).qn),(null));
return null;
}
((anZ).zn)=((((anZ).aoc).zn).AR);
((anZ).zj)=(3);
return anZ;
}
// rebuildExprDot
function Qd(aom /*ast*/){
let aot=false; // found
let aou=null; // ptr
let aow=null; // items
let aoy=null; // item
let ao3=null; // type
let ao5=null; // items2
let ao7=null; // arg
let ao8=null; // arg2
let aoF=null; // varType
let aoI=null; // member
let aoO=null; // expr
let aoS=null; // func_
let aoX=null; // argType
let aps=null; // type
let apu=null; // item
let apw=null; // item
let apy=null; // item
let apF=null; // type
let apK=null; // type
let apP=null; // type
let aoK=false;
let aoM=null;
if(((aom).zJ)!==(null)){
return (aom).zJ;
}
((aom).zJ)=(aom);
((aom).anu)=((Aj)(((aom).anu),(false)));
if(((aom).anu)===(null)){
return null;
}
if((R0)((((aom).anu).zn))){
(aot)=(false);
(aou)=((((aom).anu).zn).q1);
while((aou)!==(null)){
(aow)=((aou).ti);
(qt)((aow),([130,134]));
while(!((qv)((aow),([130,134])))){
(aoy)=((qx)((aow),([130,134])));
if(((((aoy).tU).qe)===(2))&&(((aom).ao0).S===((((aoy).tU).tZ).qZ).S)){
((aom).zn)=((((aoy).tU).tZ).s6);
((aom).zj)=(3);
(aot)=(true);
}
else if(((((aoy).tU).qe)===(256))&&(((aom).ao0).S===(((aoy).tU).qZ).S)){
(ao3)=(new AX());
(yr)((ao3),(66562),((aom).qn));
((ao3).abd)=(((aoy).tU).qk);
((ao3).abe)=(((aoy).tU).ql);
((ao3).Be)=({L:0,H:null,T:null,P:null});
(ao5)=(((aoy).tU).qi);
(qt)((ao5),([130,134]));
while(!((qv)((ao5),([130,134])))){
(ao7)=((qx)((ao5),([130,134])));
(ao8)=(new Bh());
((ao8).Bn)=((ao7).s6);
((ao8).Bp)=((ao7).sL);
(eP)(((ao3).Be),([130,134]),(ao8));
(rA)((ao5),([130,134]));
}
((ao3).AZ)=(((aoy).tU).qj);
((aom).zn)=(ao3);
((aom).zj)=(1);
(aot)=(true);
}
if(aot){
if((!((aoy).Nd))&&(((((aom).anu).q2)===(null))||((((aom).anu).q2).S!==({S:"me"}).S))){
(D)((131131),((aom).qn),([((aom).ao0)]));
return null;
}
((aom).aoD)=(aoy);
return aom;
}
(rA)((aow),([130,134]));
}
(aou)=((aou).q1);
}
}
else{
(aoF)=(((aom).anu).zn);
if(((aoF).qe)===(1028)){
if(!((((aom).anu).qe)===(67587))){throw 0xE9170000;}
(D)((131116),((aom).qn),([(((aom).anu).ah7)]));
return null;
}
(aoI)=((aom).ao0);
if((aoK=(aoL)((aoM={$:(aoI)},aoM),(aoF)),(aoI)=aoM.$,aoK)){
(aoO)=((yG)(({S:"kuin"}),({S:({S:"_"}).S+(aoI).S}),(true)));
if((aoO)===(null)){
if(!(false)){throw 0xE9170000;}
return null;
}
(aoS)=((aoO).zn);
if(((rv)(((aoS).abd),([9]),(1)))!==(0)){
if(!((((aoS).Be).L)>=(2))){throw 0xE9170000;}
(qt)(((aoS).Be),([130,134]));
if(!((s5)((((qx)(((aoS).Be),([130,134]))).Bn)))){throw 0xE9170000;}
(rA)(((aoS).Be),([130,134]));
(aoX)=(((qx)(((aoS).Be),([130,134]))).Bn);
if(!((((aoX).qe)===(66561))&&((s5)(((aoX).AR))))){throw 0xE9170000;}
(qt)(((aoS).Be),([130,134]));
(((qx)(((aoS).Be),([130,134]))).Bn)=(aoF);
}
if(((rv)(((aoS).abd),([9]),(2)))!==(0)){
if(!(((rv)(((aoS).abd),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(8)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(32)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(256)))===(0))){throw 0xE9170000;}
if(!((((aoS).Be).L)>=(3))){throw 0xE9170000;}
(qt)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
if(!((s5)((((qx)(((aoS).Be),([130,134]))).Bn)))){throw 0xE9170000;}
(qt)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
(((qx)(((aoS).Be),([130,134]))).Bn)=(aoF);
}
if(((rv)(((aoS).abd),([9]),(8)))!==(0)){
if(!(((rv)(((aoS).abd),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(2)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(32)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(256)))===(0))){throw 0xE9170000;}
if(!((((aoS).Be).L)>=(3))){throw 0xE9170000;}
(qt)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
if(!((s5)((((qx)(((aoS).Be),([130,134]))).Bn)))){throw 0xE9170000;}
(qt)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
if(((aoF).qe)===(66561)){
(((qx)(((aoS).Be),([130,134]))).Bn)=((aoF).AR);
}
else if(((aoF).qe)===(66563)){
(((qx)(((aoS).Be),([130,134]))).Bn)=((aoF).Bz);
}
else{
if(!(((aoF).qe)===(66564))){throw 0xE9170000;}
(((qx)(((aoS).Be),([130,134]))).Bn)=((aoF).B6);
}
}
if(((rv)(((aoS).abd),([9]),(32)))!==(0)){
if(!(((rv)(((aoS).abd),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(2)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(8)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(256)))===(0))){throw 0xE9170000;}
if(!((((aoS).Be).L)>=(4))){throw 0xE9170000;}
(qt)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
if(!((s5)((((qx)(((aoS).Be),([130,134]))).Bn)))){throw 0xE9170000;}
(rA)(((aoS).Be),([130,134]));
if(!((s5)((((qx)(((aoS).Be),([130,134]))).Bn)))){throw 0xE9170000;}
if(!(((aoF).qe)===(66564))){throw 0xE9170000;}
(qt)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
(((qx)(((aoS).Be),([130,134]))).Bn)=((aoF).B6);
(rA)(((aoS).Be),([130,134]));
(((qx)(((aoS).Be),([130,134]))).Bn)=((aoF).B7);
}
if(((rv)(((aoS).abd),([9]),(256)))!==(0)){
if(!(((rv)(((aoS).abd),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(2)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(8)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(32)))===(0))){throw 0xE9170000;}
if(!((((aoS).Be).L)>=(3))){throw 0xE9170000;}
(qt)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
if(!((s5)((((qx)(((aoS).Be),([130,134]))).Bn)))){throw 0xE9170000;}
if(!(((aoF).qe)===(66564))){throw 0xE9170000;}
(aps)=(new AX());
(yr)((aps),(66562),((aom).qn));
((aps).abd)=(0);
((aps).abe)=({L:0,H:null,T:null,P:null});
((aps).Be)=({L:0,H:null,T:null,P:null});
(apu)=(new Bh());
((apu).Bn)=((aoF).B6);
((apu).Bp)=(false);
(eP)(((aps).Be),([130,134]),(apu));
(apw)=(new Bh());
((apw).Bn)=((aoF).B7);
((apw).Bp)=(false);
(eP)(((aps).Be),([130,134]),(apw));
(apy)=(new Bh());
(qt)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
((apy).Bn)=(((qx)(((aoS).Be),([130,134]))).Bn);
((apy).Bp)=(false);
(eP)(((aps).Be),([130,134]),(apy));
((aps).AZ)=((aoS).AZ);
(qt)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
(rA)(((aoS).Be),([130,134]));
(((qx)(((aoS).Be),([130,134]))).Bn)=(aps);
}
if(((rv)(((aoS).abd),([9]),(4)))!==(0)){
if(!(((rv)(((aoS).abd),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(16)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(64)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(512)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(1024)))===(0))){throw 0xE9170000;}
if(!((s5)(((aoS).AZ)))){throw 0xE9170000;}
((aoS).AZ)=(aoF);
}
if(((rv)(((aoS).abd),([9]),(16)))!==(0)){
if(!(((rv)(((aoS).abd),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(4)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(64)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(512)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(1024)))===(0))){throw 0xE9170000;}
if(!((s5)(((aoS).AZ)))){throw 0xE9170000;}
if(((aoF).qe)===(66561)){
((aoS).AZ)=((aoF).AR);
}
else if(((aoF).qe)===(66563)){
((aoS).AZ)=((aoF).Bz);
}
else{
if(!(((aoF).qe)===(66564))){throw 0xE9170000;}
((aoS).AZ)=((aoF).B7);
}
}
if(((rv)(((aoS).abd),([9]),(64)))!==(0)){
if(!(((rv)(((aoS).abd),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(4)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(16)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(512)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(1024)))===(0))){throw 0xE9170000;}
if(!((s5)(((aoS).AZ)))){throw 0xE9170000;}
if(!(((aoF).qe)===(66563))){throw 0xE9170000;}
if(!(((aoF).Bx)===(0))){throw 0xE9170000;}
(apF)=(new AP());
(yr)((apF),(66561),((aom).qn));
((apF).AR)=((aoF).Bz);
((aoS).AZ)=(apF);
}
if(((rv)(((aoS).abd),([9]),(512)))!==(0)){
if(!(((rv)(((aoS).abd),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(4)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(16)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(64)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(1024)))===(0))){throw 0xE9170000;}
if(!((s5)(((aoS).AZ)))){throw 0xE9170000;}
if(!(((aoF).qe)===(66564))){throw 0xE9170000;}
(apK)=(new AP());
(yr)((apK),(66561),((aom).qn));
((apK).AR)=((aoF).B6);
((aoS).AZ)=(apK);
}
if(((rv)(((aoS).abd),([9]),(1024)))!==(0)){
if(!(((rv)(((aoS).abd),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(4)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(16)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(64)))===(0))){throw 0xE9170000;}
if(!(((rv)(((aoS).abd),([9]),(512)))===(0))){throw 0xE9170000;}
if(!((s5)(((aoS).AZ)))){throw 0xE9170000;}
if(!(((aoF).qe)===(66564))){throw 0xE9170000;}
(apP)=(new AP());
(yr)((apP),(66561),((aom).qn));
((apP).AR)=((aoF).B7);
((aoS).AZ)=(apP);
}
((aom).q1)=(aoO);
((aom).zn)=((aoO).zn);
((aom).zj)=(1);
return aom;
}
}
(D)((131130),((aom).qn),([((aom).ao0)]));
return null;
}
// rebuildExprValue
function Qg(apQ /*ast*/){
if(((apQ).zJ)!==(null)){
return (apQ).zJ;
}
((apQ).zJ)=(apQ);
if(!(((apQ).qe)===(67584))){throw 0xE9170000;}
((apQ).zj)=(1);
return apQ;
}
// rebuildExprValuePrim
function Qi(apT /*ast*/){
if(((apT).zJ)!==(null)){
return (apT).zJ;
}
((apT).zJ)=(apT);
((apT).zj)=(1);
return apT;
}
// rebuildExprValueStr
function Qk(apW /*ast*/){
if(((apW).zJ)!==(null)){
return (apW).zJ;
}
((apW).zJ)=(apW);
((apW).zj)=(1);
return apW;
}
// rebuildExprValueEnumElement
function Qn(apZ /*ast*/){
if(((apZ).zJ)!==(null)){
return (apZ).zJ;
}
((apZ).zJ)=(apZ);
((apZ).zj)=(1);
return apZ;
}
// rebuildExprValueFloat
function Qq(aqc /*ast*/){
if(((aqc).zJ)!==(null)){
return (aqc).zJ;
}
((aqc).zJ)=(aqc);
((aqc).zj)=(1);
return aqc;
}
// rebuildExprValueArray
function Qt(aqf /*ast*/){
let aqj=false; // nullSet
let aqk=false; // enumSet
let aql=null; // items
let aqn=null; // data
let aqr=null; // dataType
let aq6=null; // type
let aqF=null; // items
let aqH=null; // item
let aqN=false; // isConst
let aqP=null; // items
let aqW=null; // ast2
let aqX=null; // s
let aqY=0; // idx
let aqZ=null; // items
let arb=0;
let arc=0;
if(((aqf).zJ)!==(null)){
return (aqf).zJ;
}
((aqf).zJ)=(aqf);
if(!(((aqf).zn)===(null))){throw 0xE9170000;}
(aqj)=(false);
(aqk)=(false);
(aql)=((aqf).an3);
(qt)((aql),([130,134]));
while(!((qv)((aql),([130,134])))){
(aqn)=((qx)((aql),([130,134])));
(aqn)=((Aj)((aqn),(false)));
if((aqn)===(null)){
return null;
}
(aqr)=((aqn).zn);
if(((aqf).zn)===(null)){
if(((aqr).qe)===(1027)){
if(aqk){
(D)((131132),((aqf).qn),(null));
return null;
}
(aqj)=(true);
}
else if(((aqr).qe)===(1028)){
if(aqj){
(D)((131133),((aqf).qn),(null));
return null;
}
(aqk)=(true);
}
else{
if((aqj)&&(!((Fn)((aqr))))){
(D)((131133),((aqf).qn),(null));
return null;
}
if((aqk)&&(!((Fs)((aqr))))){
(D)((131132),((aqf).qn),(null));
return null;
}
(aq6)=(new AP());
(yr)((aq6),(66561),((aqr).qn));
((aq6).AR)=(aqr);
((aqf).zn)=(aq6);
}
}
else if(!((OL)((((aqf).zn).AR),(aqr),(false)))){
(D)((131132),((aqf).qn),(null));
return null;
}
(ty)((aql),([130,134]),(aqn));
(t1)((aql),([130,134]));
}
if(((aqf).zn)===(null)){
if(aqk){
(D)((131134),((aqf).qn),(null));
return null;
}
else{
(D)((131135),((aqf).qn),(null));
return null;
}
}
if((Fs)((((aqf).zn).AR))){
(aqF)=((aqf).an3);
(qt)((aqF),([130,134]));
while(!((qv)((aqF),([130,134])))){
(aqH)=((qx)((aqF),([130,134])));
if((((aqH).zn).qe)===(1028)){
(aqH)=((OO)((aqH),(((aqf).zn).AR)));
(ty)((aqF),([130,134]),(aqH));
(t1)((aqF),([130,134]));
}
else{
(rA)((aqF),([130,134]));
}
}
}
if((Xn)(((aqf).zn))){
(aqN)=(true);
(aqP)=((aqf).an3);
(qt)((aqP),([130,134]));
aqR:
while(!((qv)((aqP),([130,134])))){
if((((qx)((aqP),([130,134]))).qe)!==(67584)){
(aqN)=(false);
break aqR;
}
(rA)((aqP),([130,134]));
}
if(aqN){
(aqW)=(new Ql());
(yP)((aqW),(67586),((aqf).qn));
((aqW).zn)=((aqf).zn);
(aqX)=({S:"\0".repeat(((aqf).an3).L)});
(aqY)=(0);
(aqZ)=((aqf).an3);
(qt)((aqZ),([130,134]));
while(!((qv)((aqZ),([130,134])))){
(aqX).S=(arb=(aqY),(aqX).S.slice(0,arb)+String.fromCharCode(((qx)((aqZ),([130,134]))).zk)+(aqX).S.slice(arb+1));
(rA)((aqZ),([130,134]));
(aqY)=((aqY)+(1));
}
((aqW).ail)=(aqX);
(aqW)=((Qk)((aqW)));
((aqf).zJ)=(aqf);
return (aqf).zJ;
}
}
((aqf).zj)=(1);
return aqf;
}
// rebuildVar
function QB(are /*ast*/){
if(((are).zJ)!==(null)){
return;
}
((are).zJ)=(are);
(zN)(((are).tZ));
}
// rebuildIf
function QY(arh /*ast*/,ari /*retType*/,arj /*parentFunc*/){
let arp=null; // items
let arr=null; // elIf
let ary=null; // stats
let ar5=null; // items
let ar8=null; // elIf
let arH=null; // block_
if(((arh).zJ)!==(null)){
return (arh).zJ;
}
((arh).zJ)=(arh);
((arh).Sp)=((Aj)(((arh).Sp),(false)));
if((((arh).Sp)!==(null))&&(!((agA)((((arh).Sp).zn))))){
(D)((131094),(((arh).Sp).qn),(null));
}
((arh).Sr)=((Rk)(((arh).Sr),(ari),(arj)));
(arp)=((arh).Sx);
(qt)((arp),([130,134]));
while(!((qv)((arp),([130,134])))){
(arr)=((qx)((arp),([130,134])));
((arr).S1)=((Aj)(((arr).S1),(false)));
if((((arr).S1)!==(null))&&(!((agA)((((arr).S1).zn))))){
(D)((131095),(((arr).S1).qn),(null));
}
((arr).S2)=((Rk)(((arr).S2),(ari),(arj)));
(rA)((arp),([130,134]));
}
if(((arh).S4)!==(null)){
((arh).S4)=((Rk)(((arh).S4),(ari),(arj)));
}
if(((arh).Sp)!==(null)){
(ary)=(null);
if((((arh).Sp).qe)!==(67585)){
return arh;
}
if((((arh).Sp).zk)!==(0x0000000000000000)){
(ary)=((arh).Sr);
}
if((ary)!==(null)){
(ar5)=((arh).Sx);
(qt)((ar5),([130,134]));
ar7:
while(!((qv)((ar5),([130,134])))){
(ar8)=((qx)((ar5),([130,134])));
if((((ar8).S1).qe)!==(67585)){
return arh;
}
if((((ar8).S1).zk)!==(0x0000000000000000)){
(ary)=((ar8).S2);
break ar7;
}
(rA)((ar5),([130,134]));
}
if((ary)===(null)){
if(((arh).S4)===(null)){
(arH)=(new y7());
(yr)((arH),(66052),((arh).qn));
((arH).qZ)=({S:"$"});
((arH).y8)=({L:0,H:null,T:null,P:null});
(ary)=(arH);
}
else{
(ary)=((arh).S4);
}
}
}
((arh).Sp)=(null);
((arh).Sr)=(ary);
}
return arh;
}
// rebuildSwitch
function Ra(arJ /*ast*/,arK /*retType*/,arL /*parentFunc*/){
let arT=null; // items
let arV=null; // case_
let arW=null; // items2
let arY=null; // exprs
if(((arJ).zJ)!==(null)){
return (arJ).zJ;
}
((arJ).zJ)=(arJ);
((arJ).SI)=((Aj)(((arJ).SI),(false)));
if(((arJ).SI)!==(null)){
if(!((ah0)((((arJ).SI).zn),(true)))){
(D)((131096),(((arJ).SI).qn),(null));
}
(((arJ).y4).s6)=(((arJ).SI).zn);
}
(arT)=((arJ).SM);
(qt)((arT),([130,134]));
while(!((qv)((arT),([130,134])))){
(arV)=((qx)((arT),([130,134])));
(arW)=((arV).SR);
(qt)((arW),([130,134]));
while(!((qv)((arW),([130,134])))){
(arY)=((qx)((arW),([130,134])));
((arY).zo)=((Aj)(((arY).zo),(false)));
if((((arJ).SI)!==(null))&&(((arY).zo)!==(null))){
if(!((OL)((((arJ).SI).zn),(((arY).zo).zn),(false)))){
(D)((131097),(((arY).zo).qn),(null));
}
else if(((((arY).zo).zn).qe)===(1028)){
((arY).zo)=((OO)(((arY).zo),(((arJ).SI).zn)));
}
}
if(((arY).zt)!==(null)){
((arY).zt)=((Aj)(((arY).zt),(false)));
if((((arJ).SI)!==(null))&&(((arY).zt)!==(null))){
if(!((OL)((((arJ).SI).zn),(((arY).zt).zn),(false)))){
(D)((131097),(((arY).zt).qn),(null));
}
else if(((((arY).zt).zn).qe)===(1028)){
((arY).zt)=((OO)(((arY).zt),(((arJ).SI).zn)));
}
}
}
(rA)((arW),([130,134]));
}
((arV).Tf)=((Rk)(((arV).Tf),(arK),(arL)));
(rA)((arT),([130,134]));
}
if(((arJ).Th)!==(null)){
((arJ).Th)=((Rk)(((arJ).Th),(arK),(arL)));
}
return arJ;
}
// rebuildWhile
function Rc(asn /*ast*/,aso /*retType*/,asp /*parentFunc*/){
if(((asn).zJ)!==(null)){
return (asn).zJ;
}
((asn).zJ)=(asn);
if(((asn).TE)!==(null)){
((asn).TE)=((Aj)(((asn).TE),(false)));
if((((asn).TE)!==(null))&&(!((agA)((((asn).TE).zn))))){
(D)((131098),(((asn).TE).qn),(null));
}
}
((asn).TG)=((zR)(((asn).TG),(aso),(asp)));
return asn;
}
// rebuildFor
function Re(asw /*ast*/,asx /*retType*/,asy /*parentFunc*/){
if(((asw).zJ)!==(null)){
return (asw).zJ;
}
((asw).zJ)=(asw);
((asw).Ug)=((Aj)(((asw).Ug),(false)));
if(((asw).Ug)!==(null)){
if(!((s5)((((asw).Ug).zn)))){
(D)((131099),(((asw).Ug).qn),(null));
}
(((asw).y4).s6)=(((asw).Ug).zn);
}
((asw).Uf)=((Aj)(((asw).Uf),(false)));
if((((asw).Uf)!==(null))&&(!((s5)((((asw).Uf).zn))))){
(D)((131100),(((asw).Uf).qn),(null));
}
((asw).Uh)=((Aj)(((asw).Uh),(false)));
if(((asw).Uh)!==(null)){
if(!((s5)((((asw).Uh).zn)))){
(D)((131101),(((asw).Uh).qn),(null));
}
if((((asw).Uh).qe)!==(67585)){
(D)((131102),(((asw).Uh).qn),(null));
}
if((((asw).Uh).zk)===(0x0000000000000000)){
(D)((131103),(((asw).Uh).qn),(null));
}
}
((asw).Up)=((zR)(((asw).Up),(asx),(asy)));
return asw;
}
// rebuildTry
function Rg(asF /*ast*/,asG /*retType*/,asH /*parentFunc*/){
let asM=null; // items
let asO=null; // catch_
let asP=null; // items2
let asR=null; // exprs
if(((asF).zJ)!==(null)){
return (asF).zJ;
}
((asF).zJ)=(asF);
(zN)(((asF).y4));
((asF).y9)=((Rk)(((asF).y9),(asG),(asH)));
if((((asF).yA).L)!==(0)){
(asM)=((asF).yA);
(qt)((asM),([130,134]));
while(!((qv)((asM),([130,134])))){
(asO)=((qx)((asM),([130,134])));
(asP)=((asO).yY);
(qt)((asP),([130,134]));
while(!((qv)((asP),([130,134])))){
(asR)=((qx)((asP),([130,134])));
((asR).zo)=((Aj)(((asR).zo),(false)));
if((((asR).zo)!==(null))&&((!((s5)((((asR).zo).zn))))||((((asR).zo).qe)!==(67585)))){
(D)((131104),(((asR).zo).qn),(null));
}
if(((asR).zt)!==(null)){
((asR).zt)=((Aj)(((asR).zt),(false)));
if((((asR).zt)!==(null))&&((!((s5)((((asR).zt).zn))))||((((asR).zt).qe)!==(67585)))){
(D)((131104),(((asR).zt).qn),(null));
}
}
(rA)((asP),([130,134]));
}
((asO).zb)=((Rk)(((asO).zb),(asG),(asH)));
(rA)((asM),([130,134]));
}
}
if(((asF).yD)!==(null)){
((asF).yD)=((Rk)(((asF).yD),(asG),(asH)));
}
return asF;
}
// rebuildThrow
function Ri(ata /*ast*/){
if(((ata).zJ)!==(null)){
return (ata).zJ;
}
((ata).zJ)=(ata);
((ata).UV)=((Aj)(((ata).UV),(false)));
if((((ata).UV)!==(null))&&(!((s5)((((ata).UV).zn))))){
(D)((131105),(((ata).UV).qn),(null));
}
return ata;
}
// rebuildBlock
function Rk(atf /*ast*/,atg /*retType*/,ath /*parentFunc*/){
if(((atf).zJ)!==(null)){
return (atf).zJ;
}
((atf).zJ)=(atf);
((atf).y8)=((zR)(((atf).y8),(atg),(ath)));
return atf;
}
// rebuildRet
function Rm(atk /*ast*/,atl /*retType*/){
if(((atk).zJ)!==(null)){
return (atk).zJ;
}
((atk).zJ)=(atk);
if(((atk).Ve)===(null)){
if((atl)!==(null)){
(D)((131106),((atk).qn),(null));
}
}
else{
((atk).Ve)=((Aj)(((atk).Ve),(false)));
if(((atk).Ve)!==(null)){
if(((atl)===(null))||(!((OL)((((atk).Ve).zn),(atl),(false))))){
(D)((131107),((atk).qn),(null));
}
else if(((((atk).Ve).zn).qe)===(1028)){
((atk).Ve)=((OO)(((atk).Ve),(atl)));
}
}
}
return atk;
}
// rebuildDo
function Ro(aty /*ast*/){
let at3=null; // expr
let at4=0; // kind
let at6=0;
let atG=null; // block_
let atI=null; // lhs
let atN=null; // lhs2
let atQ=null; // lhs2
let atR=null; // exprAssign
let atT=null; // exprOne
if(((aty).zJ)!==(null)){
return (aty).zJ;
}
((aty).zJ)=(aty);
if((((aty).yU)!==(null))&&((((aty).yU).qe)===(2050))){
(at3)=((aty).yU);
(at4)=(0);
switch((at3).Ao){
case 1:
(at4)=(19);
break;
case 2:
(at4)=(20);
break;
case 3:
(at4)=(21);
break;
case 4:
(at4)=(22);
break;
case 5:
(at4)=(23);
break;
case 6:
(at4)=(24);
break;
case 7:
(at4)=(18);
break;
}
if((at4)!==(0)){
(atG)=(new y7());
(yr)((atG),(66052),((aty).qn));
((atG).zJ)=(atG);
((atG).qZ)=({S:"$"});
((atG).y4)=(null);
((atG).y8)=({L:0,H:null,T:null,P:null});
(atI)=((Aj)(((at3).Ar),(false)));
if((atI)===(null)){
return null;
}
if(((atI).qe)===(2059)){
(atN)=(atI);
((atN).anu)=((atO)(((atG).y8),((atN).anu),((aty).qn)));
}
else if(((atI).qe)===(2058)){
(atQ)=(atI);
((atQ).aoc)=((atO)(((atG).y8),((atQ).aoc),((aty).qn)));
((atQ).aoh)=((atO)(((atG).y8),((atQ).aoh),((aty).qn)));
}
(atR)=(new An());
(yP)((atR),(2050),((aty).qn));
((atR).Ao)=(0);
((atR).Ar)=(atI);
(atT)=(new An());
(yP)((atT),(2050),((aty).qn));
((atT).Ao)=(at4);
((atT).Ar)=(atI);
((atT).As)=((at3).As);
((atR).As)=(atT);
((aty).yU)=((Aj)((atR),(true)));
(eP)(((atG).y8),([130,134]),(aty));
return atG;
}
}
((aty).yU)=((Aj)(((aty).yU),(true)));
if(((aty).yU)===(null)){
return null;
}
if(!((((((aty).yU).qe)===(2050))&&(((((aty).yU).Ao)===(0))||((((aty).yU).Ao)===(25))))||((((aty).yU).qe)===(2057)))){
(D)((131108),(((aty).yU).qn),(null));
}
return aty;
}
// rebuildBreak
function Rq(atY /*ast*/,atZ /*retType*/,aua /*parentFunc*/){
if(((atY).zJ)!==(null)){
return (atY).zJ;
}
((atY).zJ)=(atY);
if((((atY).q1)===(null))||(((rv)((((atY).q1).qe),([9]),(66048)))!==(66048))){
(D)((131109),((atY).qn),([({S:"break"})]));
return null;
}
((atY).q1)=((At)(((atY).q1),(atZ),(aua)));
return atY;
}
// rebuildSkip
function Rs(auf /*ast*/,aug /*retType*/,auh /*parentFunc*/){
if(((auf).zJ)!==(null)){
return (auf).zJ;
}
((auf).zJ)=(auf);
if((((auf).q1)===(null))||(((rv)((((auf).q1).qe),([9]),(66048)))!==(66048))){
(D)((131109),((auf).qn),([({S:"skip"})]));
return null;
}
((auf).q1)=((At)(((auf).q1),(aug),(auh)));
return auf;
}
// rebuildAssert
function Ru(aum /*ast*/){
if(((aum).zJ)!==(null)){
return (aum).zJ;
}
if(aW){
return null;
}
((aum).zJ)=(aum);
((aum).Vv)=((Aj)(((aum).Vv),(false)));
if((((aum).Vv)!==(null))&&(!((agA)((((aum).Vv).zn))))){
(D)((131110),(((aum).Vv).qn),(null));
}
return aum;
}
// isClass
function R0(aut /*type*/){
return (((aut).qe)===(66565))&&((((aut).q1).qe)===(5));
}
// _fill
function RH(auu /*me_*/,auv /*type*/,auw /*value*/){
if(auv[0]===129&&auv[1]===2)
auu.S=String.fromCharCode(auw).repeat(auu.S.length);
else
auu.fill(auw);
}
// _offset
function RP(aux /*me_*/,auy /*n*/){
return (aux)+(auy);
}
// buildExpr
function Su(auz /*ast*/){
let au1=0;
switch((auz).qe){
case 2049:
(au3)((auz));
break;
case 2050:
(au5)((auz));
break;
case 2051:
(au7)((auz));
break;
case 2052:
(au9)((auz));
break;
case 2053:
(auB)((auz));
break;
case 2054:
(auD)((auz));
break;
case 2055:
(auF)((auz));
break;
case 2056:
(auH)((auz));
break;
case 2057:
(auJ)((auz));
break;
case 2058:
(auL)((auz));
break;
case 2059:
(auN)((auz));
break;
case 67584:
(auP)((auz));
break;
case 67585:
(auR)((auz));
break;
case 67586:
(auT)((auz));
break;
case 67588:
(auV)((auz));
break;
case 2060:
(auX)((auz));
break;
case 2062:
(auZ)((auz));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// isChar
function SJ(avb /*type*/){
return (((avb).qe)===(1026))&&(((avb).y2)===(2));
}
// addTmpVar
function Ue(avc /*type*/){
let avd=null; // tmpVar
(avd)=(new t4());
((avd).t6)=((A8)());
((avd).t5)=(avc);
(eP)((R),([130,134]),(avd));
return (avd).t6;
}
// buildExpr
function Wr(ave /*ast*/){
let avg=0;
switch((ave).qe){
case 2049:
(avi)((ave));
break;
case 2050:
(avk)((ave));
break;
case 2051:
(avm)((ave));
break;
case 2052:
(avo)((ave));
break;
case 2053:
(avq)((ave));
break;
case 2054:
(avs)((ave));
break;
case 2055:
(avu)((ave));
break;
case 2056:
(avw)((ave));
break;
case 2057:
(avy)((ave));
break;
case 2058:
(av0)((ave));
break;
case 2059:
(av2)((ave));
break;
case 67584:
(av4)((ave));
break;
case 67585:
(av6)((ave));
break;
case 67586:
(av8)((ave));
break;
case 67588:
(avA)((ave));
break;
case 2060:
(avC)((ave));
break;
case 2062:
(avE)((ave));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// isStr
function Xn(avG /*type*/){
let avJ=null; // itemType
if(((avG).qe)===(66561)){
(avJ)=((avG).AR);
if((((avJ).qe)===(1026))&&(((avJ).y2)===(2))){
return true;
}
}
return false;
}
// addTmpVar
function XE(avM /*type*/){
let avN=null; // tmpVar
(avN)=(new v7());
((avN).v8)=((Gi)());
((avN).v9)=(avM);
(eP)((an),([130,134]),(avN));
return (avN).v8;
}
// _peekStack
function YI(avO /*me_*/,avP /*type*/){
return avO[avO.length-1];
}
// isReserved
function ZF(avQ /*name*/){
let avX=0;
let avY=0;
if((ac)===(null)){
(ac)=([({S:"alias"}),({S:"assert"}),({S:"bit16"}),({S:"bit32"}),({S:"bit64"}),({S:"bit8"}),({S:"block"}),({S:"bool"}),({S:"break"}),({S:"case"}),({S:"catch"}),({S:"char"}),({S:"class"}),({S:"const"}),({S:"dbg"}),({S:"default"}),({S:"dict"}),({S:"do"}),({S:"elif"}),({S:"else"}),({S:"end"}),({S:"enum"}),({S:"env"}),({S:"false"}),({S:"finally"}),({S:"float"}),({S:"for"}),({S:"func"}),({S:"if"}),({S:"include"}),({S:"inf"}),({S:"int"}),({S:"list"}),({S:"me"}),({S:"null"}),({S:"queue"}),({S:"ret"}),({S:"skip"}),({S:"stack"}),({S:"super"}),({S:"switch"}),({S:"throw"}),({S:"to"}),({S:"true"}),({S:"try"}),({S:"var"}),({S:"while"})]);
avW:
for(avX=(0),avY=(((ac).length)-(2));avX<=avY;avX+=(1)){
if(!(((ac)[avX]).S<((ac)[(avX)+(1)]).S)){throw 0xE9170000;}
}
}
return ((avZ)((ac),([129,129,2]),(avQ)))!==(-1);
}
// parseStatEnd
function abS(awa /*row*/,awb /*col*/,awc /*block_*/){
let awd=null; // ast
let awe=null; // id
let awf=false; // err
let awh=null;
(awd)=(new yw());
(xj)((awd),(513),((xk)((ag),(awa),(awb))),(null),(false));
(awe)=((x2)((true),(false)));
(awf)=(false);
(Mb)((0x000A),(true));
awh=awe;
if(awh.S===({S:"func"}).S){
if(((awc).qe)!==(256)){
(awf)=(true);
}
}
else if(awh.S===({S:"if"}).S){
if(((awc).qe)!==(66049)){
(awf)=(true);
}
}
else if(awh.S===({S:"switch"}).S){
if(((awc).qe)!==(66050)){
(awf)=(true);
}
}
else if(awh.S===({S:"while"}).S){
if(((awc).qe)!==(16843265)){
(awf)=(true);
}
}
else if(awh.S===({S:"for"}).S){
if(((awc).qe)!==(16843266)){
(awf)=(true);
}
}
else if(awh.S===({S:"try"}).S){
if(((awc).qe)!==(66051)){
(awf)=(true);
}
}
else if(awh.S===({S:"block"}).S){
if(((awc).qe)!==(66052)){
(awf)=(true);
}
}
else{(D)((65561),((xk)((ag),(awa),(awb))),([(awe)]));
}
if(awf){
(D)((65562),((xk)((ag),(awa),(awb))),([(awe)]));
}
return awd;
}
// parseStatFunc
function abU(){
let aw6=null; // ast
(aw6)=(new aw7());
(xj)((aw6),(514),(null),(null),(false));
((aw6).aw8)=((x7)((null),(false)));
return aw6;
}
// parseStatVar
function abW(){
let aw9=null; // ast
(aw9)=(new QA());
(xj)((aw9),(515),(null),(null),(false));
((aw9).QC)=((x9)((3),(null)));
return aw9;
}
// parseStatConst
function abY(){
let awA=null; // ast
(awA)=(new awB());
(xj)((awA),(516),(null),(null),(false));
((awA).awC)=((xB)());
return awA;
}
// parseStatAlias
function aca(){
let awD=null; // ast
(awD)=(new awE());
(xj)((awD),(517),(null),(null),(false));
((awD).awF)=((xE)());
return awD;
}
// parseStatClass
function acc(){
let awG=null; // ast
(awG)=(new awH());
(xj)((awG),(518),(null),(null),(false));
((awG).awI)=((xI)());
return awG;
}
// parseStatEnum
function ace(){
let awJ=null; // ast
(awJ)=(new awK());
(xj)((awJ),(519),(null),(null),(false));
((awJ).awL)=((xK)());
return awJ;
}
// parseStatIf
function acg(){
let awM=null; // ast
let awT=null; // stat
let awV=0; // typeId
let awX=null; // elIf
let awQ=null;
let awS=null;
let awU=0;
let awY=null;
let awZ=null;
let axa=0;
let axc=null;
let axd=null;
let axe=0;
(awM)=(new EA());
(xj)((awM),(66049),((KC)()),(null),(false));
((awM).y4)=(null);
((awM).Sx)=({L:0,H:null,T:null,P:null});
((awM).S4)=(null);
(awN)((awM));
(awO)((awM));
((awM).Sp)=((NR)());
(Mb)((0x0029),(true));
(Mb)((0x000A),(true));
((awM).Sr)=((awQ=(awR)((awS={$:(awT)},awS),(awU={$:(awV)},awU),(66049),(awM)),(awT)=awS.$,(awV)=awU.$,awQ));
while((awV)===(520)){
(awX)=(awT);
((awX).S2)=((awY=(awR)((awZ={$:(awT)},awZ),(axa={$:(awV)},axa),(520),(awM)),(awT)=awZ.$,(awV)=axa.$,awY));
(eP)(((awM).Sx),([130,134]),(awX));
}
while((awV)===(521)){
((awM).S4)=((axc=(awR)((axd={$:(awT)},axd),(axe={$:(awV)},axe),(521),(awM)),(awT)=axd.$,(awV)=axe.$,axc));
}
if(!((awV)===(513))){throw 0xE9170000;}
(xU)((ah),([131,134]));
return awM;
}
// parseStatElIf
function aci(axf /*row*/,axg /*col*/,axh /*block_*/){
let axi=null; // ast
(axi)=(new S0());
(xj)((axi),(520),(null),(null),(false));
((axi).S2)=(null);
if(((axh).qe)!==(66049)){
(D)((65566),((xk)((ag),(axf),(axg))),([({S:"if"}),({S:"elif"})]));
(xN)(((xO)()));
return null;
}
(Mb)((0x0028),(true));
((axi).S1)=((NR)());
(Mb)((0x0029),(true));
(Mb)((0x000A),(true));
return axi;
}
// parseStatElse
function ack(axl /*row*/,axm /*col*/,axn /*block_*/){
let axo=null; // ast
(axo)=(new yw());
(xj)((axo),(521),(null),(null),(false));
if(((axn).qe)!==(66049)){
(D)((65566),((xk)((ag),(axl),(axm))),([({S:"if"}),({S:"else"})]));
(xN)(((xO)()));
return null;
}
(Mb)((0x000A),(true));
return axo;
}
// parseStatSwitch
function acm(axr /*row*/,axs /*col*/){
let axt=null; // ast
let axy=null; // stat
let ax4=0; // typeId
let ax8=null; // case_
let ax9=null;
let axA=null;
let axB=0;
let axD=null;
let axE=null;
let axF=0;
(axt)=(new ED());
(xj)((axt),(66050),((KC)()),(null),(false));
((axt).y4)=((axu)(((axt).qn)));
((axt).SM)=({L:0,H:null,T:null,P:null});
((axt).Th)=(null);
(awN)((axt));
(awO)((axt));
((axt).SI)=((NR)());
(Mb)((0x0029),(true));
(Mb)((0x000A),(true));
axx:
while(true){
(axy)=((M6)((axt)));
if((axy)===(null)){
if(pL){
return null;
}
else{
continue axx;
}
}
break axx;
}
(ax4)=((axy).qe);
if(!((((ax4)===(522))||((ax4)===(523)))||((ax4)===(513)))){
(D)((65567),((KC)()),(null));
}
while((ax4)===(522)){
(ax8)=(axy);
((ax8).Tf)=((ax9=(awR)((axA={$:(axy)},axA),(axB={$:(ax4)},axB),(522),(axt)),(axy)=axA.$,(ax4)=axB.$,ax9));
(eP)(((axt).SM),([130,134]),(ax8));
}
while((ax4)===(523)){
((axt).Th)=((axD=(awR)((axE={$:(axy)},axE),(axF={$:(ax4)},axF),(523),(axt)),(axy)=axE.$,(ax4)=axF.$,axD));
}
if(!((ax4)===(513))){throw 0xE9170000;}
(xU)((ah),([131,134]));
return axt;
}
// parseStatCase
function aco(axG /*row*/,axH /*col*/,axI /*block_*/){
let axJ=null; // ast
let axO=null; // exprs
let axP=0; // c
let axW=null; // id
(axJ)=(new SP());
(xj)((axJ),(522),(null),(null),(false));
((axJ).SR)=({L:0,H:null,T:null,P:null});
((axJ).Tf)=(null);
if(((axI).qe)!==(66050)){
(D)((65566),((xk)((ag),(axG),(axH))),([({S:"switch"}),({S:"case"})]));
(xN)(((xO)()));
return null;
}
axN:
while(true){
(axO)=(new ze());
((axO).zo)=((NR)());
((axO).zt)=(null);
(axP)=((xm)());
if((axP)===(0x0000)){
break axN;
}
if((axP)===(0x000A)){
(eP)(((axJ).SR),([130,134]),(axO));
break axN;
}
if((axP)===(0x002C)){
(eP)(((axJ).SR),([130,134]),(axO));
continue axN;
}
(pJ)=(axP);
(axW)=((x2)((true),(false)));
if((axW).S!==({S:"to"}).S){
(D)((65568),((KC)()),([({S:"to"}),(axW)]));
(xN)(((xO)()));
return null;
}
((axO).zt)=((NR)());
(axP)=((xm)());
if((axP)===(0x0000)){
break axN;
}
(eP)(((axJ).SR),([130,134]),(axO));
if((axP)===(0x000A)){
break axN;
}
if((axP)!==(0x002C)){
(LW)((0x002C),(axP));
}
}
return axJ;
}
// parseStatDefault
function acq(ayf /*row*/,ayg /*col*/,ayh /*block_*/){
let ayi=null; // ast
(ayi)=(new yw());
(xj)((ayi),(523),(null),(null),(false));
if(((ayh).qe)!==(66050)){
(D)((65566),((xk)((ag),(ayf),(ayg))),([({S:"switch"}),({S:"default"})]));
(xN)(((xO)()));
return null;
}
(Mb)((0x000A),(true));
return ayi;
}
// parseStatWhile
function acs(){
let ayl=null; // ast
let ayn=0; // c
let ayq=null; // id
let ayw=null; // stat
(ayl)=(new EG());
(xj)((ayl),(16843265),((KC)()),(null),(false));
((ayl).y4)=(null);
((ayl).TM)=(false);
((ayl).TG)=({L:0,H:null,T:null,P:null});
(awN)((ayl));
(awO)((ayl));
((ayl).TE)=((NR)());
(ayn)=((xm)());
if((ayn)===(0x002C)){
(ayq)=((x2)((true),(false)));
if((ayq).S!==({S:"skip"}).S){
(D)((65568),((KC)()),([({S:"skip"}),(ayq)]));
}
((ayl).TM)=(true);
}
else{
(pJ)=(ayn);
}
(Mb)((0x0029),(true));
(Mb)((0x000A),(true));
ayv:
while(true){
(ayw)=((M6)((ayl)));
if((ayw)===(null)){
if(pL){
return null;
}
else{
continue ayv;
}
}
if(((ayw).qe)===(513)){
break ayv;
}
(eP)(((ayl).TG),([130,134]),(ayw));
}
(xU)((ah),([131,134]));
return ayl;
}
// parseStatFor
function acu(ay4 /*row*/,ay5 /*col*/){
let ay6=null; // ast
let ay8=0; // c
let ayF=null; // stat
(ay6)=(new EK());
(xj)((ay6),(16843266),((KC)()),(null),(false));
((ay6).y4)=((axu)(((ay6).qn)));
((ay6).Up)=({L:0,H:null,T:null,P:null});
(awN)((ay6));
(awO)((ay6));
((ay6).Ug)=((NR)());
(Mb)((0x002C),(true));
((ay6).Uf)=((NR)());
(ay8)=((xm)());
if((ay8)===(0x002C)){
((ay6).Uh)=((NR)());
(Mb)((0x0029),(true));
(Mb)((0x000A),(true));
}
else{
((ay6).Uh)=((ayC)(((KC)()),(0),(0x0000000000000001)));
(pJ)=(ay8);
(Mb)((0x0029),(true));
(Mb)((0x000A),(true));
}
ayE:
while(true){
(ayF)=((M6)((ay6)));
if((ayF)===(null)){
if(pL){
return null;
}
else{
continue ayE;
}
}
if(((ayF).qe)===(513)){
break ayE;
}
(eP)(((ay6).Up),([130,134]),(ayF));
}
(xU)((ah),([131,134]));
return ay6;
}
// parseStatTry
function acw(ayN /*row*/,ayO /*col*/){
let ayP=null; // ast
let ayR=0; // c
let ayW=null; // type
let aza=null; // stat
let azc=0; // typeId
let aze=null; // catch_
let ayY=null;
let ayZ=null;
let azb=0;
let azf=null;
let azg=null;
let azh=0;
let azk=null;
let azl=null;
let azm=0;
(ayP)=(new yu());
(xj)((ayP),(66051),((KC)()),(null),(false));
((ayP).y4)=((axu)(((ayP).qn)));
((ayP).yA)=({L:0,H:null,T:null,P:null});
((ayP).yD)=(null);
(awN)((ayP));
(ayR)=((xm)());
if((ayR)!==(0x000A)){
(pJ)=(ayR);
((ayP).qZ)=((x2)((true),(false)));
(Mf)((ayP),(true));
(Mb)((0x000A),(true));
}
else{
((ayP).qZ)=({S:"$"});
}
(ayW)=(new y1());
(xj)((ayW),(1026),((xk)((ag),(ayN),(ayO))),(null),(false));
((ayW).y2)=(0);
(((ayP).y4).s6)=(ayW);
((ayP).y9)=((ayY=(awR)((ayZ={$:(aza)},ayZ),(azb={$:(azc)},azb),(66051),(ayP)),(aza)=ayZ.$,(azc)=azb.$,ayY));
while((azc)===(524)){
(aze)=(aza);
((aze).zb)=((azf=(awR)((azg={$:(aza)},azg),(azh={$:(azc)},azh),(524),(ayP)),(aza)=azg.$,(azc)=azh.$,azf));
(eP)(((ayP).yA),([130,134]),(aze));
}
if((azc)===(525)){
((ayP).yD)=((azk=(awR)((azl={$:(aza)},azl),(azm={$:(azc)},azm),(525),(ayP)),(aza)=azl.$,(azc)=azm.$,azk));
}
if(!((azc)===(513))){throw 0xE9170000;}
(xU)((ah),([131,134]));
return ayP;
}
// parseStatCatch
function acy(azn /*row*/,azo /*col*/,azp /*block_*/){
let azq=null; // ast
let azu=0; // c
let azx=null; // exprs
let azy=null; // pos
let az2=null; // exprs
let az9=null; // id
(azq)=(new yX());
(xj)((azq),(524),(null),(null),(false));
((azq).yY)=({L:0,H:null,T:null,P:null});
((azq).zb)=(null);
if(((azp).qe)!==(66051)){
(D)((65566),((xk)((ag),(azn),(azo))),([({S:"try"}),({S:"catch"})]));
(xN)(((xO)()));
return null;
}
(azu)=((xm)());
if((azu)===(0x000A)){
(azx)=(new ze());
(azy)=((KC)());
((azx).zo)=((ayC)((azy),(0),(0x0000000000000000)));
((azx).zt)=((ayC)((azy),(0),(0x00000000FFFFFFFF)));
(eP)(((azq).yY),([130,134]),(azx));
}
else{
(pJ)=(azu);
az1:
while(true){
(az2)=(new ze());
((az2).zo)=((NR)());
((az2).zt)=(null);
(azu)=((xm)());
if((azu)===(0x0000)){
break az1;
}
if((azu)===(0x000A)){
(eP)(((azq).yY),([130,134]),(az2));
break az1;
}
if((azu)===(0x002C)){
(eP)(((azq).yY),([130,134]),(az2));
continue az1;
}
(pJ)=(azu);
(az9)=((x2)((true),(false)));
if((az9).S!==({S:"to"}).S){
(D)((65568),((KC)()),([({S:"to"}),(az9)]));
}
((az2).zt)=((NR)());
(azu)=((xm)());
if((azu)===(0x0000)){
break az1;
}
(eP)(((azq).yY),([130,134]),(az2));
if((azu)===(0x000A)){
break az1;
}
if((azu)!==(0x002C)){
(LW)((0x002C),(azu));
}
}
}
return azq;
}
// parseStatFinally
function ac0(azI /*row*/,azJ /*col*/,azK /*block_*/){
let azL=null; // ast
(azL)=(new yw());
(xj)((azL),(525),(null),(null),(false));
if(((azK).qe)!==(66051)){
(D)((65566),((xk)((ag),(azI),(azJ))),([({S:"try"}),({S:"finally"})]));
(xN)(((xO)()));
return null;
}
(Mb)((0x000A),(true));
return azL;
}
// parseStatThrow
function ac2(){
let azO=null; // ast
(azO)=(new EP());
(xj)((azO),(526),((KC)()),(null),(false));
((azO).UV)=((NR)());
(Mb)((0x000A),(true));
return azO;
}
// parseStatBlock
function ac4(){
let azP=null; // ast
let azR=0; // c
let azX=null; // stat
(azP)=(new y7());
(xj)((azP),(66052),((KC)()),(null),(false));
((azP).y4)=(null);
((azP).y8)=({L:0,H:null,T:null,P:null});
(awN)((azP));
(azR)=((xm)());
if((azR)!==(0x000A)){
(pJ)=(azR);
((azP).qZ)=((x2)((true),(false)));
(Mf)((azP),(true));
(Mb)((0x000A),(true));
}
else{
((azP).qZ)=({S:"$"});
}
azW:
while(true){
(azX)=((M6)((azP)));
if((azX)===(null)){
if(pL){
return null;
}
else{
continue azW;
}
}
if(((azX).qe)===(513)){
break azW;
}
(eP)(((azP).y8),([130,134]),(azX));
}
(xU)((ah),([131,134]));
return azP;
}
// parseStatRet
function ac6(){
let a0f=null; // ast
let a0h=0; // c
(a0f)=(new EU());
(xj)((a0f),(527),((KC)()),(null),(false));
(a0h)=((xm)());
if((a0h)!==(0x000A)){
(pJ)=(a0h);
((a0f).Ve)=((NR)());
(Mb)((0x000A),(true));
}
else{
((a0f).Ve)=(null);
}
return a0f;
}
// parseStatDo
function ac8(){
let a0l=null; // ast
(a0l)=(new yK());
(xj)((a0l),(528),((KC)()),(null),(false));
((a0l).yU)=((NR)());
(Mb)((0x000A),(true));
return a0l;
}
// parseStatBreak
function acA(){
let a0m=null; // ast
(a0m)=(new yw());
(xj)((a0m),(529),((KC)()),(null),(false));
(Ma)((a0m),((x2)((true),(false))));
(Mb)((0x000A),(true));
return a0m;
}
// parseStatSkip
function acC(){
let a0n=null; // ast
(a0n)=(new yw());
(xj)((a0n),(530),((KC)()),(null),(false));
(Ma)((a0n),((x2)((true),(false))));
(Mb)((0x000A),(true));
return a0n;
}
// parseStatAssert
function acE(){
let a0o=null; // ast
(a0o)=(new Fd());
(xj)((a0o),(531),((KC)()),(null),(false));
((a0o).Vv)=((NR)());
(Mb)((0x000A),(true));
return a0o;
}
// parseExprThree
function acJ(){
let a0p=null; // ast
let a0t=0; // row
let a0u=0; // col
let a0v=0; // c
let a0y=null; // ast2
(a0p)=((a0q)());
a0s:
while(true){
(a0t)=(pH);
(a0u)=(pI);
(a0v)=((xm)());
if((a0v)===(0x003F)){
(Mb)((0x0028),(false));
(a0y)=(new PH());
(NW)((a0y),(2051),((xk)((ag),(a0t),(a0u))));
((a0y).ak1)=(a0p);
((a0y).ak4)=((NR)());
(Mb)((0x002C),(true));
((a0y).ak7)=((NR)());
(a0p)=(a0y);
(Mb)((0x0029),(true));
}
else{
(pJ)=(a0v);
break a0s;
}
}
return a0p;
}
// readInStr
function ads(){
let a02=0; // c
let a04=0;
a01:
while(true){
(a02)=((K1)());
switch(a02){
case 0x0009:
(D)((65540),((KC)()),(null));
continue a01;
break;
case 0x000A:
(D)((65541),((KC)()),(null));
break;
}
return a02;
}
}
// searchEnumElementValue
function afv(a07 /*ast*/,a08 /*enum_*/){
let a09=null; // name
let a0A=null; // items
let a0C=null; // item
if(!((((a07).zn).qe)===(1028))){throw 0xE9170000;}
(Pf)((a08));
(a09)=((a07).ah7);
(a0A)=((a08).NA);
(qt)((a0A),([130,134]));
while(!((qv)((a0A),([130,134])))){
(a0C)=((qx)((a0A),([130,134])));
if((a09).S===((a0C).qZ).S){
if(((a0C).qe)!==(67585)){
return 0x0000000000000000;
}
return (a0C).zk;
}
(rA)((a0A),([130,134]));
}
(D)((131090),((a07).qn),([(a09)]));
return 0x0000000000000000;
}
// process1
function af3(a0H /*ast*/,a0I /*dtor*/,a0J /*copy*/,a0K /*toBin*/,a0L /*fromBin*/){
let a0O=null; // parent
let a0T=null; // parent
let a0U=null; // chk
let a0Z=false;
let a1c=null; // astItems
let a1e=null; // item
let a1g=null; // def
let a1j=null; // memberName
let a1m=null; // parentItem
let a1o=null; // parent
let a1q=null; // items
let a1s=null; // item2
let a1t=null; // def
let a1w=null; // parentName
let a1C=null; // func1
let a1D=null; // func2
let a1G=null; // items1
let a1H=null; // items2
let a1K=0;
let a1M=null; // arg1
let a1N=null; // arg2
let a1R=null;
let a1T=null; // func_
let a1X=0;
let a2e=null; // def
let a2h=0; // idx
let a2o=null; // type
let a2r=null; // type
let a2t=null; // type2
let a2x=null; // arg
let a2z=null; // type
let a21=null; // type2
let a23=null; // arg
let a25=null; // type
let a0X=false;
let a0Y=false;
let a1L=0;
if(((a0H).q1)!==(null)){
(a0O)=((a0H).q1);
if(((a0O).qe)===(4)){
(Ph)((a0O),(null));
((a0H).q1)=(((a0O).MJ).q1);
if(!((((a0H).q1).qe)===(5))){throw 0xE9170000;}
}
else{
if(!(((a0O).qe)===(5))){throw 0xE9170000;}
(Pd)((a0O));
}
}
(a0T)=(a0H);
(a0U)=(new Map());
while((a0T)!==(null)){
if((a0X=(pT)((a0U),([133,134,3]),(a0T),(a0Y={$:(a0Z)},a0Y)),(a0Z)=a0Y.$,a0X)){
(D)((131080),((a0H).qn),([((a0H).qZ)]));
return;
}
(bE)((a0U),([133,134,3]),(a0T),(true));
(a0T)=((a0T).q1);
}
(a1c)=((a0H).ti);
(qt)((a1c),([130,134]));
while(!((qv)((a1c),([130,134])))){
(a1e)=((qx)((a1c),([130,134])));
(a1g)=((a1e).tU);
if(((a1g).qe)===(2)){
(a1j)=(((a1g).tZ).qZ);
}
else if(((a1g).qe)===(3)){
(a1j)=(((a1g).xS).qZ);
}
else{
(a1j)=((a1g).qZ);
}
(a1m)=(null);
(a1o)=((a0H).q1);
while(((a1m)===(null))&&((a1o)!==(null))){
(a1q)=((a1o).ti);
(qt)((a1q),([130,134]));
while(!((qv)((a1q),([130,134])))){
(a1s)=((qx)((a1q),([130,134])));
(a1t)=((a1s).tU);
if(((a1t).qe)===(2)){
(a1w)=(((a1t).tZ).qZ);
}
else if(((a1t).qe)===(3)){
(a1w)=(((a1t).xS).qZ);
}
else{
(a1w)=((a1t).qZ);
}
if((a1j).S===(a1w).S){
(a1m)=(a1s);
}
(rA)((a1q),([130,134]));
}
(a1o)=((a1o).q1);
}
if((a1m)===(null)){
if((a1e).Ne){
(D)((131081),(((a1e).tU).qn),([(a1j)]));
return;
}
}
else{
if(!((a1e).Ne)){
(D)((131082),(((a1e).tU).qn),([(a1j)]));
return;
}
if(!(((((a1e).tU).qe)===(256))&&((((a1m).tU).qe)===(256)))){
(D)((131083),(((a1e).tU).qn),([(a1j)]));
return;
}
if(((a1e).Nd)!==((a1m).Nd)){
(D)((131084),(((a1e).tU).qn),([(a1j)]));
return;
}
(a1C)=((a1e).tU);
(a1D)=((a1m).tU);
if(((((((a1C).qj)===(null))&&(((a1D).qj)!==(null)))||((((a1C).qj)!==(null))&&(((a1D).qj)===(null))))||(((((a1C).qj)!==(null))&&(((a1D).qj)!==(null)))&&(!((OL)(((a1C).qj),((a1D).qj),(false))))))||((((a1C).qi).L)!==(((a1D).qi).L))){
(D)((131085),(((a1e).tU).qn),([(a1j)]));
return;
}
(a1G)=((a1C).qi);
(a1H)=((a1D).qi);
(qt)((a1G),([130,134]));
(qt)((a1H),([130,134]));
a1J:
for(a1K=(0),a1L=(((a1G).L)-(1));a1K<=a1L;a1K+=(1)){
(a1M)=((qx)((a1G),([130,134])));
(a1N)=((qx)((a1H),([130,134])));
if(((((((((a1M).s6).qe)===(66565))&&((((a1M).s6).q1)===(null)))||(((((a1N).s6).qe)===(66565))&&((((a1N).s6).q1)===(null))))||(!((OL)(((a1M).s6),((a1N).s6),(false)))))||(((((a1M).qZ)!==(null))&&(((a1N).qZ)!==(null)))&&(((a1M).qZ).S!==((a1N).qZ).S)))||(((a1M).sL)!==((a1N).sL))){
(D)((131085),(((a1e).tU).qn),([(a1j)]));
return;
}
(rA)((a1G),([130,134]));
(rA)((a1H),([130,134]));
}
((a1e).Nf)=(a1m);
}
a1R=a1j;
if(a1R.S===({S:"_dtor"}).S||a1R.S===({S:"_copy"}).S||a1R.S===({S:"_toBin"}).S||a1R.S===({S:"_fromBin"}).S){
if(!((((a1e).tU).qe)===(256))){throw 0xE9170000;}
(a1T)=((a1e).tU);
if(((a1e).Ne)&&(((rv)((((a1e).tU).qk),([9]),(128)))===(0))){
(D)((131086),((a1T).qn),([(a1j)]));
return;
}
switch((a1j).S.charCodeAt(1)){
case 0x0064:
(a0I.$)=(a1T);
break;
case 0x0063:
(a0J.$)=(a1T);
break;
case 0x0074:
(a0K.$)=(a1T);
break;
case 0x0066:
(a0L.$)=(a1T);
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{(a2e)=((a1e).tU);
if(((a2e).qe)===(256)){
(a2h)=((tp)((a1c),([130,134])));
if(!((a2h)!==(-1))){throw 0xE9170000;}
(rF)((a2e));
(qt)((a1c),([130,134]));
(ts)((a1c),([130,134]),(a2h));
}
else if(((a2e).qe)===(2)){
(QB)((a2e));
}
}
(rA)((a1c),([130,134]));
}
if((a0I.$)===(null)){
(a0I.$)=((a2l)((a0H),({S:"_dtor"})));
}
if((a0J.$)===(null)){
(a0J.$)=((a2l)((a0H),({S:"_copy"})));
(a2o)=(new Mi());
(yr)((a2o),(66565),((a0H).qn));
((a2o).q1)=(a0H);
((a0J.$).qj)=(a2o);
}
if((a0K.$)===(null)){
(a0K.$)=((a2l)((a0H),({S:"_toBin"})));
(a2r)=(new AP());
(yr)((a2r),(66561),((a0H).qn));
(a2t)=(new AT());
(yr)((a2t),(1025),((a0H).qn));
((a2t).AU)=(1);
((a2r).AR)=(a2t);
((a0K.$).qj)=(a2r);
}
if((a0L.$)===(null)){
(a0L.$)=((a2l)((a0H),({S:"_fromBin"})));
(a2x)=(new rq());
(yr)((a2x),(7),((a0H).qn));
((a2x).rr)=(2);
((a2x).sL)=(false);
((a2x).y3)=(null);
(a2z)=(new AP());
(yr)((a2z),(66561),((a0H).qn));
(a21)=(new AT());
(yr)((a21),(1025),((a0H).qn));
((a21).AU)=(1);
((a2z).AR)=(a21);
((a2x).s6)=(a2z);
(eP)(((a0L.$).qi),([130,134]),(a2x));
(a23)=(new rq());
(yr)((a23),(7),((a0H).qn));
((a23).rr)=(2);
((a23).sL)=(true);
((a23).y3)=(null);
(a25)=(new y1());
(yr)((a25),(1026),((a0H).qn));
((a25).y2)=(0);
((a23).s6)=(a25);
(eP)(((a0L.$).qi),([130,134]),(a23));
(qt)(((a0L.$).qi),([130,134]));
((a0L.$).qj)=(((qx)(((a0L.$).qi),([130,134]))).s6);
}
}
// process2
function af8(a26 /*ast*/,a27 /*dtor*/,a28 /*copy*/,a29 /*toBin*/,a2A /*fromBin*/){
let a2C=null; // ptr
let a2E=null; // items
let a2G=null; // item
let a2J=null; // do_
let a2L=null; // assign
let a2P=null; // var_
let a2R=null; // var2
let a2T=null; // arg
let a2V=null; // type
let a2X=null; // new_
let a2Z=null; // result
let a3b=null; // type
let a3d=null; // ptr
let a3f=null; // items
let a3h=null; // item
let a3k=null; // member
let a3m=null; // do_
let a3o=null; // assign
let a3q=null; // dot
let a3t=null; // copy2
let a3w=null; // ret_
let a3y=null; // as
let a31=null; // var_
let a33=null; // var2
let a35=null; // arg
let a37=null; // new_
let a39=null; // value
let a3B=null; // prim
let a3D=null; // type
let a3F=null; // type
let a3H=null; // type2
let a3J=null; // result
let a3L=null; // type
let a3N=null; // ptr
let a3P=null; // items
let a3R=null; // item
let a3U=null; // member
let a3W=null; // do_
let a3Y=null; // assign
let a4a=null; // expr
let a4c=null; // array_
let a4e=null; // bit
let a4g=null; // ret_
let a4j=null; // var_
let a4l=null; // var2
let a4n=null; // arg
let a4p=null; // new_
let a4r=null; // result
let a4t=null; // type
let a4v=null; // ptr
let a4x=null; // items
let a4z=null; // item
let a42=null; // member
let a44=null; // do_
let a46=null; // assign
let a48=null; // dot
let a4A=null; // expr
let a4C=null; // ref
let a4E=null; // ref
let a4G=null; // ret_
(a2C)=(a26);
while((a2C)!==(null)){
(a2E)=((a2C).ti);
(qt)((a2E),([130,134]));
while(!((qv)((a2E),([130,134])))){
(a2G)=((qx)((a2E),([130,134])));
if(((((a2G).tU).qe)===(2))&&((Av)(((((a2G).tU).tZ).s6)))){
(a2J)=(new yK());
(yr)((a2J),(528),((a26).qn));
(a2L)=(new An());
(yP)((a2L),(2050),((a26).qn));
((a2L).Ao)=(0);
(qt)(((a27).qi),([130,134]));
((a2L).Ar)=((a2M)((a26),((qx)(((a27).qi),([130,134]))),((((a2G).tU).tZ).qZ)));
((a2L).As)=((A2)(((a26).qn)));
((a2J).yU)=(a2L);
(eP)(((a27).tr),([130,134]),((At)((a2J),((a27).qj),(a27))));
}
(rA)((a2E),([130,134]));
}
(a2C)=((a2C).q1);
}
(a2P)=(new QA());
(yr)((a2P),(515),((a26).qn));
(a2R)=(new tX());
(yr)((a2R),(2),((a26).qn));
(a2T)=(new rq());
(yr)((a2T),(7),((a26).qn));
((a2T).rr)=(3);
((a2T).sL)=(false);
(a2V)=(new Mi());
(yr)((a2V),(66565),((a26).qn));
((a2V).q1)=(a26);
((a2T).s6)=(a2V);
(a2X)=(new PK());
(yP)((a2X),(2052),((a26).qn));
((a2X).akR)=((a2T).s6);
((a2T).y3)=(a2X);
((a2R).tZ)=(a2T);
((a2P).QC)=(a2R);
(eP)(((a28).tr),([130,134]),((At)((a2P),((a28).qj),(a28))));
(a2Z)=(new yO());
(yP)((a2Z),(2062),((a26).qn));
((a2Z).q2)=({S:"me"});
((a2Z).q1)=(((a2P).QC).tZ);
(a3b)=(new Mi());
(yr)((a3b),(66565),((a26).qn));
((a3b).q1)=(a26);
((a2Z).zn)=(a3b);
(a3d)=(a26);
while((a3d)!==(null)){
(a3f)=((a3d).ti);
(qt)((a3f),([130,134]));
while(!((qv)((a3f),([130,134])))){
(a3h)=((qx)((a3f),([130,134])));
if((((a3h).tU).qe)===(2)){
(a3k)=(((a3h).tU).tZ);
(a3m)=(new yK());
(yr)((a3m),(528),((a26).qn));
(a3o)=(new An());
(yP)((a3o),(2050),((a26).qn));
((a3o).Ao)=(0);
(a3q)=(new Qe());
(yP)((a3q),(2059),((a26).qn));
((a3q).anu)=(a2Z);
((a3q).ao0)=((a3k).qZ);
((a3q).aoD)=(null);
((a3o).Ar)=(a3q);
if((Av)(((a3k).s6))){
(a3t)=(new PC());
(yP)((a3t),(2049),((a26).qn));
((a3t).agr)=(3);
(qt)(((a28).qi),([130,134]));
((a3t).agl)=((a2M)((a26),((qx)(((a28).qi),([130,134]))),((a3k).qZ)));
((a3o).As)=(a3t);
}
else{
(qt)(((a28).qi),([130,134]));
((a3o).As)=((a2M)((a26),((qx)(((a28).qi),([130,134]))),((a3k).qZ)));
}
((a3m).yU)=(a3o);
(eP)(((a28).tr),([130,134]),((At)((a3m),((a28).qj),(a28))));
}
(rA)((a3f),([130,134]));
}
(a3d)=((a3d).q1);
}
(a3w)=(new EU());
(yr)((a3w),(527),((a26).qn));
(a3y)=(new PQ());
(yP)((a3y),(2054),((a26).qn));
((a3y).al6)=(0);
((a3y).aly)=(a2Z);
((a3y).al1)=((a28).qj);
((a3w).Ve)=(a3y);
(eP)(((a28).tr),([130,134]),((At)((a3w),((a28).qj),(a28))));
(a31)=(new QA());
(yr)((a31),(515),((a26).qn));
(a33)=(new tX());
(yr)((a33),(2),((a26).qn));
(a35)=(new rq());
(yr)((a35),(7),((a26).qn));
((a35).rr)=(3);
((a35).sL)=(false);
(a37)=(new PN());
(yP)((a37),(2053),((a26).qn));
((a37).ald)=({L:0,H:null,T:null,P:null});
(a39)=(new zh());
(yP)((a39),(67585),((a26).qn));
((a39).zk)=(0x0000000000000008);
(a3B)=(new y1());
(yr)((a3B),(1026),((a26).qn));
((a3B).y2)=(0);
((a39).zn)=(a3B);
(eP)(((a37).ald),([130,134]),(a39));
(a3D)=(new AT());
(yr)((a3D),(1025),((a26).qn));
((a3D).AU)=(1);
((a37).all)=(a3D);
((a35).y3)=(a37);
(a3F)=(new AP());
(yr)((a3F),(66561),((a26).qn));
(a3H)=(new AT());
(yr)((a3H),(1025),((a26).qn));
((a3H).AU)=(1);
((a3F).AR)=(a3H);
((a35).s6)=(a3F);
((a33).tZ)=(a35);
((a31).QC)=(a33);
(eP)(((a29).tr),([130,134]),((At)((a31),((a29).qj),(a29))));
(a3J)=(new yO());
(yP)((a3J),(2062),((a26).qn));
((a3J).q1)=(((a31).QC).tZ);
(a3L)=(new Mi());
(yr)((a3L),(66565),((a26).qn));
((a3L).q1)=(a26);
((a3J).zn)=(a3L);
(a3N)=(a26);
while((a3N)!==(null)){
(a3P)=((a3N).ti);
(qt)((a3P),([130,134]));
while(!((qv)((a3P),([130,134])))){
(a3R)=((qx)((a3P),([130,134])));
if((((a3R).tU).qe)===(2)){
(a3U)=(((a3R).tU).tZ);
(a3W)=(new yK());
(yr)((a3W),(528),((a26).qn));
(a3Y)=(new An());
(yP)((a3Y),(2050),((a26).qn));
((a3Y).Ao)=(7);
((a3Y).Ar)=(a3J);
(a4a)=(new PT());
(yP)((a4a),(2055),((a26).qn));
(qt)(((a29).qi),([130,134]));
((a4a).amK)=((a2M)((a26),((qx)(((a29).qi),([130,134]))),((a3U).qZ)));
(a4c)=(new AP());
(yr)((a4c),(66561),((a26).qn));
(a4e)=(new AT());
(yr)((a4e),(1025),((a26).qn));
((a4e).AU)=(1);
((a4c).AR)=(a4e);
((a4a).amQ)=(a4c);
((a3Y).As)=(a4a);
((a3W).yU)=(a3Y);
(eP)(((a29).tr),([130,134]),((At)((a3W),((a29).qj),(a29))));
}
(rA)((a3P),([130,134]));
}
(a3N)=((a3N).q1);
}
(a4g)=(new EU());
(yr)((a4g),(527),((a26).qn));
((a4g).Ve)=(a3J);
(eP)(((a29).tr),([130,134]),((At)((a4g),((a29).qj),(a29))));
(a4j)=(new QA());
(yr)((a4j),(515),((a26).qn));
(a4l)=(new tX());
(yr)((a4l),(2),((a26).qn));
(a4n)=(new rq());
(yr)((a4n),(7),((a26).qn));
((a4n).rr)=(3);
((a4n).sL)=(false);
(qt)(((a2A).qi),([130,134]));
((a4n).s6)=(((qx)(((a2A).qi),([130,134]))).s6);
(a4p)=(new PK());
(yP)((a4p),(2052),((a26).qn));
((a4p).akR)=((a4n).s6);
((a4n).y3)=(a4p);
((a4l).tZ)=(a4n);
((a4j).QC)=(a4l);
(eP)(((a2A).tr),([130,134]),((At)((a4j),((a2A).qj),(a2A))));
(a4r)=(new yO());
(yP)((a4r),(2062),((a26).qn));
((a4r).q1)=(((a4j).QC).tZ);
((a4r).q2)=({S:"me"});
(a4t)=(new Mi());
(yr)((a4t),(66565),((a26).qn));
((a4t).q1)=(a26);
((a4r).zn)=(a4t);
(a4v)=(a26);
while((a4v)!==(null)){
(a4x)=((a4v).ti);
(qt)((a4x),([130,134]));
while(!((qv)((a4x),([130,134])))){
(a4z)=((qx)((a4x),([130,134])));
if((((a4z).tU).qe)===(2)){
(a42)=(((a4z).tU).tZ);
(a44)=(new yK());
(yr)((a44),(528),((a26).qn));
(a46)=(new An());
(yP)((a46),(2050),((a26).qn));
((a46).Ao)=(0);
(a48)=(new Qe());
(yP)((a48),(2059),((a26).qn));
((a48).aoD)=(null);
((a48).anu)=(a4r);
((a48).ao0)=((a42).qZ);
((a46).Ar)=(a48);
(a4A)=(new PW());
(yP)((a4A),(2056),((a26).qn));
(a4C)=(new yO());
(yP)((a4C),(2062),((a26).qn));
(qt)(((a2A).qi),([130,134]));
(rA)(((a2A).qi),([130,134]));
((a4C).q1)=((qx)(((a2A).qi),([130,134])));
if(!(((a4C).q1)!==(null))){throw 0xE9170000;}
((a4A).amV)=(a4C);
((a4A).ana)=((a42).s6);
(a4E)=(new yO());
(yP)((a4E),(2062),((a26).qn));
(qt)(((a2A).qi),([130,134]));
(rA)(((a2A).qi),([130,134]));
(rA)(((a2A).qi),([130,134]));
((a4E).q1)=((qx)(((a2A).qi),([130,134])));
if(!(((a4E).q1)!==(null))){throw 0xE9170000;}
((a4A).anb)=(a4E);
((a46).As)=(a4A);
((a44).yU)=(a46);
(eP)(((a2A).tr),([130,134]),((At)((a44),((a2A).qj),(a2A))));
}
(rA)((a4x),([130,134]));
}
(a4v)=((a4v).q1);
}
(a4G)=(new EU());
(yr)((a4G),(527),((a26).qn));
((a4G).Ve)=(a4r);
(eP)(((a2A).tr),([130,134]),((At)((a4G),((a2A).qj),(a2A))));
}
// isFloat
function agu(a4H /*type*/){
return (((a4H).qe)===(1026))&&(((a4H).y2)===(1));
}
// isBool
function agA(a4I /*type*/){
return (((a4I).qe)===(1026))&&(((a4I).y2)===(3));
}
// isComparable
function ah0(a4J /*type*/,a4K /*lessOrGreater*/){
if((((((((((a4J).qe)===(1025))||((s5)((a4J))))||((agu)((a4J))))||((SJ)((a4J))))||((Fs)((a4J))))||((R0)((a4J))))||((Xn)((a4J))))||(((a4J).qe)===(1028))){
return true;
}
if((!(a4K))&&((agA)((a4J)))){
return true;
}
return false;
}
// cmp
function aik(a4P /*s1*/,a4Q /*s2*/){
let a4R=0; // p
(a4R)=(0);
while(((a4R)<((a4P).S.length))&&((a4R)<((a4Q).S.length))){
if(((a4P).S.charCodeAt(a4R))!==((a4Q).S.charCodeAt(a4R))){
return (((a4P).S.charCodeAt(a4R))>((a4Q).S.charCodeAt(a4R)))?(1):((((a4P).S.charCodeAt(a4R))<((a4Q).S.charCodeAt(a4R)))?(-1):(0));
}
(a4R)=((a4R)+(1));
}
return (((a4P).S.length)>((a4Q).S.length))?(1):((((a4P).S.length)<((a4Q).S.length))?(-1):(0));
}
// bitCast
function aj7(a4W /*size*/,a4X /*n*/){
let a4Z=0;
switch(a4W){
case 1:
return a4X;
break;
case 2:
return a4X;
break;
case 4:
return a4X;
break;
case 8:
return a4X;
if(!(false)){throw 0xE9170000;}
break;
}
return 0x0000000000000000;
}
// getTypeName
function anG(a5e /*type*/){
let a5i=0;
let a5m=null; // type2
let a5n=null; // s
let a5o=false; // first
let a5p=null; // items
let a5r=null; // arg
let a56=null; // type2
let a58=0;
let a5A=null; // s
let a5F=null; // type2
let a5H=null; // type2
let a5J=0;
if((a5e)===(null)){
return {S:""};
}
switch((a5e).qe){
case 66561:
return {S:({S:"[]"}).S+((anG)(((a5e).AR))).S};
break;
case 1025:
return {S:({S:"bit"}).S+((v)((((a5e).AU)*(8)),([0]))).S};
break;
case 66562:
(a5m)=(a5e);
(a5n)=({S:"func<("});
(a5o)=(true);
(a5p)=((a5m).Be);
(qt)((a5p),([130,134]));
while(!((qv)((a5p),([130,134])))){
(a5r)=((qx)((a5p),([130,134])));
if(a5o){
(a5o)=(false);
}
else{
(a5n)=({S:(a5n).S+({S:", "}).S});
}
if((a5r).Bp){
(a5n)=({S:(a5n).S+({S:"&"}).S});
}
(a5n)=({S:(a5n).S+((anG)(((a5r).Bn))).S});
(rA)((a5p),([130,134]));
}
if(((a5m).AZ)===(null)){
(a5n)=({S:(a5n).S+({S:")>"}).S});
}
else{
(a5n)=({S:(a5n).S+({S:({S:({S:"): "}).S+((anG)(((a5m).AZ))).S}).S+({S:">"}).S}).S});
}
return a5n;
break;
case 66563:
(a56)=(a5e);
switch((a56).Bx){
case 0:
(a5A)=({S:"list<"});
break;
case 1:
(a5A)=({S:"stack<"});
break;
case 2:
(a5A)=({S:"queue<"});
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
return {S:({S:(a5A).S+((anG)(((a56).Bz))).S}).S+({S:">"}).S};
break;
case 66564:
(a5F)=(a5e);
return {S:({S:({S:({S:({S:"dict<"}).S+((anG)(((a5F).B6))).S}).S+({S:", "}).S}).S+((anG)(((a5F).B7))).S}).S+({S:">"}).S};
break;
case 1026:
(a5H)=(a5e);
switch((a5H).y2){
case 0:
return {S:"int"};
break;
case 1:
return {S:"float"};
break;
case 2:
return {S:"char"};
break;
case 3:
return {S:"bool"};
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
break;
case 66565:
return {S:((((a5e).q2).S===({S:"@"}).S)?(((a5e).qn).dh):({S:""})).S+((a5e).q2).S};
break;
case 1028:
return {S:"(UNKNOWN)"};
break;
default:
if(!(false)){throw 0xE9170000;}
return {S:""};
break;
}
}
// chkBuiltinFuncType
function aoL(a5S /*member*/,a5T /*type*/){
let a5W=0; // kind
let a5Z=false; // found
let a6d=0;
let a60=0;
let a6B=0;
let a6V=null;
let a7g=null;
let a7y=null;
let a77=null;
let a5X=0;
let a5Y=false;
if((J)===(null)){
(J)=(new Map());
(bE)((J),([133,129,2,9]),({S:"abs"}),(10));
(bE)((J),([133,129,2,9]),({S:"add"}),(6));
(bE)((J),([133,129,2,9]),({S:"and"}),(1));
(bE)((J),([133,129,2,9]),({S:"clamp"}),(10));
(bE)((J),([133,129,2,9]),({S:"clampMax"}),(10));
(bE)((J),([133,129,2,9]),({S:"clampMin"}),(10));
(bE)((J),([133,129,2,9]),({S:"del"}),(14));
(bE)((J),([133,129,2,9]),({S:"delNext"}),(8));
(bE)((J),([133,129,2,9]),({S:"endian"}),(3));
(bE)((J),([133,129,2,9]),({S:"exist"}),(12));
(bE)((J),([133,129,2,9]),({S:"fill"}),(4));
(bE)((J),([133,129,2,9]),({S:"find"}),(13));
(bE)((J),([133,129,2,9]),({S:"findBin"}),(4));
(bE)((J),([133,129,2,9]),({S:"findLast"}),(13));
(bE)((J),([133,129,2,9]),({S:"findStr"}),(5));
(bE)((J),([133,129,2,9]),({S:"findStrEx"}),(5));
(bE)((J),([133,129,2,9]),({S:"findStrLast"}),(5));
(bE)((J),([133,129,2,9]),({S:"forEach"}),(12));
(bE)((J),([133,129,2,9]),({S:"get"}),(7));
(bE)((J),([133,129,2,9]),({S:"getOffset"}),(8));
(bE)((J),([133,129,2,9]),({S:"head"}),(8));
(bE)((J),([133,129,2,9]),({S:"idx"}),(8));
(bE)((J),([133,129,2,9]),({S:"ins"}),(8));
(bE)((J),([133,129,2,9]),({S:"join"}),(11));
(bE)((J),([133,129,2,9]),({S:"lower"}),(5));
(bE)((J),([133,129,2,9]),({S:"max"}),(4));
(bE)((J),([133,129,2,9]),({S:"min"}),(4));
(bE)((J),([133,129,2,9]),({S:"moveOffset"}),(8));
(bE)((J),([133,129,2,9]),({S:"next"}),(8));
(bE)((J),([133,129,2,9]),({S:"not"}),(1));
(bE)((J),([133,129,2,9]),({S:"offset"}),(2));
(bE)((J),([133,129,2,9]),({S:"or"}),(1));
(bE)((J),([133,129,2,9]),({S:"peek"}),(9));
(bE)((J),([133,129,2,9]),({S:"prev"}),(8));
(bE)((J),([133,129,2,9]),({S:"repeat"}),(4));
(bE)((J),([133,129,2,9]),({S:"replace"}),(5));
(bE)((J),([133,129,2,9]),({S:"reverse"}),(4));
(bE)((J),([133,129,2,9]),({S:"sar"}),(3));
(bE)((J),([133,129,2,9]),({S:"shl"}),(3));
(bE)((J),([133,129,2,9]),({S:"shr"}),(3));
(bE)((J),([133,129,2,9]),({S:"shuffle"}),(4));
(bE)((J),([133,129,2,9]),({S:"sign"}),(10));
(bE)((J),([133,129,2,9]),({S:"sort"}),(13));
(bE)((J),([133,129,2,9]),({S:"sortDesc"}),(13));
(bE)((J),([133,129,2,9]),({S:"split"}),(5));
(bE)((J),([133,129,2,9]),({S:"sub"}),(4));
(bE)((J),([133,129,2,9]),({S:"tail"}),(8));
(bE)((J),([133,129,2,9]),({S:"term"}),(8));
(bE)((J),([133,129,2,9]),({S:"termOffset"}),(8));
(bE)((J),([133,129,2,9]),({S:"toArray"}),(8));
(bE)((J),([133,129,2,9]),({S:"toArrayKey"}),(12));
(bE)((J),([133,129,2,9]),({S:"toArrayValue"}),(12));
(bE)((J),([133,129,2,9]),({S:"toBit64"}),(5));
(bE)((J),([133,129,2,9]),({S:"toFloat"}),(5));
(bE)((J),([133,129,2,9]),({S:"toInt"}),(5));
(bE)((J),([133,129,2,9]),({S:"toStr"}),(0));
(bE)((J),([133,129,2,9]),({S:"toStrFmt"}),(10));
(bE)((J),([133,129,2,9]),({S:"trim"}),(5));
(bE)((J),([133,129,2,9]),({S:"trimLeft"}),(5));
(bE)((J),([133,129,2,9]),({S:"trimRight"}),(5));
(bE)((J),([133,129,2,9]),({S:"upper"}),(5));
(bE)((J),([133,129,2,9]),({S:"xor"}),(1));
}
(a5W)=((a5X=(pT)((J),([133,129,2,9]),(a5S.$),(a5Y={$:(a5Z)},a5Y)),(a5Z)=a5Y.$,a5X));
if(!(a5Z)){
return false;
}
switch(a5W){
case 0:
if(((((((s5)((a5T)))||((agu)((a5T))))||((SJ)((a5T))))||((agA)((a5T))))||(((a5T).qe)===(1025)))||((Xn)((a5T)))){
return true;
}
break;
case 1:
if((((a5T).qe)===(1025))||((Fs)((a5T)))){
return true;
}
break;
case 2:
if((SJ)((a5T))){
return true;
}
break;
case 3:
if(((a5T).qe)===(1025)){
return true;
}
break;
case 4:
if(((a5T).qe)===(66561)){
return true;
}
break;
case 5:
if((Xn)((a5T))){
return true;
}
break;
case 6:
if(((a5T).qe)===(66563)){
switch((a5T).Bx){
case 0:
(a5S.$)=({S:"addList"});
break;
case 1:
(a5S.$)=({S:"addStack"});
break;
case 2:
(a5S.$)=({S:"addQueue"});
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
return true;
}
if(((a5T).qe)===(66564)){
(a5S.$)=({S:"addDict"});
return true;
}
break;
case 7:
if(((a5T).qe)===(66563)){
switch((a5T).Bx){
case 0:
(a5S.$)=({S:"getList"});
break;
case 1:
(a5S.$)=({S:"getStack"});
break;
case 2:
(a5S.$)=({S:"getQueue"});
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
return true;
}
if(((a5T).qe)===(66564)){
(a5S.$)=({S:"getDict"});
return true;
}
break;
case 8:
if((((a5T).qe)===(66563))&&(((a5T).Bx)===(0))){
return true;
}
break;
case 9:
if(((a5T).qe)===(66563)){
if(((a5T).Bx)===(1)){
(a5S.$)=({S:"peekStack"});
return true;
}
else if(((a5T).Bx)===(2)){
(a5S.$)=({S:"peekQueue"});
return true;
}
}
break;
case 10:
if((s5)((a5T))){
a6V=a5S.$;
if(a6V.S===({S:"abs"}).S){
(a5S.$)=({S:"absInt"});
}
else if(a6V.S===({S:"clamp"}).S){
(a5S.$)=({S:"clampInt"});
}
else if(a6V.S===({S:"clampMin"}).S){
(a5S.$)=({S:"clampMinInt"});
}
else if(a6V.S===({S:"clampMax"}).S){
(a5S.$)=({S:"clampMaxInt"});
}
else if(a6V.S===({S:"sign"}).S){
(a5S.$)=({S:"signInt"});
}
else if(a6V.S===({S:"toStrFmt"}).S){
(a5S.$)=({S:"toStrFmtInt"});
}
else{if(!(false)){throw 0xE9170000;}
}
return true;
}
if((agu)((a5T))){
a7g=a5S.$;
if(a7g.S===({S:"abs"}).S){
(a5S.$)=({S:"absFloat"});
}
else if(a7g.S===({S:"clamp"}).S){
(a5S.$)=({S:"clampFloat"});
}
else if(a7g.S===({S:"clampMin"}).S){
(a5S.$)=({S:"clampMinFloat"});
}
else if(a7g.S===({S:"clampMax"}).S){
(a5S.$)=({S:"clampMaxFloat"});
}
else if(a7g.S===({S:"sign"}).S){
(a5S.$)=({S:"signFloat"});
}
else if(a7g.S===({S:"toStrFmt"}).S){
(a5S.$)=({S:"toStrFmtFloat"});
}
else{if(!(false)){throw 0xE9170000;}
}
return true;
}
break;
case 11:
if((((a5T).qe)===(66561))&&((Xn)(((a5T).AR)))){
return true;
}
break;
case 12:
if(((a5T).qe)===(66564)){
return true;
}
break;
case 13:
if(((a5T).qe)===(66561)){
a7y=a5S.$;
if(a7y.S===({S:"sort"}).S){
(a5S.$)=({S:"sortArray"});
}
else if(a7y.S===({S:"sortDesc"}).S){
(a5S.$)=({S:"sortDescArray"});
}
else if(a7y.S===({S:"find"}).S){
(a5S.$)=({S:"findArray"});
}
else if(a7y.S===({S:"findLast"}).S){
(a5S.$)=({S:"findLastArray"});
}
else{if(!(false)){throw 0xE9170000;}
}
return true;
}
if((((a5T).qe)===(66563))&&(((a5T).Bx)===(0))){
a77=a5S.$;
if(a77.S===({S:"sort"}).S){
(a5S.$)=({S:"sortList"});
}
else if(a77.S===({S:"sortDesc"}).S){
(a5S.$)=({S:"sortDescList"});
}
else if(a77.S===({S:"find"}).S){
(a5S.$)=({S:"findList"});
}
else if(a77.S===({S:"findLast"}).S){
(a5S.$)=({S:"findLastList"});
}
else{if(!(false)){throw 0xE9170000;}
}
return true;
}
break;
case 14:
if((((a5T).qe)===(66563))&&(((a5T).Bx)===(0))){
return true;
}
if(((a5T).qe)===(66564)){
(a5S.$)=({S:"delDict"});
return true;
}
break;
}
return false;
}
// cacheSubExpr
function atO(a7I /*stats*/,a7J /*ast*/,a7K /*pos*/){
let a7P=null; // ref
let a7R=null; // arg
let a7T=null; // do_
let a7V=null; // exprAssign
if((a7J)===(null)){
return null;
}
if((((a7J).qe)===(2062))||(((rv)(((a7J).qe),([9]),(67584)))===(67584))){
return a7J;
}
(a7P)=(new yO());
(yP)((a7P),(2062),(a7K));
((a7P).q2)=({S:"$"});
((a7P).zj)=(2);
((a7P).zJ)=(a7P);
(a7R)=(new rq());
(yr)((a7R),(7),(a7K));
((a7R).rr)=(3);
((a7R).sL)=(false);
((a7R).s6)=((a7J).zn);
((a7R).y3)=(null);
((a7R).zJ)=(a7R);
((a7P).q1)=(a7R);
((a7P).zn)=((a7R).s6);
(a7T)=(new yK());
(yr)((a7T),(528),(a7K));
(a7V)=(new An());
(yP)((a7V),(2050),(a7K));
((a7V).Ao)=(0);
((a7V).Ar)=(a7P);
((a7V).As)=(a7J);
((a7T).yU)=(a7V);
(eP)((a7I),([130,134]),((Ro)((a7T))));
return a7P;
}
// buildExpr1
function au3(a7W /*ast*/){
let a7Y=0;
if(!(((a7W).zj)!==(0))){throw 0xE9170000;}
switch((a7W).agr){
case 0:
(Su)(((a7W).agl));
break;
case 1:
(eP)((P),([130,129,2]),({S:"-("}));
(Su)(((a7W).agl));
(eP)((P),([130,129,2]),({S:")"}));
break;
case 2:
(eP)((P),([130,129,2]),({S:"!("}));
(Su)(((a7W).agl));
(eP)((P),([130,129,2]),({S:")"}));
break;
case 3:
(eP)((P),([130,129,2]),({S:"copy_("}));
(Su)(((a7W).agl));
(eP)((P),([130,129,2]),({S:")"}));
break;
case 4:
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((a7W).agl));
(eP)((P),([130,129,2]),({S:")->Len()"}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// buildExpr2
function au5(a8f /*ast*/){
let a8g=null; // type
let a8i=0;
let a8Q=null; // tmpVar
if(!(((a8f).zj)!==(0))){throw 0xE9170000;}
(a8g)=(((a8f).Ar).zn);
switch((a8f).Ao){
case 0:
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:") = ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")"}));
break;
case 8:
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:") || ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")"}));
break;
case 9:
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:") && ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")"}));
break;
case 10:
if((Av)((a8g))){
(eP)((P),([130,129,2]),({S:"cmp_(("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:"), ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")) < 0"}));
}
else{
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:") < ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")"}));
}
break;
case 11:
if((Av)((a8g))){
(eP)((P),([130,129,2]),({S:"cmp_(("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:"), ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")) > 0"}));
}
else{
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:") > ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")"}));
}
break;
case 12:
if((Av)((a8g))){
(eP)((P),([130,129,2]),({S:"cmp_(("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:"), ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")) <= 0"}));
}
else{
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:") <= ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")"}));
}
break;
case 13:
if((Av)((a8g))){
(eP)((P),([130,129,2]),({S:"cmp_(("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:"), ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")) >= 0"}));
}
else{
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:") >= ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")"}));
}
break;
case 14:
if((Av)((a8g))){
(eP)((P),([130,129,2]),({S:"cmp_(("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:"), ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")) == 0"}));
}
else{
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:") == ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")"}));
}
break;
case 15:
if((Av)((a8g))){
(eP)((P),([130,129,2]),({S:"cmp_(("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:"), ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")) != 0"}));
}
else{
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:") != ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")"}));
}
break;
case 16:
(eP)((P),([130,129,2]),({S:"eqAddr_(("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:"), ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:"))"}));
break;
case 17:
(eP)((P),([130,129,2]),({S:"!eqAddr_(("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:"), ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:"))"}));
break;
case 18:
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:")->Cat("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")"}));
break;
case 19:
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:") + ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")"}));
break;
case 20:
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:") - ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")"}));
break;
case 21:
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:") * ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")"}));
break;
case 22:
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:") / ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")"}));
break;
case 23:
if(((s5)((a8g)))||(((rv)(((a8g).qe),([9]),(1025)))===(1025))){
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:") % ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:")"}));
}
else{
if(!((agu)((a8g)))){throw 0xE9170000;}
(eP)((P),([130,129,2]),({S:"fmod(("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:"), ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:"))"}));
}
break;
case 24:
if(((s5)((a8g)))||(((rv)(((a8g).qe),([9]),(1025)))===(1025))){
(eP)((P),([130,129,2]),({S:"PowI_(("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:"), ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:"))"}));
}
else{
if(!((agu)((a8g)))){throw 0xE9170000;}
(eP)((P),([130,129,2]),({S:"pow(("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:"), ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:"))"}));
}
break;
case 25:
(a8Q)=((Ue)((a8g)));
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)((a8Q),([129,2]))).S}).S+({S:" = ("}).S}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:"), ("}));
(Su)(((a8f).Ar));
(eP)((P),([130,129,2]),({S:") = ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:"), ("}));
(Su)(((a8f).As));
(eP)((P),([130,129,2]),({S:({S:({S:") = ("}).S+((v)((a8Q),([129,2]))).S}).S+({S:")"}).S}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// buildExpr3
function au7(a8S /*ast*/){
if(!(((a8S).zj)!==(0))){throw 0xE9170000;}
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((a8S).ak1));
(eP)((P),([130,129,2]),({S:") ? ("}));
(Su)(((a8S).ak4));
(eP)((P),([130,129,2]),({S:") : ("}));
(Su)(((a8S).ak7));
(eP)((P),([130,129,2]),({S:")"}));
}
// buildExprNew
function au9(a8T /*ast*/){
let a8W=null; // class_
let a8X=null; // id
let a9b=null; // gen
let a9d=0;
let a9j=null; // dict_
if(!(((a8T).zj)!==(0))){throw 0xE9170000;}
if((R0)(((a8T).akR))){
(a8W)=(((a8T).akR).q1);
(a8X)=((tB)((a8W)));
(eP)((P),([130,129,2]),({S:({S:({S:"new "}).S+((v)((a8X),([129,2]))).S}).S+({S:"()"}).S}));
}
else{
if((((a8T).akR).qe)===(66563)){
(a9b)=((a8T).akR);
switch((a9b).Bx){
case 0:
(eP)((P),([130,129,2]),({S:({S:({S:"new List_<"}).S+((v)(((ss)(((a9b).Bz))),([129,2]))).S}).S+({S:">()"}).S}));
break;
case 1:
(eP)((P),([130,129,2]),({S:({S:({S:"new Stack_<"}).S+((v)(((ss)(((a9b).Bz))),([129,2]))).S}).S+({S:">()"}).S}));
break;
case 2:
(eP)((P),([130,129,2]),({S:({S:({S:"new Queue_<"}).S+((v)(((ss)(((a9b).Bz))),([129,2]))).S}).S+({S:">()"}).S}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{
if(!((((a8T).akR).qe)===(66564))){throw 0xE9170000;}
(a9j)=((a8T).akR);
(eP)((P),([130,129,2]),({S:({S:({S:"new Dict_<"}).S+((v)(((ss)(((a9j).B6))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((ss)(((a9j).B7))),([129,2]))).S}).S+({S:">()"}).S}).S}));
}
}
}
// buildExprNewArray
function auB(a9k /*ast*/){
let a9m=null; // items
if(!(((a9k).zj)!==(0))){throw 0xE9170000;}
(eP)((P),([130,129,2]),({S:({S:({S:"newArray_<"}).S+((v)(((ss)(((a9k).all))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((ss)(((a9k).zn))),([129,2]))).S}).S+({S:({S:({S:">("}).S+((v)((((a9k).ald).L),([0]))).S}).S+({S:""}).S}).S}).S}));
(a9m)=((a9k).ald);
(qt)((a9m),([130,134]));
while(!((qv)((a9m),([130,134])))){
(eP)((P),([130,129,2]),({S:", ("}));
(Su)(((qx)((a9m),([130,134]))));
(eP)((P),([130,129,2]),({S:")"}));
(rA)((a9m),([130,134]));
}
(eP)((P),([130,129,2]),({S:")"}));
}
// buildExprAs
function auD(a9o /*ast*/){
let a9q=0;
let a9s=null; // t1
let a9t=null; // t2
let a9w=null; // id
let a9x=null; // info
let a90=null; // info
let a92=null; // info
if(!(((a9o).zj)!==(0))){throw 0xE9170000;}
switch((a9o).al6){
case 0:
(a9s)=(((a9o).aly).zn);
(a9t)=((a9o).al1);
if((R0)((a9s))){
if(!((R0)((a9t)))){throw 0xE9170000;}
(a9w)=((tB)(((a9t).q1)));
(a9x)=((rW)(((a9t).q1)));
(eP)((P),([130,129,2]),({S:({S:({S:"as_<"}).S+((v)((a9w),([129,2]))).S}).S+({S:">(classTable_, ("}).S}));
(Su)(((a9o).aly));
(eP)((P),([130,129,2]),({S:({S:({S:"), "}).S+((v)((((a9x).tG)*(2)),([0]))).S}).S+({S:")"}).S}));
}
else{
(eP)((P),([130,129,2]),({S:({S:({S:"static_cast<"}).S+((v)(((ss)(((a9o).al1))),([129,2]))).S}).S+({S:">("}).S}));
(Su)(((a9o).aly));
(eP)((P),([130,129,2]),({S:")"}));
}
break;
case 1:
(tB)((((a9o).al1).q1));
(a90)=((rW)((((a9o).al1).q1)));
(eP)((P),([130,129,2]),({S:"is_(classTable_, ("}));
(Su)(((a9o).aly));
(eP)((P),([130,129,2]),({S:({S:({S:"), "}).S+((v)((((a90).tG)*(2)),([0]))).S}).S+({S:")"}).S}));
break;
case 2:
(tB)((((a9o).al1).q1));
(a92)=((rW)((((a9o).al1).q1)));
(eP)((P),([130,129,2]),({S:"!is_(classTable_, ("}));
(Su)(((a9o).aly));
(eP)((P),([130,129,2]),({S:({S:({S:"), "}).S+((v)((((a92).tG)*(2)),([0]))).S}).S+({S:")"}).S}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// buildExprToBin
function auF(a94 /*ast*/){
if(!(((a94).zj)!==(0))){throw 0xE9170000;}
(eP)((P),([130,129,2]),({S:"toBin_("}));
(Su)(((a94).amK));
(eP)((P),([130,129,2]),({S:")"}));
}
// buildExprFromBin
function auH(a95 /*ast*/){
if(!(((a95).zj)!==(0))){throw 0xE9170000;}
(eP)((P),([130,129,2]),({S:({S:({S:"fromBin_<"}).S+((v)(((ss)(((a95).ana))),([129,2]))).S}).S+({S:">(("}).S}));
(Su)(((a95).amV));
(eP)((P),([130,129,2]),({S:"), ("}));
(Su)(((a95).anb));
(eP)((P),([130,129,2]),({S:"))"}));
}
// buildExprCall
function auJ(a96 /*ast*/){
let a97=null; // funcType
let a98=null; // template
let a9B=null; // items
let a9C=null; // meType
let aAd=false; // first
let aAe=null; // items
let aAg=null; // item
let aAn=null; // type
if(!(((a96).zj)!==(0))){throw 0xE9170000;}
(a97)=(((a96).yT).zn);
(a98)=(null);
if(((a97)!==(null))&&(((rv)(((a97).abd),([9]),(1)))===(1))){
(a9B)=((a96).yQ);
(qt)((a9B),([130,134]));
(a9C)=((((qx)((a9B),([130,134]))).z7).zn);
if(((rv)(((a97).abd),([9]),(32)))===(32)){
(a98)=({S:({S:({S:"<"}).S+((v)(((ss)((a9C))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((ss)(((a9C).B6))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((ss)(((a9C).B7))),([129,2]))).S}).S+({S:">"}).S}).S}).S});
}
else if(((rv)(((a97).abd),([9]),(8)))===(8)){
if(((rv)(((a97).abd),([9]),(16)))===(16)){
(a98)=({S:({S:({S:"<"}).S+((v)(((ss)((a9C))),([129,2]))).S}).S+({S:", "}).S});
if(((a9C).qe)===(66563)){
(a98)=({S:(a98).S+({S:({S:({S:""}).S+((v)(((ss)(((a9C).Bz))),([129,2]))).S}).S+({S:", "}).S}).S});
}
else{
if(!(((a9C).qe)===(66564))){throw 0xE9170000;}
(a98)=({S:(a98).S+({S:({S:({S:""}).S+((v)(((ss)(((a9C).B6))),([129,2]))).S}).S+({S:", "}).S}).S});
}
(a98)=({S:(a98).S+({S:({S:({S:""}).S+((v)(((ss)(((a97).AZ))),([129,2]))).S}).S+({S:">"}).S}).S});
}
else{
(a98)=({S:({S:({S:"<"}).S+((v)(((ss)((a9C))),([129,2]))).S}).S+({S:", "}).S});
if(((a9C).qe)===(66561)){
(a98)=({S:(a98).S+({S:({S:({S:""}).S+((v)(((ss)(((a9C).AR))),([129,2]))).S}).S+({S:">"}).S}).S});
}
else if(((a9C).qe)===(66563)){
(a98)=({S:(a98).S+({S:({S:({S:""}).S+((v)(((ss)(((a9C).Bz))),([129,2]))).S}).S+({S:">"}).S}).S});
}
else{
if(!(((a9C).qe)===(66564))){throw 0xE9170000;}
(a98)=({S:(a98).S+({S:({S:({S:""}).S+((v)(((ss)(((a9C).B6))),([129,2]))).S}).S+({S:">"}).S}).S});
}
}
}
else if(((rv)(((a97).abd),([9]),(16)))===(16)){
(a98)=({S:({S:({S:"<"}).S+((v)(((ss)((a9C))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((ss)(((a97).AZ))),([129,2]))).S}).S+({S:">"}).S}).S});
}
else if(((rv)(((a97).abd),([9]),(256)))===(256)){
(a98)=({S:({S:({S:"<"}).S+((v)(((ss)((a9C))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((ss)(((a9C).B6))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((ss)(((a9C).B7))),([129,2]))).S}).S+({S:">"}).S}).S}).S});
}
else{
(a98)=({S:({S:({S:"<"}).S+((v)(((ss)((a9C))),([129,2]))).S}).S+({S:">"}).S});
}
}
if((a98)===(null)){
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((a96).yT));
(eP)((P),([130,129,2]),({S:")"}));
}
else{
(Su)(((a96).yT));
(eP)((P),([130,129,2]),(a98));
}
(eP)((P),([130,129,2]),({S:"("}));
(aAd)=(true);
(aAe)=((a96).yQ);
(qt)((aAe),([130,134]));
while(!((qv)((aAe),([130,134])))){
(aAg)=((qx)((aAe),([130,134])));
if(aAd){
(aAd)=(false);
(eP)((P),([130,129,2]),({S:"("}));
}
else{
(eP)((P),([130,129,2]),({S:", ("}));
}
if((aAg).z3){
(eP)((P),([130,129,2]),({S:"&"}));
}
(Su)(((aAg).z7));
(eP)((P),([130,129,2]),({S:")"}));
(rA)((aAe),([130,134]));
}
(eP)((P),([130,129,2]),({S:")"}));
(aAn)=((a96).zn);
if((aAn)!==(null)){
if((R0)((aAn))){
(tB)(((aAn).q1));
}
}
}
// buildExprArray
function auL(aAs /*ast*/){
if(!(((aAs).zj)!==(0))){throw 0xE9170000;}
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((aAs).aoc));
(eP)((P),([130,129,2]),({S:")->At("}));
(Su)(((aAs).aoh));
(eP)((P),([130,129,2]),({S:")"}));
}
// buildExprDot
function auN(aAt /*ast*/){
let aAw=null; // classItem
let aAz=null; // info
if(!(((aAt).zj)!==(0))){throw 0xE9170000;}
if((R0)((((aAt).anu).zn))){
(aAw)=((aAt).aoD);
if(!((aAw)!==(null))){throw 0xE9170000;}
(tB)(((((aAt).anu).zn).q1));
if((((aAw).tU).qe)===(2)){
(aAz)=((rW)((((aAw).tU).tZ)));
(eP)((P),([130,129,2]),({S:"("}));
(Su)(((aAt).anu));
(eP)((P),([130,129,2]),({S:({S:({S:")->"}).S+((v)(((aAz).sP),([129,2]))).S}).S+({S:""}).S}));
}
else{
if(!((((aAw).tU).qe)===(256))){throw 0xE9170000;}
(aAz)=((rW)(((aAw).tU)));
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((aAz).sP),([129,2]))).S}).S+({S:""}).S}));
}
}
else{
if(!((((aAt).q1).qe)===(2062))){throw 0xE9170000;}
(auZ)(((aAt).q1));
}
}
// buildExprValue
function auP(aA2 /*ast*/){
if(!((((aA2).zn).qe)===(1027))){throw 0xE9170000;}
(eP)((P),([130,129,2]),({S:"nullptr"}));
}
// buildExprValuePrim
function auR(aA3 /*ast*/){
let aA4=null; // type
let aAB=0;
(aA4)=((aA3).zn);
if(((s5)((aA4)))||((Fs)((aA4)))){
(eP)((P),([130,129,2]),({S:((v)(((aA3).zk),([0]))).S+({S:"LL"}).S}));
}
else if((SJ)((aA4))){
(eP)((P),([130,129,2]),({S:({S:({S:"u\'\\u"}).S+((v)(((pB)(((v)(((aA3).zk),([5]))),([129,2]),(2),(-1))),([129,2]))).S}).S+({S:"\'"}).S}));
}
else if((agA)((aA4))){
(eP)((P),([130,129,2]),((((aA3).zk)===(0x0000000000000000))?({S:"false"}):({S:"true"})));
}
else if(((aA4).qe)===(1025)){
switch((aA4).AU){
case 1:
(eP)((P),([130,129,2]),({S:({S:({S:"static_cast<uint8_t>("}).S+((v)(((aA3).zk),([4]))).S}).S+({S:"U)"}).S}));
break;
case 2:
(eP)((P),([130,129,2]),({S:({S:({S:"static_cast<uint16_t>("}).S+((v)(((aA3).zk),([5]))).S}).S+({S:"U)"}).S}));
break;
case 4:
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((aA3).zk),([6]))).S}).S+({S:"U"}).S}));
break;
case 8:
(eP)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((aA3).zk),([7]))).S}).S+({S:"ULL"}).S}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{
if(!(false)){throw 0xE9170000;}
}
}
// buildExprValueStr
function auT(aAI /*ast*/){
let aAJ=null; // value
let aAK=null; // s
let aAN=0;
let aAO=0;
(aAJ)=((aAI).ail);
(aAK)=({S:({S:({S:"new Array_<char16_t>("}).S+((v)(((aAJ).S.length),([0]))).S}).S+({S:""}).S});
aAM:
for(aAN=(0),aAO=(((aAJ).S.length)-(1));aAN<=aAO;aAN+=(1)){
(aAK)=({S:(aAK).S+({S:({S:({S:", u\'\\u"}).S+((v)(((pB)(((v)(((aAJ).S.charCodeAt(aAN)),([5]))),([129,2]),(2),(-1))),([129,2]))).S}).S+({S:"\'"}).S}).S});
}
(aAK)=({S:(aAK).S+({S:")"}).S});
(eP)((P),([130,129,2]),(aAK));
}
// buildExprValueFloat
function auV(aAR /*ast*/){
let aAS=null; // value
(aAS)=((v)(((aAR).ag7),([1])));
if((aAS).S===({S:"inf"}).S){
(eP)((P),([130,129,2]),({S:"std::numeric_limits<double>::infinity()"}));
}
else if(((q5)((aAS),([129,2]),(0x002E),(-1)))===(-1)){
(eP)((P),([130,129,2]),({S:(aAS).S+({S:".0"}).S}));
}
else{
(eP)((P),([130,129,2]),(aAS));
}
}
// buildExprValueArray
function auX(aAX /*ast*/){
let aAY=null; // items
(eP)((P),([130,129,2]),({S:({S:({S:"new Array_<"}).S+((v)(((ss)((((aAX).zn).AR))),([129,2]))).S}).S+({S:({S:({S:">("}).S+((v)((((aAX).an3).L),([0]))).S}).S+({S:""}).S}).S}));
(aAY)=((aAX).an3);
(qt)((aAY),([130,134]));
while(!((qv)((aAY),([130,134])))){
(eP)((P),([130,129,2]),({S:", ("}));
(Su)(((qx)((aAY),([130,134]))));
(eP)((P),([130,129,2]),({S:")"}));
(rA)((aAY),([130,134]));
}
(eP)((P),([130,129,2]),({S:")"}));
}
// buildExprRef
function auZ(aBa /*ast*/){
let aBb=null; // ast2
let aBc=null; // info
let aBg=null; // arg
let aBi=0;
(aBb)=((aBa).q1);
(aBc)=((rW)((aBb)));
if(((aBb).qe)===(256)){
(eS)((K),([132,134]),(aBb));
}
else{
if(!(((aBb).qe)===(7))){throw 0xE9170000;}
(aBg)=(aBb);
switch((aBg).rr){
case 1:
if(!((aBc).rZ)){
((aBc).rZ)=(true);
(eP)((S),([130,134]),(aBg));
}
break;
case 2:
break;
case 3:
if(!((aBc).rZ)){
((aBc).rZ)=(true);
(eP)((T),([130,134]),(aBg));
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
if((aBg).sL){
(eP)((P),([130,129,2]),({S:"*"}));
}
}
(eP)((P),([130,129,2]),((aBc).sP));
}
// buildExpr1
function avi(aBt /*ast*/){
let aBv=0;
let aB0=null; // typeId
let aB3=null; // type
let aB7=0;
if(!(((aBt).zj)!==(0))){throw 0xE9170000;}
switch((aBt).agr){
case 0:
(Wr)(((aBt).agl));
break;
case 1:
(eP)((am),([130,129,2]),({S:"-("}));
(Wr)(((aBt).agl));
(eP)((am),([130,129,2]),({S:")"}));
break;
case 2:
(eP)((am),([130,129,2]),({S:"!("}));
(Wr)(((aBt).agl));
(eP)((am),([130,129,2]),({S:")"}));
break;
case 3:
(aB0)=((aB1)((((aBt).agl).zn)));
(eP)((am),([130,129,2]),({S:({S:({S:"C_("}).S+((v)((aB0),([129,2]))).S}).S+({S:",("}).S}));
(Wr)(((aBt).agl));
(eP)((am),([130,129,2]),({S:"))"}));
break;
case 4:
(aB3)=(((aBt).agl).zn);
if(((aB3).qe)===(66563)){
switch((aB3).Bx){
case 0:
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBt).agl));
(eP)((am),([130,129,2]),({S:").L"}));
break;
case 1:
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBt).agl));
(eP)((am),([130,129,2]),({S:").length"}));
break;
case 2:
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBt).agl));
(eP)((am),([130,129,2]),({S:").length"}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else if(((aB3).qe)===(66564)){
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBt).agl));
(eP)((am),([130,129,2]),({S:").size"}));
}
else{
if(!(((aB3).qe)===(66561))){throw 0xE9170000;}
if((SJ)(((aB3).AR))){
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBt).agl));
(eP)((am),([130,129,2]),({S:").S.length"}));
}
else{
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBt).agl));
(eP)((am),([130,129,2]),({S:").length"}));
}
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// buildExpr2
function avk(aBI /*ast*/){
let aBJ=null; // type
let aBL=0;
let aBP=null; // ast2
let aBQ=null; // tmpIdx
let aBR=null; // tmpChar
let aCH=null; // tmpVar
if(!(((aBI).zj)!==(0))){throw 0xE9170000;}
(aBJ)=(((aBI).Ar).zn);
switch((aBI).Ao){
case 0:
if(((((aBI).Ar).qe)===(2058))&&((SJ)((((aBI).Ar).zn)))){
(aBP)=((aBI).Ar);
(aBQ)=((XE)((((aBP).aoh).zn)));
(aBR)=((XE)(((aBP).zn)));
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBP).aoc));
(eP)((am),([130,129,2]),({S:({S:({S:").S=("}).S+((v)((aBQ),([129,2]))).S}).S+({S:"=("}).S}));
(Wr)(((aBP).aoh));
(eP)((am),([130,129,2]),({S:"),("}));
(Wr)(((aBP).aoc));
(eP)((am),([130,129,2]),({S:({S:({S:").S.slice(0,"}).S+((v)((aBQ),([129,2]))).S}).S+({S:")+String.fromCharCode("}).S}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:")+("}));
(Wr)(((aBP).aoc));
(eP)((am),([130,129,2]),({S:({S:({S:").S.slice("}).S+((v)((aBQ),([129,2]))).S}).S+({S:"+1))"}).S}));
}
else{
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:")=("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:")"}));
}
break;
case 8:
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:")||("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:")"}));
break;
case 9:
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:")&&("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:")"}));
break;
case 10:
if((Xn)((aBJ))){
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:").S<("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:").S"}));
}
else if((Av)((aBJ))){
(eP)((am),([130,129,2]),({S:"cmp_(("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:"),("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:"))<0"}));
}
else{
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:")<("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:")"}));
}
break;
case 11:
if((Xn)((aBJ))){
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:").S>("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:").S"}));
}
else if((Av)((aBJ))){
(eP)((am),([130,129,2]),({S:"cmp_(("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:"),("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:"))>0"}));
}
else{
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:")>("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:")"}));
}
break;
case 12:
if((Xn)((aBJ))){
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:").S<=("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:").S"}));
}
else if((Av)((aBJ))){
(eP)((am),([130,129,2]),({S:"cmp_(("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:"),("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:"))<=0"}));
}
else{
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:")<=("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:")"}));
}
break;
case 13:
if((Xn)((aBJ))){
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:").S>=("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:").S"}));
}
else if((Av)((aBJ))){
(eP)((am),([130,129,2]),({S:"cmp_(("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:"),("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:"))>=0"}));
}
else{
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:")>=("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:")"}));
}
break;
case 14:
if((Xn)((aBJ))){
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:").S===("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:").S"}));
}
else if((Av)((aBJ))){
(eP)((am),([130,129,2]),({S:"cmp_(("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:"),("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:"))==0"}));
}
else{
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:")===("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:")"}));
}
break;
case 15:
if((Xn)((aBJ))){
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:").S!==("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:").S"}));
}
else if((Av)((aBJ))){
(eP)((am),([130,129,2]),({S:"cmp_(("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:"),("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:"))!=0"}));
}
else{
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:")!==("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:")"}));
}
break;
case 16:
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:")===("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:")"}));
break;
case 17:
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:")!==("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:")"}));
break;
case 18:
if((Xn)((aBJ))){
(eP)((am),([130,129,2]),({S:"{S:("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:").S+("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:").S}"}));
}
else{
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:").concat("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:")"}));
}
break;
case 19:
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:")+("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:")"}));
break;
case 20:
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:")-("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:")"}));
break;
case 21:
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:")*("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:")"}));
break;
case 22:
if(!((agu)((aBJ)))){
(eP)((am),([130,129,2]),({S:"~~("}));
}
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:")/("}));
(Wr)(((aBI).As));
if(!((agu)((aBJ)))){
(eP)((am),([130,129,2]),({S:"))"}));
}
else{
(eP)((am),([130,129,2]),({S:")"}));
}
break;
case 23:
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:")%("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:")"}));
break;
case 24:
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:")**("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:")"}));
break;
case 25:
(aCH)=((XE)((aBJ)));
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)((aCH),([129,2]))).S}).S+({S:"=("}).S}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:"),("}));
(Wr)(((aBI).Ar));
(eP)((am),([130,129,2]),({S:")=("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:"),("}));
(Wr)(((aBI).As));
(eP)((am),([130,129,2]),({S:({S:({S:")=("}).S+((v)((aCH),([129,2]))).S}).S+({S:")"}).S}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// buildExpr3
function avm(aCJ /*ast*/){
if(!(((aCJ).zj)!==(0))){throw 0xE9170000;}
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aCJ).ak1));
(eP)((am),([130,129,2]),({S:")?("}));
(Wr)(((aCJ).ak4));
(eP)((am),([130,129,2]),({S:"):("}));
(Wr)(((aCJ).ak7));
(eP)((am),([130,129,2]),({S:")"}));
}
// buildExprNew
function avo(aCK /*ast*/){
let aCN=null; // class_
let aCO=null; // id
let aCS=null; // gen
let aCU=0;
if(!(((aCK).zj)!==(0))){throw 0xE9170000;}
if((R0)(((aCK).akR))){
(aCN)=(((aCK).akR).q1);
(aCO)=((vE)((aCN)));
(eP)((am),([130,129,2]),({S:({S:({S:"new "}).S+((v)((aCO),([129,2]))).S}).S+({S:"()"}).S}));
}
else{
if((((aCK).akR).qe)===(66563)){
(aCS)=((aCK).akR);
switch((aCS).Bx){
case 0:
(eP)((am),([130,129,2]),({S:"{L:0,H:null,T:null,P:null}"}));
break;
case 1:
(eP)((am),([130,129,2]),({S:"[]"}));
break;
case 2:
(eP)((am),([130,129,2]),({S:"[]"}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{
if(!((((aCK).akR).qe)===(66564))){throw 0xE9170000;}
(eP)((am),([130,129,2]),({S:"new Map()"}));
}
}
}
// buildExprNewArray
function avq(aDa /*ast*/){
let aDc=null; // items
let aDi=false; // first
let aDr=false; // first
if(!(((aDa).zj)!==(0))){throw 0xE9170000;}
(aDc)=((aDa).ald);
(qt)((aDc),([130,134]));
if((SJ)(((aDa).all))){
if(((aDc).L)===(1)){
(eP)((am),([130,129,2]),({S:"{S:\"\\0\".repeat("}));
(Wr)(((qx)((aDc),([130,134]))));
(eP)((am),([130,129,2]),({S:")}"}));
}
else{
(eP)((am),([130,129,2]),({S:({S:({S:"(function A_(n){if(n.length===1)return{S:\"\\0\".repeat("}).S+((v)(((v3)(((aDa).all))),([129,2]))).S}).S+({S:")}else{let a=new Array(n[0]),m=n.shift(),i;for(i=0;i<n[0];i++)a[i]=A_(m);return a}})(["}).S}));
(aDi)=(true);
while(!((qv)((aDc),([130,134])))){
if(aDi){
(aDi)=(false);
}
else{
(eP)((am),([130,129,2]),({S:",("}));
}
(Wr)(((qx)((aDc),([130,134]))));
(eP)((am),([130,129,2]),({S:")"}));
(rA)((aDc),([130,134]));
}
(eP)((am),([130,129,2]),({S:"])"}));
}
}
else{
if(((aDc).L)===(1)){
(eP)((am),([130,129,2]),({S:"new Array("}));
(Wr)(((qx)((aDc),([130,134]))));
(eP)((am),([130,129,2]),({S:({S:({S:").fill("}).S+((v)(((v3)(((aDa).all))),([129,2]))).S}).S+({S:")"}).S}));
}
else{
(eP)((am),([130,129,2]),({S:({S:({S:"(function A_(n){if(n.length===1)return new Array(n[0]).fill("}).S+((v)(((v3)(((aDa).all))),([129,2]))).S}).S+({S:")else{let a=new Array(n[0]),m=n.shift(),i;for(i=0;i<n[0];i++)a[i]=A_(m);return a}})(["}).S}));
(aDr)=(true);
while(!((qv)((aDc),([130,134])))){
if(aDr){
(aDr)=(false);
}
else{
(eP)((am),([130,129,2]),({S:",("}));
}
(Wr)(((qx)((aDc),([130,134]))));
(eP)((am),([130,129,2]),({S:")"}));
(rA)((aDc),([130,134]));
}
(eP)((am),([130,129,2]),({S:"])"}));
}
}
}
// buildExprAs
function avs(aDw /*ast*/){
let aDy=0;
let aD0=null; // t1
let aD1=null; // t2
let aDJ=null; // info
let aDL=null; // info
if(!(((aDw).zj)!==(0))){throw 0xE9170000;}
switch((aDw).al6){
case 0:
(aD0)=(((aDw).aly).zn);
(aD1)=((aDw).al1);
if((R0)((aD0))){
if(!((R0)((aD1)))){throw 0xE9170000;}
(vE)(((aD1).q1));
(Wr)(((aDw).aly));
}
else{
if((((((aD0).qe)===(1025))||((s5)((aD0))))||((SJ)((aD0))))||((Fs)((aD0)))){
if(((((((aD1).qe)===(1025))||((s5)((aD1))))||((SJ)((aD1))))||((Fs)((aD1))))||((agu)((aD1)))){
(Wr)(((aDw).aly));
}
else{
if(!((agA)((aD1)))){throw 0xE9170000;}
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aDw).aly));
(eP)((am),([130,129,2]),({S:")!=0"}));
}
}
else if((agu)((aD0))){
if((((aD1).qe)===(1025))||((s5)((aD1)))){
(eP)((am),([130,129,2]),({S:"~~("}));
(Wr)(((aDw).aly));
(eP)((am),([130,129,2]),({S:")"}));
}
else{
if(!((agu)((aD1)))){throw 0xE9170000;}
(Wr)(((aDw).aly));
}
}
else{
if(!((agA)((aD0)))){throw 0xE9170000;}
if((((aD1).qe)===(1025))||((s5)((aD1)))){
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aDw).aly));
(eP)((am),([130,129,2]),({S:")?1:0"}));
}
else{
if(!((agA)((aD1)))){throw 0xE9170000;}
(Wr)(((aDw).aly));
}
}
}
break;
case 1:
(vE)((((aDw).al1).q1));
(aDJ)=((uK)((((aDw).al1).q1)));
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aDw).aly));
(eP)((am),([130,129,2]),({S:({S:({S:")instanceof "}).S+((v)(((aDJ).vb),([129,2]))).S}).S+({S:""}).S}));
break;
case 2:
(vE)((((aDw).al1).q1));
(aDL)=((uK)((((aDw).al1).q1)));
(eP)((am),([130,129,2]),({S:"!(("}));
(Wr)(((aDw).aly));
(eP)((am),([130,129,2]),({S:({S:({S:")instanceof "}).S+((v)(((aDL).vb),([129,2]))).S}).S+({S:")"}).S}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// buildExprToBin
function avu(aDN /*ast*/){
if(!(((aDN).zj)!==(0))){throw 0xE9170000;}
(eP)((am),([130,129,2]),({S:"toBin_("}));
(Wr)(((aDN).amK));
(eP)((am),([130,129,2]),({S:")"}));
}
// buildExprFromBin
function avw(aDO /*ast*/){
if(!(((aDO).zj)!==(0))){throw 0xE9170000;}
(eP)((am),([130,129,2]),({S:"fromBin_(("}));
(Wr)(((aDO).amV));
(eP)((am),([130,129,2]),({S:"),("}));
(Wr)(((aDO).anb));
(eP)((am),([130,129,2]),({S:"))"}));
}
// buildExprCall
function avy(aDP /*ast*/){
let aDQ=null; // funcType
let aDR=null; // meTypeId
let aDU=null; // items
let aDV=0; // refNum
let aDX=null; // items
let aEc=null; // resultVar
let aEd=null; // refVar
let aEj=0; // idx
let aEk=0; // refCnt
let aEl=false; // first
let aEm=null; // items
let aEo=null; // item
let aE1=0; // idx
let aE2=0; // refCnt
let aE3=null; // items
let aE5=null; // item
let aEE=null; // type
if(!(((aDP).zj)!==(0))){throw 0xE9170000;}
(aDQ)=(((aDP).yT).zn);
(aDR)=(null);
if(((aDQ)!==(null))&&(((rv)(((aDQ).abd),([9]),(1)))===(1))){
(aDU)=((aDP).yQ);
(qt)((aDU),([130,134]));
(aDR)=((aB1)(((((qx)((aDU),([130,134]))).z7).zn)));
}
(aDV)=(0);
(aDX)=((aDP).yQ);
(qt)((aDX),([130,134]));
while(!((qv)((aDX),([130,134])))){
if(((qx)((aDX),([130,134]))).z3){
(aDV)=((aDV)+(1));
}
(rA)((aDX),([130,134]));
}
(aEc)=(null);
(aEd)=(null);
if((aDV)>(0)){
(eP)((am),([130,129,2]),({S:"("}));
if(((aDP).zn)!==(null)){
(aEc)=((XE)(((aDP).zn)));
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)((aEc),([129,2]))).S}).S+({S:"="}).S}));
}
(aEd)=(new Array(aDV).fill(null));
}
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aDP).yT));
(eP)((am),([130,129,2]),({S:")("}));
(aEj)=(0);
(aEk)=(0);
(aEl)=(true);
(aEm)=((aDP).yQ);
(qt)((aEm),([130,134]));
while(!((qv)((aEm),([130,134])))){
(aEo)=((qx)((aEm),([130,134])));
if(aEl){
(aEl)=(false);
(eP)((am),([130,129,2]),({S:"("}));
}
else{
(eP)((am),([130,129,2]),({S:",("}));
}
if(((aDR)!==(null))&&((aEj)===(1))){
(eP)((am),([130,129,2]),(aDR));
}
else if((aEo).z3){
((aEd)[aEk])=((XE)((((aEo).z7).zn)));
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((aEd)[aEk]),([129,2]))).S}).S+({S:"={$:("}).S}));
(Wr)(((aEo).z7));
(eP)((am),([130,129,2]),({S:({S:({S:")},"}).S+((v)(((aEd)[aEk]),([129,2]))).S}).S+({S:""}).S}));
(aEk)=((aEk)+(1));
}
else{
(Wr)(((aEo).z7));
}
(eP)((am),([130,129,2]),({S:")"}));
(aEj)=((aEj)+(1));
(rA)((aEm),([130,134]));
}
(eP)((am),([130,129,2]),({S:")"}));
if((aDV)>(0)){
(aE1)=(0);
(aE2)=(0);
(aE3)=((aDP).yQ);
(qt)((aE3),([130,134]));
while(!((qv)((aE3),([130,134])))){
(aE5)=((qx)((aE3),([130,134])));
if(((aDR)!==(null))&&((aE1)===(1))){
}
else if((aE5).z3){
(eP)((am),([130,129,2]),({S:",("}));
(Wr)(((aE5).z7));
(eP)((am),([130,129,2]),({S:({S:({S:")="}).S+((v)(((aEd)[aE2]),([129,2]))).S}).S+({S:".$"}).S}));
(aE2)=((aE2)+(1));
}
(aE1)=((aE1)+(1));
(rA)((aE3),([130,134]));
}
if(((aDP).zn)!==(null)){
(eP)((am),([130,129,2]),({S:({S:({S:","}).S+((v)((aEc),([129,2]))).S}).S+({S:""}).S}));
}
(eP)((am),([130,129,2]),({S:")"}));
}
(aEE)=((aDP).zn);
if((aEE)!==(null)){
if((R0)((aEE))){
(vE)(((aEE).q1));
}
}
}
// buildExprArray
function av0(aEJ /*ast*/){
if(!(((aEJ).zj)!==(0))){throw 0xE9170000;}
if((SJ)(((aEJ).zn))){
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aEJ).aoc));
(eP)((am),([130,129,2]),({S:").S.charCodeAt("}));
(Wr)(((aEJ).aoh));
(eP)((am),([130,129,2]),({S:")"}));
}
else{
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aEJ).aoc));
(eP)((am),([130,129,2]),({S:")["}));
(Wr)(((aEJ).aoh));
(eP)((am),([130,129,2]),({S:"]"}));
}
}
// buildExprDot
function av2(aEN /*ast*/){
let aEQ=null; // classItem
let aET=null; // info
if(!(((aEN).zj)!==(0))){throw 0xE9170000;}
if((R0)((((aEN).anu).zn))){
(aEQ)=((aEN).aoD);
if(!((aEQ)!==(null))){throw 0xE9170000;}
(vE)(((((aEN).anu).zn).q1));
if((((aEQ).tU).qe)===(2)){
(aET)=((uK)((((aEQ).tU).tZ)));
(eP)((am),([130,129,2]),({S:"("}));
(Wr)(((aEN).anu));
(eP)((am),([130,129,2]),({S:({S:({S:")."}).S+((v)(((aET).vb),([129,2]))).S}).S+({S:""}).S}));
}
else{
if(!((((aEQ).tU).qe)===(256))){throw 0xE9170000;}
(aET)=((uK)(((aEQ).tU)));
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((aET).vb),([129,2]))).S}).S+({S:""}).S}));
}
}
else{
if(!((((aEN).q1).qe)===(2062))){throw 0xE9170000;}
(avE)(((aEN).q1));
}
}
// buildExprValue
function av4(aEW /*ast*/){
if(!((((aEW).zn).qe)===(1027))){throw 0xE9170000;}
(eP)((am),([130,129,2]),({S:"null"}));
}
// buildExprValuePrim
function av6(aEX /*ast*/){
let aEY=null; // type
let aFf=0;
(aEY)=((aEX).zn);
if(((s5)((aEY)))||((Fs)((aEY)))){
(eP)((am),([130,129,2]),((v)(((aEX).zk),([0]))));
}
else if((SJ)((aEY))){
(eP)((am),([130,129,2]),((v)(((aEX).zk),([5]))));
}
else if((agA)((aEY))){
(eP)((am),([130,129,2]),((((aEX).zk)===(0x0000000000000000))?({S:"false"}):({S:"true"})));
}
else if(((aEY).qe)===(1025)){
switch((aEY).AU){
case 1:
(eP)((am),([130,129,2]),((v)(((aEX).zk),([4]))));
break;
case 2:
(eP)((am),([130,129,2]),((v)(((aEX).zk),([5]))));
break;
case 4:
(eP)((am),([130,129,2]),((v)(((aEX).zk),([6]))));
break;
case 8:
(eP)((am),([130,129,2]),((v)(((aEX).zk),([7]))));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{
if(!(false)){throw 0xE9170000;}
}
}
// buildExprValueStr
function av8(aFm /*ast*/){
let aFn=null; // value
let aFo=null; // s
let aFr=0;
let aFs=0;
(aFn)=((aFm).ail);
(aFo)=({S:"{S:\""});
aFq:
for(aFr=(0),aFs=(((aFn).S.length)-(1));aFr<=aFs;aFr+=(1)){
(aFo)=({S:(aFo).S+((wv)(((aFn).S.charCodeAt(aFr)))).S});
}
(aFo)=({S:(aFo).S+({S:"\"}"}).S});
(eP)((am),([130,129,2]),(aFo));
}
// buildExprValueFloat
function avA(aFv /*ast*/){
let aFw=null; // value
(aFw)=((v)(((aFv).ag7),([1])));
if((aFw).S===({S:"inf"}).S){
(eP)((am),([130,129,2]),({S:"Infinity"}));
}
else{
(eP)((am),([130,129,2]),(aFw));
}
}
// buildExprValueArray
function avC(aF0 /*ast*/){
let aF1=false; // first
let aF2=null; // items
(eP)((am),([130,129,2]),({S:"["}));
(aF1)=(true);
(aF2)=((aF0).an3);
(qt)((aF2),([130,134]));
while(!((qv)((aF2),([130,134])))){
if(aF1){
(aF1)=(false);
(eP)((am),([130,129,2]),({S:"("}));
}
else{
(eP)((am),([130,129,2]),({S:",("}));
}
(Wr)(((qx)((aF2),([130,134]))));
(eP)((am),([130,129,2]),({S:")"}));
(rA)((aF2),([130,134]));
}
(eP)((am),([130,129,2]),({S:"]"}));
}
// buildExprRef
function avE(aF7 /*ast*/){
let aF8=null; // ast2
let aF9=null; // info
let aFD=null; // arg
let aFF=0;
(aF8)=((aF7).q1);
(aF9)=((uK)((aF8)));
if(((aF8).qe)===(256)){
(eS)((aj),([132,134]),(aF8));
(eP)((am),([130,129,2]),((aF9).vb));
}
else{
if(!(((aF8).qe)===(7))){throw 0xE9170000;}
(aFD)=(aF8);
switch((aFD).rr){
case 1:
if(!((aF9).uN)){
((aF9).uN)=(true);
(eP)((ao),([130,134]),(aFD));
}
break;
case 2:
break;
case 3:
if(!((aF9).uN)){
((aF9).uN)=(true);
(eP)((ap),([130,134]),(aFD));
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
if((aFD).sL){
(eP)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((aF9).vb),([129,2]))).S}).S+({S:".$"}).S}));
}
else{
(eP)((am),([130,129,2]),((aF9).vb));
}
}
}
// _findBin
function avZ(aFR /*me_*/,aFS /*type*/,aFT /*item*/){
let a_=0,b_=aFR.length-1,c_,m_,f_;
switch(aFS[0]){
case 0:
case 1:
case 2:
case 4:
case 5:
case 6:
case 7:
case 9:
f_=function(a,b){return a>b?1:a<b?-1:0};
break;
case 129:
f_=function(a,b){return a.S>b.S?1:a.S<b.S?-1:0};
break;
default:
break;
}
while (a_<=b_){
c_=~~((a_+b_)/2);
m_=f_(aFT,aFR[c_]);
if(m_<0)b_=c_-1;
else if(m_>0)a_=c_+1;
else return c_;
}
return -1;
}
// pushDummyScope
function awN(aFU /*ast*/){
let aFV=null; // dummy
(aFV)=(new c8());
(xj)((aFV),(0),(null),(null),(true));
(bE)((((YI)((ah),([131,134]))).qa),([133,129,2,134]),({S:({S:"$"}).S+((v)((pM),([0]))).S}),(aFV));
(pM)=((pM)+(1));
((aFV).qa)=(new Map());
(xl)((ah),([131,134]),(aFV));
((aFU).qW)=(aFV);
}
// obtainBlockName
function awO(aFX /*ast*/){
let aFY=0; // c
(aFY)=((xm)());
if((aFY)!==(0x0028)){
(pJ)=(aFY);
((aFX).qZ)=((x2)((true),(false)));
(Mf)((aFX),(true));
(Mb)((0x0028),(true));
}
else{
((aFX).qZ)=({S:"$"});
}
}
// parseDummyBlock
function awR(aGc /*outStat*/,aGd /*outTypeId*/,aGe /*typeId*/,aGf /*block_*/){
let aGg=null; // ast
let aGj=null; // stat
let aGp=false; // endFlag
let aGr=0;
let aGu=0;
let aGy=0;
let aG2=0;
let aG7=0;
let aGB=0;
let aGG=0;
let aGK=0;
let aGO=0;
(aGg)=(new y7());
(xj)((aGg),(66052),((KC)()),(null),(false));
((aGg).y4)=(null);
((aGg).y8)=({L:0,H:null,T:null,P:null});
(awN)((aGg));
((aGg).qZ)=({S:"$"});
aGi:
while(true){
(aGj)=((M6)((aGf)));
if((aGj)===(null)){
if(pL){
(aGc.$)=(null);
(aGd.$)=(513);
break aGi;
}
else{
continue aGi;
}
}
(aGp)=(false);
switch(aGe){
case 66049:
switch((aGj).qe){
case 520:
case 521:
case 513:
(aGp)=(true);
break;
}
break;
case 520:
switch((aGj).qe){
case 520:
case 521:
case 513:
(aGp)=(true);
break;
}
break;
case 521:
switch((aGj).qe){
case 520:
case 521:
(D)((65563),((KC)()),(null));
continue aGi;
break;
case 513:
(aGp)=(true);
break;
}
break;
case 522:
switch((aGj).qe){
case 522:
case 523:
case 513:
(aGp)=(true);
break;
}
break;
case 523:
switch((aGj).qe){
case 522:
case 523:
(D)((65564),((KC)()),(null));
continue aGi;
break;
case 513:
(aGp)=(true);
break;
}
break;
case 66051:
switch((aGj).qe){
case 524:
case 525:
(aGp)=(true);
break;
}
break;
case 524:
switch((aGj).qe){
case 524:
case 525:
case 520:
(aGp)=(true);
break;
}
break;
case 525:
switch((aGj).qe){
case 524:
case 525:
(D)((65565),((KC)()),(null));
continue aGi;
break;
case 513:
(aGp)=(true);
break;
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
if(aGp){
(aGc.$)=(aGj);
(aGd.$)=((aGj).qe);
break aGi;
}
(eP)(((aGg).y8),([130,134]),(aGj));
}
(xU)((ah),([131,134]));
return aGg;
}
// makeBlockVar
function axu(aGU /*pos*/){
let aGV=null; // arg
(aGV)=(new rq());
(xj)((aGV),(7),(aGU),(null),(false));
((aGV).rr)=(3);
((aGV).sL)=(false);
((aGV).s6)=(null);
((aGV).y3)=(null);
return aGV;
}
// makePrimValue
function ayC(aGW /*pos*/,aGX /*kind*/,aGY /*value*/){
let aGZ=null; // expr
let aHb=null; // type
(aGZ)=(new zh());
(NW)((aGZ),(67585),(aGW));
(aHb)=(new y1());
(xj)((aHb),(1026),(aGW),(null),(false));
((aHb).y2)=(aGX);
((aGZ).zn)=(aHb);
((aGZ).zk)=(aGY);
return aGZ;
}
// parseExprOr
function a0q(){
let aHc=null; // ast
let aHg=0; // row
let aHh=0; // col
let aHi=0; // c
let aHl=null; // ast2
(aHc)=((aHd)());
aHf:
while(true){
(aHg)=(pH);
(aHh)=(pI);
(aHi)=((xm)());
if((aHi)===(0x007C)){
(aHl)=(new An());
(NW)((aHl),(2050),((xk)((ag),(aHg),(aHh))));
((aHl).Ao)=(8);
((aHl).Ar)=(aHc);
((aHl).As)=((aHd)());
(aHc)=(aHl);
}
else{
(pJ)=(aHi);
break aHf;
}
}
return aHc;
}
// addSpecialFunc
function a2l(aHn /*class_*/,aHo /*name*/){
let aHp=null; // ast
let aHr=null; // me_
let aHt=null; // type
let aHv=null; // item
let aHw=null; // ptr
let aHy=null; // items
let aH1=null; // item2
(aHp)=(new c7());
(yr)((aHp),(256),((aHn).qn));
((aHp).qZ)=(aHo);
((aHp).qk)=(0);
((aHp).ql)=({L:0,H:null,T:null,P:null});
((aHp).qi)=({L:0,H:null,T:null,P:null});
((aHp).qj)=(null);
((aHp).tr)=({L:0,H:null,T:null,P:null});
(aHr)=(new rq());
(yr)((aHr),(7),((aHn).qn));
((aHr).rr)=(2);
((aHr).sL)=(false);
((aHr).y3)=(null);
(aHt)=(new Mi());
(yr)((aHt),(66565),((aHn).qn));
((aHt).q1)=(aHn);
((aHr).s6)=(aHt);
(eP)(((aHp).qi),([130,134]),(aHr));
(aHv)=(new tS());
((aHv).Ne)=(true);
((aHv).tU)=(aHp);
((aHv).Nf)=(null);
(aHw)=((aHn).q1);
while(((aHw).q1)!==(null)){
(aHw)=((aHw).q1);
}
(aHy)=((aHw).ti);
(qt)((aHy),([130,134]));
aH0:
while(!((qv)((aHy),([130,134])))){
(aH1)=((qx)((aHy),([130,134])));
if((((aH1).tU).qZ).S===(aHo).S){
((aHv).Nf)=(aH1);
break aH0;
}
(rA)((aHy),([130,134]));
}
if(!(((aHv).Nf)!==(null))){throw 0xE9170000;}
((aHv).Nd)=(((aHv).Nf).Nd);
(eP)(((aHn).ti),([130,134]),(aHv));
return aHp;
}
// makeMeDot
function a2M(aH4 /*class_*/,aH5 /*arg*/,aH6 /*name*/){
let aH7=null; // ast
let aH9=null; // me_
let aHB=null; // type
(aH7)=(new Qe());
(yP)((aH7),(2059),((aH4).qn));
((aH7).ao0)=(aH6);
((aH7).aoD)=(null);
(aH9)=(new yO());
(yP)((aH9),(2062),((aH4).qn));
((aH9).q2)=({S:"me"});
((aH9).q1)=(aH5);
(aHB)=(new Mi());
(yr)((aHB),(66565),((aH4).qn));
((aHB).q1)=(aH4);
((aH9).zn)=(aHB);
((aH7).anu)=(aH9);
return aH7;
}
// makeTypeId
function aB1(aHC /*type*/){
let aHD=null; // result
let aHE=false; // first
let aHF=null; // items
(aHD)=({S:"["});
(aHE)=(true);
(aHF)=((aHG)((aHC)));
(qt)((aHF),([130,0]));
while(!((qv)((aHF),([130,0])))){
if(aHE){
(aHE)=(false);
}
else{
(aHD)=({S:(aHD).S+({S:","}).S});
}
(aHD)=({S:(aHD).S+((v)(((qx)((aHF),([130,0]))),([0]))).S});
(rA)((aHF),([130,0]));
}
(aHD)=({S:(aHD).S+({S:"]"}).S});
return aHD;
}
// parseExprAnd
function aHd(){
let aHO=null; // ast
let aHS=0; // row
let aHT=0; // col
let aHU=0; // c
let aHX=null; // ast2
(aHO)=((aHP)());
aHR:
while(true){
(aHS)=(pH);
(aHT)=(pI);
(aHU)=((xm)());
if((aHU)===(0x0026)){
(aHX)=(new An());
(NW)((aHX),(2050),((xk)((ag),(aHS),(aHT))));
((aHX).Ao)=(9);
((aHX).Ar)=(aHO);
((aHX).As)=((aHP)());
(aHO)=(aHX);
}
else{
(pJ)=(aHU);
break aHR;
}
}
return aHO;
}
// getTypeId
function aHG(aHZ /*type*/){
let aIa=null; // result
(aIa)=({L:0,H:null,T:null,P:null});
(aIb)((aHZ),(aIa));
return aIa;
}
// parseExprCmp
function aHP(){
let aIc=null; // ast
let aIg=0; // row
let aIh=0; // col
let aIi=0; // c
let aIk=0;
let aIn=0;
let aIp=null; // ast2
let aIs=0;
let aIu=null; // ast2
let aIw=null; // ast2
let aIy=null; // ast2
let aI0=null; // ast2
let aI2=null; // ast2
let aI8=0;
let aIA=null; // ast2
let aIC=null; // ast2
let aIE=null; // ast2
(aIc)=((aId)());
aIf:
while(true){
(aIg)=(pH);
(aIh)=(pI);
(aIi)=((xm)());
switch(aIi){
case 0x003C:
(aIi)=((xO)());
switch(aIi){
case 0x003D:
(aIp)=(new An());
(NW)((aIp),(2050),((xk)((ag),(aIg),(aIh))));
((aIp).Ao)=(12);
((aIp).Ar)=(aIc);
((aIp).As)=((aId)());
(aIc)=(aIp);
break;
case 0x003E:
(aIi)=((xO)());
switch(aIi){
case 0x0026:
(aIu)=(new An());
(NW)((aIu),(2050),((xk)((ag),(aIg),(aIh))));
((aIu).Ao)=(17);
((aIu).Ar)=(aIc);
((aIu).As)=((aId)());
(aIc)=(aIu);
break;
case 0x0024:
(aIw)=(new PQ());
(NW)((aIw),(2054),((xk)((ag),(aIg),(aIh))));
((aIw).al6)=(2);
((aIw).aly)=(aIc);
((aIw).al1)=((M0)());
(aIc)=(aIw);
break;
default:
(pJ)=(aIi);
(aIy)=(new An());
(NW)((aIy),(2050),((xk)((ag),(aIg),(aIh))));
((aIy).Ao)=(15);
((aIy).Ar)=(aIc);
((aIy).As)=((aId)());
(aIc)=(aIy);
break;
}
break;
default:
(pJ)=(aIi);
(aI0)=(new An());
(NW)((aI0),(2050),((xk)((ag),(aIg),(aIh))));
((aI0).Ao)=(10);
((aI0).Ar)=(aIc);
((aI0).As)=((aId)());
(aIc)=(aI0);
break;
}
break;
case 0x003E:
(aI2)=(new An());
(NW)((aI2),(2050),((xk)((ag),(aIg),(aIh))));
(aIi)=((xO)());
if((aIi)===(0x003D)){
((aI2).Ao)=(13);
}
else{
(pJ)=(aIi);
((aI2).Ao)=(11);
}
((aI2).Ar)=(aIc);
((aI2).As)=((aId)());
(aIc)=(aI2);
break;
case 0x003D:
(aIi)=((xO)());
switch(aIi){
case 0x0026:
(aIA)=(new An());
(NW)((aIA),(2050),((xk)((ag),(aIg),(aIh))));
((aIA).Ao)=(16);
((aIA).Ar)=(aIc);
((aIA).As)=((aId)());
(aIc)=(aIA);
break;
case 0x0024:
(aIC)=(new PQ());
(NW)((aIC),(2054),((xk)((ag),(aIg),(aIh))));
((aIC).al6)=(1);
((aIC).aly)=(aIc);
((aIC).al1)=((M0)());
(aIc)=(aIC);
break;
default:
(pJ)=(aIi);
(aIE)=(new An());
(NW)((aIE),(2050),((xk)((ag),(aIg),(aIh))));
((aIE).Ao)=(14);
((aIE).Ar)=(aIc);
((aIE).As)=((aId)());
(aIc)=(aIE);
break;
}
break;
default:
(pJ)=(aIi);
break aIf;
break;
}
}
return aIc;
}
// makeTypeIdRecursion
function aIb(aIG /*type*/,aIH /*output*/){
let aIT=0;
let aJi=0;
if((s5)((aIG))){
(eP)((aIH),([130,0]),(0));
return;
}
if((agu)((aIG))){
(eP)((aIH),([130,0]),(1));
return;
}
if((SJ)((aIG))){
(eP)((aIH),([130,0]),(2));
return;
}
if((agA)((aIG))){
(eP)((aIH),([130,0]),(3));
return;
}
if(((aIG).qe)===(1025)){
switch((aIG).AU){
case 1:
(eP)((aIH),([130,0]),(4));
break;
case 2:
(eP)((aIH),([130,0]),(5));
break;
case 4:
(eP)((aIH),([130,0]),(6));
break;
case 8:
(eP)((aIH),([130,0]),(7));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
return;
}
if(((aIG).qe)===(66562)){
(eP)((aIH),([130,0]),(8));
return;
}
if((Fs)((aIG))){
(eP)((aIH),([130,0]),(9));
return;
}
if(((aIG).qe)===(66561)){
(eP)((aIH),([130,0]),(129));
(aIb)(((aIG).AR),(aIH));
return;
}
if(((aIG).qe)===(66563)){
switch((aIG).Bx){
case 0:
(eP)((aIH),([130,0]),(130));
break;
case 1:
(eP)((aIH),([130,0]),(131));
break;
case 2:
(eP)((aIH),([130,0]),(132));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(aIb)(((aIG).Bz),(aIH));
return;
}
if(((aIG).qe)===(66564)){
(eP)((aIH),([130,0]),(133));
(aIb)(((aIG).B6),(aIH));
(aIb)(((aIG).B7),(aIH));
return;
}
if(!((R0)((aIG)))){throw 0xE9170000;}
(eP)((aIH),([130,0]),(134));
}
// parseExprCat
function aId(){
let aJp=null; // ast
let aJt=0; // row
let aJu=0; // col
let aJv=0; // c
let aJy=null; // ast2
(aJp)=((aJq)());
aJs:
while(true){
(aJt)=(pH);
(aJu)=(pI);
(aJv)=((xm)());
if((aJv)===(0x007E)){
(aJy)=(new An());
(NW)((aJy),(2050),((xk)((ag),(aJt),(aJu))));
((aJy).Ao)=(18);
((aJy).Ar)=(aJp);
((aJy).As)=((aJq)());
(aJp)=(aJy);
}
else{
(pJ)=(aJv);
break aJs;
}
}
return aJp;
}
// parseExprAdd
function aJq(){
let aJ0=null; // ast
let aJ4=0; // row
let aJ5=0; // col
let aJ6=0; // c
let aJ8=0;
let aJA=null; // ast2
let aJC=null; // ast2
(aJ0)=((aJ1)());
aJ3:
while(true){
(aJ4)=(pH);
(aJ5)=(pI);
(aJ6)=((xm)());
switch(aJ6){
case 0x002B:
(aJA)=(new An());
(NW)((aJA),(2050),((xk)((ag),(aJ4),(aJ5))));
((aJA).Ao)=(19);
((aJA).Ar)=(aJ0);
((aJA).As)=((aJ1)());
(aJ0)=(aJA);
break;
case 0x002D:
(aJC)=(new An());
(NW)((aJC),(2050),((xk)((ag),(aJ4),(aJ5))));
((aJC).Ao)=(20);
((aJC).Ar)=(aJ0);
((aJC).As)=((aJ1)());
(aJ0)=(aJC);
break;
default:
(pJ)=(aJ6);
break aJ3;
break;
}
}
return aJ0;
}
// parseExprMul
function aJ1(){
let aJE=null; // ast
let aJI=0; // row
let aJJ=0; // col
let aJK=0; // c
let aJM=0;
let aJO=null; // ast2
let aJQ=null; // ast2
let aJS=null; // ast2
(aJE)=((aJF)());
aJH:
while(true){
(aJI)=(pH);
(aJJ)=(pI);
(aJK)=((xm)());
switch(aJK){
case 0x002A:
(aJO)=(new An());
(NW)((aJO),(2050),((xk)((ag),(aJI),(aJJ))));
((aJO).Ao)=(21);
((aJO).Ar)=(aJE);
((aJO).As)=((aJF)());
(aJE)=(aJO);
break;
case 0x002F:
(aJQ)=(new An());
(NW)((aJQ),(2050),((xk)((ag),(aJI),(aJJ))));
((aJQ).Ao)=(22);
((aJQ).Ar)=(aJE);
((aJQ).As)=((aJF)());
(aJE)=(aJQ);
break;
case 0x0025:
(aJS)=(new An());
(NW)((aJS),(2050),((xk)((ag),(aJI),(aJJ))));
((aJS).Ao)=(23);
((aJS).Ar)=(aJE);
((aJS).As)=((aJF)());
(aJE)=(aJS);
break;
default:
(pJ)=(aJK);
break aJH;
break;
}
}
return aJE;
}
// parseExprPlus
function aJF(){
let aJU=null; // ast
let aJY=0; // row
let aJZ=0; // col
let aKa=0; // c
let aKe=0;
let aKg=null; // ast2
let aKq=null; // ast2
let aKs=null; // ast2
let aKu=null; // ast2
let aKw=0;
(aJU)=((aJV)());
if((aJU)!==(null)){
return aJU;
}
(aJY)=(pH);
(aJZ)=(pI);
(aKa)=((xm)());
if((aKa)===(0x0023)){
(aKa)=((xO)());
switch(aKa){
case 0x005B:
(aKg)=(new PN());
(NW)((aKg),(2053),((xk)((ag),(aJY),(aJZ))));
((aKg).ald)=({L:0,H:null,T:null,P:null});
aKi:
while(true){
(eP)(((aKg).ald),([130,134]),((NR)()));
(aKa)=((xm)());
if((aKa)===(0x0000)){
break aKi;
}
if((aKa)===(0x005D)){
break aKi;
}
if((aKa)!==(0x002C)){
(LW)((0x002C),(aKa));
return null;
}
}
((aKg).all)=((M0)());
(aJU)=(aKg);
break;
case 0x0023:
(aKq)=(new PC());
(NW)((aKq),(2049),((xk)((ag),(aJY),(aJZ))));
((aKq).agr)=(3);
((aKq).agl)=((aJF)());
(aJU)=(aKq);
break;
default:
(pJ)=(aKa);
(aKs)=(new PK());
(NW)((aKs),(2052),((xk)((ag),(aJY),(aJZ))));
((aKs).akR)=((M0)());
(aJU)=(aKs);
break;
}
}
else{
(aKu)=(new PC());
(NW)((aKu),(2049),((xk)((ag),(aJY),(aJZ))));
switch(aKa){
case 0x002B:
((aKu).agr)=(0);
break;
case 0x002D:
((aKu).agr)=(1);
break;
case 0x0021:
((aKu).agr)=(2);
break;
case 0x005E:
((aKu).agr)=(4);
break;
default:
(D)((65569),((aKu).qn),([((KD)((aKa)))]));
(xN)((aKa));
return null;
break;
}
((aKu).agl)=((aJF)());
(aJU)=(aKu);
}
return aJU;
}
// parseExprPow
function aJV(){
let aK2=null; // ast
let aK6=0; // row
let aK7=0; // col
let aK8=0; // c
let aKB=null; // ast2
(aK2)=((aK3)());
if((aK2)===(null)){
return aK2;
}
(aK6)=(pH);
(aK7)=(pI);
(aK8)=((xm)());
if((aK8)===(0x005E)){
(aKB)=(new An());
(NW)((aKB),(2050),((xk)((ag),(aK6),(aK7))));
((aKB).Ao)=(24);
((aKB).Ar)=(aK2);
((aKB).As)=((aJF)());
(aK2)=(aKB);
}
else{
(pJ)=(aK8);
}
return aK2;
}
// parseExprCall
function aK3(){
let aKD=null; // ast
let aKJ=0; // row
let aKK=0; // col
let aKL=0; // c
let aKN=0;
let aKP=null; // ast2
let aKU=null; // arg
let aLc=null; // ast3
let aLl=null; // ast2
let aLn=null; // ast2
let aLq=0;
let aLs=null; // ast2
let aLu=null; // ast2
let aLw=null; // ast2
(aKD)=((aKE)());
if((aKD)===(null)){
return aKD;
}
aKI:
while(true){
(aKJ)=(pH);
(aKK)=(pI);
(aKL)=((xm)());
switch(aKL){
case 0x0028:
if(!((aKD)!==(null))){throw 0xE9170000;}
(aKP)=(new yN());
(NW)((aKP),(2057),((xk)((ag),(aKJ),(aKK))));
((aKP).yT)=(aKD);
((aKP).yQ)=({L:0,H:null,T:null,P:null});
(aKL)=((xm)());
if((aKL)!==(0x0029)){
(pJ)=(aKL);
aKT:
while(true){
(aKU)=(new z2());
((aKU).z4)=(false);
(aKL)=((xm)());
if((aKL)===(0x0026)){
((aKU).z3)=(true);
(aKL)=((xm)());
if(((aKL)===(0x002C))||((aKL)===(0x0029))){
((aKU).z4)=(true);
}
}
else{
((aKU).z3)=(false);
}
(pJ)=(aKL);
if((aKU).z4){
(aLc)=(new yO());
(NW)((aLc),(2062),((aKP).qn));
((aLc).q2)=({S:"$"});
((aLc).q1)=((axu)(((aLc).qn)));
((aKU).z7)=(aLc);
}
else{
((aKU).z7)=((NR)());
}
(eP)(((aKP).yQ),([130,134]),(aKU));
(aKL)=((xm)());
if((aKL)===(0x0000)){
break aKT;
}
if((aKL)===(0x0029)){
break aKT;
}
if((aKL)!==(0x002C)){
(LW)((0x002C),(aKL));
return null;
}
}
}
(aKD)=(aKP);
break;
case 0x005B:
if(!((aKD)!==(null))){throw 0xE9170000;}
(aLl)=(new Qb());
(NW)((aLl),(2058),((xk)((ag),(aKJ),(aKK))));
((aLl).aoc)=(aKD);
((aLl).aoh)=((NR)());
(Mb)((0x005D),(true));
(aKD)=(aLl);
break;
case 0x002E:
if(!((aKD)!==(null))){throw 0xE9170000;}
(aLn)=(new Qe());
(NW)((aLn),(2059),((xk)((ag),(aKJ),(aKK))));
((aLn).anu)=(aKD);
((aLn).ao0)=((x2)((true),(false)));
((aLn).aoD)=(null);
(aKD)=(aLn);
break;
case 0x0024:
if(!((aKD)!==(null))){throw 0xE9170000;}
(aKL)=((xO)());
switch(aKL){
case 0x003E:
(aLs)=(new PT());
(NW)((aLs),(2055),((xk)((ag),(aKJ),(aKK))));
((aLs).amK)=(aKD);
((aLs).amQ)=((M0)());
(aKD)=(aLs);
break;
case 0x003C:
(aLu)=(new PW());
(NW)((aLu),(2056),((xk)((ag),(aKJ),(aKK))));
((aLu).amV)=(aKD);
((aLu).ana)=((M0)());
((aLu).anb)=((ayC)(((aLu).qn),(0),(0x0000000000000000)));
(aKD)=(aLu);
break;
default:
(pJ)=(aKL);
(aLw)=(new PQ());
(NW)((aLw),(2054),((xk)((ag),(aKJ),(aKK))));
((aLw).al6)=(0);
((aLw).aly)=(aKD);
((aLw).al1)=((M0)());
(aKD)=(aLw);
break;
}
break;
default:
(pJ)=(aKL);
break aKI;
break;
}
}
return aKD;
}
// parseExprValue
function aKE(){
let aLy=0; // row
let aLz=0; // col
let aL0=0; // c
let aL1=null; // pos
let aL3=0;
let aL5=null; // buf
let aL6=0; // len
let aL7=false; // esc
let aLG=null; // cat
let aLI=null; // cat2
let aLL=null; // call
let aLN=null; // dot
let aMe=0; // buf
let aMf=false; // set
let aMg=false; // esc
let aMy=null; // ast
let aM2=null; // ast
let aM7=null; // expr
let aMH=null; // id
let aMI=null; // expr
let aMK=null; // type
let aMS=null; // id
let aMU=null;
let aNa=null; // ast
let aNc=null; // type
let aNg=null; // ast
let aLQ=0;
let aLR=0;
let aMa=0;
let aMb=0;
(aLy)=(pH);
(aLz)=(pI);
(aL0)=((xm)());
(aL1)=((xk)((ag),(aLy),(aLz)));
switch(aL0){
case 0x0022:
(aL5)=({S:"\0".repeat(1024)});
(aL6)=(0);
(aL7)=(false);
aL9:
while(true){
(aL0)=((ads)());
if((aL0)===(0x0000)){
(D)((65573),(aL1),(null));
return null;
}
if(aL7){
if((aL0)===(0x007B)){
(aLG)=(new An());
(NW)((aLG),(2050),(aL1));
((aLG).Ao)=(18);
(aLI)=(new An());
(NW)((aLI),(2050),(aL1));
((aLI).Ao)=(18);
((aLI).Ar)=((aLJ)((aL1),((pB)((aL5),([129,2]),(0),(aL6)))));
(aLL)=(new yN());
(NW)((aLL),(2057),(aL1));
((aLL).yQ)=({L:0,H:null,T:null,P:null});
(aLN)=(new Qe());
(NW)((aLN),(2059),(aL1));
((aLN).anu)=((NR)());
((aLN).ao0)=({S:"toStr"});
((aLN).aoD)=(null);
((aLL).yT)=(aLN);
((aLI).As)=(aLL);
(Mb)((0x007D),(false));
((aLG).Ar)=(aLI);
(pJ)=(0x0022);
((aLG).As)=((aKE)());
return aLG;
}
if((aL6)===(1024)){
(D)((65570),(aL1),([(aL5)]));
(xN)((aL0));
return null;
}
(aL5).S=(aLQ=(aL6),(aL5).S.slice(0,aLQ)+String.fromCharCode((aLS)((aL0)))+(aL5).S.slice(aLQ+1));
(aL6)=((aL6)+(1));
(aL7)=(false);
continue aL9;
}
if((aL0)===(0x0022)){
break aL9;
}
if((aL0)===(0x005C)){
(aL7)=(true);
continue aL9;
}
if((aL6)===(1024)){
(D)((65570),(aL1),([(aL5)]));
(xN)((aL0));
return null;
}
(aL5).S=(aMa=(aL6),(aL5).S.slice(0,aMa)+String.fromCharCode(aL0)+(aL5).S.slice(aMa+1));
(aL6)=((aL6)+(1));
}
return (aLJ)((aL1),((pB)((aL5),([129,2]),(0),(aL6))));
break;
case 0x0027:
(aMe)=(0x0000);
(aMf)=(false);
(aMg)=(false);
aMi:
while(true){
(aL0)=((ads)());
if((aL0)===(0x0000)){
(D)((65573),(aL1),(null));
return null;
}
if(aMg){
if(aMf){
(D)((65574),(aL1),([((KD)((aMe)))]));
(xN)((aL0));
return null;
}
(aMe)=((aLS)((aL0)));
(aMf)=(true);
(aMg)=(false);
continue aMi;
}
if((aL0)===(0x0027)){
break aMi;
}
if((aL0)===(0x005C)){
(aMg)=(true);
continue aMi;
}
if(aMf){
(D)((65574),(aL1),([((KD)((aMe)))]));
(xN)((aL0));
return null;
}
(aMe)=(aL0);
(aMf)=(true);
}
if(!(aMf)){
(D)((65575),(aL1),(null));
(xN)((aL0));
return null;
}
return (ayC)((aL1),(2),(aMe));
break;
case 0x0028:
(aMy)=((NR)());
(aL0)=((xm)());
if((aL0)!==(0x0029)){
(D)((65576),(aL1),(null));
(xN)((aL0));
return null;
}
return aMy;
break;
case 0x005B:
(aM2)=(new Qu());
(NW)((aM2),(2060),(aL1));
((aM2).an3)=({L:0,H:null,T:null,P:null});
(aL0)=((xm)());
if((aL0)!==(0x005D)){
(pJ)=(aL0);
aM6:
while(true){
(aM7)=((NR)());
if((aM7)!==(null)){
(eP)(((aM2).an3),([130,134]),(aM7));
}
(aL0)=((xm)());
if((aL0)===(0x0000)){
break aM6;
}
if((aL0)===(0x005D)){
break aM6;
}
if((aL0)!==(0x002C)){
(LW)((0x002C),(aL0));
return null;
}
}
}
return aM2;
break;
case 0x0025:
(aMH)=((x2)((false),(false)));
(aMI)=(new Qo());
(NW)((aMI),(67587),(aL1));
(aMK)=(new aML());
(xj)((aMK),(1028),(aL1),(null),(false));
((aMI).zn)=(aMK);
((aMI).ah7)=(aMH);
return aMI;
break;
default:
if(((0x0030)<=(aL0))&&((aL0)<=(0x0039))){
return (aMP)((aLy),(aLz),(aL0));
}
if(((((((0x0061)<=(aL0))&&((aL0)<=(0x007A)))||(((0x0041)<=(aL0))&&((aL0)<=(0x005A))))||((aL0)===(0x005F)))||((aL0)===(0x0040)))||((aL0)===(0x005C))){
(pJ)=(aL0);
(aMS)=((x2)((true),(true)));
aMU=aMS;
if(aMU.S===({S:"false"}).S){
return (ayC)((aL1),(3),(0x0000000000000000));
}
else if(aMU.S===({S:"true"}).S){
return (ayC)((aL1),(3),(0x0000000000000001));
}
else if(aMU.S===({S:"inf"}).S){
return (aMY)((aL1),(Infinity));
}
else if(aMU.S===({S:"null"}).S){
(aNa)=(new zi());
(NW)((aNa),(67584),(aL1));
(aNc)=(new R5());
(xj)((aNc),(1027),(aL1),(null),(false));
((aNa).zn)=(aNc);
return aNa;
}
else if(aMU.S===({S:"dbg"}).S){
return (ayC)((aL1),(3),((aW)?(0x0000000000000000):(0x0000000000000001)));
}
else if(aMU.S===({S:"env"}).S){
return (ayC)((aL1),(0),(bL));
}
else{(aNg)=(new yO());
(NW)((aNg),(2062),(aL1));
(Ma)((aNg),(aMS));
return aNg;
}
}
break;
}
(pJ)=(aL0);
return null;
}
// makeStrValue
function aLJ(aNh /*pos*/,aNi /*value*/){
let aNj=null; // expr
let aNl=null; // type
let aNn=null; // type2
(aNj)=(new Ql());
(NW)((aNj),(67586),(aNh));
(aNl)=(new AP());
(xj)((aNl),(66561),(aNh),(null),(false));
(aNn)=(new y1());
(xj)((aNn),(1026),(aNh),(null),(false));
((aNn).y2)=(2);
((aNl).AR)=(aNn);
((aNj).zn)=(aNl);
((aNj).ail)=(aNi);
return aNj;
}
// escChar
function aLS(aNo /*c*/){
let aNq=0;
let aNw=null; // buf
let aN3=0;
let aNB=false;
let aNx=0;
let aNy=0;
let aNz=0;
let aN0=0;
let aN4=0;
let aN7=0;
let aN8=0;
let aN9=0;
let aNA=false;
switch(aNo){
case 0x0022:
case 0x0027:
case 0x005C:
return aNo;
break;
case 0x0030:
return 0x0000;
break;
case 0x006E:
return 0x000A;
break;
case 0x0074:
return 0x0009;
break;
case 0x0075:
(aNw)=({S:"\0".repeat(6)});
(aNw).S=(aNx=(0),(aNw).S.slice(0,aNx)+String.fromCharCode(0x0030)+(aNw).S.slice(aNx+1));
(aNw).S=(aNz=(1),(aNw).S.slice(0,aNz)+String.fromCharCode(0x0078)+(aNw).S.slice(aNz+1));
aN2:
for(aN3=(0),aN4=(3);aN3<=aN4;aN3+=(1)){
(aNo)=((ads)());
if(!((((0x0030)<=(aNo))&&((aNo)<=(0x0039)))||(((0x0041)<=(aNo))&&((aNo)<=(0x0046))))){
(D)((65572),((KC)()),(null));
return 0x0075;
}
(aNw).S=(aN7=((2)+(aN3)),(aNw).S.slice(0,aN7)+String.fromCharCode(aNo)+(aNw).S.slice(aN7+1));
}
return (aN9=(ca)((aNw),(aNA={$:(aNB)},aNA)),(aNB)=aNA.$,aN9);
break;
default:
(D)((65571),((KC)()),([((KD)((aNo)))]));
return aNo;
break;
}
}
// parseExprNumber
function aMP(aND /*row*/,aNE /*col*/,aNF /*c*/){
let aNG=null; // pos
let aNH=null; // buf
let aNI=0; // len
let aNJ=0; // base
let aNK=false; // changeBase
let aNL=false; // floatType
let aNM=0; // byteSize
let aNQ=0;
let aOC=0; // value
let aOG=false; // success
let aOJ=null; // ast2
let aOK=null; // ast
let aOP=0;
let aOZ=0; // value
let aPd=false; // success
let aPl=null; // ast2
let aPo=null; // type
let aPt=null; // type
let aOb=0;
let aOc=0;
let aOh=0;
let aOi=0;
let aOt=0;
let aOu=0;
let aO0=0;
let aO1=0;
let aO8=0;
let aO9=0;
let aOD=0;
let aOF=false;
let aPa=0;
let aPc=false;
let aPf=0;
let aPg=false;
(aNG)=((xk)((ag),(aND),(aNE)));
(aNH)=({S:"\0".repeat(1024)});
(aNI)=(0);
(aNJ)=(10);
(aNK)=(false);
(aNL)=(false);
(aNM)=(0);
aNO:
while(true){
aNQ=aNF;
if(aNQ===(0x0078)){
if((aNK)||(aNL)){
(D)((65577),(aNG),([({S:"x"})]));
(xN)((aNF));
return null;
}
if(((aNI)!==(1))||(((aNH).S.charCodeAt(0))!==(0x0030))){
(D)((65579),(aNG),(null));
(xN)((aNF));
return null;
}
(aNI)=(0);
(aNJ)=(16);
(aNK)=(true);
}
else if(aNQ===(0x002E)){
if((aNK)||(aNL)){
(D)((65577),(aNG),([({S:"."})]));
(xN)((aNF));
return null;
}
if((aNI)===(1024)){
(D)((65578),(aNG),([((pB)((aNH),([129,2]),(0),(aNI)))]));
(xN)((aNF));
return null;
}
(aNH).S=(aOb=(aNI),(aNH).S.slice(0,aOb)+String.fromCharCode(aNF)+(aNH).S.slice(aOb+1));
(aNI)=((aNI)+(1));
(aNL)=(true);
}
else if((0x0030)<=aNQ&&aNQ<=(0x0039)||(0x0041)<=aNQ&&aNQ<=(0x0046)){
if((aNI)===(1024)){
(D)((65578),(aNG),([((pB)((aNH),([129,2]),(0),(aNI)))]));
(xN)((aNF));
return null;
}
(aNH).S=(aOh=(aNI),(aNH).S.slice(0,aOh)+String.fromCharCode(aNF)+(aNH).S.slice(aOh+1));
(aNI)=((aNI)+(1));
}
else{(pJ)=(aNF);
break aNO;
}
(aNF)=((xO)());
}
if(((aNI)===(0))||(((aNH).S.charCodeAt((aNI)-(1)))===(0x002E))){
(D)((65577),(aNG),([({S:"."})]));
(xN)(((xO)()));
return null;
}
if(aNL){
(aNF)=((xO)());
if((aNF)===(0x0065)){
if((aNI)===(1024)){
(D)((65578),(aNG),([((pB)((aNH),([129,2]),(0),(aNI)))]));
(xN)((aNF));
return null;
}
(aNH).S=(aOt=(aNI),(aNH).S.slice(0,aOt)+String.fromCharCode(aNF)+(aNH).S.slice(aOt+1));
(aNI)=((aNI)+(1));
(aNF)=((xO)());
if(((aNF)!==(0x002B))&&((aNF)!==(0x002D))){
(D)((65580),(aNG),(null));
(xN)((aNF));
return null;
}
if((aNI)===(1024)){
(D)((65578),(aNG),([((pB)((aNH),([129,2]),(0),(aNI)))]));
(xN)((aNF));
return null;
}
(aNH).S=(aO0=(aNI),(aNH).S.slice(0,aO0)+String.fromCharCode(aNF)+(aNH).S.slice(aO0+1));
(aNI)=((aNI)+(1));
(aNF)=((xO)());
if(!(((0x0030)<=(aNF))&&((aNF)<=(0x0039)))){
(D)((65580),(aNG),(null));
(xN)((aNF));
return null;
}
do{
if((aNI)===(1024)){
(D)((65578),(aNG),([((pB)((aNH),([129,2]),(0),(aNI)))]));
(xN)((aNF));
return null;
}
(aNH).S=(aO8=(aNI),(aNH).S.slice(0,aO8)+String.fromCharCode(aNF)+(aNH).S.slice(aO8+1));
(aNI)=((aNI)+(1));
(aNF)=((xO)());
}while(((0x0030)<=(aNF))&&((aNF)<=(0x0039)));
}
(pJ)=(aNF);
(aOC)=((aOD=(aOE)(((pB)((aNH),([129,2]),(0),(aNI))),(aOF={$:(aOG)},aOF)),(aOG)=aOF.$,aOD));
if(!(aOG)){
(D)((65581),(aNG),([((pB)((aNH),([129,2]),(0),(aNI)))]));
(xN)(((xO)()));
return null;
}
(aOJ)=(new Qr());
(NW)((aOJ),(67588),(aNG));
((aOJ).ag7)=(aOC);
(aOK)=(aOJ);
}
else{
(aNF)=((xO)());
if((aNF)===(0x0062)){
(aNF)=((xO)());
switch(aNF){
case 0x0038:
(aNM)=(1);
break;
case 0x0031:
(Mb)((0x0036),(false));
(aNM)=(2);
break;
case 0x0033:
(Mb)((0x0032),(false));
(aNM)=(4);
break;
case 0x0036:
(Mb)((0x0034),(false));
(aNM)=(8);
break;
default:
(D)((65582),(aNG),([((pB)((aNH),([129,2]),(0),(aNI)))]));
(xN)((aNF));
break;
}
}
else{
(pJ)=(aNF);
}
if((aNJ)===(10)){
(aOZ)=((aPa=(aPb)(((pB)((aNH),([129,2]),(0),(aNI))),(aPc={$:(aPd)},aPc)),(aPd)=aPc.$,aPa));
}
else{
if(!((aNJ)===(16))){throw 0xE9170000;}
(aOZ)=((aPf=(aPb)(({S:({S:"0x"}).S+((pB)((aNH),([129,2]),(0),(aNI))).S}),(aPg={$:(aPd)},aPg)),(aPd)=aPg.$,aPf));
}
if(!(aPd)){
(D)((65583),(aNG),([((pB)((aNH),([129,2]),(0),(aNI)))]));
(xN)(((xO)()));
return null;
}
if((((((aNM)===(1))&&((aOZ)>(0x00000000000000FF)))||(((aNM)===(2))&&((aOZ)>(0x000000000000FFFF))))||(((aNM)===(4))&&((aOZ)>(0x00000000FFFFFFFF))))||(((aNM)===(0))&&((aOZ)>(0x7FFFFFFFFFFFFFFF)))){
(D)((65583),(aNG),([((pB)((aNH),([129,2]),(0),(aNI)))]));
(xN)(((xO)()));
return null;
}
(aPl)=(new zh());
(NW)((aPl),(67585),(aNG));
((aPl).zk)=(aOZ);
(aOK)=(aPl);
}
if((aNM)===(0)){
(aPo)=(new y1());
(xj)((aPo),(1026),(aNG),(null),(false));
if(aNL){
((aPo).y2)=(1);
}
else{
((aPo).y2)=(0);
}
((aOK).zn)=(aPo);
}
else{
(aPt)=(new AT());
(xj)((aPt),(1025),(aNG),(null),(false));
((aPt).AU)=(aNM);
((aOK).zn)=(aPt);
}
return aOK;
}
// makeFloatValue
function aMY(aPu /*pos*/,aPv /*value*/){
let aPw=null; // expr
let aPy=null; // type
(aPw)=(new Qr());
(NW)((aPw),(67588),(aPu));
(aPy)=(new y1());
(xj)((aPy),(1026),(aPu),(null),(false));
((aPy).y2)=(1);
((aPw).zn)=(aPy);
((aPw).ag7)=(aPv);
return aPw;
}
// _toFloat
function aOE(aPz /*me_*/,aP0 /*success*/){
let r_=Number(aPz.S);
aP0.$=!isNaN(r_);
return r_;
}
// _toBit64
function aPb(aP1 /*me_*/,aP2 /*success*/){
if(aP1.S.length>=2&&aP1.S[0]==="0"&&aP1.S[1]==="x"){
let s_=aP1.S.slice(2),r_=Number(aP1.S);
aP2.$=!isNaN(r_);
return parseInt(s_,16);
}else{
let r_=Number(aP1.S);
aP2.$=!isNaN(r_);
return parseInt(aP1.S,10);
}
}
// Class
function cA(){
Object.call(this);
aP3(this);
}
cA.prototype = Object.create(Object.prototype);
// HasType
function c9(){
cA.call(this);
}
c9.prototype = Object.create(cA.prototype);
// Ast
function c8(){
c9.call(this);
}
c8.prototype = Object.create(c9.prototype);
// AstFunc
function c7(){
c8.call(this);
}
c7.prototype = Object.create(c8.prototype);
// ResFiles
function cF(){
cA.call(this);
}
cF.prototype = Object.create(cA.prototype);
// Pos
function dg(){
cA.call(this);
}
dg.prototype = Object.create(cA.prototype);
// Bool
function e2(){
cA.call(this);
}
e2.prototype = Object.create(cA.prototype);
// AstClass
function fb(){
c8.call(this);
}
fb.prototype = Object.create(c8.prototype);
// Reader
function pE(){
cA.call(this);
}
pE.prototype = Object.create(cA.prototype);
// AstRoot
function pP(){
c8.call(this);
}
pP.prototype = Object.create(c8.prototype);
// ScopeRefedItem
function qy(){
cA.call(this);
}
qy.prototype = Object.create(cA.prototype);
// AstArg
function rq(){
c8.call(this);
}
rq.prototype = Object.create(c8.prototype);
// CppInfo
function rX(){
c9.call(this);
}
rX.prototype = Object.create(c9.prototype);
// AstType
function tf(){
c8.call(this);
}
tf.prototype = Object.create(c8.prototype);
// TmpVar
function t4(){
cA.call(this);
}
t4.prototype = Object.create(cA.prototype);
// AstClassItem
function tS(){
cA.call(this);
}
tS.prototype = Object.create(cA.prototype);
// AstVar
function tX(){
c8.call(this);
}
tX.prototype = Object.create(c8.prototype);
// Writer
function u3(){
cA.call(this);
}
u3.prototype = Object.create(cA.prototype);
// WebInfo
function uL(){
c9.call(this);
}
uL.prototype = Object.create(c9.prototype);
// TmpVar
function v7(){
cA.call(this);
}
v7.prototype = Object.create(cA.prototype);
// AstConst
function xC(){
c8.call(this);
}
xC.prototype = Object.create(c8.prototype);
// AstAlias
function xF(){
c8.call(this);
}
xF.prototype = Object.create(c8.prototype);
// AstEnum
function xL(){
c8.call(this);
}
xL.prototype = Object.create(c8.prototype);
// AstStat
function yw(){
c8.call(this);
}
yw.prototype = Object.create(c8.prototype);
// AstStatBreakable
function yv(){
yw.call(this);
}
yv.prototype = Object.create(yw.prototype);
// AstStatTry
function yu(){
yv.call(this);
}
yu.prototype = Object.create(yv.prototype);
// AstTypePrim
function y1(){
tf.call(this);
}
y1.prototype = Object.create(tf.prototype);
// AstStatBlock
function y7(){
yv.call(this);
}
y7.prototype = Object.create(yv.prototype);
// AstStatDo
function yK(){
yw.call(this);
}
yK.prototype = Object.create(yw.prototype);
// AstExpr
function yO(){
c8.call(this);
}
yO.prototype = Object.create(c8.prototype);
// AstExprCall
function yN(){
yO.call(this);
}
yN.prototype = Object.create(yO.prototype);
// AstStatCatch
function yX(){
yw.call(this);
}
yX.prototype = Object.create(yw.prototype);
// ExprPair
function ze(){
cA.call(this);
}
ze.prototype = Object.create(cA.prototype);
// AstExprValue
function zi(){
yO.call(this);
}
zi.prototype = Object.create(yO.prototype);
// AstExprValuePrim
function zh(){
zi.call(this);
}
zh.prototype = Object.create(zi.prototype);
// AstExprCallArg
function z2(){
cA.call(this);
}
z2.prototype = Object.create(cA.prototype);
// AstExpr2
function An(){
yO.call(this);
}
An.prototype = Object.create(yO.prototype);
// AstTypeNullable
function AQ(){
tf.call(this);
}
AQ.prototype = Object.create(tf.prototype);
// AstTypeArray
function AP(){
AQ.call(this);
}
AP.prototype = Object.create(AQ.prototype);
// AstTypeBit
function AT(){
tf.call(this);
}
AT.prototype = Object.create(tf.prototype);
// AstTypeFunc
function AX(){
AQ.call(this);
}
AX.prototype = Object.create(AQ.prototype);
// AstTypeFuncArg
function Bh(){
cA.call(this);
}
Bh.prototype = Object.create(cA.prototype);
// AstTypeGen
function Bu(){
AQ.call(this);
}
Bu.prototype = Object.create(AQ.prototype);
// AstTypeDict
function B5(){
AQ.call(this);
}
B5.prototype = Object.create(AQ.prototype);
// AstStatIf
function EA(){
yv.call(this);
}
EA.prototype = Object.create(yv.prototype);
// AstStatSwitch
function ED(){
yv.call(this);
}
ED.prototype = Object.create(yv.prototype);
// AstStatSkipable
function EH(){
yv.call(this);
}
EH.prototype = Object.create(yv.prototype);
// AstStatWhile
function EG(){
EH.call(this);
}
EG.prototype = Object.create(EH.prototype);
// AstStatFor
function EK(){
EH.call(this);
}
EK.prototype = Object.create(EH.prototype);
// AstStatThrow
function EP(){
yw.call(this);
}
EP.prototype = Object.create(yw.prototype);
// AstStatRet
function EU(){
yw.call(this);
}
EU.prototype = Object.create(yw.prototype);
// AstStatAssert
function Fd(){
yw.call(this);
}
Fd.prototype = Object.create(yw.prototype);
// AstTypeUser
function Mi(){
AQ.call(this);
}
Mi.prototype = Object.create(AQ.prototype);
// AstExpr1
function PC(){
yO.call(this);
}
PC.prototype = Object.create(yO.prototype);
// AstExpr3
function PH(){
yO.call(this);
}
PH.prototype = Object.create(yO.prototype);
// AstExprNew
function PK(){
yO.call(this);
}
PK.prototype = Object.create(yO.prototype);
// AstExprNewArray
function PN(){
yO.call(this);
}
PN.prototype = Object.create(yO.prototype);
// AstExprAs
function PQ(){
yO.call(this);
}
PQ.prototype = Object.create(yO.prototype);
// AstExprToBin
function PT(){
yO.call(this);
}
PT.prototype = Object.create(yO.prototype);
// AstExprFromBin
function PW(){
yO.call(this);
}
PW.prototype = Object.create(yO.prototype);
// AstExprArray
function Qb(){
yO.call(this);
}
Qb.prototype = Object.create(yO.prototype);
// AstExprDot
function Qe(){
yO.call(this);
}
Qe.prototype = Object.create(yO.prototype);
// AstExprValueStr
function Ql(){
zi.call(this);
}
Ql.prototype = Object.create(zi.prototype);
// AstExprValueEnumElement
function Qo(){
zi.call(this);
}
Qo.prototype = Object.create(zi.prototype);
// AstExprValueFloat
function Qr(){
zi.call(this);
}
Qr.prototype = Object.create(zi.prototype);
// AstExprValueArray
function Qu(){
yO.call(this);
}
Qu.prototype = Object.create(yO.prototype);
// AstStatVar
function QA(){
yw.call(this);
}
QA.prototype = Object.create(yw.prototype);
// AstTypeNull
function R5(){
tf.call(this);
}
R5.prototype = Object.create(tf.prototype);
// AstStatElIf
function S0(){
yw.call(this);
}
S0.prototype = Object.create(yw.prototype);
// AstStatCase
function SP(){
yw.call(this);
}
SP.prototype = Object.create(yw.prototype);
// AstStatFunc
function aw7(){
yw.call(this);
}
aw7.prototype = Object.create(yw.prototype);
// AstStatConst
function awB(){
yw.call(this);
}
awB.prototype = Object.create(yw.prototype);
// AstStatAlias
function awE(){
yw.call(this);
}
awE.prototype = Object.create(yw.prototype);
// AstStatClass
function awH(){
yw.call(this);
}
awH.prototype = Object.create(yw.prototype);
// AstStatEnum
function awK(){
yw.call(this);
}
awK.prototype = Object.create(yw.prototype);
// AstTypeEnumElement
function aML(){
tf.call(this);
}
aML.prototype = Object.create(tf.prototype);
// ctor
function aP3(aP4 /*me*/){
}
// _dtor
function aP5(aP6 /*me*/){
}
// cmp
function aP7(aP8 /*me*/,aP9 /*t*/){
throw 3910598660;
}
// _copy
function aPA(aPB /*me*/){
let aPC=null;
(aPC)=(new cA());
return aPC;
}
// _toBin
function aPD(aPE /*me*/){
let aPF=null;
(aPF)=(new Array(8).fill(0));
return aPF;
}
// _fromBin
function aPG(aPH /*me*/,aPI /*bin*/,aPJ /*idx*/){
let aPK=null;
(aPK)=(new cA());
return aPK;
}
// toStr
function aPL(aPM /*me*/){
return {S:""};
}
// _dtor
function aPN(aPO){
}
// _copy
function aPP(aPQ){
let aPR=null;
(aPR)=(new c9());
((aPR).qe)=((aPQ).qe);
return aPR;
}
// _toBin
function aPS(aPT){
let aPU=null;
(aPU)=(new Array(8).fill(0));
(aPU)=((aPU).concat(toBin_((aPT).qe)));
return aPU;
}
// _fromBin
function aPW(aPX,aPY,aPZ){
let aQa=null;
(aQa)=(new c9());
((aQa).qe)=(fromBin_((aPY),(aPZ.$)));
return aQa;
}
// cmp
function aQb(aQc /*me*/,aQd /*t*/){
let aQe=0; // meAddr
let aQg=0; // tAddr
(aQe)=((aQf)((aQc)));
(aQg)=((aQf)((aQd)));
return ((aQe)>(aQg))?(1):(((aQe)<(aQg))?(-1):(0));
}
// _dtor
function aQh(aQi){
((aQi).qn)=(null);
((aQi).qZ)=(null);
((aQi).qW)=(null);
((aQi).qa)=(null);
((aQi).q2)=(null);
((aQi).q1)=(null);
((aQi).zJ)=(null);
}
// _copy
function aQj(aQk){
let aQl=null;
(aQl)=(new c8());
((aQl).qn)=(C_([134],((aQk).qn)));
((aQl).qZ)=(C_([129,2],((aQk).qZ)));
((aQl).qW)=(C_([134],((aQk).qW)));
((aQl).qa)=(C_([133,129,2,134],((aQk).qa)));
((aQl).q2)=(C_([129,2],((aQk).q2)));
((aQl).q1)=(C_([134],((aQk).q1)));
((aQl).zJ)=(C_([134],((aQk).zJ)));
((aQl).r7)=((aQk).r7);
((aQl).qe)=((aQk).qe);
return aQl;
}
// _toBin
function aQm(aQn){
let aQo=null;
(aQo)=(new Array(8).fill(0));
(aQo)=((aQo).concat(toBin_((aQn).qn)));
(aQo)=((aQo).concat(toBin_((aQn).qZ)));
(aQo)=((aQo).concat(toBin_((aQn).qW)));
(aQo)=((aQo).concat(toBin_((aQn).qa)));
(aQo)=((aQo).concat(toBin_((aQn).q2)));
(aQo)=((aQo).concat(toBin_((aQn).q1)));
(aQo)=((aQo).concat(toBin_((aQn).zJ)));
(aQo)=((aQo).concat(toBin_((aQn).r7)));
(aQo)=((aQo).concat(toBin_((aQn).qe)));
return aQo;
}
// _fromBin
function aQy(aQz,aQ0,aQ1){
let aQ2=null;
(aQ2)=(new c8());
((aQ2).qn)=(fromBin_((aQ0),(aQ1.$)));
((aQ2).qZ)=(fromBin_((aQ0),(aQ1.$)));
((aQ2).qW)=(fromBin_((aQ0),(aQ1.$)));
((aQ2).qa)=(fromBin_((aQ0),(aQ1.$)));
((aQ2).q2)=(fromBin_((aQ0),(aQ1.$)));
((aQ2).q1)=(fromBin_((aQ0),(aQ1.$)));
((aQ2).zJ)=(fromBin_((aQ0),(aQ1.$)));
((aQ2).r7)=(fromBin_((aQ0),(aQ1.$)));
((aQ2).qe)=(fromBin_((aQ0),(aQ1.$)));
return aQ2;
}
// _dtor
function aQ3(aQ4){
((aQ4).ql)=(null);
((aQ4).qi)=(null);
((aQ4).qj)=(null);
((aQ4).tr)=(null);
((aQ4).qn)=(null);
((aQ4).qZ)=(null);
((aQ4).qW)=(null);
((aQ4).qa)=(null);
((aQ4).q2)=(null);
((aQ4).q1)=(null);
((aQ4).zJ)=(null);
}
// _copy
function aQ5(aQ6){
let aQ7=null;
(aQ7)=(new c7());
((aQ7).qk)=((aQ6).qk);
((aQ7).ql)=(C_([130,129,2],((aQ6).ql)));
((aQ7).qi)=(C_([130,134],((aQ6).qi)));
((aQ7).qj)=(C_([134],((aQ6).qj)));
((aQ7).tr)=(C_([130,134],((aQ6).tr)));
((aQ7).qn)=(C_([134],((aQ6).qn)));
((aQ7).qZ)=(C_([129,2],((aQ6).qZ)));
((aQ7).qW)=(C_([134],((aQ6).qW)));
((aQ7).qa)=(C_([133,129,2,134],((aQ6).qa)));
((aQ7).q2)=(C_([129,2],((aQ6).q2)));
((aQ7).q1)=(C_([134],((aQ6).q1)));
((aQ7).zJ)=(C_([134],((aQ6).zJ)));
((aQ7).r7)=((aQ6).r7);
((aQ7).qe)=((aQ6).qe);
return aQ7;
}
// _toBin
function aQ8(aQ9){
let aQA=null;
(aQA)=(new Array(8).fill(0));
(aQA)=((aQA).concat(toBin_((aQ9).qk)));
(aQA)=((aQA).concat(toBin_((aQ9).ql)));
(aQA)=((aQA).concat(toBin_((aQ9).qi)));
(aQA)=((aQA).concat(toBin_((aQ9).qj)));
(aQA)=((aQA).concat(toBin_((aQ9).tr)));
(aQA)=((aQA).concat(toBin_((aQ9).qn)));
(aQA)=((aQA).concat(toBin_((aQ9).qZ)));
(aQA)=((aQA).concat(toBin_((aQ9).qW)));
(aQA)=((aQA).concat(toBin_((aQ9).qa)));
(aQA)=((aQA).concat(toBin_((aQ9).q2)));
(aQA)=((aQA).concat(toBin_((aQ9).q1)));
(aQA)=((aQA).concat(toBin_((aQ9).zJ)));
(aQA)=((aQA).concat(toBin_((aQ9).r7)));
(aQA)=((aQA).concat(toBin_((aQ9).qe)));
return aQA;
}
// _fromBin
function aQP(aQQ,aQR,aQS){
let aQT=null;
(aQT)=(new c7());
((aQT).qk)=(fromBin_((aQR),(aQS.$)));
((aQT).ql)=(fromBin_((aQR),(aQS.$)));
((aQT).qi)=(fromBin_((aQR),(aQS.$)));
((aQT).qj)=(fromBin_((aQR),(aQS.$)));
((aQT).tr)=(fromBin_((aQR),(aQS.$)));
((aQT).qn)=(fromBin_((aQR),(aQS.$)));
((aQT).qZ)=(fromBin_((aQR),(aQS.$)));
((aQT).qW)=(fromBin_((aQR),(aQS.$)));
((aQT).qa)=(fromBin_((aQR),(aQS.$)));
((aQT).q2)=(fromBin_((aQR),(aQS.$)));
((aQT).q1)=(fromBin_((aQR),(aQS.$)));
((aQT).zJ)=(fromBin_((aQR),(aQS.$)));
((aQT).r7)=(fromBin_((aQR),(aQS.$)));
((aQT).qe)=(fromBin_((aQR),(aQS.$)));
return aQT;
}
// _dtor
function aQU(aQV){
((aQV).cG)=(null);
}
// _copy
function aQW(aQX){
let aQY=null;
(aQY)=(new cF());
((aQY).cG)=(C_([130,129,2],((aQX).cG)));
return aQY;
}
// _toBin
function aQZ(aRa){
let aRb=null;
(aRb)=(new Array(8).fill(0));
(aRb)=((aRb).concat(toBin_((aRa).cG)));
return aRb;
}
// _fromBin
function aRd(aRe,aRf,aRg){
let aRh=null;
(aRh)=(new cF());
((aRh).cG)=(fromBin_((aRf),(aRg.$)));
return aRh;
}
// _dtor
function aRi(aRj){
((aRj).dh)=(null);
}
// _copy
function aRk(aRl){
let aRm=null;
(aRm)=(new dg());
((aRm).dh)=(C_([129,2],((aRl).dh)));
((aRm).di)=((aRl).di);
((aRm).dj)=((aRl).dj);
return aRm;
}
// _toBin
function aRn(aRo){
let aRp=null;
(aRp)=(new Array(8).fill(0));
(aRp)=((aRp).concat(toBin_((aRo).dh)));
(aRp)=((aRp).concat(toBin_((aRo).di)));
(aRp)=((aRp).concat(toBin_((aRo).dj)));
return aRp;
}
// _fromBin
function aRt(aRu,aRv,aRw){
let aRx=null;
(aRx)=(new dg());
((aRx).dh)=(fromBin_((aRv),(aRw.$)));
((aRx).di)=(fromBin_((aRv),(aRw.$)));
((aRx).dj)=(fromBin_((aRv),(aRw.$)));
return aRx;
}
// cmp
function aRy(aRz /*me*/,aR0 /*t*/){
return (aR1)(((((aRz).e3)?1:0)-(((aR0).e3)?1:0)));
}
// toStr
function aR2(aR3 /*me*/){
return (v)(((aR3).e3),([3]));
}
// _dtor
function aR4(aR5){
}
// _copy
function aR6(aR7){
let aR8=null;
(aR8)=(new e2());
((aR8).e3)=((aR7).e3);
return aR8;
}
// _toBin
function aR9(aRA){
let aRB=null;
(aRB)=(new Array(8).fill(0));
(aRB)=((aRB).concat(toBin_((aRA).e3)));
return aRB;
}
// _fromBin
function aRD(aRE,aRF,aRG){
let aRH=null;
(aRH)=(new e2());
((aRH).e3)=(fromBin_((aRF),(aRG.$)));
return aRH;
}
// _dtor
function aRI(aRJ){
((aRJ).ti)=(null);
((aRJ).qn)=(null);
((aRJ).qZ)=(null);
((aRJ).qW)=(null);
((aRJ).qa)=(null);
((aRJ).q2)=(null);
((aRJ).q1)=(null);
((aRJ).zJ)=(null);
}
// _copy
function aRK(aRL){
let aRM=null;
(aRM)=(new fb());
((aRM).ti)=(C_([130,134],((aRL).ti)));
((aRM).qn)=(C_([134],((aRL).qn)));
((aRM).qZ)=(C_([129,2],((aRL).qZ)));
((aRM).qW)=(C_([134],((aRL).qW)));
((aRM).qa)=(C_([133,129,2,134],((aRL).qa)));
((aRM).q2)=(C_([129,2],((aRL).q2)));
((aRM).q1)=(C_([134],((aRL).q1)));
((aRM).zJ)=(C_([134],((aRL).zJ)));
((aRM).r7)=((aRL).r7);
((aRM).qe)=((aRL).qe);
return aRM;
}
// _toBin
function aRN(aRO){
let aRP=null;
(aRP)=(new Array(8).fill(0));
(aRP)=((aRP).concat(toBin_((aRO).ti)));
(aRP)=((aRP).concat(toBin_((aRO).qn)));
(aRP)=((aRP).concat(toBin_((aRO).qZ)));
(aRP)=((aRP).concat(toBin_((aRO).qW)));
(aRP)=((aRP).concat(toBin_((aRO).qa)));
(aRP)=((aRP).concat(toBin_((aRO).q2)));
(aRP)=((aRP).concat(toBin_((aRO).q1)));
(aRP)=((aRP).concat(toBin_((aRO).zJ)));
(aRP)=((aRP).concat(toBin_((aRO).r7)));
(aRP)=((aRP).concat(toBin_((aRO).qe)));
return aRP;
}
// _fromBin
function aSa(aSb,aSc,aSd){
let aSe=null;
(aSe)=(new fb());
((aSe).ti)=(fromBin_((aSc),(aSd.$)));
((aSe).qn)=(fromBin_((aSc),(aSd.$)));
((aSe).qZ)=(fromBin_((aSc),(aSd.$)));
((aSe).qW)=(fromBin_((aSc),(aSd.$)));
((aSe).qa)=(fromBin_((aSc),(aSd.$)));
((aSe).q2)=(fromBin_((aSc),(aSd.$)));
((aSe).q1)=(fromBin_((aSc),(aSd.$)));
((aSe).zJ)=(fromBin_((aSc),(aSd.$)));
((aSe).r7)=(fromBin_((aSc),(aSd.$)));
((aSe).qe)=(fromBin_((aSc),(aSd.$)));
return aSe;
}
// _dtor
function aSf(aSg /*me*/){
}
// fin
function pQ(aSh /*me*/){
aSh.xh.F=null;
}
// setPos
function aSi(aSj /*me*/,aSk /*origin*/,aSl /*pos*/){
aSj.xh.I=aSl;
}
// getPos
function aSm(aSn /*me*/){
return aSn.xh.I;
}
// delimiter
function aSo(aSp /*me*/,aSq /*delimiters*/){
}
// read
function aSr(aSs /*me*/,aSt /*size*/){
}
// readLetter
function YP(aSu /*me*/){
return aSu.xh.F.charCodeAt(aSu.xh.I++);
}
// readInt
function aSv(aSw /*me*/){
}
// readFloat
function aSx(aSy /*me*/){
}
// readChar
function aSz(aS0 /*me*/){
}
// readStr
function aS1(aS2 /*me*/){
}
// readLine
function wz(aS3 /*me*/){
return null;
}
// fileSize
function aS4(aS5 /*me*/){
}
// term
function wx(aS6 /*me*/){
return aS6.xh.I>=aS6.xh.F.length;
}
// _copy
function aS7(aS8){
let aS9=null;
(aS9)=(new pE());
((aS9).xh)=((aS8).xh);
((aS9).aSA)=((aS8).aSA);
((aS9).aSB)=((aS8).aSB);
((aS9).aSC)=((aS8).aSC);
return aS9;
}
// _toBin
function aSD(aSE){
let aSF=null;
(aSF)=(new Array(8).fill(0));
(aSF)=((aSF).concat(toBin_((aSE).xh)));
(aSF)=((aSF).concat(toBin_((aSE).aSA)));
(aSF)=((aSF).concat(toBin_((aSE).aSB)));
(aSF)=((aSF).concat(toBin_((aSE).aSC)));
return aSF;
}
// _fromBin
function aSK(aSL,aSM,aSN){
let aSO=null;
(aSO)=(new pE());
((aSO).xh)=(fromBin_((aSM),(aSN.$)));
((aSO).aSA)=(fromBin_((aSM),(aSN.$)));
((aSO).aSB)=(fromBin_((aSM),(aSN.$)));
((aSO).aSC)=(fromBin_((aSM),(aSN.$)));
return aSO;
}
// _dtor
function aSP(aSQ){
((aSQ).rK)=(null);
((aSQ).qs)=(null);
((aSQ).qn)=(null);
((aSQ).qZ)=(null);
((aSQ).qW)=(null);
((aSQ).qa)=(null);
((aSQ).q2)=(null);
((aSQ).q1)=(null);
((aSQ).zJ)=(null);
}
// _copy
function aSR(aSS){
let aST=null;
(aST)=(new pP());
((aST).rK)=(C_([130,134],((aSS).rK)));
((aST).qs)=(C_([130,134],((aSS).qs)));
((aST).qn)=(C_([134],((aSS).qn)));
((aST).qZ)=(C_([129,2],((aSS).qZ)));
((aST).qW)=(C_([134],((aSS).qW)));
((aST).qa)=(C_([133,129,2,134],((aSS).qa)));
((aST).q2)=(C_([129,2],((aSS).q2)));
((aST).q1)=(C_([134],((aSS).q1)));
((aST).zJ)=(C_([134],((aSS).zJ)));
((aST).r7)=((aSS).r7);
((aST).qe)=((aSS).qe);
return aST;
}
// _toBin
function aSU(aSV){
let aSW=null;
(aSW)=(new Array(8).fill(0));
(aSW)=((aSW).concat(toBin_((aSV).rK)));
(aSW)=((aSW).concat(toBin_((aSV).qs)));
(aSW)=((aSW).concat(toBin_((aSV).qn)));
(aSW)=((aSW).concat(toBin_((aSV).qZ)));
(aSW)=((aSW).concat(toBin_((aSV).qW)));
(aSW)=((aSW).concat(toBin_((aSV).qa)));
(aSW)=((aSW).concat(toBin_((aSV).q2)));
(aSW)=((aSW).concat(toBin_((aSV).q1)));
(aSW)=((aSW).concat(toBin_((aSV).zJ)));
(aSW)=((aSW).concat(toBin_((aSV).r7)));
(aSW)=((aSW).concat(toBin_((aSV).qe)));
return aSW;
}
// _fromBin
function aTi(aTj,aTk,aTl){
let aTm=null;
(aTm)=(new pP());
((aTm).rK)=(fromBin_((aTk),(aTl.$)));
((aTm).qs)=(fromBin_((aTk),(aTl.$)));
((aTm).qn)=(fromBin_((aTk),(aTl.$)));
((aTm).qZ)=(fromBin_((aTk),(aTl.$)));
((aTm).qW)=(fromBin_((aTk),(aTl.$)));
((aTm).qa)=(fromBin_((aTk),(aTl.$)));
((aTm).q2)=(fromBin_((aTk),(aTl.$)));
((aTm).q1)=(fromBin_((aTk),(aTl.$)));
((aTm).zJ)=(fromBin_((aTk),(aTl.$)));
((aTm).r7)=(fromBin_((aTk),(aTl.$)));
((aTm).qe)=(fromBin_((aTk),(aTl.$)));
return aTm;
}
// _dtor
function aTn(aTo){
((aTo).q0)=(null);
((aTo).qR)=(null);
}
// _copy
function aTp(aTq){
let aTr=null;
(aTr)=(new qy());
((aTr).q0)=(C_([134],((aTq).q0)));
((aTr).qR)=(C_([134],((aTq).qR)));
return aTr;
}
// _toBin
function aTs(aTt){
let aTu=null;
(aTu)=(new Array(8).fill(0));
(aTu)=((aTu).concat(toBin_((aTt).q0)));
(aTu)=((aTu).concat(toBin_((aTt).qR)));
return aTu;
}
// _fromBin
function aTx(aTy,aTz,aT0){
let aT1=null;
(aT1)=(new qy());
((aT1).q0)=(fromBin_((aTz),(aT0.$)));
((aT1).qR)=(fromBin_((aTz),(aT0.$)));
return aT1;
}
// _dtor
function aT2(aT3){
((aT3).s6)=(null);
((aT3).y3)=(null);
((aT3).qn)=(null);
((aT3).qZ)=(null);
((aT3).qW)=(null);
((aT3).qa)=(null);
((aT3).q2)=(null);
((aT3).q1)=(null);
((aT3).zJ)=(null);
}
// _copy
function aT4(aT5){
let aT6=null;
(aT6)=(new rq());
((aT6).rr)=((aT5).rr);
((aT6).sL)=((aT5).sL);
((aT6).s6)=(C_([134],((aT5).s6)));
((aT6).y3)=(C_([134],((aT5).y3)));
((aT6).qn)=(C_([134],((aT5).qn)));
((aT6).qZ)=(C_([129,2],((aT5).qZ)));
((aT6).qW)=(C_([134],((aT5).qW)));
((aT6).qa)=(C_([133,129,2,134],((aT5).qa)));
((aT6).q2)=(C_([129,2],((aT5).q2)));
((aT6).q1)=(C_([134],((aT5).q1)));
((aT6).zJ)=(C_([134],((aT5).zJ)));
((aT6).r7)=((aT5).r7);
((aT6).qe)=((aT5).qe);
return aT6;
}
// _toBin
function aT7(aT8){
let aT9=null;
(aT9)=(new Array(8).fill(0));
(aT9)=((aT9).concat(toBin_((aT8).rr)));
(aT9)=((aT9).concat(toBin_((aT8).sL)));
(aT9)=((aT9).concat(toBin_((aT8).s6)));
(aT9)=((aT9).concat(toBin_((aT8).y3)));
(aT9)=((aT9).concat(toBin_((aT8).qn)));
(aT9)=((aT9).concat(toBin_((aT8).qZ)));
(aT9)=((aT9).concat(toBin_((aT8).qW)));
(aT9)=((aT9).concat(toBin_((aT8).qa)));
(aT9)=((aT9).concat(toBin_((aT8).q2)));
(aT9)=((aT9).concat(toBin_((aT8).q1)));
(aT9)=((aT9).concat(toBin_((aT8).zJ)));
(aT9)=((aT9).concat(toBin_((aT8).r7)));
(aT9)=((aT9).concat(toBin_((aT8).qe)));
return aT9;
}
// _fromBin
function aTN(aTO,aTP,aTQ){
let aTR=null;
(aTR)=(new rq());
((aTR).rr)=(fromBin_((aTP),(aTQ.$)));
((aTR).sL)=(fromBin_((aTP),(aTQ.$)));
((aTR).s6)=(fromBin_((aTP),(aTQ.$)));
((aTR).y3)=(fromBin_((aTP),(aTQ.$)));
((aTR).qn)=(fromBin_((aTP),(aTQ.$)));
((aTR).qZ)=(fromBin_((aTP),(aTQ.$)));
((aTR).qW)=(fromBin_((aTP),(aTQ.$)));
((aTR).qa)=(fromBin_((aTP),(aTQ.$)));
((aTR).q2)=(fromBin_((aTP),(aTQ.$)));
((aTR).q1)=(fromBin_((aTP),(aTQ.$)));
((aTR).zJ)=(fromBin_((aTP),(aTQ.$)));
((aTR).r7)=(fromBin_((aTP),(aTQ.$)));
((aTR).qe)=(fromBin_((aTP),(aTQ.$)));
return aTR;
}
// _dtor
function aTS(aTT){
((aTT).sP)=(null);
((aTT).AB)=(null);
((aTT).AE)=(null);
}
// _copy
function aTU(aTV){
let aTW=null;
(aTW)=(new rX());
((aTW).sP)=(C_([129,2],((aTV).sP)));
((aTW).AB)=(C_([129,2],((aTV).AB)));
((aTW).AE)=(C_([129,2],((aTV).AE)));
((aTW).tG)=((aTV).tG);
((aTW).rZ)=((aTV).rZ);
((aTW).AH)=((aTV).AH);
((aTW).AI)=((aTV).AI);
((aTW).qe)=((aTV).qe);
return aTW;
}
// _toBin
function aTX(aTY){
let aTZ=null;
(aTZ)=(new Array(8).fill(0));
(aTZ)=((aTZ).concat(toBin_((aTY).sP)));
(aTZ)=((aTZ).concat(toBin_((aTY).AB)));
(aTZ)=((aTZ).concat(toBin_((aTY).AE)));
(aTZ)=((aTZ).concat(toBin_((aTY).tG)));
(aTZ)=((aTZ).concat(toBin_((aTY).rZ)));
(aTZ)=((aTZ).concat(toBin_((aTY).AH)));
(aTZ)=((aTZ).concat(toBin_((aTY).AI)));
(aTZ)=((aTZ).concat(toBin_((aTY).qe)));
return aTZ;
}
// _fromBin
function aUi(aUj,aUk,aUl){
let aUm=null;
(aUm)=(new rX());
((aUm).sP)=(fromBin_((aUk),(aUl.$)));
((aUm).AB)=(fromBin_((aUk),(aUl.$)));
((aUm).AE)=(fromBin_((aUk),(aUl.$)));
((aUm).tG)=(fromBin_((aUk),(aUl.$)));
((aUm).rZ)=(fromBin_((aUk),(aUl.$)));
((aUm).AH)=(fromBin_((aUk),(aUl.$)));
((aUm).AI)=(fromBin_((aUk),(aUl.$)));
((aUm).qe)=(fromBin_((aUk),(aUl.$)));
return aUm;
}
// _dtor
function aUn(aUo){
((aUo).qn)=(null);
((aUo).qZ)=(null);
((aUo).qW)=(null);
((aUo).qa)=(null);
((aUo).q2)=(null);
((aUo).q1)=(null);
((aUo).zJ)=(null);
}
// _copy
function aUp(aUq){
let aUr=null;
(aUr)=(new tf());
((aUr).qn)=(C_([134],((aUq).qn)));
((aUr).qZ)=(C_([129,2],((aUq).qZ)));
((aUr).qW)=(C_([134],((aUq).qW)));
((aUr).qa)=(C_([133,129,2,134],((aUq).qa)));
((aUr).q2)=(C_([129,2],((aUq).q2)));
((aUr).q1)=(C_([134],((aUq).q1)));
((aUr).zJ)=(C_([134],((aUq).zJ)));
((aUr).r7)=((aUq).r7);
((aUr).qe)=((aUq).qe);
return aUr;
}
// _toBin
function aUs(aUt){
let aUu=null;
(aUu)=(new Array(8).fill(0));
(aUu)=((aUu).concat(toBin_((aUt).qn)));
(aUu)=((aUu).concat(toBin_((aUt).qZ)));
(aUu)=((aUu).concat(toBin_((aUt).qW)));
(aUu)=((aUu).concat(toBin_((aUt).qa)));
(aUu)=((aUu).concat(toBin_((aUt).q2)));
(aUu)=((aUu).concat(toBin_((aUt).q1)));
(aUu)=((aUu).concat(toBin_((aUt).zJ)));
(aUu)=((aUu).concat(toBin_((aUt).r7)));
(aUu)=((aUu).concat(toBin_((aUt).qe)));
return aUu;
}
// _fromBin
function aU4(aU5,aU6,aU7){
let aU8=null;
(aU8)=(new tf());
((aU8).qn)=(fromBin_((aU6),(aU7.$)));
((aU8).qZ)=(fromBin_((aU6),(aU7.$)));
((aU8).qW)=(fromBin_((aU6),(aU7.$)));
((aU8).qa)=(fromBin_((aU6),(aU7.$)));
((aU8).q2)=(fromBin_((aU6),(aU7.$)));
((aU8).q1)=(fromBin_((aU6),(aU7.$)));
((aU8).zJ)=(fromBin_((aU6),(aU7.$)));
((aU8).r7)=(fromBin_((aU6),(aU7.$)));
((aU8).qe)=(fromBin_((aU6),(aU7.$)));
return aU8;
}
// _dtor
function aU9(aUA){
((aUA).t6)=(null);
((aUA).t5)=(null);
}
// _copy
function aUB(aUC){
let aUD=null;
(aUD)=(new t4());
((aUD).t6)=(C_([129,2],((aUC).t6)));
((aUD).t5)=(C_([134],((aUC).t5)));
return aUD;
}
// _toBin
function aUE(aUF){
let aUG=null;
(aUG)=(new Array(8).fill(0));
(aUG)=((aUG).concat(toBin_((aUF).t6)));
(aUG)=((aUG).concat(toBin_((aUF).t5)));
return aUG;
}
// _fromBin
function aUJ(aUK,aUL,aUM){
let aUN=null;
(aUN)=(new t4());
((aUN).t6)=(fromBin_((aUL),(aUM.$)));
((aUN).t5)=(fromBin_((aUL),(aUM.$)));
return aUN;
}
// _dtor
function aUO(aUP){
((aUP).tU)=(null);
((aUP).Nf)=(null);
}
// _copy
function aUQ(aUR){
let aUS=null;
(aUS)=(new tS());
((aUS).Nd)=((aUR).Nd);
((aUS).Ne)=((aUR).Ne);
((aUS).tU)=(C_([134],((aUR).tU)));
((aUS).Nf)=(C_([134],((aUR).Nf)));
return aUS;
}
// _toBin
function aUT(aUU){
let aUV=null;
(aUV)=(new Array(8).fill(0));
(aUV)=((aUV).concat(toBin_((aUU).Nd)));
(aUV)=((aUV).concat(toBin_((aUU).Ne)));
(aUV)=((aUV).concat(toBin_((aUU).tU)));
(aUV)=((aUV).concat(toBin_((aUU).Nf)));
return aUV;
}
// _fromBin
function aVa(aVb,aVc,aVd){
let aVe=null;
(aVe)=(new tS());
((aVe).Nd)=(fromBin_((aVc),(aVd.$)));
((aVe).Ne)=(fromBin_((aVc),(aVd.$)));
((aVe).tU)=(fromBin_((aVc),(aVd.$)));
((aVe).Nf)=(fromBin_((aVc),(aVd.$)));
return aVe;
}
// _dtor
function aVf(aVg){
((aVg).tZ)=(null);
((aVg).qn)=(null);
((aVg).qZ)=(null);
((aVg).qW)=(null);
((aVg).qa)=(null);
((aVg).q2)=(null);
((aVg).q1)=(null);
((aVg).zJ)=(null);
}
// _copy
function aVh(aVi){
let aVj=null;
(aVj)=(new tX());
((aVj).tZ)=(C_([134],((aVi).tZ)));
((aVj).qn)=(C_([134],((aVi).qn)));
((aVj).qZ)=(C_([129,2],((aVi).qZ)));
((aVj).qW)=(C_([134],((aVi).qW)));
((aVj).qa)=(C_([133,129,2,134],((aVi).qa)));
((aVj).q2)=(C_([129,2],((aVi).q2)));
((aVj).q1)=(C_([134],((aVi).q1)));
((aVj).zJ)=(C_([134],((aVi).zJ)));
((aVj).r7)=((aVi).r7);
((aVj).qe)=((aVi).qe);
return aVj;
}
// _toBin
function aVk(aVl){
let aVm=null;
(aVm)=(new Array(8).fill(0));
(aVm)=((aVm).concat(toBin_((aVl).tZ)));
(aVm)=((aVm).concat(toBin_((aVl).qn)));
(aVm)=((aVm).concat(toBin_((aVl).qZ)));
(aVm)=((aVm).concat(toBin_((aVl).qW)));
(aVm)=((aVm).concat(toBin_((aVl).qa)));
(aVm)=((aVm).concat(toBin_((aVl).q2)));
(aVm)=((aVm).concat(toBin_((aVl).q1)));
(aVm)=((aVm).concat(toBin_((aVl).zJ)));
(aVm)=((aVm).concat(toBin_((aVl).r7)));
(aVm)=((aVm).concat(toBin_((aVl).qe)));
return aVm;
}
// _fromBin
function aVx(aVy,aVz,aV0){
let aV1=null;
(aV1)=(new tX());
((aV1).tZ)=(fromBin_((aVz),(aV0.$)));
((aV1).qn)=(fromBin_((aVz),(aV0.$)));
((aV1).qZ)=(fromBin_((aVz),(aV0.$)));
((aV1).qW)=(fromBin_((aVz),(aV0.$)));
((aV1).qa)=(fromBin_((aVz),(aV0.$)));
((aV1).q2)=(fromBin_((aVz),(aV0.$)));
((aV1).q1)=(fromBin_((aVz),(aV0.$)));
((aV1).zJ)=(fromBin_((aVz),(aV0.$)));
((aV1).r7)=(fromBin_((aVz),(aV0.$)));
((aV1).qe)=(fromBin_((aVz),(aV0.$)));
return aV1;
}
// _dtor
function aV2(aV3 /*me*/){
}
// fin
function uH(aV4 /*me*/){
var d_=aV4.Gd.F.replace("\n", "\u000D\n");
if(O_&&O_.writeFile){O_.writeFile(aV4.Gd.P,d_);return;}
let b_=new Blob([d_],{type:"text/plain"});
let l_=document.createElement("a");
l_.download=aV4.Gd.P;
l_.href=(URL||webkitURL).createObjectURL(b_);
l_.setAttribute("style","display:none");
document.body.appendChild(l_);
l_.click();
document.body.removeChild(l_);
aV4.Gd.F=null;
}
// setPos
function aV5(aV6 /*me*/,aV7 /*origin*/,aV8 /*pos*/){
aV6.Gd.I=aV8;
}
// getPos
function aV9(aVA /*me*/){
return aVA.Gd.I;
}
// write
function aVB(aVC /*me*/,aVD /*bin*/){
}
// writeInt
function aVE(aVF /*me*/,aVG /*n*/){
let aVH=null; // s
let aVK=0;
let aVL=0;
(aVH)=((v)((aVG),([0])));
aVJ:
for(aVK=(0),aVL=(((aVH).S.length)-(1));aVK<=aVL;aVK+=(1)){
(aVM)((aVF),((aVH).S.charCodeAt(aVK)));
}
}
// writeFloat
function aVN(aVO /*me*/,aVP /*n*/){
let aVQ=null; // s
let aVT=0;
let aVU=0;
(aVQ)=((v)((aVP),([1])));
aVS:
for(aVT=(0),aVU=(((aVQ).S.length)-(1));aVT<=aVU;aVT+=(1)){
(aVM)((aVO),((aVQ).S.charCodeAt(aVT)));
}
}
// writeChar
function aVM(aVV /*me*/,aVW /*n*/){
if(aVV.Gd.I<aVV.Gd.F.length)
aVV.Gd.F=aVV.Gd.F.slice(0,aVV.Gd.I)+String.fromCharCode(aVW)+aVV.Gd.F.slice(aVV.Gd.I+1);
else{
aVV.Gd.F+=String.fromCharCode(aVW);
}
aVV.Gd.I++;
}
// writeStr
function u4(aVX /*me*/,aVY /*n*/){
let aWb=0;
let aWc=0;
aWa:
for(aWb=(0),aWc=(((aVY).S.length)-(1));aWb<=aWc;aWb+=(1)){
(aVM)((aVX),((aVY).S.charCodeAt(aWb)));
}
}
// _copy
function aWd(aWe){
let aWf=null;
(aWf)=(new u3());
((aWf).Gd)=((aWe).Gd);
return aWf;
}
// _toBin
function aWg(aWh){
let aWi=null;
(aWi)=(new Array(8).fill(0));
(aWi)=((aWi).concat(toBin_((aWh).Gd)));
return aWi;
}
// _fromBin
function aWk(aWl,aWm,aWn){
let aWo=null;
(aWo)=(new u3());
((aWo).Gd)=(fromBin_((aWm),(aWn.$)));
return aWo;
}
// _dtor
function aWp(aWq){
((aWq).vb)=(null);
((aWq).Gl)=(null);
}
// _copy
function aWr(aWs){
let aWt=null;
(aWt)=(new uL());
((aWt).vb)=(C_([129,2],((aWs).vb)));
((aWt).Gl)=(C_([129,2],((aWs).Gl)));
((aWt).uN)=((aWs).uN);
((aWt).qe)=((aWs).qe);
return aWt;
}
// _toBin
function aWu(aWv){
let aWw=null;
(aWw)=(new Array(8).fill(0));
(aWw)=((aWw).concat(toBin_((aWv).vb)));
(aWw)=((aWw).concat(toBin_((aWv).Gl)));
(aWw)=((aWw).concat(toBin_((aWv).uN)));
(aWw)=((aWw).concat(toBin_((aWv).qe)));
return aWw;
}
// _fromBin
function aW1(aW2,aW3,aW4){
let aW5=null;
(aW5)=(new uL());
((aW5).vb)=(fromBin_((aW3),(aW4.$)));
((aW5).Gl)=(fromBin_((aW3),(aW4.$)));
((aW5).uN)=(fromBin_((aW3),(aW4.$)));
((aW5).qe)=(fromBin_((aW3),(aW4.$)));
return aW5;
}
// _dtor
function aW6(aW7){
((aW7).v8)=(null);
((aW7).v9)=(null);
}
// _copy
function aW8(aW9){
let aWA=null;
(aWA)=(new v7());
((aWA).v8)=(C_([129,2],((aW9).v8)));
((aWA).v9)=(C_([134],((aW9).v9)));
return aWA;
}
// _toBin
function aWB(aWC){
let aWD=null;
(aWD)=(new Array(8).fill(0));
(aWD)=((aWD).concat(toBin_((aWC).v8)));
(aWD)=((aWD).concat(toBin_((aWC).v9)));
return aWD;
}
// _fromBin
function aWG(aWH,aWI,aWJ){
let aWK=null;
(aWK)=(new v7());
((aWK).v8)=(fromBin_((aWI),(aWJ.$)));
((aWK).v9)=(fromBin_((aWI),(aWJ.$)));
return aWK;
}
// _dtor
function aWL(aWM){
((aWM).xS)=(null);
((aWM).qn)=(null);
((aWM).qZ)=(null);
((aWM).qW)=(null);
((aWM).qa)=(null);
((aWM).q2)=(null);
((aWM).q1)=(null);
((aWM).zJ)=(null);
}
// _copy
function aWN(aWO){
let aWP=null;
(aWP)=(new xC());
((aWP).xS)=(C_([134],((aWO).xS)));
((aWP).qn)=(C_([134],((aWO).qn)));
((aWP).qZ)=(C_([129,2],((aWO).qZ)));
((aWP).qW)=(C_([134],((aWO).qW)));
((aWP).qa)=(C_([133,129,2,134],((aWO).qa)));
((aWP).q2)=(C_([129,2],((aWO).q2)));
((aWP).q1)=(C_([134],((aWO).q1)));
((aWP).zJ)=(C_([134],((aWO).zJ)));
((aWP).r7)=((aWO).r7);
((aWP).qe)=((aWO).qe);
return aWP;
}
// _toBin
function aWQ(aWR){
let aWS=null;
(aWS)=(new Array(8).fill(0));
(aWS)=((aWS).concat(toBin_((aWR).xS)));
(aWS)=((aWS).concat(toBin_((aWR).qn)));
(aWS)=((aWS).concat(toBin_((aWR).qZ)));
(aWS)=((aWS).concat(toBin_((aWR).qW)));
(aWS)=((aWS).concat(toBin_((aWR).qa)));
(aWS)=((aWS).concat(toBin_((aWR).q2)));
(aWS)=((aWS).concat(toBin_((aWR).q1)));
(aWS)=((aWS).concat(toBin_((aWR).zJ)));
(aWS)=((aWS).concat(toBin_((aWR).r7)));
(aWS)=((aWS).concat(toBin_((aWR).qe)));
return aWS;
}
// _fromBin
function aXd(aXe,aXf,aXg){
let aXh=null;
(aXh)=(new xC());
((aXh).xS)=(fromBin_((aXf),(aXg.$)));
((aXh).qn)=(fromBin_((aXf),(aXg.$)));
((aXh).qZ)=(fromBin_((aXf),(aXg.$)));
((aXh).qW)=(fromBin_((aXf),(aXg.$)));
((aXh).qa)=(fromBin_((aXf),(aXg.$)));
((aXh).q2)=(fromBin_((aXf),(aXg.$)));
((aXh).q1)=(fromBin_((aXf),(aXg.$)));
((aXh).zJ)=(fromBin_((aXf),(aXg.$)));
((aXh).r7)=(fromBin_((aXf),(aXg.$)));
((aXh).qe)=(fromBin_((aXf),(aXg.$)));
return aXh;
}
// _dtor
function aXi(aXj){
((aXj).MJ)=(null);
((aXj).qn)=(null);
((aXj).qZ)=(null);
((aXj).qW)=(null);
((aXj).qa)=(null);
((aXj).q2)=(null);
((aXj).q1)=(null);
((aXj).zJ)=(null);
}
// _copy
function aXk(aXl){
let aXm=null;
(aXm)=(new xF());
((aXm).MJ)=(C_([134],((aXl).MJ)));
((aXm).qn)=(C_([134],((aXl).qn)));
((aXm).qZ)=(C_([129,2],((aXl).qZ)));
((aXm).qW)=(C_([134],((aXl).qW)));
((aXm).qa)=(C_([133,129,2,134],((aXl).qa)));
((aXm).q2)=(C_([129,2],((aXl).q2)));
((aXm).q1)=(C_([134],((aXl).q1)));
((aXm).zJ)=(C_([134],((aXl).zJ)));
((aXm).r7)=((aXl).r7);
((aXm).qe)=((aXl).qe);
return aXm;
}
// _toBin
function aXn(aXo){
let aXp=null;
(aXp)=(new Array(8).fill(0));
(aXp)=((aXp).concat(toBin_((aXo).MJ)));
(aXp)=((aXp).concat(toBin_((aXo).qn)));
(aXp)=((aXp).concat(toBin_((aXo).qZ)));
(aXp)=((aXp).concat(toBin_((aXo).qW)));
(aXp)=((aXp).concat(toBin_((aXo).qa)));
(aXp)=((aXp).concat(toBin_((aXo).q2)));
(aXp)=((aXp).concat(toBin_((aXo).q1)));
(aXp)=((aXp).concat(toBin_((aXo).zJ)));
(aXp)=((aXp).concat(toBin_((aXo).r7)));
(aXp)=((aXp).concat(toBin_((aXo).qe)));
return aXp;
}
// _fromBin
function aX0(aX1,aX2,aX3){
let aX4=null;
(aX4)=(new xF());
((aX4).MJ)=(fromBin_((aX2),(aX3.$)));
((aX4).qn)=(fromBin_((aX2),(aX3.$)));
((aX4).qZ)=(fromBin_((aX2),(aX3.$)));
((aX4).qW)=(fromBin_((aX2),(aX3.$)));
((aX4).qa)=(fromBin_((aX2),(aX3.$)));
((aX4).q2)=(fromBin_((aX2),(aX3.$)));
((aX4).q1)=(fromBin_((aX2),(aX3.$)));
((aX4).zJ)=(fromBin_((aX2),(aX3.$)));
((aX4).r7)=(fromBin_((aX2),(aX3.$)));
((aX4).qe)=(fromBin_((aX2),(aX3.$)));
return aX4;
}
// _dtor
function aX5(aX6){
((aX6).NA)=(null);
((aX6).qn)=(null);
((aX6).qZ)=(null);
((aX6).qW)=(null);
((aX6).qa)=(null);
((aX6).q2)=(null);
((aX6).q1)=(null);
((aX6).zJ)=(null);
}
// _copy
function aX7(aX8){
let aX9=null;
(aX9)=(new xL());
((aX9).NA)=(C_([130,134],((aX8).NA)));
((aX9).qn)=(C_([134],((aX8).qn)));
((aX9).qZ)=(C_([129,2],((aX8).qZ)));
((aX9).qW)=(C_([134],((aX8).qW)));
((aX9).qa)=(C_([133,129,2,134],((aX8).qa)));
((aX9).q2)=(C_([129,2],((aX8).q2)));
((aX9).q1)=(C_([134],((aX8).q1)));
((aX9).zJ)=(C_([134],((aX8).zJ)));
((aX9).r7)=((aX8).r7);
((aX9).qe)=((aX8).qe);
return aX9;
}
// _toBin
function aXA(aXB){
let aXC=null;
(aXC)=(new Array(8).fill(0));
(aXC)=((aXC).concat(toBin_((aXB).NA)));
(aXC)=((aXC).concat(toBin_((aXB).qn)));
(aXC)=((aXC).concat(toBin_((aXB).qZ)));
(aXC)=((aXC).concat(toBin_((aXB).qW)));
(aXC)=((aXC).concat(toBin_((aXB).qa)));
(aXC)=((aXC).concat(toBin_((aXB).q2)));
(aXC)=((aXC).concat(toBin_((aXB).q1)));
(aXC)=((aXC).concat(toBin_((aXB).zJ)));
(aXC)=((aXC).concat(toBin_((aXB).r7)));
(aXC)=((aXC).concat(toBin_((aXB).qe)));
return aXC;
}
// _fromBin
function aXN(aXO,aXP,aXQ){
let aXR=null;
(aXR)=(new xL());
((aXR).NA)=(fromBin_((aXP),(aXQ.$)));
((aXR).qn)=(fromBin_((aXP),(aXQ.$)));
((aXR).qZ)=(fromBin_((aXP),(aXQ.$)));
((aXR).qW)=(fromBin_((aXP),(aXQ.$)));
((aXR).qa)=(fromBin_((aXP),(aXQ.$)));
((aXR).q2)=(fromBin_((aXP),(aXQ.$)));
((aXR).q1)=(fromBin_((aXP),(aXQ.$)));
((aXR).zJ)=(fromBin_((aXP),(aXQ.$)));
((aXR).r7)=(fromBin_((aXP),(aXQ.$)));
((aXR).qe)=(fromBin_((aXP),(aXQ.$)));
return aXR;
}
// _dtor
function aXS(aXT){
((aXT).qn)=(null);
((aXT).qZ)=(null);
((aXT).qW)=(null);
((aXT).qa)=(null);
((aXT).q2)=(null);
((aXT).q1)=(null);
((aXT).zJ)=(null);
}
// _copy
function aXU(aXV){
let aXW=null;
(aXW)=(new yw());
((aXW).qn)=(C_([134],((aXV).qn)));
((aXW).qZ)=(C_([129,2],((aXV).qZ)));
((aXW).qW)=(C_([134],((aXV).qW)));
((aXW).qa)=(C_([133,129,2,134],((aXV).qa)));
((aXW).q2)=(C_([129,2],((aXV).q2)));
((aXW).q1)=(C_([134],((aXV).q1)));
((aXW).zJ)=(C_([134],((aXV).zJ)));
((aXW).r7)=((aXV).r7);
((aXW).qe)=((aXV).qe);
return aXW;
}
// _toBin
function aXX(aXY){
let aXZ=null;
(aXZ)=(new Array(8).fill(0));
(aXZ)=((aXZ).concat(toBin_((aXY).qn)));
(aXZ)=((aXZ).concat(toBin_((aXY).qZ)));
(aXZ)=((aXZ).concat(toBin_((aXY).qW)));
(aXZ)=((aXZ).concat(toBin_((aXY).qa)));
(aXZ)=((aXZ).concat(toBin_((aXY).q2)));
(aXZ)=((aXZ).concat(toBin_((aXY).q1)));
(aXZ)=((aXZ).concat(toBin_((aXY).zJ)));
(aXZ)=((aXZ).concat(toBin_((aXY).r7)));
(aXZ)=((aXZ).concat(toBin_((aXY).qe)));
return aXZ;
}
// _fromBin
function aYj(aYk,aYl,aYm){
let aYn=null;
(aYn)=(new yw());
((aYn).qn)=(fromBin_((aYl),(aYm.$)));
((aYn).qZ)=(fromBin_((aYl),(aYm.$)));
((aYn).qW)=(fromBin_((aYl),(aYm.$)));
((aYn).qa)=(fromBin_((aYl),(aYm.$)));
((aYn).q2)=(fromBin_((aYl),(aYm.$)));
((aYn).q1)=(fromBin_((aYl),(aYm.$)));
((aYn).zJ)=(fromBin_((aYl),(aYm.$)));
((aYn).r7)=(fromBin_((aYl),(aYm.$)));
((aYn).qe)=(fromBin_((aYl),(aYm.$)));
return aYn;
}
// _dtor
function aYo(aYp){
((aYp).y4)=(null);
((aYp).qn)=(null);
((aYp).qZ)=(null);
((aYp).qW)=(null);
((aYp).qa)=(null);
((aYp).q2)=(null);
((aYp).q1)=(null);
((aYp).zJ)=(null);
}
// _copy
function aYq(aYr){
let aYs=null;
(aYs)=(new yv());
((aYs).y4)=(C_([134],((aYr).y4)));
((aYs).qn)=(C_([134],((aYr).qn)));
((aYs).qZ)=(C_([129,2],((aYr).qZ)));
((aYs).qW)=(C_([134],((aYr).qW)));
((aYs).qa)=(C_([133,129,2,134],((aYr).qa)));
((aYs).q2)=(C_([129,2],((aYr).q2)));
((aYs).q1)=(C_([134],((aYr).q1)));
((aYs).zJ)=(C_([134],((aYr).zJ)));
((aYs).r7)=((aYr).r7);
((aYs).qe)=((aYr).qe);
return aYs;
}
// _toBin
function aYt(aYu){
let aYv=null;
(aYv)=(new Array(8).fill(0));
(aYv)=((aYv).concat(toBin_((aYu).y4)));
(aYv)=((aYv).concat(toBin_((aYu).qn)));
(aYv)=((aYv).concat(toBin_((aYu).qZ)));
(aYv)=((aYv).concat(toBin_((aYu).qW)));
(aYv)=((aYv).concat(toBin_((aYu).qa)));
(aYv)=((aYv).concat(toBin_((aYu).q2)));
(aYv)=((aYv).concat(toBin_((aYu).q1)));
(aYv)=((aYv).concat(toBin_((aYu).zJ)));
(aYv)=((aYv).concat(toBin_((aYu).r7)));
(aYv)=((aYv).concat(toBin_((aYu).qe)));
return aYv;
}
// _fromBin
function aY6(aY7,aY8,aY9){
let aYA=null;
(aYA)=(new yv());
((aYA).y4)=(fromBin_((aY8),(aY9.$)));
((aYA).qn)=(fromBin_((aY8),(aY9.$)));
((aYA).qZ)=(fromBin_((aY8),(aY9.$)));
((aYA).qW)=(fromBin_((aY8),(aY9.$)));
((aYA).qa)=(fromBin_((aY8),(aY9.$)));
((aYA).q2)=(fromBin_((aY8),(aY9.$)));
((aYA).q1)=(fromBin_((aY8),(aY9.$)));
((aYA).zJ)=(fromBin_((aY8),(aY9.$)));
((aYA).r7)=(fromBin_((aY8),(aY9.$)));
((aYA).qe)=(fromBin_((aY8),(aY9.$)));
return aYA;
}
// _dtor
function aYB(aYC){
((aYC).y9)=(null);
((aYC).yA)=(null);
((aYC).yD)=(null);
((aYC).y4)=(null);
((aYC).qn)=(null);
((aYC).qZ)=(null);
((aYC).qW)=(null);
((aYC).qa)=(null);
((aYC).q2)=(null);
((aYC).q1)=(null);
((aYC).zJ)=(null);
}
// _copy
function aYD(aYE){
let aYF=null;
(aYF)=(new yu());
((aYF).y9)=(C_([134],((aYE).y9)));
((aYF).yA)=(C_([130,134],((aYE).yA)));
((aYF).yD)=(C_([134],((aYE).yD)));
((aYF).y4)=(C_([134],((aYE).y4)));
((aYF).qn)=(C_([134],((aYE).qn)));
((aYF).qZ)=(C_([129,2],((aYE).qZ)));
((aYF).qW)=(C_([134],((aYE).qW)));
((aYF).qa)=(C_([133,129,2,134],((aYE).qa)));
((aYF).q2)=(C_([129,2],((aYE).q2)));
((aYF).q1)=(C_([134],((aYE).q1)));
((aYF).zJ)=(C_([134],((aYE).zJ)));
((aYF).r7)=((aYE).r7);
((aYF).qe)=((aYE).qe);
return aYF;
}
// _toBin
function aYG(aYH){
let aYI=null;
(aYI)=(new Array(8).fill(0));
(aYI)=((aYI).concat(toBin_((aYH).y9)));
(aYI)=((aYI).concat(toBin_((aYH).yA)));
(aYI)=((aYI).concat(toBin_((aYH).yD)));
(aYI)=((aYI).concat(toBin_((aYH).y4)));
(aYI)=((aYI).concat(toBin_((aYH).qn)));
(aYI)=((aYI).concat(toBin_((aYH).qZ)));
(aYI)=((aYI).concat(toBin_((aYH).qW)));
(aYI)=((aYI).concat(toBin_((aYH).qa)));
(aYI)=((aYI).concat(toBin_((aYH).q2)));
(aYI)=((aYI).concat(toBin_((aYH).q1)));
(aYI)=((aYI).concat(toBin_((aYH).zJ)));
(aYI)=((aYI).concat(toBin_((aYH).r7)));
(aYI)=((aYI).concat(toBin_((aYH).qe)));
return aYI;
}
// _fromBin
function aYW(aYX,aYY,aYZ){
let aZa=null;
(aZa)=(new yu());
((aZa).y9)=(fromBin_((aYY),(aYZ.$)));
((aZa).yA)=(fromBin_((aYY),(aYZ.$)));
((aZa).yD)=(fromBin_((aYY),(aYZ.$)));
((aZa).y4)=(fromBin_((aYY),(aYZ.$)));
((aZa).qn)=(fromBin_((aYY),(aYZ.$)));
((aZa).qZ)=(fromBin_((aYY),(aYZ.$)));
((aZa).qW)=(fromBin_((aYY),(aYZ.$)));
((aZa).qa)=(fromBin_((aYY),(aYZ.$)));
((aZa).q2)=(fromBin_((aYY),(aYZ.$)));
((aZa).q1)=(fromBin_((aYY),(aYZ.$)));
((aZa).zJ)=(fromBin_((aYY),(aYZ.$)));
((aZa).r7)=(fromBin_((aYY),(aYZ.$)));
((aZa).qe)=(fromBin_((aYY),(aYZ.$)));
return aZa;
}
// _dtor
function aZb(aZc){
((aZc).qn)=(null);
((aZc).qZ)=(null);
((aZc).qW)=(null);
((aZc).qa)=(null);
((aZc).q2)=(null);
((aZc).q1)=(null);
((aZc).zJ)=(null);
}
// _copy
function aZd(aZe){
let aZf=null;
(aZf)=(new y1());
((aZf).y2)=((aZe).y2);
((aZf).qn)=(C_([134],((aZe).qn)));
((aZf).qZ)=(C_([129,2],((aZe).qZ)));
((aZf).qW)=(C_([134],((aZe).qW)));
((aZf).qa)=(C_([133,129,2,134],((aZe).qa)));
((aZf).q2)=(C_([129,2],((aZe).q2)));
((aZf).q1)=(C_([134],((aZe).q1)));
((aZf).zJ)=(C_([134],((aZe).zJ)));
((aZf).r7)=((aZe).r7);
((aZf).qe)=((aZe).qe);
return aZf;
}
// _toBin
function aZg(aZh){
let aZi=null;
(aZi)=(new Array(8).fill(0));
(aZi)=((aZi).concat(toBin_((aZh).y2)));
(aZi)=((aZi).concat(toBin_((aZh).qn)));
(aZi)=((aZi).concat(toBin_((aZh).qZ)));
(aZi)=((aZi).concat(toBin_((aZh).qW)));
(aZi)=((aZi).concat(toBin_((aZh).qa)));
(aZi)=((aZi).concat(toBin_((aZh).q2)));
(aZi)=((aZi).concat(toBin_((aZh).q1)));
(aZi)=((aZi).concat(toBin_((aZh).zJ)));
(aZi)=((aZi).concat(toBin_((aZh).r7)));
(aZi)=((aZi).concat(toBin_((aZh).qe)));
return aZi;
}
// _fromBin
function aZt(aZu,aZv,aZw){
let aZx=null;
(aZx)=(new y1());
((aZx).y2)=(fromBin_((aZv),(aZw.$)));
((aZx).qn)=(fromBin_((aZv),(aZw.$)));
((aZx).qZ)=(fromBin_((aZv),(aZw.$)));
((aZx).qW)=(fromBin_((aZv),(aZw.$)));
((aZx).qa)=(fromBin_((aZv),(aZw.$)));
((aZx).q2)=(fromBin_((aZv),(aZw.$)));
((aZx).q1)=(fromBin_((aZv),(aZw.$)));
((aZx).zJ)=(fromBin_((aZv),(aZw.$)));
((aZx).r7)=(fromBin_((aZv),(aZw.$)));
((aZx).qe)=(fromBin_((aZv),(aZw.$)));
return aZx;
}
// _dtor
function aZy(aZz){
((aZz).y8)=(null);
((aZz).y4)=(null);
((aZz).qn)=(null);
((aZz).qZ)=(null);
((aZz).qW)=(null);
((aZz).qa)=(null);
((aZz).q2)=(null);
((aZz).q1)=(null);
((aZz).zJ)=(null);
}
// _copy
function aZ0(aZ1){
let aZ2=null;
(aZ2)=(new y7());
((aZ2).y8)=(C_([130,134],((aZ1).y8)));
((aZ2).y4)=(C_([134],((aZ1).y4)));
((aZ2).qn)=(C_([134],((aZ1).qn)));
((aZ2).qZ)=(C_([129,2],((aZ1).qZ)));
((aZ2).qW)=(C_([134],((aZ1).qW)));
((aZ2).qa)=(C_([133,129,2,134],((aZ1).qa)));
((aZ2).q2)=(C_([129,2],((aZ1).q2)));
((aZ2).q1)=(C_([134],((aZ1).q1)));
((aZ2).zJ)=(C_([134],((aZ1).zJ)));
((aZ2).r7)=((aZ1).r7);
((aZ2).qe)=((aZ1).qe);
return aZ2;
}
// _toBin
function aZ3(aZ4){
let aZ5=null;
(aZ5)=(new Array(8).fill(0));
(aZ5)=((aZ5).concat(toBin_((aZ4).y8)));
(aZ5)=((aZ5).concat(toBin_((aZ4).y4)));
(aZ5)=((aZ5).concat(toBin_((aZ4).qn)));
(aZ5)=((aZ5).concat(toBin_((aZ4).qZ)));
(aZ5)=((aZ5).concat(toBin_((aZ4).qW)));
(aZ5)=((aZ5).concat(toBin_((aZ4).qa)));
(aZ5)=((aZ5).concat(toBin_((aZ4).q2)));
(aZ5)=((aZ5).concat(toBin_((aZ4).q1)));
(aZ5)=((aZ5).concat(toBin_((aZ4).zJ)));
(aZ5)=((aZ5).concat(toBin_((aZ4).r7)));
(aZ5)=((aZ5).concat(toBin_((aZ4).qe)));
return aZ5;
}
// _fromBin
function aZH(aZI,aZJ,aZK){
let aZL=null;
(aZL)=(new y7());
((aZL).y8)=(fromBin_((aZJ),(aZK.$)));
((aZL).y4)=(fromBin_((aZJ),(aZK.$)));
((aZL).qn)=(fromBin_((aZJ),(aZK.$)));
((aZL).qZ)=(fromBin_((aZJ),(aZK.$)));
((aZL).qW)=(fromBin_((aZJ),(aZK.$)));
((aZL).qa)=(fromBin_((aZJ),(aZK.$)));
((aZL).q2)=(fromBin_((aZJ),(aZK.$)));
((aZL).q1)=(fromBin_((aZJ),(aZK.$)));
((aZL).zJ)=(fromBin_((aZJ),(aZK.$)));
((aZL).r7)=(fromBin_((aZJ),(aZK.$)));
((aZL).qe)=(fromBin_((aZJ),(aZK.$)));
return aZL;
}
// _dtor
function aZM(aZN){
((aZN).yU)=(null);
((aZN).qn)=(null);
((aZN).qZ)=(null);
((aZN).qW)=(null);
((aZN).qa)=(null);
((aZN).q2)=(null);
((aZN).q1)=(null);
((aZN).zJ)=(null);
}
// _copy
function aZO(aZP){
let aZQ=null;
(aZQ)=(new yK());
((aZQ).yU)=(C_([134],((aZP).yU)));
((aZQ).qn)=(C_([134],((aZP).qn)));
((aZQ).qZ)=(C_([129,2],((aZP).qZ)));
((aZQ).qW)=(C_([134],((aZP).qW)));
((aZQ).qa)=(C_([133,129,2,134],((aZP).qa)));
((aZQ).q2)=(C_([129,2],((aZP).q2)));
((aZQ).q1)=(C_([134],((aZP).q1)));
((aZQ).zJ)=(C_([134],((aZP).zJ)));
((aZQ).r7)=((aZP).r7);
((aZQ).qe)=((aZP).qe);
return aZQ;
}
// _toBin
function aZR(aZS){
let aZT=null;
(aZT)=(new Array(8).fill(0));
(aZT)=((aZT).concat(toBin_((aZS).yU)));
(aZT)=((aZT).concat(toBin_((aZS).qn)));
(aZT)=((aZT).concat(toBin_((aZS).qZ)));
(aZT)=((aZT).concat(toBin_((aZS).qW)));
(aZT)=((aZT).concat(toBin_((aZS).qa)));
(aZT)=((aZT).concat(toBin_((aZS).q2)));
(aZT)=((aZT).concat(toBin_((aZS).q1)));
(aZT)=((aZT).concat(toBin_((aZS).zJ)));
(aZT)=((aZT).concat(toBin_((aZS).r7)));
(aZT)=((aZT).concat(toBin_((aZS).qe)));
return aZT;
}
// _fromBin
function bae(baf,bag,bah){
let bai=null;
(bai)=(new yK());
((bai).yU)=(fromBin_((bag),(bah.$)));
((bai).qn)=(fromBin_((bag),(bah.$)));
((bai).qZ)=(fromBin_((bag),(bah.$)));
((bai).qW)=(fromBin_((bag),(bah.$)));
((bai).qa)=(fromBin_((bag),(bah.$)));
((bai).q2)=(fromBin_((bag),(bah.$)));
((bai).q1)=(fromBin_((bag),(bah.$)));
((bai).zJ)=(fromBin_((bag),(bah.$)));
((bai).r7)=(fromBin_((bag),(bah.$)));
((bai).qe)=(fromBin_((bag),(bah.$)));
return bai;
}
// _dtor
function baj(bak){
((bak).zn)=(null);
((bak).qn)=(null);
((bak).qZ)=(null);
((bak).qW)=(null);
((bak).qa)=(null);
((bak).q2)=(null);
((bak).q1)=(null);
((bak).zJ)=(null);
}
// _copy
function bal(bam){
let ban=null;
(ban)=(new yO());
((ban).zn)=(C_([134],((bam).zn)));
((ban).zj)=((bam).zj);
((ban).qn)=(C_([134],((bam).qn)));
((ban).qZ)=(C_([129,2],((bam).qZ)));
((ban).qW)=(C_([134],((bam).qW)));
((ban).qa)=(C_([133,129,2,134],((bam).qa)));
((ban).q2)=(C_([129,2],((bam).q2)));
((ban).q1)=(C_([134],((bam).q1)));
((ban).zJ)=(C_([134],((bam).zJ)));
((ban).r7)=((bam).r7);
((ban).qe)=((bam).qe);
return ban;
}
// _toBin
function bao(bap){
let baq=null;
(baq)=(new Array(8).fill(0));
(baq)=((baq).concat(toBin_((bap).zn)));
(baq)=((baq).concat(toBin_((bap).zj)));
(baq)=((baq).concat(toBin_((bap).qn)));
(baq)=((baq).concat(toBin_((bap).qZ)));
(baq)=((baq).concat(toBin_((bap).qW)));
(baq)=((baq).concat(toBin_((bap).qa)));
(baq)=((baq).concat(toBin_((bap).q2)));
(baq)=((baq).concat(toBin_((bap).q1)));
(baq)=((baq).concat(toBin_((bap).zJ)));
(baq)=((baq).concat(toBin_((bap).r7)));
(baq)=((baq).concat(toBin_((bap).qe)));
return baq;
}
// _fromBin
function ba2(ba3,ba4,ba5){
let ba6=null;
(ba6)=(new yO());
((ba6).zn)=(fromBin_((ba4),(ba5.$)));
((ba6).zj)=(fromBin_((ba4),(ba5.$)));
((ba6).qn)=(fromBin_((ba4),(ba5.$)));
((ba6).qZ)=(fromBin_((ba4),(ba5.$)));
((ba6).qW)=(fromBin_((ba4),(ba5.$)));
((ba6).qa)=(fromBin_((ba4),(ba5.$)));
((ba6).q2)=(fromBin_((ba4),(ba5.$)));
((ba6).q1)=(fromBin_((ba4),(ba5.$)));
((ba6).zJ)=(fromBin_((ba4),(ba5.$)));
((ba6).r7)=(fromBin_((ba4),(ba5.$)));
((ba6).qe)=(fromBin_((ba4),(ba5.$)));
return ba6;
}
// _dtor
function ba7(ba8){
((ba8).yT)=(null);
((ba8).yQ)=(null);
((ba8).zn)=(null);
((ba8).qn)=(null);
((ba8).qZ)=(null);
((ba8).qW)=(null);
((ba8).qa)=(null);
((ba8).q2)=(null);
((ba8).q1)=(null);
((ba8).zJ)=(null);
}
// _copy
function ba9(baA){
let baB=null;
(baB)=(new yN());
((baB).yT)=(C_([134],((baA).yT)));
((baB).yQ)=(C_([130,134],((baA).yQ)));
((baB).zn)=(C_([134],((baA).zn)));
((baB).zj)=((baA).zj);
((baB).qn)=(C_([134],((baA).qn)));
((baB).qZ)=(C_([129,2],((baA).qZ)));
((baB).qW)=(C_([134],((baA).qW)));
((baB).qa)=(C_([133,129,2,134],((baA).qa)));
((baB).q2)=(C_([129,2],((baA).q2)));
((baB).q1)=(C_([134],((baA).q1)));
((baB).zJ)=(C_([134],((baA).zJ)));
((baB).r7)=((baA).r7);
((baB).qe)=((baA).qe);
return baB;
}
// _toBin
function baC(baD){
let baE=null;
(baE)=(new Array(8).fill(0));
(baE)=((baE).concat(toBin_((baD).yT)));
(baE)=((baE).concat(toBin_((baD).yQ)));
(baE)=((baE).concat(toBin_((baD).zn)));
(baE)=((baE).concat(toBin_((baD).zj)));
(baE)=((baE).concat(toBin_((baD).qn)));
(baE)=((baE).concat(toBin_((baD).qZ)));
(baE)=((baE).concat(toBin_((baD).qW)));
(baE)=((baE).concat(toBin_((baD).qa)));
(baE)=((baE).concat(toBin_((baD).q2)));
(baE)=((baE).concat(toBin_((baD).q1)));
(baE)=((baE).concat(toBin_((baD).zJ)));
(baE)=((baE).concat(toBin_((baD).r7)));
(baE)=((baE).concat(toBin_((baD).qe)));
return baE;
}
// _fromBin
function baS(baT,baU,baV){
let baW=null;
(baW)=(new yN());
((baW).yT)=(fromBin_((baU),(baV.$)));
((baW).yQ)=(fromBin_((baU),(baV.$)));
((baW).zn)=(fromBin_((baU),(baV.$)));
((baW).zj)=(fromBin_((baU),(baV.$)));
((baW).qn)=(fromBin_((baU),(baV.$)));
((baW).qZ)=(fromBin_((baU),(baV.$)));
((baW).qW)=(fromBin_((baU),(baV.$)));
((baW).qa)=(fromBin_((baU),(baV.$)));
((baW).q2)=(fromBin_((baU),(baV.$)));
((baW).q1)=(fromBin_((baU),(baV.$)));
((baW).zJ)=(fromBin_((baU),(baV.$)));
((baW).r7)=(fromBin_((baU),(baV.$)));
((baW).qe)=(fromBin_((baU),(baV.$)));
return baW;
}
// _dtor
function baX(baY){
((baY).yY)=(null);
((baY).zb)=(null);
((baY).qn)=(null);
((baY).qZ)=(null);
((baY).qW)=(null);
((baY).qa)=(null);
((baY).q2)=(null);
((baY).q1)=(null);
((baY).zJ)=(null);
}
// _copy
function baZ(bba){
let bbb=null;
(bbb)=(new yX());
((bbb).yY)=(C_([130,134],((bba).yY)));
((bbb).zb)=(C_([134],((bba).zb)));
((bbb).qn)=(C_([134],((bba).qn)));
((bbb).qZ)=(C_([129,2],((bba).qZ)));
((bbb).qW)=(C_([134],((bba).qW)));
((bbb).qa)=(C_([133,129,2,134],((bba).qa)));
((bbb).q2)=(C_([129,2],((bba).q2)));
((bbb).q1)=(C_([134],((bba).q1)));
((bbb).zJ)=(C_([134],((bba).zJ)));
((bbb).r7)=((bba).r7);
((bbb).qe)=((bba).qe);
return bbb;
}
// _toBin
function bbc(bbd){
let bbe=null;
(bbe)=(new Array(8).fill(0));
(bbe)=((bbe).concat(toBin_((bbd).yY)));
(bbe)=((bbe).concat(toBin_((bbd).zb)));
(bbe)=((bbe).concat(toBin_((bbd).qn)));
(bbe)=((bbe).concat(toBin_((bbd).qZ)));
(bbe)=((bbe).concat(toBin_((bbd).qW)));
(bbe)=((bbe).concat(toBin_((bbd).qa)));
(bbe)=((bbe).concat(toBin_((bbd).q2)));
(bbe)=((bbe).concat(toBin_((bbd).q1)));
(bbe)=((bbe).concat(toBin_((bbd).zJ)));
(bbe)=((bbe).concat(toBin_((bbd).r7)));
(bbe)=((bbe).concat(toBin_((bbd).qe)));
return bbe;
}
// _fromBin
function bbq(bbr,bbs,bbt){
let bbu=null;
(bbu)=(new yX());
((bbu).yY)=(fromBin_((bbs),(bbt.$)));
((bbu).zb)=(fromBin_((bbs),(bbt.$)));
((bbu).qn)=(fromBin_((bbs),(bbt.$)));
((bbu).qZ)=(fromBin_((bbs),(bbt.$)));
((bbu).qW)=(fromBin_((bbs),(bbt.$)));
((bbu).qa)=(fromBin_((bbs),(bbt.$)));
((bbu).q2)=(fromBin_((bbs),(bbt.$)));
((bbu).q1)=(fromBin_((bbs),(bbt.$)));
((bbu).zJ)=(fromBin_((bbs),(bbt.$)));
((bbu).r7)=(fromBin_((bbs),(bbt.$)));
((bbu).qe)=(fromBin_((bbs),(bbt.$)));
return bbu;
}
// _dtor
function bbv(bbw){
((bbw).zo)=(null);
((bbw).zt)=(null);
}
// _copy
function bbx(bby){
let bbz=null;
(bbz)=(new ze());
((bbz).zo)=(C_([134],((bby).zo)));
((bbz).zt)=(C_([134],((bby).zt)));
return bbz;
}
// _toBin
function bb0(bb1){
let bb2=null;
(bb2)=(new Array(8).fill(0));
(bb2)=((bb2).concat(toBin_((bb1).zo)));
(bb2)=((bb2).concat(toBin_((bb1).zt)));
return bb2;
}
// _fromBin
function bb5(bb6,bb7,bb8){
let bb9=null;
(bb9)=(new ze());
((bb9).zo)=(fromBin_((bb7),(bb8.$)));
((bb9).zt)=(fromBin_((bb7),(bb8.$)));
return bb9;
}
// _dtor
function bbA(bbB){
((bbB).zn)=(null);
((bbB).qn)=(null);
((bbB).qZ)=(null);
((bbB).qW)=(null);
((bbB).qa)=(null);
((bbB).q2)=(null);
((bbB).q1)=(null);
((bbB).zJ)=(null);
}
// _copy
function bbC(bbD){
let bbE=null;
(bbE)=(new zi());
((bbE).zn)=(C_([134],((bbD).zn)));
((bbE).zj)=((bbD).zj);
((bbE).qn)=(C_([134],((bbD).qn)));
((bbE).qZ)=(C_([129,2],((bbD).qZ)));
((bbE).qW)=(C_([134],((bbD).qW)));
((bbE).qa)=(C_([133,129,2,134],((bbD).qa)));
((bbE).q2)=(C_([129,2],((bbD).q2)));
((bbE).q1)=(C_([134],((bbD).q1)));
((bbE).zJ)=(C_([134],((bbD).zJ)));
((bbE).r7)=((bbD).r7);
((bbE).qe)=((bbD).qe);
return bbE;
}
// _toBin
function bbF(bbG){
let bbH=null;
(bbH)=(new Array(8).fill(0));
(bbH)=((bbH).concat(toBin_((bbG).zn)));
(bbH)=((bbH).concat(toBin_((bbG).zj)));
(bbH)=((bbH).concat(toBin_((bbG).qn)));
(bbH)=((bbH).concat(toBin_((bbG).qZ)));
(bbH)=((bbH).concat(toBin_((bbG).qW)));
(bbH)=((bbH).concat(toBin_((bbG).qa)));
(bbH)=((bbH).concat(toBin_((bbG).q2)));
(bbH)=((bbH).concat(toBin_((bbG).q1)));
(bbH)=((bbH).concat(toBin_((bbG).zJ)));
(bbH)=((bbH).concat(toBin_((bbG).r7)));
(bbH)=((bbH).concat(toBin_((bbG).qe)));
return bbH;
}
// _fromBin
function bbT(bbU,bbV,bbW){
let bbX=null;
(bbX)=(new zi());
((bbX).zn)=(fromBin_((bbV),(bbW.$)));
((bbX).zj)=(fromBin_((bbV),(bbW.$)));
((bbX).qn)=(fromBin_((bbV),(bbW.$)));
((bbX).qZ)=(fromBin_((bbV),(bbW.$)));
((bbX).qW)=(fromBin_((bbV),(bbW.$)));
((bbX).qa)=(fromBin_((bbV),(bbW.$)));
((bbX).q2)=(fromBin_((bbV),(bbW.$)));
((bbX).q1)=(fromBin_((bbV),(bbW.$)));
((bbX).zJ)=(fromBin_((bbV),(bbW.$)));
((bbX).r7)=(fromBin_((bbV),(bbW.$)));
((bbX).qe)=(fromBin_((bbV),(bbW.$)));
return bbX;
}
// _dtor
function bbY(bbZ){
((bbZ).zn)=(null);
((bbZ).qn)=(null);
((bbZ).qZ)=(null);
((bbZ).qW)=(null);
((bbZ).qa)=(null);
((bbZ).q2)=(null);
((bbZ).q1)=(null);
((bbZ).zJ)=(null);
}
// _copy
function bca(bcb){
let bcc=null;
(bcc)=(new zh());
((bcc).zk)=((bcb).zk);
((bcc).zn)=(C_([134],((bcb).zn)));
((bcc).zj)=((bcb).zj);
((bcc).qn)=(C_([134],((bcb).qn)));
((bcc).qZ)=(C_([129,2],((bcb).qZ)));
((bcc).qW)=(C_([134],((bcb).qW)));
((bcc).qa)=(C_([133,129,2,134],((bcb).qa)));
((bcc).q2)=(C_([129,2],((bcb).q2)));
((bcc).q1)=(C_([134],((bcb).q1)));
((bcc).zJ)=(C_([134],((bcb).zJ)));
((bcc).r7)=((bcb).r7);
((bcc).qe)=((bcb).qe);
return bcc;
}
// _toBin
function bcd(bce){
let bcf=null;
(bcf)=(new Array(8).fill(0));
(bcf)=((bcf).concat(toBin_((bce).zk)));
(bcf)=((bcf).concat(toBin_((bce).zn)));
(bcf)=((bcf).concat(toBin_((bce).zj)));
(bcf)=((bcf).concat(toBin_((bce).qn)));
(bcf)=((bcf).concat(toBin_((bce).qZ)));
(bcf)=((bcf).concat(toBin_((bce).qW)));
(bcf)=((bcf).concat(toBin_((bce).qa)));
(bcf)=((bcf).concat(toBin_((bce).q2)));
(bcf)=((bcf).concat(toBin_((bce).q1)));
(bcf)=((bcf).concat(toBin_((bce).zJ)));
(bcf)=((bcf).concat(toBin_((bce).r7)));
(bcf)=((bcf).concat(toBin_((bce).qe)));
return bcf;
}
// _fromBin
function bcs(bct,bcu,bcv){
let bcw=null;
(bcw)=(new zh());
((bcw).zk)=(fromBin_((bcu),(bcv.$)));
((bcw).zn)=(fromBin_((bcu),(bcv.$)));
((bcw).zj)=(fromBin_((bcu),(bcv.$)));
((bcw).qn)=(fromBin_((bcu),(bcv.$)));
((bcw).qZ)=(fromBin_((bcu),(bcv.$)));
((bcw).qW)=(fromBin_((bcu),(bcv.$)));
((bcw).qa)=(fromBin_((bcu),(bcv.$)));
((bcw).q2)=(fromBin_((bcu),(bcv.$)));
((bcw).q1)=(fromBin_((bcu),(bcv.$)));
((bcw).zJ)=(fromBin_((bcu),(bcv.$)));
((bcw).r7)=(fromBin_((bcu),(bcv.$)));
((bcw).qe)=(fromBin_((bcu),(bcv.$)));
return bcw;
}
// _dtor
function bcx(bcy){
((bcy).z7)=(null);
}
// _copy
function bcz(bc0){
let bc1=null;
(bc1)=(new z2());
((bc1).z7)=(C_([134],((bc0).z7)));
((bc1).z3)=((bc0).z3);
((bc1).z4)=((bc0).z4);
return bc1;
}
// _toBin
function bc2(bc3){
let bc4=null;
(bc4)=(new Array(8).fill(0));
(bc4)=((bc4).concat(toBin_((bc3).z7)));
(bc4)=((bc4).concat(toBin_((bc3).z3)));
(bc4)=((bc4).concat(toBin_((bc3).z4)));
return bc4;
}
// _fromBin
function bc8(bc9,bcA,bcB){
let bcC=null;
(bcC)=(new z2());
((bcC).z7)=(fromBin_((bcA),(bcB.$)));
((bcC).z3)=(fromBin_((bcA),(bcB.$)));
((bcC).z4)=(fromBin_((bcA),(bcB.$)));
return bcC;
}
// _dtor
function bcD(bcE){
((bcE).Ar)=(null);
((bcE).As)=(null);
((bcE).zn)=(null);
((bcE).qn)=(null);
((bcE).qZ)=(null);
((bcE).qW)=(null);
((bcE).qa)=(null);
((bcE).q2)=(null);
((bcE).q1)=(null);
((bcE).zJ)=(null);
}
// _copy
function bcF(bcG){
let bcH=null;
(bcH)=(new An());
((bcH).Ao)=((bcG).Ao);
((bcH).Ar)=(C_([134],((bcG).Ar)));
((bcH).As)=(C_([134],((bcG).As)));
((bcH).zn)=(C_([134],((bcG).zn)));
((bcH).zj)=((bcG).zj);
((bcH).qn)=(C_([134],((bcG).qn)));
((bcH).qZ)=(C_([129,2],((bcG).qZ)));
((bcH).qW)=(C_([134],((bcG).qW)));
((bcH).qa)=(C_([133,129,2,134],((bcG).qa)));
((bcH).q2)=(C_([129,2],((bcG).q2)));
((bcH).q1)=(C_([134],((bcG).q1)));
((bcH).zJ)=(C_([134],((bcG).zJ)));
((bcH).r7)=((bcG).r7);
((bcH).qe)=((bcG).qe);
return bcH;
}
// _toBin
function bcI(bcJ){
let bcK=null;
(bcK)=(new Array(8).fill(0));
(bcK)=((bcK).concat(toBin_((bcJ).Ao)));
(bcK)=((bcK).concat(toBin_((bcJ).Ar)));
(bcK)=((bcK).concat(toBin_((bcJ).As)));
(bcK)=((bcK).concat(toBin_((bcJ).zn)));
(bcK)=((bcK).concat(toBin_((bcJ).zj)));
(bcK)=((bcK).concat(toBin_((bcJ).qn)));
(bcK)=((bcK).concat(toBin_((bcJ).qZ)));
(bcK)=((bcK).concat(toBin_((bcJ).qW)));
(bcK)=((bcK).concat(toBin_((bcJ).qa)));
(bcK)=((bcK).concat(toBin_((bcJ).q2)));
(bcK)=((bcK).concat(toBin_((bcJ).q1)));
(bcK)=((bcK).concat(toBin_((bcJ).zJ)));
(bcK)=((bcK).concat(toBin_((bcJ).r7)));
(bcK)=((bcK).concat(toBin_((bcJ).qe)));
return bcK;
}
// _fromBin
function bcZ(bda,bdb,bdc){
let bdd=null;
(bdd)=(new An());
((bdd).Ao)=(fromBin_((bdb),(bdc.$)));
((bdd).Ar)=(fromBin_((bdb),(bdc.$)));
((bdd).As)=(fromBin_((bdb),(bdc.$)));
((bdd).zn)=(fromBin_((bdb),(bdc.$)));
((bdd).zj)=(fromBin_((bdb),(bdc.$)));
((bdd).qn)=(fromBin_((bdb),(bdc.$)));
((bdd).qZ)=(fromBin_((bdb),(bdc.$)));
((bdd).qW)=(fromBin_((bdb),(bdc.$)));
((bdd).qa)=(fromBin_((bdb),(bdc.$)));
((bdd).q2)=(fromBin_((bdb),(bdc.$)));
((bdd).q1)=(fromBin_((bdb),(bdc.$)));
((bdd).zJ)=(fromBin_((bdb),(bdc.$)));
((bdd).r7)=(fromBin_((bdb),(bdc.$)));
((bdd).qe)=(fromBin_((bdb),(bdc.$)));
return bdd;
}
// _dtor
function bde(bdf){
((bdf).qn)=(null);
((bdf).qZ)=(null);
((bdf).qW)=(null);
((bdf).qa)=(null);
((bdf).q2)=(null);
((bdf).q1)=(null);
((bdf).zJ)=(null);
}
// _copy
function bdg(bdh){
let bdi=null;
(bdi)=(new AQ());
((bdi).qn)=(C_([134],((bdh).qn)));
((bdi).qZ)=(C_([129,2],((bdh).qZ)));
((bdi).qW)=(C_([134],((bdh).qW)));
((bdi).qa)=(C_([133,129,2,134],((bdh).qa)));
((bdi).q2)=(C_([129,2],((bdh).q2)));
((bdi).q1)=(C_([134],((bdh).q1)));
((bdi).zJ)=(C_([134],((bdh).zJ)));
((bdi).r7)=((bdh).r7);
((bdi).qe)=((bdh).qe);
return bdi;
}
// _toBin
function bdj(bdk){
let bdl=null;
(bdl)=(new Array(8).fill(0));
(bdl)=((bdl).concat(toBin_((bdk).qn)));
(bdl)=((bdl).concat(toBin_((bdk).qZ)));
(bdl)=((bdl).concat(toBin_((bdk).qW)));
(bdl)=((bdl).concat(toBin_((bdk).qa)));
(bdl)=((bdl).concat(toBin_((bdk).q2)));
(bdl)=((bdl).concat(toBin_((bdk).q1)));
(bdl)=((bdl).concat(toBin_((bdk).zJ)));
(bdl)=((bdl).concat(toBin_((bdk).r7)));
(bdl)=((bdl).concat(toBin_((bdk).qe)));
return bdl;
}
// _fromBin
function bdv(bdw,bdx,bdy){
let bdz=null;
(bdz)=(new AQ());
((bdz).qn)=(fromBin_((bdx),(bdy.$)));
((bdz).qZ)=(fromBin_((bdx),(bdy.$)));
((bdz).qW)=(fromBin_((bdx),(bdy.$)));
((bdz).qa)=(fromBin_((bdx),(bdy.$)));
((bdz).q2)=(fromBin_((bdx),(bdy.$)));
((bdz).q1)=(fromBin_((bdx),(bdy.$)));
((bdz).zJ)=(fromBin_((bdx),(bdy.$)));
((bdz).r7)=(fromBin_((bdx),(bdy.$)));
((bdz).qe)=(fromBin_((bdx),(bdy.$)));
return bdz;
}
// _dtor
function bd0(bd1){
((bd1).AR)=(null);
((bd1).qn)=(null);
((bd1).qZ)=(null);
((bd1).qW)=(null);
((bd1).qa)=(null);
((bd1).q2)=(null);
((bd1).q1)=(null);
((bd1).zJ)=(null);
}
// _copy
function bd2(bd3){
let bd4=null;
(bd4)=(new AP());
((bd4).AR)=(C_([134],((bd3).AR)));
((bd4).qn)=(C_([134],((bd3).qn)));
((bd4).qZ)=(C_([129,2],((bd3).qZ)));
((bd4).qW)=(C_([134],((bd3).qW)));
((bd4).qa)=(C_([133,129,2,134],((bd3).qa)));
((bd4).q2)=(C_([129,2],((bd3).q2)));
((bd4).q1)=(C_([134],((bd3).q1)));
((bd4).zJ)=(C_([134],((bd3).zJ)));
((bd4).r7)=((bd3).r7);
((bd4).qe)=((bd3).qe);
return bd4;
}
// _toBin
function bd5(bd6){
let bd7=null;
(bd7)=(new Array(8).fill(0));
(bd7)=((bd7).concat(toBin_((bd6).AR)));
(bd7)=((bd7).concat(toBin_((bd6).qn)));
(bd7)=((bd7).concat(toBin_((bd6).qZ)));
(bd7)=((bd7).concat(toBin_((bd6).qW)));
(bd7)=((bd7).concat(toBin_((bd6).qa)));
(bd7)=((bd7).concat(toBin_((bd6).q2)));
(bd7)=((bd7).concat(toBin_((bd6).q1)));
(bd7)=((bd7).concat(toBin_((bd6).zJ)));
(bd7)=((bd7).concat(toBin_((bd6).r7)));
(bd7)=((bd7).concat(toBin_((bd6).qe)));
return bd7;
}
// _fromBin
function bdI(bdJ,bdK,bdL){
let bdM=null;
(bdM)=(new AP());
((bdM).AR)=(fromBin_((bdK),(bdL.$)));
((bdM).qn)=(fromBin_((bdK),(bdL.$)));
((bdM).qZ)=(fromBin_((bdK),(bdL.$)));
((bdM).qW)=(fromBin_((bdK),(bdL.$)));
((bdM).qa)=(fromBin_((bdK),(bdL.$)));
((bdM).q2)=(fromBin_((bdK),(bdL.$)));
((bdM).q1)=(fromBin_((bdK),(bdL.$)));
((bdM).zJ)=(fromBin_((bdK),(bdL.$)));
((bdM).r7)=(fromBin_((bdK),(bdL.$)));
((bdM).qe)=(fromBin_((bdK),(bdL.$)));
return bdM;
}
// _dtor
function bdN(bdO){
((bdO).qn)=(null);
((bdO).qZ)=(null);
((bdO).qW)=(null);
((bdO).qa)=(null);
((bdO).q2)=(null);
((bdO).q1)=(null);
((bdO).zJ)=(null);
}
// _copy
function bdP(bdQ){
let bdR=null;
(bdR)=(new AT());
((bdR).AU)=((bdQ).AU);
((bdR).qn)=(C_([134],((bdQ).qn)));
((bdR).qZ)=(C_([129,2],((bdQ).qZ)));
((bdR).qW)=(C_([134],((bdQ).qW)));
((bdR).qa)=(C_([133,129,2,134],((bdQ).qa)));
((bdR).q2)=(C_([129,2],((bdQ).q2)));
((bdR).q1)=(C_([134],((bdQ).q1)));
((bdR).zJ)=(C_([134],((bdQ).zJ)));
((bdR).r7)=((bdQ).r7);
((bdR).qe)=((bdQ).qe);
return bdR;
}
// _toBin
function bdS(bdT){
let bdU=null;
(bdU)=(new Array(8).fill(0));
(bdU)=((bdU).concat(toBin_((bdT).AU)));
(bdU)=((bdU).concat(toBin_((bdT).qn)));
(bdU)=((bdU).concat(toBin_((bdT).qZ)));
(bdU)=((bdU).concat(toBin_((bdT).qW)));
(bdU)=((bdU).concat(toBin_((bdT).qa)));
(bdU)=((bdU).concat(toBin_((bdT).q2)));
(bdU)=((bdU).concat(toBin_((bdT).q1)));
(bdU)=((bdU).concat(toBin_((bdT).zJ)));
(bdU)=((bdU).concat(toBin_((bdT).r7)));
(bdU)=((bdU).concat(toBin_((bdT).qe)));
return bdU;
}
// _fromBin
function bef(beg,beh,bei){
let bej=null;
(bej)=(new AT());
((bej).AU)=(fromBin_((beh),(bei.$)));
((bej).qn)=(fromBin_((beh),(bei.$)));
((bej).qZ)=(fromBin_((beh),(bei.$)));
((bej).qW)=(fromBin_((beh),(bei.$)));
((bej).qa)=(fromBin_((beh),(bei.$)));
((bej).q2)=(fromBin_((beh),(bei.$)));
((bej).q1)=(fromBin_((beh),(bei.$)));
((bej).zJ)=(fromBin_((beh),(bei.$)));
((bej).r7)=(fromBin_((beh),(bei.$)));
((bej).qe)=(fromBin_((beh),(bei.$)));
return bej;
}
// _dtor
function bek(bel){
((bel).abe)=(null);
((bel).Be)=(null);
((bel).AZ)=(null);
((bel).qn)=(null);
((bel).qZ)=(null);
((bel).qW)=(null);
((bel).qa)=(null);
((bel).q2)=(null);
((bel).q1)=(null);
((bel).zJ)=(null);
}
// _copy
function bem(ben){
let beo=null;
(beo)=(new AX());
((beo).abd)=((ben).abd);
((beo).abe)=(C_([130,129,2],((ben).abe)));
((beo).Be)=(C_([130,134],((ben).Be)));
((beo).AZ)=(C_([134],((ben).AZ)));
((beo).qn)=(C_([134],((ben).qn)));
((beo).qZ)=(C_([129,2],((ben).qZ)));
((beo).qW)=(C_([134],((ben).qW)));
((beo).qa)=(C_([133,129,2,134],((ben).qa)));
((beo).q2)=(C_([129,2],((ben).q2)));
((beo).q1)=(C_([134],((ben).q1)));
((beo).zJ)=(C_([134],((ben).zJ)));
((beo).r7)=((ben).r7);
((beo).qe)=((ben).qe);
return beo;
}
// _toBin
function bep(beq){
let ber=null;
(ber)=(new Array(8).fill(0));
(ber)=((ber).concat(toBin_((beq).abd)));
(ber)=((ber).concat(toBin_((beq).abe)));
(ber)=((ber).concat(toBin_((beq).Be)));
(ber)=((ber).concat(toBin_((beq).AZ)));
(ber)=((ber).concat(toBin_((beq).qn)));
(ber)=((ber).concat(toBin_((beq).qZ)));
(ber)=((ber).concat(toBin_((beq).qW)));
(ber)=((ber).concat(toBin_((beq).qa)));
(ber)=((ber).concat(toBin_((beq).q2)));
(ber)=((ber).concat(toBin_((beq).q1)));
(ber)=((ber).concat(toBin_((beq).zJ)));
(ber)=((ber).concat(toBin_((beq).r7)));
(ber)=((ber).concat(toBin_((beq).qe)));
return ber;
}
// _fromBin
function be5(be6,be7,be8){
let be9=null;
(be9)=(new AX());
((be9).abd)=(fromBin_((be7),(be8.$)));
((be9).abe)=(fromBin_((be7),(be8.$)));
((be9).Be)=(fromBin_((be7),(be8.$)));
((be9).AZ)=(fromBin_((be7),(be8.$)));
((be9).qn)=(fromBin_((be7),(be8.$)));
((be9).qZ)=(fromBin_((be7),(be8.$)));
((be9).qW)=(fromBin_((be7),(be8.$)));
((be9).qa)=(fromBin_((be7),(be8.$)));
((be9).q2)=(fromBin_((be7),(be8.$)));
((be9).q1)=(fromBin_((be7),(be8.$)));
((be9).zJ)=(fromBin_((be7),(be8.$)));
((be9).r7)=(fromBin_((be7),(be8.$)));
((be9).qe)=(fromBin_((be7),(be8.$)));
return be9;
}
// _dtor
function beA(beB){
((beB).Bn)=(null);
}
// _copy
function beC(beD){
let beE=null;
(beE)=(new Bh());
((beE).Bn)=(C_([134],((beD).Bn)));
((beE).Bp)=((beD).Bp);
return beE;
}
// _toBin
function beF(beG){
let beH=null;
(beH)=(new Array(8).fill(0));
(beH)=((beH).concat(toBin_((beG).Bn)));
(beH)=((beH).concat(toBin_((beG).Bp)));
return beH;
}
// _fromBin
function beK(beL,beM,beN){
let beO=null;
(beO)=(new Bh());
((beO).Bn)=(fromBin_((beM),(beN.$)));
((beO).Bp)=(fromBin_((beM),(beN.$)));
return beO;
}
// _dtor
function beP(beQ){
((beQ).Bz)=(null);
((beQ).qn)=(null);
((beQ).qZ)=(null);
((beQ).qW)=(null);
((beQ).qa)=(null);
((beQ).q2)=(null);
((beQ).q1)=(null);
((beQ).zJ)=(null);
}
// _copy
function beR(beS){
let beT=null;
(beT)=(new Bu());
((beT).Bx)=((beS).Bx);
((beT).Bz)=(C_([134],((beS).Bz)));
((beT).qn)=(C_([134],((beS).qn)));
((beT).qZ)=(C_([129,2],((beS).qZ)));
((beT).qW)=(C_([134],((beS).qW)));
((beT).qa)=(C_([133,129,2,134],((beS).qa)));
((beT).q2)=(C_([129,2],((beS).q2)));
((beT).q1)=(C_([134],((beS).q1)));
((beT).zJ)=(C_([134],((beS).zJ)));
((beT).r7)=((beS).r7);
((beT).qe)=((beS).qe);
return beT;
}
// _toBin
function beU(beV){
let beW=null;
(beW)=(new Array(8).fill(0));
(beW)=((beW).concat(toBin_((beV).Bx)));
(beW)=((beW).concat(toBin_((beV).Bz)));
(beW)=((beW).concat(toBin_((beV).qn)));
(beW)=((beW).concat(toBin_((beV).qZ)));
(beW)=((beW).concat(toBin_((beV).qW)));
(beW)=((beW).concat(toBin_((beV).qa)));
(beW)=((beW).concat(toBin_((beV).q2)));
(beW)=((beW).concat(toBin_((beV).q1)));
(beW)=((beW).concat(toBin_((beV).zJ)));
(beW)=((beW).concat(toBin_((beV).r7)));
(beW)=((beW).concat(toBin_((beV).qe)));
return beW;
}
// _fromBin
function bfi(bfj,bfk,bfl){
let bfm=null;
(bfm)=(new Bu());
((bfm).Bx)=(fromBin_((bfk),(bfl.$)));
((bfm).Bz)=(fromBin_((bfk),(bfl.$)));
((bfm).qn)=(fromBin_((bfk),(bfl.$)));
((bfm).qZ)=(fromBin_((bfk),(bfl.$)));
((bfm).qW)=(fromBin_((bfk),(bfl.$)));
((bfm).qa)=(fromBin_((bfk),(bfl.$)));
((bfm).q2)=(fromBin_((bfk),(bfl.$)));
((bfm).q1)=(fromBin_((bfk),(bfl.$)));
((bfm).zJ)=(fromBin_((bfk),(bfl.$)));
((bfm).r7)=(fromBin_((bfk),(bfl.$)));
((bfm).qe)=(fromBin_((bfk),(bfl.$)));
return bfm;
}
// _dtor
function bfn(bfo){
((bfo).B6)=(null);
((bfo).B7)=(null);
((bfo).qn)=(null);
((bfo).qZ)=(null);
((bfo).qW)=(null);
((bfo).qa)=(null);
((bfo).q2)=(null);
((bfo).q1)=(null);
((bfo).zJ)=(null);
}
// _copy
function bfp(bfq){
let bfr=null;
(bfr)=(new B5());
((bfr).B6)=(C_([134],((bfq).B6)));
((bfr).B7)=(C_([134],((bfq).B7)));
((bfr).qn)=(C_([134],((bfq).qn)));
((bfr).qZ)=(C_([129,2],((bfq).qZ)));
((bfr).qW)=(C_([134],((bfq).qW)));
((bfr).qa)=(C_([133,129,2,134],((bfq).qa)));
((bfr).q2)=(C_([129,2],((bfq).q2)));
((bfr).q1)=(C_([134],((bfq).q1)));
((bfr).zJ)=(C_([134],((bfq).zJ)));
((bfr).r7)=((bfq).r7);
((bfr).qe)=((bfq).qe);
return bfr;
}
// _toBin
function bfs(bft){
let bfu=null;
(bfu)=(new Array(8).fill(0));
(bfu)=((bfu).concat(toBin_((bft).B6)));
(bfu)=((bfu).concat(toBin_((bft).B7)));
(bfu)=((bfu).concat(toBin_((bft).qn)));
(bfu)=((bfu).concat(toBin_((bft).qZ)));
(bfu)=((bfu).concat(toBin_((bft).qW)));
(bfu)=((bfu).concat(toBin_((bft).qa)));
(bfu)=((bfu).concat(toBin_((bft).q2)));
(bfu)=((bfu).concat(toBin_((bft).q1)));
(bfu)=((bfu).concat(toBin_((bft).zJ)));
(bfu)=((bfu).concat(toBin_((bft).r7)));
(bfu)=((bfu).concat(toBin_((bft).qe)));
return bfu;
}
// _fromBin
function bf6(bf7,bf8,bf9){
let bfA=null;
(bfA)=(new B5());
((bfA).B6)=(fromBin_((bf8),(bf9.$)));
((bfA).B7)=(fromBin_((bf8),(bf9.$)));
((bfA).qn)=(fromBin_((bf8),(bf9.$)));
((bfA).qZ)=(fromBin_((bf8),(bf9.$)));
((bfA).qW)=(fromBin_((bf8),(bf9.$)));
((bfA).qa)=(fromBin_((bf8),(bf9.$)));
((bfA).q2)=(fromBin_((bf8),(bf9.$)));
((bfA).q1)=(fromBin_((bf8),(bf9.$)));
((bfA).zJ)=(fromBin_((bf8),(bf9.$)));
((bfA).r7)=(fromBin_((bf8),(bf9.$)));
((bfA).qe)=(fromBin_((bf8),(bf9.$)));
return bfA;
}
// _dtor
function bfB(bfC){
((bfC).Sp)=(null);
((bfC).Sr)=(null);
((bfC).Sx)=(null);
((bfC).S4)=(null);
((bfC).y4)=(null);
((bfC).qn)=(null);
((bfC).qZ)=(null);
((bfC).qW)=(null);
((bfC).qa)=(null);
((bfC).q2)=(null);
((bfC).q1)=(null);
((bfC).zJ)=(null);
}
// _copy
function bfD(bfE){
let bfF=null;
(bfF)=(new EA());
((bfF).Sp)=(C_([134],((bfE).Sp)));
((bfF).Sr)=(C_([134],((bfE).Sr)));
((bfF).Sx)=(C_([130,134],((bfE).Sx)));
((bfF).S4)=(C_([134],((bfE).S4)));
((bfF).y4)=(C_([134],((bfE).y4)));
((bfF).qn)=(C_([134],((bfE).qn)));
((bfF).qZ)=(C_([129,2],((bfE).qZ)));
((bfF).qW)=(C_([134],((bfE).qW)));
((bfF).qa)=(C_([133,129,2,134],((bfE).qa)));
((bfF).q2)=(C_([129,2],((bfE).q2)));
((bfF).q1)=(C_([134],((bfE).q1)));
((bfF).zJ)=(C_([134],((bfE).zJ)));
((bfF).r7)=((bfE).r7);
((bfF).qe)=((bfE).qe);
return bfF;
}
// _toBin
function bfG(bfH){
let bfI=null;
(bfI)=(new Array(8).fill(0));
(bfI)=((bfI).concat(toBin_((bfH).Sp)));
(bfI)=((bfI).concat(toBin_((bfH).Sr)));
(bfI)=((bfI).concat(toBin_((bfH).Sx)));
(bfI)=((bfI).concat(toBin_((bfH).S4)));
(bfI)=((bfI).concat(toBin_((bfH).y4)));
(bfI)=((bfI).concat(toBin_((bfH).qn)));
(bfI)=((bfI).concat(toBin_((bfH).qZ)));
(bfI)=((bfI).concat(toBin_((bfH).qW)));
(bfI)=((bfI).concat(toBin_((bfH).qa)));
(bfI)=((bfI).concat(toBin_((bfH).q2)));
(bfI)=((bfI).concat(toBin_((bfH).q1)));
(bfI)=((bfI).concat(toBin_((bfH).zJ)));
(bfI)=((bfI).concat(toBin_((bfH).r7)));
(bfI)=((bfI).concat(toBin_((bfH).qe)));
return bfI;
}
// _fromBin
function bfX(bfY,bfZ,bga){
let bgb=null;
(bgb)=(new EA());
((bgb).Sp)=(fromBin_((bfZ),(bga.$)));
((bgb).Sr)=(fromBin_((bfZ),(bga.$)));
((bgb).Sx)=(fromBin_((bfZ),(bga.$)));
((bgb).S4)=(fromBin_((bfZ),(bga.$)));
((bgb).y4)=(fromBin_((bfZ),(bga.$)));
((bgb).qn)=(fromBin_((bfZ),(bga.$)));
((bgb).qZ)=(fromBin_((bfZ),(bga.$)));
((bgb).qW)=(fromBin_((bfZ),(bga.$)));
((bgb).qa)=(fromBin_((bfZ),(bga.$)));
((bgb).q2)=(fromBin_((bfZ),(bga.$)));
((bgb).q1)=(fromBin_((bfZ),(bga.$)));
((bgb).zJ)=(fromBin_((bfZ),(bga.$)));
((bgb).r7)=(fromBin_((bfZ),(bga.$)));
((bgb).qe)=(fromBin_((bfZ),(bga.$)));
return bgb;
}
// _dtor
function bgc(bgd){
((bgd).SI)=(null);
((bgd).SM)=(null);
((bgd).Th)=(null);
((bgd).y4)=(null);
((bgd).qn)=(null);
((bgd).qZ)=(null);
((bgd).qW)=(null);
((bgd).qa)=(null);
((bgd).q2)=(null);
((bgd).q1)=(null);
((bgd).zJ)=(null);
}
// _copy
function bge(bgf){
let bgg=null;
(bgg)=(new ED());
((bgg).SI)=(C_([134],((bgf).SI)));
((bgg).SM)=(C_([130,134],((bgf).SM)));
((bgg).Th)=(C_([134],((bgf).Th)));
((bgg).y4)=(C_([134],((bgf).y4)));
((bgg).qn)=(C_([134],((bgf).qn)));
((bgg).qZ)=(C_([129,2],((bgf).qZ)));
((bgg).qW)=(C_([134],((bgf).qW)));
((bgg).qa)=(C_([133,129,2,134],((bgf).qa)));
((bgg).q2)=(C_([129,2],((bgf).q2)));
((bgg).q1)=(C_([134],((bgf).q1)));
((bgg).zJ)=(C_([134],((bgf).zJ)));
((bgg).r7)=((bgf).r7);
((bgg).qe)=((bgf).qe);
return bgg;
}
// _toBin
function bgh(bgi){
let bgj=null;
(bgj)=(new Array(8).fill(0));
(bgj)=((bgj).concat(toBin_((bgi).SI)));
(bgj)=((bgj).concat(toBin_((bgi).SM)));
(bgj)=((bgj).concat(toBin_((bgi).Th)));
(bgj)=((bgj).concat(toBin_((bgi).y4)));
(bgj)=((bgj).concat(toBin_((bgi).qn)));
(bgj)=((bgj).concat(toBin_((bgi).qZ)));
(bgj)=((bgj).concat(toBin_((bgi).qW)));
(bgj)=((bgj).concat(toBin_((bgi).qa)));
(bgj)=((bgj).concat(toBin_((bgi).q2)));
(bgj)=((bgj).concat(toBin_((bgi).q1)));
(bgj)=((bgj).concat(toBin_((bgi).zJ)));
(bgj)=((bgj).concat(toBin_((bgi).r7)));
(bgj)=((bgj).concat(toBin_((bgi).qe)));
return bgj;
}
// _fromBin
function bgx(bgy,bgz,bg0){
let bg1=null;
(bg1)=(new ED());
((bg1).SI)=(fromBin_((bgz),(bg0.$)));
((bg1).SM)=(fromBin_((bgz),(bg0.$)));
((bg1).Th)=(fromBin_((bgz),(bg0.$)));
((bg1).y4)=(fromBin_((bgz),(bg0.$)));
((bg1).qn)=(fromBin_((bgz),(bg0.$)));
((bg1).qZ)=(fromBin_((bgz),(bg0.$)));
((bg1).qW)=(fromBin_((bgz),(bg0.$)));
((bg1).qa)=(fromBin_((bgz),(bg0.$)));
((bg1).q2)=(fromBin_((bgz),(bg0.$)));
((bg1).q1)=(fromBin_((bgz),(bg0.$)));
((bg1).zJ)=(fromBin_((bgz),(bg0.$)));
((bg1).r7)=(fromBin_((bgz),(bg0.$)));
((bg1).qe)=(fromBin_((bgz),(bg0.$)));
return bg1;
}
// _dtor
function bg2(bg3){
((bg3).y4)=(null);
((bg3).qn)=(null);
((bg3).qZ)=(null);
((bg3).qW)=(null);
((bg3).qa)=(null);
((bg3).q2)=(null);
((bg3).q1)=(null);
((bg3).zJ)=(null);
}
// _copy
function bg4(bg5){
let bg6=null;
(bg6)=(new EH());
((bg6).y4)=(C_([134],((bg5).y4)));
((bg6).qn)=(C_([134],((bg5).qn)));
((bg6).qZ)=(C_([129,2],((bg5).qZ)));
((bg6).qW)=(C_([134],((bg5).qW)));
((bg6).qa)=(C_([133,129,2,134],((bg5).qa)));
((bg6).q2)=(C_([129,2],((bg5).q2)));
((bg6).q1)=(C_([134],((bg5).q1)));
((bg6).zJ)=(C_([134],((bg5).zJ)));
((bg6).r7)=((bg5).r7);
((bg6).qe)=((bg5).qe);
return bg6;
}
// _toBin
function bg7(bg8){
let bg9=null;
(bg9)=(new Array(8).fill(0));
(bg9)=((bg9).concat(toBin_((bg8).y4)));
(bg9)=((bg9).concat(toBin_((bg8).qn)));
(bg9)=((bg9).concat(toBin_((bg8).qZ)));
(bg9)=((bg9).concat(toBin_((bg8).qW)));
(bg9)=((bg9).concat(toBin_((bg8).qa)));
(bg9)=((bg9).concat(toBin_((bg8).q2)));
(bg9)=((bg9).concat(toBin_((bg8).q1)));
(bg9)=((bg9).concat(toBin_((bg8).zJ)));
(bg9)=((bg9).concat(toBin_((bg8).r7)));
(bg9)=((bg9).concat(toBin_((bg8).qe)));
return bg9;
}
// _fromBin
function bgK(bgL,bgM,bgN){
let bgO=null;
(bgO)=(new EH());
((bgO).y4)=(fromBin_((bgM),(bgN.$)));
((bgO).qn)=(fromBin_((bgM),(bgN.$)));
((bgO).qZ)=(fromBin_((bgM),(bgN.$)));
((bgO).qW)=(fromBin_((bgM),(bgN.$)));
((bgO).qa)=(fromBin_((bgM),(bgN.$)));
((bgO).q2)=(fromBin_((bgM),(bgN.$)));
((bgO).q1)=(fromBin_((bgM),(bgN.$)));
((bgO).zJ)=(fromBin_((bgM),(bgN.$)));
((bgO).r7)=(fromBin_((bgM),(bgN.$)));
((bgO).qe)=(fromBin_((bgM),(bgN.$)));
return bgO;
}
// _dtor
function bgP(bgQ){
((bgQ).TE)=(null);
((bgQ).TG)=(null);
((bgQ).y4)=(null);
((bgQ).qn)=(null);
((bgQ).qZ)=(null);
((bgQ).qW)=(null);
((bgQ).qa)=(null);
((bgQ).q2)=(null);
((bgQ).q1)=(null);
((bgQ).zJ)=(null);
}
// _copy
function bgR(bgS){
let bgT=null;
(bgT)=(new EG());
((bgT).TE)=(C_([134],((bgS).TE)));
((bgT).TM)=((bgS).TM);
((bgT).TG)=(C_([130,134],((bgS).TG)));
((bgT).y4)=(C_([134],((bgS).y4)));
((bgT).qn)=(C_([134],((bgS).qn)));
((bgT).qZ)=(C_([129,2],((bgS).qZ)));
((bgT).qW)=(C_([134],((bgS).qW)));
((bgT).qa)=(C_([133,129,2,134],((bgS).qa)));
((bgT).q2)=(C_([129,2],((bgS).q2)));
((bgT).q1)=(C_([134],((bgS).q1)));
((bgT).zJ)=(C_([134],((bgS).zJ)));
((bgT).r7)=((bgS).r7);
((bgT).qe)=((bgS).qe);
return bgT;
}
// _toBin
function bgU(bgV){
let bgW=null;
(bgW)=(new Array(8).fill(0));
(bgW)=((bgW).concat(toBin_((bgV).TE)));
(bgW)=((bgW).concat(toBin_((bgV).TM)));
(bgW)=((bgW).concat(toBin_((bgV).TG)));
(bgW)=((bgW).concat(toBin_((bgV).y4)));
(bgW)=((bgW).concat(toBin_((bgV).qn)));
(bgW)=((bgW).concat(toBin_((bgV).qZ)));
(bgW)=((bgW).concat(toBin_((bgV).qW)));
(bgW)=((bgW).concat(toBin_((bgV).qa)));
(bgW)=((bgW).concat(toBin_((bgV).q2)));
(bgW)=((bgW).concat(toBin_((bgV).q1)));
(bgW)=((bgW).concat(toBin_((bgV).zJ)));
(bgW)=((bgW).concat(toBin_((bgV).r7)));
(bgW)=((bgW).concat(toBin_((bgV).qe)));
return bgW;
}
// _fromBin
function bhk(bhl,bhm,bhn){
let bho=null;
(bho)=(new EG());
((bho).TE)=(fromBin_((bhm),(bhn.$)));
((bho).TM)=(fromBin_((bhm),(bhn.$)));
((bho).TG)=(fromBin_((bhm),(bhn.$)));
((bho).y4)=(fromBin_((bhm),(bhn.$)));
((bho).qn)=(fromBin_((bhm),(bhn.$)));
((bho).qZ)=(fromBin_((bhm),(bhn.$)));
((bho).qW)=(fromBin_((bhm),(bhn.$)));
((bho).qa)=(fromBin_((bhm),(bhn.$)));
((bho).q2)=(fromBin_((bhm),(bhn.$)));
((bho).q1)=(fromBin_((bhm),(bhn.$)));
((bho).zJ)=(fromBin_((bhm),(bhn.$)));
((bho).r7)=(fromBin_((bhm),(bhn.$)));
((bho).qe)=(fromBin_((bhm),(bhn.$)));
return bho;
}
// _dtor
function bhp(bhq){
((bhq).Ug)=(null);
((bhq).Uf)=(null);
((bhq).Uh)=(null);
((bhq).Up)=(null);
((bhq).y4)=(null);
((bhq).qn)=(null);
((bhq).qZ)=(null);
((bhq).qW)=(null);
((bhq).qa)=(null);
((bhq).q2)=(null);
((bhq).q1)=(null);
((bhq).zJ)=(null);
}
// _copy
function bhr(bhs){
let bht=null;
(bht)=(new EK());
((bht).Ug)=(C_([134],((bhs).Ug)));
((bht).Uf)=(C_([134],((bhs).Uf)));
((bht).Uh)=(C_([134],((bhs).Uh)));
((bht).Up)=(C_([130,134],((bhs).Up)));
((bht).y4)=(C_([134],((bhs).y4)));
((bht).qn)=(C_([134],((bhs).qn)));
((bht).qZ)=(C_([129,2],((bhs).qZ)));
((bht).qW)=(C_([134],((bhs).qW)));
((bht).qa)=(C_([133,129,2,134],((bhs).qa)));
((bht).q2)=(C_([129,2],((bhs).q2)));
((bht).q1)=(C_([134],((bhs).q1)));
((bht).zJ)=(C_([134],((bhs).zJ)));
((bht).r7)=((bhs).r7);
((bht).qe)=((bhs).qe);
return bht;
}
// _toBin
function bhu(bhv){
let bhw=null;
(bhw)=(new Array(8).fill(0));
(bhw)=((bhw).concat(toBin_((bhv).Ug)));
(bhw)=((bhw).concat(toBin_((bhv).Uf)));
(bhw)=((bhw).concat(toBin_((bhv).Uh)));
(bhw)=((bhw).concat(toBin_((bhv).Up)));
(bhw)=((bhw).concat(toBin_((bhv).y4)));
(bhw)=((bhw).concat(toBin_((bhv).qn)));
(bhw)=((bhw).concat(toBin_((bhv).qZ)));
(bhw)=((bhw).concat(toBin_((bhv).qW)));
(bhw)=((bhw).concat(toBin_((bhv).qa)));
(bhw)=((bhw).concat(toBin_((bhv).q2)));
(bhw)=((bhw).concat(toBin_((bhv).q1)));
(bhw)=((bhw).concat(toBin_((bhv).zJ)));
(bhw)=((bhw).concat(toBin_((bhv).r7)));
(bhw)=((bhw).concat(toBin_((bhv).qe)));
return bhw;
}
// _fromBin
function bhB(bhC,bhD,bhE){
let bhF=null;
(bhF)=(new EK());
((bhF).Ug)=(fromBin_((bhD),(bhE.$)));
((bhF).Uf)=(fromBin_((bhD),(bhE.$)));
((bhF).Uh)=(fromBin_((bhD),(bhE.$)));
((bhF).Up)=(fromBin_((bhD),(bhE.$)));
((bhF).y4)=(fromBin_((bhD),(bhE.$)));
((bhF).qn)=(fromBin_((bhD),(bhE.$)));
((bhF).qZ)=(fromBin_((bhD),(bhE.$)));
((bhF).qW)=(fromBin_((bhD),(bhE.$)));
((bhF).qa)=(fromBin_((bhD),(bhE.$)));
((bhF).q2)=(fromBin_((bhD),(bhE.$)));
((bhF).q1)=(fromBin_((bhD),(bhE.$)));
((bhF).zJ)=(fromBin_((bhD),(bhE.$)));
((bhF).r7)=(fromBin_((bhD),(bhE.$)));
((bhF).qe)=(fromBin_((bhD),(bhE.$)));
return bhF;
}
// _dtor
function bhG(bhH){
((bhH).UV)=(null);
((bhH).qn)=(null);
((bhH).qZ)=(null);
((bhH).qW)=(null);
((bhH).qa)=(null);
((bhH).q2)=(null);
((bhH).q1)=(null);
((bhH).zJ)=(null);
}
// _copy
function bhI(bhJ){
let bhK=null;
(bhK)=(new EP());
((bhK).UV)=(C_([134],((bhJ).UV)));
((bhK).qn)=(C_([134],((bhJ).qn)));
((bhK).qZ)=(C_([129,2],((bhJ).qZ)));
((bhK).qW)=(C_([134],((bhJ).qW)));
((bhK).qa)=(C_([133,129,2,134],((bhJ).qa)));
((bhK).q2)=(C_([129,2],((bhJ).q2)));
((bhK).q1)=(C_([134],((bhJ).q1)));
((bhK).zJ)=(C_([134],((bhJ).zJ)));
((bhK).r7)=((bhJ).r7);
((bhK).qe)=((bhJ).qe);
return bhK;
}
// _toBin
function bhL(bhM){
let bhN=null;
(bhN)=(new Array(8).fill(0));
(bhN)=((bhN).concat(toBin_((bhM).UV)));
(bhN)=((bhN).concat(toBin_((bhM).qn)));
(bhN)=((bhN).concat(toBin_((bhM).qZ)));
(bhN)=((bhN).concat(toBin_((bhM).qW)));
(bhN)=((bhN).concat(toBin_((bhM).qa)));
(bhN)=((bhN).concat(toBin_((bhM).q2)));
(bhN)=((bhN).concat(toBin_((bhM).q1)));
(bhN)=((bhN).concat(toBin_((bhM).zJ)));
(bhN)=((bhN).concat(toBin_((bhM).r7)));
(bhN)=((bhN).concat(toBin_((bhM).qe)));
return bhN;
}
// _fromBin
function bhY(bhZ,bia,bib){
let bic=null;
(bic)=(new EP());
((bic).UV)=(fromBin_((bia),(bib.$)));
((bic).qn)=(fromBin_((bia),(bib.$)));
((bic).qZ)=(fromBin_((bia),(bib.$)));
((bic).qW)=(fromBin_((bia),(bib.$)));
((bic).qa)=(fromBin_((bia),(bib.$)));
((bic).q2)=(fromBin_((bia),(bib.$)));
((bic).q1)=(fromBin_((bia),(bib.$)));
((bic).zJ)=(fromBin_((bia),(bib.$)));
((bic).r7)=(fromBin_((bia),(bib.$)));
((bic).qe)=(fromBin_((bia),(bib.$)));
return bic;
}
// _dtor
function bid(bie){
((bie).Ve)=(null);
((bie).qn)=(null);
((bie).qZ)=(null);
((bie).qW)=(null);
((bie).qa)=(null);
((bie).q2)=(null);
((bie).q1)=(null);
((bie).zJ)=(null);
}
// _copy
function bif(big){
let bih=null;
(bih)=(new EU());
((bih).Ve)=(C_([134],((big).Ve)));
((bih).qn)=(C_([134],((big).qn)));
((bih).qZ)=(C_([129,2],((big).qZ)));
((bih).qW)=(C_([134],((big).qW)));
((bih).qa)=(C_([133,129,2,134],((big).qa)));
((bih).q2)=(C_([129,2],((big).q2)));
((bih).q1)=(C_([134],((big).q1)));
((bih).zJ)=(C_([134],((big).zJ)));
((bih).r7)=((big).r7);
((bih).qe)=((big).qe);
return bih;
}
// _toBin
function bii(bij){
let bik=null;
(bik)=(new Array(8).fill(0));
(bik)=((bik).concat(toBin_((bij).Ve)));
(bik)=((bik).concat(toBin_((bij).qn)));
(bik)=((bik).concat(toBin_((bij).qZ)));
(bik)=((bik).concat(toBin_((bij).qW)));
(bik)=((bik).concat(toBin_((bij).qa)));
(bik)=((bik).concat(toBin_((bij).q2)));
(bik)=((bik).concat(toBin_((bij).q1)));
(bik)=((bik).concat(toBin_((bij).zJ)));
(bik)=((bik).concat(toBin_((bij).r7)));
(bik)=((bik).concat(toBin_((bij).qe)));
return bik;
}
// _fromBin
function biv(biw,bix,biy){
let biz=null;
(biz)=(new EU());
((biz).Ve)=(fromBin_((bix),(biy.$)));
((biz).qn)=(fromBin_((bix),(biy.$)));
((biz).qZ)=(fromBin_((bix),(biy.$)));
((biz).qW)=(fromBin_((bix),(biy.$)));
((biz).qa)=(fromBin_((bix),(biy.$)));
((biz).q2)=(fromBin_((bix),(biy.$)));
((biz).q1)=(fromBin_((bix),(biy.$)));
((biz).zJ)=(fromBin_((bix),(biy.$)));
((biz).r7)=(fromBin_((bix),(biy.$)));
((biz).qe)=(fromBin_((bix),(biy.$)));
return biz;
}
// _dtor
function bi0(bi1){
((bi1).Vv)=(null);
((bi1).qn)=(null);
((bi1).qZ)=(null);
((bi1).qW)=(null);
((bi1).qa)=(null);
((bi1).q2)=(null);
((bi1).q1)=(null);
((bi1).zJ)=(null);
}
// _copy
function bi2(bi3){
let bi4=null;
(bi4)=(new Fd());
((bi4).Vv)=(C_([134],((bi3).Vv)));
((bi4).qn)=(C_([134],((bi3).qn)));
((bi4).qZ)=(C_([129,2],((bi3).qZ)));
((bi4).qW)=(C_([134],((bi3).qW)));
((bi4).qa)=(C_([133,129,2,134],((bi3).qa)));
((bi4).q2)=(C_([129,2],((bi3).q2)));
((bi4).q1)=(C_([134],((bi3).q1)));
((bi4).zJ)=(C_([134],((bi3).zJ)));
((bi4).r7)=((bi3).r7);
((bi4).qe)=((bi3).qe);
return bi4;
}
// _toBin
function bi5(bi6){
let bi7=null;
(bi7)=(new Array(8).fill(0));
(bi7)=((bi7).concat(toBin_((bi6).Vv)));
(bi7)=((bi7).concat(toBin_((bi6).qn)));
(bi7)=((bi7).concat(toBin_((bi6).qZ)));
(bi7)=((bi7).concat(toBin_((bi6).qW)));
(bi7)=((bi7).concat(toBin_((bi6).qa)));
(bi7)=((bi7).concat(toBin_((bi6).q2)));
(bi7)=((bi7).concat(toBin_((bi6).q1)));
(bi7)=((bi7).concat(toBin_((bi6).zJ)));
(bi7)=((bi7).concat(toBin_((bi6).r7)));
(bi7)=((bi7).concat(toBin_((bi6).qe)));
return bi7;
}
// _fromBin
function biI(biJ,biK,biL){
let biM=null;
(biM)=(new Fd());
((biM).Vv)=(fromBin_((biK),(biL.$)));
((biM).qn)=(fromBin_((biK),(biL.$)));
((biM).qZ)=(fromBin_((biK),(biL.$)));
((biM).qW)=(fromBin_((biK),(biL.$)));
((biM).qa)=(fromBin_((biK),(biL.$)));
((biM).q2)=(fromBin_((biK),(biL.$)));
((biM).q1)=(fromBin_((biK),(biL.$)));
((biM).zJ)=(fromBin_((biK),(biL.$)));
((biM).r7)=(fromBin_((biK),(biL.$)));
((biM).qe)=(fromBin_((biK),(biL.$)));
return biM;
}
// _dtor
function biN(biO){
((biO).qn)=(null);
((biO).qZ)=(null);
((biO).qW)=(null);
((biO).qa)=(null);
((biO).q2)=(null);
((biO).q1)=(null);
((biO).zJ)=(null);
}
// _copy
function biP(biQ){
let biR=null;
(biR)=(new Mi());
((biR).qn)=(C_([134],((biQ).qn)));
((biR).qZ)=(C_([129,2],((biQ).qZ)));
((biR).qW)=(C_([134],((biQ).qW)));
((biR).qa)=(C_([133,129,2,134],((biQ).qa)));
((biR).q2)=(C_([129,2],((biQ).q2)));
((biR).q1)=(C_([134],((biQ).q1)));
((biR).zJ)=(C_([134],((biQ).zJ)));
((biR).r7)=((biQ).r7);
((biR).qe)=((biQ).qe);
return biR;
}
// _toBin
function biS(biT){
let biU=null;
(biU)=(new Array(8).fill(0));
(biU)=((biU).concat(toBin_((biT).qn)));
(biU)=((biU).concat(toBin_((biT).qZ)));
(biU)=((biU).concat(toBin_((biT).qW)));
(biU)=((biU).concat(toBin_((biT).qa)));
(biU)=((biU).concat(toBin_((biT).q2)));
(biU)=((biU).concat(toBin_((biT).q1)));
(biU)=((biU).concat(toBin_((biT).zJ)));
(biU)=((biU).concat(toBin_((biT).r7)));
(biU)=((biU).concat(toBin_((biT).qe)));
return biU;
}
// _fromBin
function bje(bjf,bjg,bjh){
let bji=null;
(bji)=(new Mi());
((bji).qn)=(fromBin_((bjg),(bjh.$)));
((bji).qZ)=(fromBin_((bjg),(bjh.$)));
((bji).qW)=(fromBin_((bjg),(bjh.$)));
((bji).qa)=(fromBin_((bjg),(bjh.$)));
((bji).q2)=(fromBin_((bjg),(bjh.$)));
((bji).q1)=(fromBin_((bjg),(bjh.$)));
((bji).zJ)=(fromBin_((bjg),(bjh.$)));
((bji).r7)=(fromBin_((bjg),(bjh.$)));
((bji).qe)=(fromBin_((bjg),(bjh.$)));
return bji;
}
// _dtor
function bjj(bjk){
((bjk).agl)=(null);
((bjk).zn)=(null);
((bjk).qn)=(null);
((bjk).qZ)=(null);
((bjk).qW)=(null);
((bjk).qa)=(null);
((bjk).q2)=(null);
((bjk).q1)=(null);
((bjk).zJ)=(null);
}
// _copy
function bjl(bjm){
let bjn=null;
(bjn)=(new PC());
((bjn).agr)=((bjm).agr);
((bjn).agl)=(C_([134],((bjm).agl)));
((bjn).zn)=(C_([134],((bjm).zn)));
((bjn).zj)=((bjm).zj);
((bjn).qn)=(C_([134],((bjm).qn)));
((bjn).qZ)=(C_([129,2],((bjm).qZ)));
((bjn).qW)=(C_([134],((bjm).qW)));
((bjn).qa)=(C_([133,129,2,134],((bjm).qa)));
((bjn).q2)=(C_([129,2],((bjm).q2)));
((bjn).q1)=(C_([134],((bjm).q1)));
((bjn).zJ)=(C_([134],((bjm).zJ)));
((bjn).r7)=((bjm).r7);
((bjn).qe)=((bjm).qe);
return bjn;
}
// _toBin
function bjo(bjp){
let bjq=null;
(bjq)=(new Array(8).fill(0));
(bjq)=((bjq).concat(toBin_((bjp).agr)));
(bjq)=((bjq).concat(toBin_((bjp).agl)));
(bjq)=((bjq).concat(toBin_((bjp).zn)));
(bjq)=((bjq).concat(toBin_((bjp).zj)));
(bjq)=((bjq).concat(toBin_((bjp).qn)));
(bjq)=((bjq).concat(toBin_((bjp).qZ)));
(bjq)=((bjq).concat(toBin_((bjp).qW)));
(bjq)=((bjq).concat(toBin_((bjp).qa)));
(bjq)=((bjq).concat(toBin_((bjp).q2)));
(bjq)=((bjq).concat(toBin_((bjp).q1)));
(bjq)=((bjq).concat(toBin_((bjp).zJ)));
(bjq)=((bjq).concat(toBin_((bjp).r7)));
(bjq)=((bjq).concat(toBin_((bjp).qe)));
return bjq;
}
// _fromBin
function bj4(bj5,bj6,bj7){
let bj8=null;
(bj8)=(new PC());
((bj8).agr)=(fromBin_((bj6),(bj7.$)));
((bj8).agl)=(fromBin_((bj6),(bj7.$)));
((bj8).zn)=(fromBin_((bj6),(bj7.$)));
((bj8).zj)=(fromBin_((bj6),(bj7.$)));
((bj8).qn)=(fromBin_((bj6),(bj7.$)));
((bj8).qZ)=(fromBin_((bj6),(bj7.$)));
((bj8).qW)=(fromBin_((bj6),(bj7.$)));
((bj8).qa)=(fromBin_((bj6),(bj7.$)));
((bj8).q2)=(fromBin_((bj6),(bj7.$)));
((bj8).q1)=(fromBin_((bj6),(bj7.$)));
((bj8).zJ)=(fromBin_((bj6),(bj7.$)));
((bj8).r7)=(fromBin_((bj6),(bj7.$)));
((bj8).qe)=(fromBin_((bj6),(bj7.$)));
return bj8;
}
// _dtor
function bj9(bjA){
((bjA).ak1)=(null);
((bjA).ak4)=(null);
((bjA).ak7)=(null);
((bjA).zn)=(null);
((bjA).qn)=(null);
((bjA).qZ)=(null);
((bjA).qW)=(null);
((bjA).qa)=(null);
((bjA).q2)=(null);
((bjA).q1)=(null);
((bjA).zJ)=(null);
}
// _copy
function bjB(bjC){
let bjD=null;
(bjD)=(new PH());
((bjD).ak1)=(C_([134],((bjC).ak1)));
((bjD).ak4)=(C_([134],((bjC).ak4)));
((bjD).ak7)=(C_([134],((bjC).ak7)));
((bjD).zn)=(C_([134],((bjC).zn)));
((bjD).zj)=((bjC).zj);
((bjD).qn)=(C_([134],((bjC).qn)));
((bjD).qZ)=(C_([129,2],((bjC).qZ)));
((bjD).qW)=(C_([134],((bjC).qW)));
((bjD).qa)=(C_([133,129,2,134],((bjC).qa)));
((bjD).q2)=(C_([129,2],((bjC).q2)));
((bjD).q1)=(C_([134],((bjC).q1)));
((bjD).zJ)=(C_([134],((bjC).zJ)));
((bjD).r7)=((bjC).r7);
((bjD).qe)=((bjC).qe);
return bjD;
}
// _toBin
function bjE(bjF){
let bjG=null;
(bjG)=(new Array(8).fill(0));
(bjG)=((bjG).concat(toBin_((bjF).ak1)));
(bjG)=((bjG).concat(toBin_((bjF).ak4)));
(bjG)=((bjG).concat(toBin_((bjF).ak7)));
(bjG)=((bjG).concat(toBin_((bjF).zn)));
(bjG)=((bjG).concat(toBin_((bjF).zj)));
(bjG)=((bjG).concat(toBin_((bjF).qn)));
(bjG)=((bjG).concat(toBin_((bjF).qZ)));
(bjG)=((bjG).concat(toBin_((bjF).qW)));
(bjG)=((bjG).concat(toBin_((bjF).qa)));
(bjG)=((bjG).concat(toBin_((bjF).q2)));
(bjG)=((bjG).concat(toBin_((bjF).q1)));
(bjG)=((bjG).concat(toBin_((bjF).zJ)));
(bjG)=((bjG).concat(toBin_((bjF).r7)));
(bjG)=((bjG).concat(toBin_((bjF).qe)));
return bjG;
}
// _fromBin
function bjV(bjW,bjX,bjY){
let bjZ=null;
(bjZ)=(new PH());
((bjZ).ak1)=(fromBin_((bjX),(bjY.$)));
((bjZ).ak4)=(fromBin_((bjX),(bjY.$)));
((bjZ).ak7)=(fromBin_((bjX),(bjY.$)));
((bjZ).zn)=(fromBin_((bjX),(bjY.$)));
((bjZ).zj)=(fromBin_((bjX),(bjY.$)));
((bjZ).qn)=(fromBin_((bjX),(bjY.$)));
((bjZ).qZ)=(fromBin_((bjX),(bjY.$)));
((bjZ).qW)=(fromBin_((bjX),(bjY.$)));
((bjZ).qa)=(fromBin_((bjX),(bjY.$)));
((bjZ).q2)=(fromBin_((bjX),(bjY.$)));
((bjZ).q1)=(fromBin_((bjX),(bjY.$)));
((bjZ).zJ)=(fromBin_((bjX),(bjY.$)));
((bjZ).r7)=(fromBin_((bjX),(bjY.$)));
((bjZ).qe)=(fromBin_((bjX),(bjY.$)));
return bjZ;
}
// _dtor
function bka(bkb){
((bkb).akR)=(null);
((bkb).zn)=(null);
((bkb).qn)=(null);
((bkb).qZ)=(null);
((bkb).qW)=(null);
((bkb).qa)=(null);
((bkb).q2)=(null);
((bkb).q1)=(null);
((bkb).zJ)=(null);
}
// _copy
function bkc(bkd){
let bke=null;
(bke)=(new PK());
((bke).akR)=(C_([134],((bkd).akR)));
((bke).zn)=(C_([134],((bkd).zn)));
((bke).zj)=((bkd).zj);
((bke).qn)=(C_([134],((bkd).qn)));
((bke).qZ)=(C_([129,2],((bkd).qZ)));
((bke).qW)=(C_([134],((bkd).qW)));
((bke).qa)=(C_([133,129,2,134],((bkd).qa)));
((bke).q2)=(C_([129,2],((bkd).q2)));
((bke).q1)=(C_([134],((bkd).q1)));
((bke).zJ)=(C_([134],((bkd).zJ)));
((bke).r7)=((bkd).r7);
((bke).qe)=((bkd).qe);
return bke;
}
// _toBin
function bkf(bkg){
let bkh=null;
(bkh)=(new Array(8).fill(0));
(bkh)=((bkh).concat(toBin_((bkg).akR)));
(bkh)=((bkh).concat(toBin_((bkg).zn)));
(bkh)=((bkh).concat(toBin_((bkg).zj)));
(bkh)=((bkh).concat(toBin_((bkg).qn)));
(bkh)=((bkh).concat(toBin_((bkg).qZ)));
(bkh)=((bkh).concat(toBin_((bkg).qW)));
(bkh)=((bkh).concat(toBin_((bkg).qa)));
(bkh)=((bkh).concat(toBin_((bkg).q2)));
(bkh)=((bkh).concat(toBin_((bkg).q1)));
(bkh)=((bkh).concat(toBin_((bkg).zJ)));
(bkh)=((bkh).concat(toBin_((bkg).r7)));
(bkh)=((bkh).concat(toBin_((bkg).qe)));
return bkh;
}
// _fromBin
function bku(bkv,bkw,bkx){
let bky=null;
(bky)=(new PK());
((bky).akR)=(fromBin_((bkw),(bkx.$)));
((bky).zn)=(fromBin_((bkw),(bkx.$)));
((bky).zj)=(fromBin_((bkw),(bkx.$)));
((bky).qn)=(fromBin_((bkw),(bkx.$)));
((bky).qZ)=(fromBin_((bkw),(bkx.$)));
((bky).qW)=(fromBin_((bkw),(bkx.$)));
((bky).qa)=(fromBin_((bkw),(bkx.$)));
((bky).q2)=(fromBin_((bkw),(bkx.$)));
((bky).q1)=(fromBin_((bkw),(bkx.$)));
((bky).zJ)=(fromBin_((bkw),(bkx.$)));
((bky).r7)=(fromBin_((bkw),(bkx.$)));
((bky).qe)=(fromBin_((bkw),(bkx.$)));
return bky;
}
// _dtor
function bkz(bk0){
((bk0).ald)=(null);
((bk0).all)=(null);
((bk0).zn)=(null);
((bk0).qn)=(null);
((bk0).qZ)=(null);
((bk0).qW)=(null);
((bk0).qa)=(null);
((bk0).q2)=(null);
((bk0).q1)=(null);
((bk0).zJ)=(null);
}
// _copy
function bk1(bk2){
let bk3=null;
(bk3)=(new PN());
((bk3).ald)=(C_([130,134],((bk2).ald)));
((bk3).all)=(C_([134],((bk2).all)));
((bk3).zn)=(C_([134],((bk2).zn)));
((bk3).zj)=((bk2).zj);
((bk3).qn)=(C_([134],((bk2).qn)));
((bk3).qZ)=(C_([129,2],((bk2).qZ)));
((bk3).qW)=(C_([134],((bk2).qW)));
((bk3).qa)=(C_([133,129,2,134],((bk2).qa)));
((bk3).q2)=(C_([129,2],((bk2).q2)));
((bk3).q1)=(C_([134],((bk2).q1)));
((bk3).zJ)=(C_([134],((bk2).zJ)));
((bk3).r7)=((bk2).r7);
((bk3).qe)=((bk2).qe);
return bk3;
}
// _toBin
function bk4(bk5){
let bk6=null;
(bk6)=(new Array(8).fill(0));
(bk6)=((bk6).concat(toBin_((bk5).ald)));
(bk6)=((bk6).concat(toBin_((bk5).all)));
(bk6)=((bk6).concat(toBin_((bk5).zn)));
(bk6)=((bk6).concat(toBin_((bk5).zj)));
(bk6)=((bk6).concat(toBin_((bk5).qn)));
(bk6)=((bk6).concat(toBin_((bk5).qZ)));
(bk6)=((bk6).concat(toBin_((bk5).qW)));
(bk6)=((bk6).concat(toBin_((bk5).qa)));
(bk6)=((bk6).concat(toBin_((bk5).q2)));
(bk6)=((bk6).concat(toBin_((bk5).q1)));
(bk6)=((bk6).concat(toBin_((bk5).zJ)));
(bk6)=((bk6).concat(toBin_((bk5).r7)));
(bk6)=((bk6).concat(toBin_((bk5).qe)));
return bk6;
}
// _fromBin
function bkK(bkL,bkM,bkN){
let bkO=null;
(bkO)=(new PN());
((bkO).ald)=(fromBin_((bkM),(bkN.$)));
((bkO).all)=(fromBin_((bkM),(bkN.$)));
((bkO).zn)=(fromBin_((bkM),(bkN.$)));
((bkO).zj)=(fromBin_((bkM),(bkN.$)));
((bkO).qn)=(fromBin_((bkM),(bkN.$)));
((bkO).qZ)=(fromBin_((bkM),(bkN.$)));
((bkO).qW)=(fromBin_((bkM),(bkN.$)));
((bkO).qa)=(fromBin_((bkM),(bkN.$)));
((bkO).q2)=(fromBin_((bkM),(bkN.$)));
((bkO).q1)=(fromBin_((bkM),(bkN.$)));
((bkO).zJ)=(fromBin_((bkM),(bkN.$)));
((bkO).r7)=(fromBin_((bkM),(bkN.$)));
((bkO).qe)=(fromBin_((bkM),(bkN.$)));
return bkO;
}
// _dtor
function bkP(bkQ){
((bkQ).aly)=(null);
((bkQ).al1)=(null);
((bkQ).zn)=(null);
((bkQ).qn)=(null);
((bkQ).qZ)=(null);
((bkQ).qW)=(null);
((bkQ).qa)=(null);
((bkQ).q2)=(null);
((bkQ).q1)=(null);
((bkQ).zJ)=(null);
}
// _copy
function bkR(bkS){
let bkT=null;
(bkT)=(new PQ());
((bkT).al6)=((bkS).al6);
((bkT).aly)=(C_([134],((bkS).aly)));
((bkT).al1)=(C_([134],((bkS).al1)));
((bkT).zn)=(C_([134],((bkS).zn)));
((bkT).zj)=((bkS).zj);
((bkT).qn)=(C_([134],((bkS).qn)));
((bkT).qZ)=(C_([129,2],((bkS).qZ)));
((bkT).qW)=(C_([134],((bkS).qW)));
((bkT).qa)=(C_([133,129,2,134],((bkS).qa)));
((bkT).q2)=(C_([129,2],((bkS).q2)));
((bkT).q1)=(C_([134],((bkS).q1)));
((bkT).zJ)=(C_([134],((bkS).zJ)));
((bkT).r7)=((bkS).r7);
((bkT).qe)=((bkS).qe);
return bkT;
}
// _toBin
function bkU(bkV){
let bkW=null;
(bkW)=(new Array(8).fill(0));
(bkW)=((bkW).concat(toBin_((bkV).al6)));
(bkW)=((bkW).concat(toBin_((bkV).aly)));
(bkW)=((bkW).concat(toBin_((bkV).al1)));
(bkW)=((bkW).concat(toBin_((bkV).zn)));
(bkW)=((bkW).concat(toBin_((bkV).zj)));
(bkW)=((bkW).concat(toBin_((bkV).qn)));
(bkW)=((bkW).concat(toBin_((bkV).qZ)));
(bkW)=((bkW).concat(toBin_((bkV).qW)));
(bkW)=((bkW).concat(toBin_((bkV).qa)));
(bkW)=((bkW).concat(toBin_((bkV).q2)));
(bkW)=((bkW).concat(toBin_((bkV).q1)));
(bkW)=((bkW).concat(toBin_((bkV).zJ)));
(bkW)=((bkW).concat(toBin_((bkV).r7)));
(bkW)=((bkW).concat(toBin_((bkV).qe)));
return bkW;
}
// _fromBin
function bll(blm,bln,blo){
let blp=null;
(blp)=(new PQ());
((blp).al6)=(fromBin_((bln),(blo.$)));
((blp).aly)=(fromBin_((bln),(blo.$)));
((blp).al1)=(fromBin_((bln),(blo.$)));
((blp).zn)=(fromBin_((bln),(blo.$)));
((blp).zj)=(fromBin_((bln),(blo.$)));
((blp).qn)=(fromBin_((bln),(blo.$)));
((blp).qZ)=(fromBin_((bln),(blo.$)));
((blp).qW)=(fromBin_((bln),(blo.$)));
((blp).qa)=(fromBin_((bln),(blo.$)));
((blp).q2)=(fromBin_((bln),(blo.$)));
((blp).q1)=(fromBin_((bln),(blo.$)));
((blp).zJ)=(fromBin_((bln),(blo.$)));
((blp).r7)=(fromBin_((bln),(blo.$)));
((blp).qe)=(fromBin_((bln),(blo.$)));
return blp;
}
// _dtor
function blq(blr){
((blr).amK)=(null);
((blr).amQ)=(null);
((blr).zn)=(null);
((blr).qn)=(null);
((blr).qZ)=(null);
((blr).qW)=(null);
((blr).qa)=(null);
((blr).q2)=(null);
((blr).q1)=(null);
((blr).zJ)=(null);
}
// _copy
function bls(blt){
let blu=null;
(blu)=(new PT());
((blu).amK)=(C_([134],((blt).amK)));
((blu).amQ)=(C_([134],((blt).amQ)));
((blu).zn)=(C_([134],((blt).zn)));
((blu).zj)=((blt).zj);
((blu).qn)=(C_([134],((blt).qn)));
((blu).qZ)=(C_([129,2],((blt).qZ)));
((blu).qW)=(C_([134],((blt).qW)));
((blu).qa)=(C_([133,129,2,134],((blt).qa)));
((blu).q2)=(C_([129,2],((blt).q2)));
((blu).q1)=(C_([134],((blt).q1)));
((blu).zJ)=(C_([134],((blt).zJ)));
((blu).r7)=((blt).r7);
((blu).qe)=((blt).qe);
return blu;
}
// _toBin
function blv(blw){
let blx=null;
(blx)=(new Array(8).fill(0));
(blx)=((blx).concat(toBin_((blw).amK)));
(blx)=((blx).concat(toBin_((blw).amQ)));
(blx)=((blx).concat(toBin_((blw).zn)));
(blx)=((blx).concat(toBin_((blw).zj)));
(blx)=((blx).concat(toBin_((blw).qn)));
(blx)=((blx).concat(toBin_((blw).qZ)));
(blx)=((blx).concat(toBin_((blw).qW)));
(blx)=((blx).concat(toBin_((blw).qa)));
(blx)=((blx).concat(toBin_((blw).q2)));
(blx)=((blx).concat(toBin_((blw).q1)));
(blx)=((blx).concat(toBin_((blw).zJ)));
(blx)=((blx).concat(toBin_((blw).r7)));
(blx)=((blx).concat(toBin_((blw).qe)));
return blx;
}
// _fromBin
function blB(blC,blD,blE){
let blF=null;
(blF)=(new PT());
((blF).amK)=(fromBin_((blD),(blE.$)));
((blF).amQ)=(fromBin_((blD),(blE.$)));
((blF).zn)=(fromBin_((blD),(blE.$)));
((blF).zj)=(fromBin_((blD),(blE.$)));
((blF).qn)=(fromBin_((blD),(blE.$)));
((blF).qZ)=(fromBin_((blD),(blE.$)));
((blF).qW)=(fromBin_((blD),(blE.$)));
((blF).qa)=(fromBin_((blD),(blE.$)));
((blF).q2)=(fromBin_((blD),(blE.$)));
((blF).q1)=(fromBin_((blD),(blE.$)));
((blF).zJ)=(fromBin_((blD),(blE.$)));
((blF).r7)=(fromBin_((blD),(blE.$)));
((blF).qe)=(fromBin_((blD),(blE.$)));
return blF;
}
// _dtor
function blG(blH){
((blH).amV)=(null);
((blH).ana)=(null);
((blH).anb)=(null);
((blH).zn)=(null);
((blH).qn)=(null);
((blH).qZ)=(null);
((blH).qW)=(null);
((blH).qa)=(null);
((blH).q2)=(null);
((blH).q1)=(null);
((blH).zJ)=(null);
}
// _copy
function blI(blJ){
let blK=null;
(blK)=(new PW());
((blK).amV)=(C_([134],((blJ).amV)));
((blK).ana)=(C_([134],((blJ).ana)));
((blK).anb)=(C_([134],((blJ).anb)));
((blK).zn)=(C_([134],((blJ).zn)));
((blK).zj)=((blJ).zj);
((blK).qn)=(C_([134],((blJ).qn)));
((blK).qZ)=(C_([129,2],((blJ).qZ)));
((blK).qW)=(C_([134],((blJ).qW)));
((blK).qa)=(C_([133,129,2,134],((blJ).qa)));
((blK).q2)=(C_([129,2],((blJ).q2)));
((blK).q1)=(C_([134],((blJ).q1)));
((blK).zJ)=(C_([134],((blJ).zJ)));
((blK).r7)=((blJ).r7);
((blK).qe)=((blJ).qe);
return blK;
}
// _toBin
function blL(blM){
let blN=null;
(blN)=(new Array(8).fill(0));
(blN)=((blN).concat(toBin_((blM).amV)));
(blN)=((blN).concat(toBin_((blM).ana)));
(blN)=((blN).concat(toBin_((blM).anb)));
(blN)=((blN).concat(toBin_((blM).zn)));
(blN)=((blN).concat(toBin_((blM).zj)));
(blN)=((blN).concat(toBin_((blM).qn)));
(blN)=((blN).concat(toBin_((blM).qZ)));
(blN)=((blN).concat(toBin_((blM).qW)));
(blN)=((blN).concat(toBin_((blM).qa)));
(blN)=((blN).concat(toBin_((blM).q2)));
(blN)=((blN).concat(toBin_((blM).q1)));
(blN)=((blN).concat(toBin_((blM).zJ)));
(blN)=((blN).concat(toBin_((blM).r7)));
(blN)=((blN).concat(toBin_((blM).qe)));
return blN;
}
// _fromBin
function bmc(bmd,bme,bmf){
let bmg=null;
(bmg)=(new PW());
((bmg).amV)=(fromBin_((bme),(bmf.$)));
((bmg).ana)=(fromBin_((bme),(bmf.$)));
((bmg).anb)=(fromBin_((bme),(bmf.$)));
((bmg).zn)=(fromBin_((bme),(bmf.$)));
((bmg).zj)=(fromBin_((bme),(bmf.$)));
((bmg).qn)=(fromBin_((bme),(bmf.$)));
((bmg).qZ)=(fromBin_((bme),(bmf.$)));
((bmg).qW)=(fromBin_((bme),(bmf.$)));
((bmg).qa)=(fromBin_((bme),(bmf.$)));
((bmg).q2)=(fromBin_((bme),(bmf.$)));
((bmg).q1)=(fromBin_((bme),(bmf.$)));
((bmg).zJ)=(fromBin_((bme),(bmf.$)));
((bmg).r7)=(fromBin_((bme),(bmf.$)));
((bmg).qe)=(fromBin_((bme),(bmf.$)));
return bmg;
}
// _dtor
function bmh(bmi){
((bmi).aoc)=(null);
((bmi).aoh)=(null);
((bmi).zn)=(null);
((bmi).qn)=(null);
((bmi).qZ)=(null);
((bmi).qW)=(null);
((bmi).qa)=(null);
((bmi).q2)=(null);
((bmi).q1)=(null);
((bmi).zJ)=(null);
}
// _copy
function bmj(bmk){
let bml=null;
(bml)=(new Qb());
((bml).aoc)=(C_([134],((bmk).aoc)));
((bml).aoh)=(C_([134],((bmk).aoh)));
((bml).zn)=(C_([134],((bmk).zn)));
((bml).zj)=((bmk).zj);
((bml).qn)=(C_([134],((bmk).qn)));
((bml).qZ)=(C_([129,2],((bmk).qZ)));
((bml).qW)=(C_([134],((bmk).qW)));
((bml).qa)=(C_([133,129,2,134],((bmk).qa)));
((bml).q2)=(C_([129,2],((bmk).q2)));
((bml).q1)=(C_([134],((bmk).q1)));
((bml).zJ)=(C_([134],((bmk).zJ)));
((bml).r7)=((bmk).r7);
((bml).qe)=((bmk).qe);
return bml;
}
// _toBin
function bmm(bmn){
let bmo=null;
(bmo)=(new Array(8).fill(0));
(bmo)=((bmo).concat(toBin_((bmn).aoc)));
(bmo)=((bmo).concat(toBin_((bmn).aoh)));
(bmo)=((bmo).concat(toBin_((bmn).zn)));
(bmo)=((bmo).concat(toBin_((bmn).zj)));
(bmo)=((bmo).concat(toBin_((bmn).qn)));
(bmo)=((bmo).concat(toBin_((bmn).qZ)));
(bmo)=((bmo).concat(toBin_((bmn).qW)));
(bmo)=((bmo).concat(toBin_((bmn).qa)));
(bmo)=((bmo).concat(toBin_((bmn).q2)));
(bmo)=((bmo).concat(toBin_((bmn).q1)));
(bmo)=((bmo).concat(toBin_((bmn).zJ)));
(bmo)=((bmo).concat(toBin_((bmn).r7)));
(bmo)=((bmo).concat(toBin_((bmn).qe)));
return bmo;
}
// _fromBin
function bm2(bm3,bm4,bm5){
let bm6=null;
(bm6)=(new Qb());
((bm6).aoc)=(fromBin_((bm4),(bm5.$)));
((bm6).aoh)=(fromBin_((bm4),(bm5.$)));
((bm6).zn)=(fromBin_((bm4),(bm5.$)));
((bm6).zj)=(fromBin_((bm4),(bm5.$)));
((bm6).qn)=(fromBin_((bm4),(bm5.$)));
((bm6).qZ)=(fromBin_((bm4),(bm5.$)));
((bm6).qW)=(fromBin_((bm4),(bm5.$)));
((bm6).qa)=(fromBin_((bm4),(bm5.$)));
((bm6).q2)=(fromBin_((bm4),(bm5.$)));
((bm6).q1)=(fromBin_((bm4),(bm5.$)));
((bm6).zJ)=(fromBin_((bm4),(bm5.$)));
((bm6).r7)=(fromBin_((bm4),(bm5.$)));
((bm6).qe)=(fromBin_((bm4),(bm5.$)));
return bm6;
}
// _dtor
function bm7(bm8){
((bm8).anu)=(null);
((bm8).ao0)=(null);
((bm8).aoD)=(null);
((bm8).zn)=(null);
((bm8).qn)=(null);
((bm8).qZ)=(null);
((bm8).qW)=(null);
((bm8).qa)=(null);
((bm8).q2)=(null);
((bm8).q1)=(null);
((bm8).zJ)=(null);
}
// _copy
function bm9(bmA){
let bmB=null;
(bmB)=(new Qe());
((bmB).anu)=(C_([134],((bmA).anu)));
((bmB).ao0)=(C_([129,2],((bmA).ao0)));
((bmB).aoD)=(C_([134],((bmA).aoD)));
((bmB).zn)=(C_([134],((bmA).zn)));
((bmB).zj)=((bmA).zj);
((bmB).qn)=(C_([134],((bmA).qn)));
((bmB).qZ)=(C_([129,2],((bmA).qZ)));
((bmB).qW)=(C_([134],((bmA).qW)));
((bmB).qa)=(C_([133,129,2,134],((bmA).qa)));
((bmB).q2)=(C_([129,2],((bmA).q2)));
((bmB).q1)=(C_([134],((bmA).q1)));
((bmB).zJ)=(C_([134],((bmA).zJ)));
((bmB).r7)=((bmA).r7);
((bmB).qe)=((bmA).qe);
return bmB;
}
// _toBin
function bmC(bmD){
let bmE=null;
(bmE)=(new Array(8).fill(0));
(bmE)=((bmE).concat(toBin_((bmD).anu)));
(bmE)=((bmE).concat(toBin_((bmD).ao0)));
(bmE)=((bmE).concat(toBin_((bmD).aoD)));
(bmE)=((bmE).concat(toBin_((bmD).zn)));
(bmE)=((bmE).concat(toBin_((bmD).zj)));
(bmE)=((bmE).concat(toBin_((bmD).qn)));
(bmE)=((bmE).concat(toBin_((bmD).qZ)));
(bmE)=((bmE).concat(toBin_((bmD).qW)));
(bmE)=((bmE).concat(toBin_((bmD).qa)));
(bmE)=((bmE).concat(toBin_((bmD).q2)));
(bmE)=((bmE).concat(toBin_((bmD).q1)));
(bmE)=((bmE).concat(toBin_((bmD).zJ)));
(bmE)=((bmE).concat(toBin_((bmD).r7)));
(bmE)=((bmE).concat(toBin_((bmD).qe)));
return bmE;
}
// _fromBin
function bmT(bmU,bmV,bmW){
let bmX=null;
(bmX)=(new Qe());
((bmX).anu)=(fromBin_((bmV),(bmW.$)));
((bmX).ao0)=(fromBin_((bmV),(bmW.$)));
((bmX).aoD)=(fromBin_((bmV),(bmW.$)));
((bmX).zn)=(fromBin_((bmV),(bmW.$)));
((bmX).zj)=(fromBin_((bmV),(bmW.$)));
((bmX).qn)=(fromBin_((bmV),(bmW.$)));
((bmX).qZ)=(fromBin_((bmV),(bmW.$)));
((bmX).qW)=(fromBin_((bmV),(bmW.$)));
((bmX).qa)=(fromBin_((bmV),(bmW.$)));
((bmX).q2)=(fromBin_((bmV),(bmW.$)));
((bmX).q1)=(fromBin_((bmV),(bmW.$)));
((bmX).zJ)=(fromBin_((bmV),(bmW.$)));
((bmX).r7)=(fromBin_((bmV),(bmW.$)));
((bmX).qe)=(fromBin_((bmV),(bmW.$)));
return bmX;
}
// _dtor
function bmY(bmZ){
((bmZ).ail)=(null);
((bmZ).zn)=(null);
((bmZ).qn)=(null);
((bmZ).qZ)=(null);
((bmZ).qW)=(null);
((bmZ).qa)=(null);
((bmZ).q2)=(null);
((bmZ).q1)=(null);
((bmZ).zJ)=(null);
}
// _copy
function bna(bnb){
let bnc=null;
(bnc)=(new Ql());
((bnc).ail)=(C_([129,2],((bnb).ail)));
((bnc).zn)=(C_([134],((bnb).zn)));
((bnc).zj)=((bnb).zj);
((bnc).qn)=(C_([134],((bnb).qn)));
((bnc).qZ)=(C_([129,2],((bnb).qZ)));
((bnc).qW)=(C_([134],((bnb).qW)));
((bnc).qa)=(C_([133,129,2,134],((bnb).qa)));
((bnc).q2)=(C_([129,2],((bnb).q2)));
((bnc).q1)=(C_([134],((bnb).q1)));
((bnc).zJ)=(C_([134],((bnb).zJ)));
((bnc).r7)=((bnb).r7);
((bnc).qe)=((bnb).qe);
return bnc;
}
// _toBin
function bnd(bne){
let bnf=null;
(bnf)=(new Array(8).fill(0));
(bnf)=((bnf).concat(toBin_((bne).ail)));
(bnf)=((bnf).concat(toBin_((bne).zn)));
(bnf)=((bnf).concat(toBin_((bne).zj)));
(bnf)=((bnf).concat(toBin_((bne).qn)));
(bnf)=((bnf).concat(toBin_((bne).qZ)));
(bnf)=((bnf).concat(toBin_((bne).qW)));
(bnf)=((bnf).concat(toBin_((bne).qa)));
(bnf)=((bnf).concat(toBin_((bne).q2)));
(bnf)=((bnf).concat(toBin_((bne).q1)));
(bnf)=((bnf).concat(toBin_((bne).zJ)));
(bnf)=((bnf).concat(toBin_((bne).r7)));
(bnf)=((bnf).concat(toBin_((bne).qe)));
return bnf;
}
// _fromBin
function bns(bnt,bnu,bnv){
let bnw=null;
(bnw)=(new Ql());
((bnw).ail)=(fromBin_((bnu),(bnv.$)));
((bnw).zn)=(fromBin_((bnu),(bnv.$)));
((bnw).zj)=(fromBin_((bnu),(bnv.$)));
((bnw).qn)=(fromBin_((bnu),(bnv.$)));
((bnw).qZ)=(fromBin_((bnu),(bnv.$)));
((bnw).qW)=(fromBin_((bnu),(bnv.$)));
((bnw).qa)=(fromBin_((bnu),(bnv.$)));
((bnw).q2)=(fromBin_((bnu),(bnv.$)));
((bnw).q1)=(fromBin_((bnu),(bnv.$)));
((bnw).zJ)=(fromBin_((bnu),(bnv.$)));
((bnw).r7)=(fromBin_((bnu),(bnv.$)));
((bnw).qe)=(fromBin_((bnu),(bnv.$)));
return bnw;
}
// _dtor
function bnx(bny){
((bny).ah7)=(null);
((bny).zn)=(null);
((bny).qn)=(null);
((bny).qZ)=(null);
((bny).qW)=(null);
((bny).qa)=(null);
((bny).q2)=(null);
((bny).q1)=(null);
((bny).zJ)=(null);
}
// _copy
function bnz(bn0){
let bn1=null;
(bn1)=(new Qo());
((bn1).ah7)=(C_([129,2],((bn0).ah7)));
((bn1).zn)=(C_([134],((bn0).zn)));
((bn1).zj)=((bn0).zj);
((bn1).qn)=(C_([134],((bn0).qn)));
((bn1).qZ)=(C_([129,2],((bn0).qZ)));
((bn1).qW)=(C_([134],((bn0).qW)));
((bn1).qa)=(C_([133,129,2,134],((bn0).qa)));
((bn1).q2)=(C_([129,2],((bn0).q2)));
((bn1).q1)=(C_([134],((bn0).q1)));
((bn1).zJ)=(C_([134],((bn0).zJ)));
((bn1).r7)=((bn0).r7);
((bn1).qe)=((bn0).qe);
return bn1;
}
// _toBin
function bn2(bn3){
let bn4=null;
(bn4)=(new Array(8).fill(0));
(bn4)=((bn4).concat(toBin_((bn3).ah7)));
(bn4)=((bn4).concat(toBin_((bn3).zn)));
(bn4)=((bn4).concat(toBin_((bn3).zj)));
(bn4)=((bn4).concat(toBin_((bn3).qn)));
(bn4)=((bn4).concat(toBin_((bn3).qZ)));
(bn4)=((bn4).concat(toBin_((bn3).qW)));
(bn4)=((bn4).concat(toBin_((bn3).qa)));
(bn4)=((bn4).concat(toBin_((bn3).q2)));
(bn4)=((bn4).concat(toBin_((bn3).q1)));
(bn4)=((bn4).concat(toBin_((bn3).zJ)));
(bn4)=((bn4).concat(toBin_((bn3).r7)));
(bn4)=((bn4).concat(toBin_((bn3).qe)));
return bn4;
}
// _fromBin
function bnH(bnI,bnJ,bnK){
let bnL=null;
(bnL)=(new Qo());
((bnL).ah7)=(fromBin_((bnJ),(bnK.$)));
((bnL).zn)=(fromBin_((bnJ),(bnK.$)));
((bnL).zj)=(fromBin_((bnJ),(bnK.$)));
((bnL).qn)=(fromBin_((bnJ),(bnK.$)));
((bnL).qZ)=(fromBin_((bnJ),(bnK.$)));
((bnL).qW)=(fromBin_((bnJ),(bnK.$)));
((bnL).qa)=(fromBin_((bnJ),(bnK.$)));
((bnL).q2)=(fromBin_((bnJ),(bnK.$)));
((bnL).q1)=(fromBin_((bnJ),(bnK.$)));
((bnL).zJ)=(fromBin_((bnJ),(bnK.$)));
((bnL).r7)=(fromBin_((bnJ),(bnK.$)));
((bnL).qe)=(fromBin_((bnJ),(bnK.$)));
return bnL;
}
// _dtor
function bnM(bnN){
((bnN).zn)=(null);
((bnN).qn)=(null);
((bnN).qZ)=(null);
((bnN).qW)=(null);
((bnN).qa)=(null);
((bnN).q2)=(null);
((bnN).q1)=(null);
((bnN).zJ)=(null);
}
// _copy
function bnO(bnP){
let bnQ=null;
(bnQ)=(new Qr());
((bnQ).ag7)=((bnP).ag7);
((bnQ).zn)=(C_([134],((bnP).zn)));
((bnQ).zj)=((bnP).zj);
((bnQ).qn)=(C_([134],((bnP).qn)));
((bnQ).qZ)=(C_([129,2],((bnP).qZ)));
((bnQ).qW)=(C_([134],((bnP).qW)));
((bnQ).qa)=(C_([133,129,2,134],((bnP).qa)));
((bnQ).q2)=(C_([129,2],((bnP).q2)));
((bnQ).q1)=(C_([134],((bnP).q1)));
((bnQ).zJ)=(C_([134],((bnP).zJ)));
((bnQ).r7)=((bnP).r7);
((bnQ).qe)=((bnP).qe);
return bnQ;
}
// _toBin
function bnR(bnS){
let bnT=null;
(bnT)=(new Array(8).fill(0));
(bnT)=((bnT).concat(toBin_((bnS).ag7)));
(bnT)=((bnT).concat(toBin_((bnS).zn)));
(bnT)=((bnT).concat(toBin_((bnS).zj)));
(bnT)=((bnT).concat(toBin_((bnS).qn)));
(bnT)=((bnT).concat(toBin_((bnS).qZ)));
(bnT)=((bnT).concat(toBin_((bnS).qW)));
(bnT)=((bnT).concat(toBin_((bnS).qa)));
(bnT)=((bnT).concat(toBin_((bnS).q2)));
(bnT)=((bnT).concat(toBin_((bnS).q1)));
(bnT)=((bnT).concat(toBin_((bnS).zJ)));
(bnT)=((bnT).concat(toBin_((bnS).r7)));
(bnT)=((bnT).concat(toBin_((bnS).qe)));
return bnT;
}
// _fromBin
function bog(boh,boi,boj){
let bok=null;
(bok)=(new Qr());
((bok).ag7)=(fromBin_((boi),(boj.$)));
((bok).zn)=(fromBin_((boi),(boj.$)));
((bok).zj)=(fromBin_((boi),(boj.$)));
((bok).qn)=(fromBin_((boi),(boj.$)));
((bok).qZ)=(fromBin_((boi),(boj.$)));
((bok).qW)=(fromBin_((boi),(boj.$)));
((bok).qa)=(fromBin_((boi),(boj.$)));
((bok).q2)=(fromBin_((boi),(boj.$)));
((bok).q1)=(fromBin_((boi),(boj.$)));
((bok).zJ)=(fromBin_((boi),(boj.$)));
((bok).r7)=(fromBin_((boi),(boj.$)));
((bok).qe)=(fromBin_((boi),(boj.$)));
return bok;
}
// _dtor
function bol(bom){
((bom).an3)=(null);
((bom).zn)=(null);
((bom).qn)=(null);
((bom).qZ)=(null);
((bom).qW)=(null);
((bom).qa)=(null);
((bom).q2)=(null);
((bom).q1)=(null);
((bom).zJ)=(null);
}
// _copy
function bon(boo){
let bop=null;
(bop)=(new Qu());
((bop).an3)=(C_([130,134],((boo).an3)));
((bop).zn)=(C_([134],((boo).zn)));
((bop).zj)=((boo).zj);
((bop).qn)=(C_([134],((boo).qn)));
((bop).qZ)=(C_([129,2],((boo).qZ)));
((bop).qW)=(C_([134],((boo).qW)));
((bop).qa)=(C_([133,129,2,134],((boo).qa)));
((bop).q2)=(C_([129,2],((boo).q2)));
((bop).q1)=(C_([134],((boo).q1)));
((bop).zJ)=(C_([134],((boo).zJ)));
((bop).r7)=((boo).r7);
((bop).qe)=((boo).qe);
return bop;
}
// _toBin
function boq(bor){
let bos=null;
(bos)=(new Array(8).fill(0));
(bos)=((bos).concat(toBin_((bor).an3)));
(bos)=((bos).concat(toBin_((bor).zn)));
(bos)=((bos).concat(toBin_((bor).zj)));
(bos)=((bos).concat(toBin_((bor).qn)));
(bos)=((bos).concat(toBin_((bor).qZ)));
(bos)=((bos).concat(toBin_((bor).qW)));
(bos)=((bos).concat(toBin_((bor).qa)));
(bos)=((bos).concat(toBin_((bor).q2)));
(bos)=((bos).concat(toBin_((bor).q1)));
(bos)=((bos).concat(toBin_((bor).zJ)));
(bos)=((bos).concat(toBin_((bor).r7)));
(bos)=((bos).concat(toBin_((bor).qe)));
return bos;
}
// _fromBin
function bo5(bo6,bo7,bo8){
let bo9=null;
(bo9)=(new Qu());
((bo9).an3)=(fromBin_((bo7),(bo8.$)));
((bo9).zn)=(fromBin_((bo7),(bo8.$)));
((bo9).zj)=(fromBin_((bo7),(bo8.$)));
((bo9).qn)=(fromBin_((bo7),(bo8.$)));
((bo9).qZ)=(fromBin_((bo7),(bo8.$)));
((bo9).qW)=(fromBin_((bo7),(bo8.$)));
((bo9).qa)=(fromBin_((bo7),(bo8.$)));
((bo9).q2)=(fromBin_((bo7),(bo8.$)));
((bo9).q1)=(fromBin_((bo7),(bo8.$)));
((bo9).zJ)=(fromBin_((bo7),(bo8.$)));
((bo9).r7)=(fromBin_((bo7),(bo8.$)));
((bo9).qe)=(fromBin_((bo7),(bo8.$)));
return bo9;
}
// _dtor
function boA(boB){
((boB).QC)=(null);
((boB).qn)=(null);
((boB).qZ)=(null);
((boB).qW)=(null);
((boB).qa)=(null);
((boB).q2)=(null);
((boB).q1)=(null);
((boB).zJ)=(null);
}
// _copy
function boC(boD){
let boE=null;
(boE)=(new QA());
((boE).QC)=(C_([134],((boD).QC)));
((boE).qn)=(C_([134],((boD).qn)));
((boE).qZ)=(C_([129,2],((boD).qZ)));
((boE).qW)=(C_([134],((boD).qW)));
((boE).qa)=(C_([133,129,2,134],((boD).qa)));
((boE).q2)=(C_([129,2],((boD).q2)));
((boE).q1)=(C_([134],((boD).q1)));
((boE).zJ)=(C_([134],((boD).zJ)));
((boE).r7)=((boD).r7);
((boE).qe)=((boD).qe);
return boE;
}
// _toBin
function boF(boG){
let boH=null;
(boH)=(new Array(8).fill(0));
(boH)=((boH).concat(toBin_((boG).QC)));
(boH)=((boH).concat(toBin_((boG).qn)));
(boH)=((boH).concat(toBin_((boG).qZ)));
(boH)=((boH).concat(toBin_((boG).qW)));
(boH)=((boH).concat(toBin_((boG).qa)));
(boH)=((boH).concat(toBin_((boG).q2)));
(boH)=((boH).concat(toBin_((boG).q1)));
(boH)=((boH).concat(toBin_((boG).zJ)));
(boH)=((boH).concat(toBin_((boG).r7)));
(boH)=((boH).concat(toBin_((boG).qe)));
return boH;
}
// _fromBin
function boS(boT,boU,boV){
let boW=null;
(boW)=(new QA());
((boW).QC)=(fromBin_((boU),(boV.$)));
((boW).qn)=(fromBin_((boU),(boV.$)));
((boW).qZ)=(fromBin_((boU),(boV.$)));
((boW).qW)=(fromBin_((boU),(boV.$)));
((boW).qa)=(fromBin_((boU),(boV.$)));
((boW).q2)=(fromBin_((boU),(boV.$)));
((boW).q1)=(fromBin_((boU),(boV.$)));
((boW).zJ)=(fromBin_((boU),(boV.$)));
((boW).r7)=(fromBin_((boU),(boV.$)));
((boW).qe)=(fromBin_((boU),(boV.$)));
return boW;
}
// _dtor
function boX(boY){
((boY).qn)=(null);
((boY).qZ)=(null);
((boY).qW)=(null);
((boY).qa)=(null);
((boY).q2)=(null);
((boY).q1)=(null);
((boY).zJ)=(null);
}
// _copy
function boZ(bpa){
let bpb=null;
(bpb)=(new R5());
((bpb).qn)=(C_([134],((bpa).qn)));
((bpb).qZ)=(C_([129,2],((bpa).qZ)));
((bpb).qW)=(C_([134],((bpa).qW)));
((bpb).qa)=(C_([133,129,2,134],((bpa).qa)));
((bpb).q2)=(C_([129,2],((bpa).q2)));
((bpb).q1)=(C_([134],((bpa).q1)));
((bpb).zJ)=(C_([134],((bpa).zJ)));
((bpb).r7)=((bpa).r7);
((bpb).qe)=((bpa).qe);
return bpb;
}
// _toBin
function bpc(bpd){
let bpe=null;
(bpe)=(new Array(8).fill(0));
(bpe)=((bpe).concat(toBin_((bpd).qn)));
(bpe)=((bpe).concat(toBin_((bpd).qZ)));
(bpe)=((bpe).concat(toBin_((bpd).qW)));
(bpe)=((bpe).concat(toBin_((bpd).qa)));
(bpe)=((bpe).concat(toBin_((bpd).q2)));
(bpe)=((bpe).concat(toBin_((bpd).q1)));
(bpe)=((bpe).concat(toBin_((bpd).zJ)));
(bpe)=((bpe).concat(toBin_((bpd).r7)));
(bpe)=((bpe).concat(toBin_((bpd).qe)));
return bpe;
}
// _fromBin
function bpo(bpp,bpq,bpr){
let bps=null;
(bps)=(new R5());
((bps).qn)=(fromBin_((bpq),(bpr.$)));
((bps).qZ)=(fromBin_((bpq),(bpr.$)));
((bps).qW)=(fromBin_((bpq),(bpr.$)));
((bps).qa)=(fromBin_((bpq),(bpr.$)));
((bps).q2)=(fromBin_((bpq),(bpr.$)));
((bps).q1)=(fromBin_((bpq),(bpr.$)));
((bps).zJ)=(fromBin_((bpq),(bpr.$)));
((bps).r7)=(fromBin_((bpq),(bpr.$)));
((bps).qe)=(fromBin_((bpq),(bpr.$)));
return bps;
}
// _dtor
function bpt(bpu){
((bpu).S1)=(null);
((bpu).S2)=(null);
((bpu).qn)=(null);
((bpu).qZ)=(null);
((bpu).qW)=(null);
((bpu).qa)=(null);
((bpu).q2)=(null);
((bpu).q1)=(null);
((bpu).zJ)=(null);
}
// _copy
function bpv(bpw){
let bpx=null;
(bpx)=(new S0());
((bpx).S1)=(C_([134],((bpw).S1)));
((bpx).S2)=(C_([134],((bpw).S2)));
((bpx).qn)=(C_([134],((bpw).qn)));
((bpx).qZ)=(C_([129,2],((bpw).qZ)));
((bpx).qW)=(C_([134],((bpw).qW)));
((bpx).qa)=(C_([133,129,2,134],((bpw).qa)));
((bpx).q2)=(C_([129,2],((bpw).q2)));
((bpx).q1)=(C_([134],((bpw).q1)));
((bpx).zJ)=(C_([134],((bpw).zJ)));
((bpx).r7)=((bpw).r7);
((bpx).qe)=((bpw).qe);
return bpx;
}
// _toBin
function bpy(bpz){
let bp0=null;
(bp0)=(new Array(8).fill(0));
(bp0)=((bp0).concat(toBin_((bpz).S1)));
(bp0)=((bp0).concat(toBin_((bpz).S2)));
(bp0)=((bp0).concat(toBin_((bpz).qn)));
(bp0)=((bp0).concat(toBin_((bpz).qZ)));
(bp0)=((bp0).concat(toBin_((bpz).qW)));
(bp0)=((bp0).concat(toBin_((bpz).qa)));
(bp0)=((bp0).concat(toBin_((bpz).q2)));
(bp0)=((bp0).concat(toBin_((bpz).q1)));
(bp0)=((bp0).concat(toBin_((bpz).zJ)));
(bp0)=((bp0).concat(toBin_((bpz).r7)));
(bp0)=((bp0).concat(toBin_((bpz).qe)));
return bp0;
}
// _fromBin
function bpC(bpD,bpE,bpF){
let bpG=null;
(bpG)=(new S0());
((bpG).S1)=(fromBin_((bpE),(bpF.$)));
((bpG).S2)=(fromBin_((bpE),(bpF.$)));
((bpG).qn)=(fromBin_((bpE),(bpF.$)));
((bpG).qZ)=(fromBin_((bpE),(bpF.$)));
((bpG).qW)=(fromBin_((bpE),(bpF.$)));
((bpG).qa)=(fromBin_((bpE),(bpF.$)));
((bpG).q2)=(fromBin_((bpE),(bpF.$)));
((bpG).q1)=(fromBin_((bpE),(bpF.$)));
((bpG).zJ)=(fromBin_((bpE),(bpF.$)));
((bpG).r7)=(fromBin_((bpE),(bpF.$)));
((bpG).qe)=(fromBin_((bpE),(bpF.$)));
return bpG;
}
// _dtor
function bpH(bpI){
((bpI).SR)=(null);
((bpI).Tf)=(null);
((bpI).qn)=(null);
((bpI).qZ)=(null);
((bpI).qW)=(null);
((bpI).qa)=(null);
((bpI).q2)=(null);
((bpI).q1)=(null);
((bpI).zJ)=(null);
}
// _copy
function bpJ(bpK){
let bpL=null;
(bpL)=(new SP());
((bpL).SR)=(C_([130,134],((bpK).SR)));
((bpL).Tf)=(C_([134],((bpK).Tf)));
((bpL).qn)=(C_([134],((bpK).qn)));
((bpL).qZ)=(C_([129,2],((bpK).qZ)));
((bpL).qW)=(C_([134],((bpK).qW)));
((bpL).qa)=(C_([133,129,2,134],((bpK).qa)));
((bpL).q2)=(C_([129,2],((bpK).q2)));
((bpL).q1)=(C_([134],((bpK).q1)));
((bpL).zJ)=(C_([134],((bpK).zJ)));
((bpL).r7)=((bpK).r7);
((bpL).qe)=((bpK).qe);
return bpL;
}
// _toBin
function bpM(bpN){
let bpO=null;
(bpO)=(new Array(8).fill(0));
(bpO)=((bpO).concat(toBin_((bpN).SR)));
(bpO)=((bpO).concat(toBin_((bpN).Tf)));
(bpO)=((bpO).concat(toBin_((bpN).qn)));
(bpO)=((bpO).concat(toBin_((bpN).qZ)));
(bpO)=((bpO).concat(toBin_((bpN).qW)));
(bpO)=((bpO).concat(toBin_((bpN).qa)));
(bpO)=((bpO).concat(toBin_((bpN).q2)));
(bpO)=((bpO).concat(toBin_((bpN).q1)));
(bpO)=((bpO).concat(toBin_((bpN).zJ)));
(bpO)=((bpO).concat(toBin_((bpN).r7)));
(bpO)=((bpO).concat(toBin_((bpN).qe)));
return bpO;
}
// _fromBin
function bqa(bqb,bqc,bqd){
let bqe=null;
(bqe)=(new SP());
((bqe).SR)=(fromBin_((bqc),(bqd.$)));
((bqe).Tf)=(fromBin_((bqc),(bqd.$)));
((bqe).qn)=(fromBin_((bqc),(bqd.$)));
((bqe).qZ)=(fromBin_((bqc),(bqd.$)));
((bqe).qW)=(fromBin_((bqc),(bqd.$)));
((bqe).qa)=(fromBin_((bqc),(bqd.$)));
((bqe).q2)=(fromBin_((bqc),(bqd.$)));
((bqe).q1)=(fromBin_((bqc),(bqd.$)));
((bqe).zJ)=(fromBin_((bqc),(bqd.$)));
((bqe).r7)=(fromBin_((bqc),(bqd.$)));
((bqe).qe)=(fromBin_((bqc),(bqd.$)));
return bqe;
}
// _dtor
function bqf(bqg){
((bqg).aw8)=(null);
((bqg).qn)=(null);
((bqg).qZ)=(null);
((bqg).qW)=(null);
((bqg).qa)=(null);
((bqg).q2)=(null);
((bqg).q1)=(null);
((bqg).zJ)=(null);
}
// _copy
function bqh(bqi){
let bqj=null;
(bqj)=(new aw7());
((bqj).aw8)=(C_([134],((bqi).aw8)));
((bqj).qn)=(C_([134],((bqi).qn)));
((bqj).qZ)=(C_([129,2],((bqi).qZ)));
((bqj).qW)=(C_([134],((bqi).qW)));
((bqj).qa)=(C_([133,129,2,134],((bqi).qa)));
((bqj).q2)=(C_([129,2],((bqi).q2)));
((bqj).q1)=(C_([134],((bqi).q1)));
((bqj).zJ)=(C_([134],((bqi).zJ)));
((bqj).r7)=((bqi).r7);
((bqj).qe)=((bqi).qe);
return bqj;
}
// _toBin
function bqk(bql){
let bqm=null;
(bqm)=(new Array(8).fill(0));
(bqm)=((bqm).concat(toBin_((bql).aw8)));
(bqm)=((bqm).concat(toBin_((bql).qn)));
(bqm)=((bqm).concat(toBin_((bql).qZ)));
(bqm)=((bqm).concat(toBin_((bql).qW)));
(bqm)=((bqm).concat(toBin_((bql).qa)));
(bqm)=((bqm).concat(toBin_((bql).q2)));
(bqm)=((bqm).concat(toBin_((bql).q1)));
(bqm)=((bqm).concat(toBin_((bql).zJ)));
(bqm)=((bqm).concat(toBin_((bql).r7)));
(bqm)=((bqm).concat(toBin_((bql).qe)));
return bqm;
}
// _fromBin
function bqx(bqy,bqz,bq0){
let bq1=null;
(bq1)=(new aw7());
((bq1).aw8)=(fromBin_((bqz),(bq0.$)));
((bq1).qn)=(fromBin_((bqz),(bq0.$)));
((bq1).qZ)=(fromBin_((bqz),(bq0.$)));
((bq1).qW)=(fromBin_((bqz),(bq0.$)));
((bq1).qa)=(fromBin_((bqz),(bq0.$)));
((bq1).q2)=(fromBin_((bqz),(bq0.$)));
((bq1).q1)=(fromBin_((bqz),(bq0.$)));
((bq1).zJ)=(fromBin_((bqz),(bq0.$)));
((bq1).r7)=(fromBin_((bqz),(bq0.$)));
((bq1).qe)=(fromBin_((bqz),(bq0.$)));
return bq1;
}
// _dtor
function bq2(bq3){
((bq3).awC)=(null);
((bq3).qn)=(null);
((bq3).qZ)=(null);
((bq3).qW)=(null);
((bq3).qa)=(null);
((bq3).q2)=(null);
((bq3).q1)=(null);
((bq3).zJ)=(null);
}
// _copy
function bq4(bq5){
let bq6=null;
(bq6)=(new awB());
((bq6).awC)=(C_([134],((bq5).awC)));
((bq6).qn)=(C_([134],((bq5).qn)));
((bq6).qZ)=(C_([129,2],((bq5).qZ)));
((bq6).qW)=(C_([134],((bq5).qW)));
((bq6).qa)=(C_([133,129,2,134],((bq5).qa)));
((bq6).q2)=(C_([129,2],((bq5).q2)));
((bq6).q1)=(C_([134],((bq5).q1)));
((bq6).zJ)=(C_([134],((bq5).zJ)));
((bq6).r7)=((bq5).r7);
((bq6).qe)=((bq5).qe);
return bq6;
}
// _toBin
function bq7(bq8){
let bq9=null;
(bq9)=(new Array(8).fill(0));
(bq9)=((bq9).concat(toBin_((bq8).awC)));
(bq9)=((bq9).concat(toBin_((bq8).qn)));
(bq9)=((bq9).concat(toBin_((bq8).qZ)));
(bq9)=((bq9).concat(toBin_((bq8).qW)));
(bq9)=((bq9).concat(toBin_((bq8).qa)));
(bq9)=((bq9).concat(toBin_((bq8).q2)));
(bq9)=((bq9).concat(toBin_((bq8).q1)));
(bq9)=((bq9).concat(toBin_((bq8).zJ)));
(bq9)=((bq9).concat(toBin_((bq8).r7)));
(bq9)=((bq9).concat(toBin_((bq8).qe)));
return bq9;
}
// _fromBin
function bqK(bqL,bqM,bqN){
let bqO=null;
(bqO)=(new awB());
((bqO).awC)=(fromBin_((bqM),(bqN.$)));
((bqO).qn)=(fromBin_((bqM),(bqN.$)));
((bqO).qZ)=(fromBin_((bqM),(bqN.$)));
((bqO).qW)=(fromBin_((bqM),(bqN.$)));
((bqO).qa)=(fromBin_((bqM),(bqN.$)));
((bqO).q2)=(fromBin_((bqM),(bqN.$)));
((bqO).q1)=(fromBin_((bqM),(bqN.$)));
((bqO).zJ)=(fromBin_((bqM),(bqN.$)));
((bqO).r7)=(fromBin_((bqM),(bqN.$)));
((bqO).qe)=(fromBin_((bqM),(bqN.$)));
return bqO;
}
// _dtor
function bqP(bqQ){
((bqQ).awF)=(null);
((bqQ).qn)=(null);
((bqQ).qZ)=(null);
((bqQ).qW)=(null);
((bqQ).qa)=(null);
((bqQ).q2)=(null);
((bqQ).q1)=(null);
((bqQ).zJ)=(null);
}
// _copy
function bqR(bqS){
let bqT=null;
(bqT)=(new awE());
((bqT).awF)=(C_([134],((bqS).awF)));
((bqT).qn)=(C_([134],((bqS).qn)));
((bqT).qZ)=(C_([129,2],((bqS).qZ)));
((bqT).qW)=(C_([134],((bqS).qW)));
((bqT).qa)=(C_([133,129,2,134],((bqS).qa)));
((bqT).q2)=(C_([129,2],((bqS).q2)));
((bqT).q1)=(C_([134],((bqS).q1)));
((bqT).zJ)=(C_([134],((bqS).zJ)));
((bqT).r7)=((bqS).r7);
((bqT).qe)=((bqS).qe);
return bqT;
}
// _toBin
function bqU(bqV){
let bqW=null;
(bqW)=(new Array(8).fill(0));
(bqW)=((bqW).concat(toBin_((bqV).awF)));
(bqW)=((bqW).concat(toBin_((bqV).qn)));
(bqW)=((bqW).concat(toBin_((bqV).qZ)));
(bqW)=((bqW).concat(toBin_((bqV).qW)));
(bqW)=((bqW).concat(toBin_((bqV).qa)));
(bqW)=((bqW).concat(toBin_((bqV).q2)));
(bqW)=((bqW).concat(toBin_((bqV).q1)));
(bqW)=((bqW).concat(toBin_((bqV).zJ)));
(bqW)=((bqW).concat(toBin_((bqV).r7)));
(bqW)=((bqW).concat(toBin_((bqV).qe)));
return bqW;
}
// _fromBin
function brh(bri,brj,brk){
let brl=null;
(brl)=(new awE());
((brl).awF)=(fromBin_((brj),(brk.$)));
((brl).qn)=(fromBin_((brj),(brk.$)));
((brl).qZ)=(fromBin_((brj),(brk.$)));
((brl).qW)=(fromBin_((brj),(brk.$)));
((brl).qa)=(fromBin_((brj),(brk.$)));
((brl).q2)=(fromBin_((brj),(brk.$)));
((brl).q1)=(fromBin_((brj),(brk.$)));
((brl).zJ)=(fromBin_((brj),(brk.$)));
((brl).r7)=(fromBin_((brj),(brk.$)));
((brl).qe)=(fromBin_((brj),(brk.$)));
return brl;
}
// _dtor
function brm(brn){
((brn).awI)=(null);
((brn).qn)=(null);
((brn).qZ)=(null);
((brn).qW)=(null);
((brn).qa)=(null);
((brn).q2)=(null);
((brn).q1)=(null);
((brn).zJ)=(null);
}
// _copy
function bro(brp){
let brq=null;
(brq)=(new awH());
((brq).awI)=(C_([134],((brp).awI)));
((brq).qn)=(C_([134],((brp).qn)));
((brq).qZ)=(C_([129,2],((brp).qZ)));
((brq).qW)=(C_([134],((brp).qW)));
((brq).qa)=(C_([133,129,2,134],((brp).qa)));
((brq).q2)=(C_([129,2],((brp).q2)));
((brq).q1)=(C_([134],((brp).q1)));
((brq).zJ)=(C_([134],((brp).zJ)));
((brq).r7)=((brp).r7);
((brq).qe)=((brp).qe);
return brq;
}
// _toBin
function brr(brs){
let brt=null;
(brt)=(new Array(8).fill(0));
(brt)=((brt).concat(toBin_((brs).awI)));
(brt)=((brt).concat(toBin_((brs).qn)));
(brt)=((brt).concat(toBin_((brs).qZ)));
(brt)=((brt).concat(toBin_((brs).qW)));
(brt)=((brt).concat(toBin_((brs).qa)));
(brt)=((brt).concat(toBin_((brs).q2)));
(brt)=((brt).concat(toBin_((brs).q1)));
(brt)=((brt).concat(toBin_((brs).zJ)));
(brt)=((brt).concat(toBin_((brs).r7)));
(brt)=((brt).concat(toBin_((brs).qe)));
return brt;
}
// _fromBin
function br4(br5,br6,br7){
let br8=null;
(br8)=(new awH());
((br8).awI)=(fromBin_((br6),(br7.$)));
((br8).qn)=(fromBin_((br6),(br7.$)));
((br8).qZ)=(fromBin_((br6),(br7.$)));
((br8).qW)=(fromBin_((br6),(br7.$)));
((br8).qa)=(fromBin_((br6),(br7.$)));
((br8).q2)=(fromBin_((br6),(br7.$)));
((br8).q1)=(fromBin_((br6),(br7.$)));
((br8).zJ)=(fromBin_((br6),(br7.$)));
((br8).r7)=(fromBin_((br6),(br7.$)));
((br8).qe)=(fromBin_((br6),(br7.$)));
return br8;
}
// _dtor
function br9(brA){
((brA).awL)=(null);
((brA).qn)=(null);
((brA).qZ)=(null);
((brA).qW)=(null);
((brA).qa)=(null);
((brA).q2)=(null);
((brA).q1)=(null);
((brA).zJ)=(null);
}
// _copy
function brB(brC){
let brD=null;
(brD)=(new awK());
((brD).awL)=(C_([134],((brC).awL)));
((brD).qn)=(C_([134],((brC).qn)));
((brD).qZ)=(C_([129,2],((brC).qZ)));
((brD).qW)=(C_([134],((brC).qW)));
((brD).qa)=(C_([133,129,2,134],((brC).qa)));
((brD).q2)=(C_([129,2],((brC).q2)));
((brD).q1)=(C_([134],((brC).q1)));
((brD).zJ)=(C_([134],((brC).zJ)));
((brD).r7)=((brC).r7);
((brD).qe)=((brC).qe);
return brD;
}
// _toBin
function brE(brF){
let brG=null;
(brG)=(new Array(8).fill(0));
(brG)=((brG).concat(toBin_((brF).awL)));
(brG)=((brG).concat(toBin_((brF).qn)));
(brG)=((brG).concat(toBin_((brF).qZ)));
(brG)=((brG).concat(toBin_((brF).qW)));
(brG)=((brG).concat(toBin_((brF).qa)));
(brG)=((brG).concat(toBin_((brF).q2)));
(brG)=((brG).concat(toBin_((brF).q1)));
(brG)=((brG).concat(toBin_((brF).zJ)));
(brG)=((brG).concat(toBin_((brF).r7)));
(brG)=((brG).concat(toBin_((brF).qe)));
return brG;
}
// _fromBin
function brR(brS,brT,brU){
let brV=null;
(brV)=(new awK());
((brV).awL)=(fromBin_((brT),(brU.$)));
((brV).qn)=(fromBin_((brT),(brU.$)));
((brV).qZ)=(fromBin_((brT),(brU.$)));
((brV).qW)=(fromBin_((brT),(brU.$)));
((brV).qa)=(fromBin_((brT),(brU.$)));
((brV).q2)=(fromBin_((brT),(brU.$)));
((brV).q1)=(fromBin_((brT),(brU.$)));
((brV).zJ)=(fromBin_((brT),(brU.$)));
((brV).r7)=(fromBin_((brT),(brU.$)));
((brV).qe)=(fromBin_((brT),(brU.$)));
return brV;
}
// _dtor
function brW(brX){
((brX).qn)=(null);
((brX).qZ)=(null);
((brX).qW)=(null);
((brX).qa)=(null);
((brX).q2)=(null);
((brX).q1)=(null);
((brX).zJ)=(null);
}
// _copy
function brY(brZ){
let bsa=null;
(bsa)=(new aML());
((bsa).qn)=(C_([134],((brZ).qn)));
((bsa).qZ)=(C_([129,2],((brZ).qZ)));
((bsa).qW)=(C_([134],((brZ).qW)));
((bsa).qa)=(C_([133,129,2,134],((brZ).qa)));
((bsa).q2)=(C_([129,2],((brZ).q2)));
((bsa).q1)=(C_([134],((brZ).q1)));
((bsa).zJ)=(C_([134],((brZ).zJ)));
((bsa).r7)=((brZ).r7);
((bsa).qe)=((brZ).qe);
return bsa;
}
// _toBin
function bsb(bsc){
let bsd=null;
(bsd)=(new Array(8).fill(0));
(bsd)=((bsd).concat(toBin_((bsc).qn)));
(bsd)=((bsd).concat(toBin_((bsc).qZ)));
(bsd)=((bsd).concat(toBin_((bsc).qW)));
(bsd)=((bsd).concat(toBin_((bsc).qa)));
(bsd)=((bsd).concat(toBin_((bsc).q2)));
(bsd)=((bsd).concat(toBin_((bsc).q1)));
(bsd)=((bsd).concat(toBin_((bsc).zJ)));
(bsd)=((bsd).concat(toBin_((bsc).r7)));
(bsd)=((bsd).concat(toBin_((bsc).qe)));
return bsd;
}
// _fromBin
function bsn(bso,bsp,bsq){
let bsr=null;
(bsr)=(new aML());
((bsr).qn)=(fromBin_((bsp),(bsq.$)));
((bsr).qZ)=(fromBin_((bsp),(bsq.$)));
((bsr).qW)=(fromBin_((bsp),(bsq.$)));
((bsr).qa)=(fromBin_((bsp),(bsq.$)));
((bsr).q2)=(fromBin_((bsp),(bsq.$)));
((bsr).q1)=(fromBin_((bsp),(bsq.$)));
((bsr).zJ)=(fromBin_((bsp),(bsq.$)));
((bsr).r7)=(fromBin_((bsp),(bsq.$)));
((bsr).qe)=(fromBin_((bsp),(bsq.$)));
return bsr;
}
// addr
function aQf(bss /*class_*/){
}
// _signInt
function aR1(bst /*me_*/){
return ((bst)>(0))?(1):(((bst)<(0))?(-1):(0));
}
function C_(t,v){
switch(t[0]){
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
return v;
case 129:
if(t[1]===2)
return v===null?null:{S:v.S};
else{
let a=new Array(v.length);
for(let i=0;i<v.length;i++)a[i]=C_(t.slice(1),v[i]);
return a;
}
case 130:
case 131:
case 132:
case 133:
case 134:
}
}
function F_(p){
if(p==="res/analyze.kn")
return "var asts: dict<[]char, \\ast@Ast>\n\n+func analyze(asts: dict<[]char, \\ast@Ast>): \\ast@AstFunc\n\u0009do @asts :: asts\n\u0009\n\u0009var mainFunc: \\ast@AstFunc :: @searchMain()\n\u0009if(mainFunc =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009do asts.forEach(@resolveIdentifier, null)\n\u0009ret @rebuild(mainFunc)\nend func\n\n+func searchMain(): \\ast@AstFunc\n\u0009var ast: \\ast@Ast :: @asts.get(\"\\\\\" ~ \\option@inputName, &)\n\u0009if(ast =& null)\n\u0009\u0009do \\err@err(%noMainFunc, null, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009var mainFunc: \\ast@Ast :: ast.scopeChildren.get(\"main\", &)\n\u0009if(mainFunc =& null | mainFunc.typeId <> %func_)\n\u0009\u0009do \\err@err(%noMainFunc, null, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009var mainFunc2: \\ast@AstFunc :: mainFunc $ \\ast@AstFunc\n\u0009if(^mainFunc2.args <> 0 | mainFunc2.ret_ <>& null | mainFunc2.funcOption <> %none | ^mainFunc2.funcAttr <> 0)\n\u0009\u0009do \\err@err(%wrongMainFunc, mainFunc2.pos, null)\n\u0009end if\n\u0009ret mainFunc2\nend func\n\nfunc resolveIdentifier(key: []char, value: \\ast@Ast, data: kuin@Class): bool\n\u0009assert value =$ \\ast@AstRoot\n\u0009var scopeRefedItems: list<\\ast@ScopeRefedItem> :: (value $ \\ast@AstRoot).scopeRefedItems\n\u0009\n\u0009; Search scopes for identifiers and resolve references.\n\u0009do scopeRefedItems.head()\n\u0009while(!scopeRefedItems.term())\n\u0009\u0009var item: \\ast@ScopeRefedItem :: scopeRefedItems.get()\n\u0009\u0009var ast: \\ast@Ast :: item.def\n\u0009\u0009assert ast.refItem =& null {Must not resolve references that have been already resolved.}\n\u0009\u0009assert ast.refName <>& null\n\u0009\u0009var otherFile: bool :: false\n\u0009\u0009var ptrAt: int :: ast.refName.find(\'@\', -1)\n\u0009\u0009var ptrName: []char :: ptrAt = -1 ?(ast.refName, ast.refName.sub(ptrAt + 1, -1))\n\u0009\u0009var foundAst: \\ast@Ast :: null\n\u0009\u0009if(ptrAt <> -1)\n\u0009\u0009\u0009; Search the root of the source.\n\u0009\u0009\u0009var ptrSrc: []char {The source name before \'@\'.}\n\u0009\u0009\u0009if(ptrAt = 0)\n\u0009\u0009\u0009\u0009do ptrSrc :: key\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do ptrSrc :: ast.refName.sub(0, ptrAt)\n\u0009\u0009\u0009\u0009if(ptrSrc = key)\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%nonOmittingAt, ast.pos, [ptrSrc])\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do otherFile :: true\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009var ast2: \\ast@Ast :: @asts.get(ptrSrc, &)\n\u0009\u0009\u0009if(ast2 <>& null)\n\u0009\u0009\u0009\u0009do foundAst :: ast2.scopeChildren.get(ptrName, &)\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009; Search from the current scope toward its parent\'s scope.\n\u0009\u0009\u0009var scope: \\ast@Ast :: item.scope\n\u0009\u0009\u0009var overFunc: bool :: false\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009if(scope.scopeParent =& null)\n\u0009\u0009\u0009\u0009\u0009break loop {No more parent scope exists.}\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(scope.name <>& null & scope.name = ptrName)\n\u0009\u0009\u0009\u0009\u0009if(scope.typeId = %func_ & scope.refName <>& null)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%accessMemberWithoutMe, ast.pos, [ptrName])\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009; The compiler also looks at the current scope\'s name.\n\u0009\u0009\u0009\u0009\u0009\u0009do foundAst :: scope\n\u0009\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009var ast2: \\ast@Ast :: scope.scopeChildren.get(ptrName, &)\n\u0009\u0009\u0009\u0009if(ast2 <>& null)\n\u0009\u0009\u0009\u0009\u0009var err: bool :: false\n\u0009\u0009\u0009\u0009\u0009if(overFunc)\n\u0009\u0009\u0009\u0009\u0009\u0009if(ast2.typeId = %arg)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var kind: \\ast@AstArgKind :: (ast2 $ \\ast@AstArg).kind\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(kind = %member | kind = %localVar | kind = %localArg)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do err :: true\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009if(!err & ast2.typeId.and(%statBreakable) = %statBreakable)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do err :: true\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(!err & ast2.typeId = %func_ & ast2.refName <>& null)\n\u0009\u0009\u0009\u0009\u0009\u0009do err :: true\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(err)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%accessMemberWithoutMe, ast.pos, [ptrName])\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do foundAst :: ast2\n\u0009\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(scope.typeId = %func_)\n\u0009\u0009\u0009\u0009\u0009do overFunc :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do scope :: scope.scopeParent\n\u0009\u0009\u0009end while\n\u0009\u0009end if\n\u0009\u0009if(foundAst <>& null)\n\u0009\u0009\u0009if(otherFile & !foundAst.publicInSrc)\n\u0009\u0009\u0009\u0009do \\err@err(%accessUnpublishedElement, ast.pos, [ast.refName])\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.refItem :: foundAst\n\u0009\u0009else\n\u0009\u0009\u0009do \\err@err(%identifierNotFound, ast.pos, [ast.refName])\n\u0009\u0009\u0009do ast.refItem :: null\n\u0009\u0009end if\n\u0009\u0009do scopeRefedItems.next()\n\u0009end while\n\u0009ret true\nend func\n\nfunc rebuild(mainFunc: \\ast@AstFunc): \\ast@AstFunc\n\u0009var entry: \\ast@AstFunc\n\u0009\n\u0009; Build the entry point and register it in the root.\n\u0009block\n\u0009\u0009do entry :: @makeEntryPoint(mainFunc)\n\u0009\u0009do @rebuildFunc(entry)\n\u0009\u0009var root: \\ast@Ast :: @asts.get(\"\\\\\" ~ \\option@inputName, &)\n\u0009\u0009assert root =$ \\ast@AstRoot\n\u0009\u0009do(root $ \\ast@AstRoot).items.add(entry)\n\u0009end block\n\u0009\n\u0009do @asts.forEach(@rebuildRoot, null)\n\u0009\n\u0009ret entry\nend func\n\nfunc makeEntryPoint(mainFunc: \\ast@AstFunc): \\ast@AstFunc\n\u0009var pos: \\pos@Pos :: \\pos@make(\"kuin\", 1, 1)\n\u0009var entry: \\ast@AstFunc :: #\\ast@AstFunc\n\u0009do @initAst(entry, %func_, pos)\n\u0009do entry.name :: \"$\"\n\u0009do entry.funcOption :: %none\n\u0009do entry.funcAttr :: #list<[]char>\n\u0009do entry.args :: #list<\\ast@AstArg>\n\u0009do entry.ret_ :: null\n\u0009do entry.stats :: #list<\\ast@AstStat>\n\u0009block\n\u0009\u0009var try_: \\ast@AstStatTry :: #\\ast@AstStatTry\n\u0009\u0009do @initAst(try_, %statTry, pos)\n\u0009\u0009block\n\u0009\u0009\u0009var var_: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009do @initAst(var_, %arg, pos)\n\u0009\u0009\u0009do var_.name :: \"$\"\n\u0009\u0009\u0009do var_.kind :: %localVar\n\u0009\u0009\u0009do var_.refVar :: false\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, pos)\n\u0009\u0009\u0009\u0009do type.kind :: %int_\n\u0009\u0009\u0009\u0009do var_.type :: type\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do var_.expr :: null\n\u0009\u0009\u0009do try_.blockVar :: var_\n\u0009\u0009end block\n\u0009\u0009block\n\u0009\u0009\u0009var block_: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009\u0009\u0009do @initAst(block_, %statBlock, pos)\n\u0009\u0009\u0009do block_.name :: \"$\"\n\u0009\u0009\u0009do block_.blockVar :: null\n\u0009\u0009\u0009do block_.stats :: #list<\\ast@AstStat>\n\u0009\u0009\u0009do try_.statBlock :: block_\n\u0009\u0009end block\n\u0009\u0009do try_.catches :: #list<\\ast@AstStatCatch>\n\u0009\u0009block\n\u0009\u0009\u0009var block_: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009\u0009\u0009do @initAst(block_, %statBlock, pos)\n\u0009\u0009\u0009do block_.name :: \"$\"\n\u0009\u0009\u0009do block_.blockVar :: null\n\u0009\u0009\u0009do block_.stats :: #list<\\ast@AstStat>\n\u0009\u0009\u0009do try_.finallyStatBlock :: block_\n\u0009\u0009end block\n\u0009\u0009block\n\u0009\u0009\u0009; Make the program to call \'init\' and \'main\'.\n\u0009\u0009\u0009var funcs: list<\\ast@Ast> :: #list<\\ast@Ast>\n\u0009\u0009\u0009do funcs.add(@searchStdItem(\"kuin\", \"_init\", false))\n\u0009\u0009\u0009do funcs.add(@searchStdItem(\"kuin\", \"_initVars\", false))\n\u0009\u0009\u0009do funcs.add(mainFunc)\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009do funcs.head()\n\u0009\u0009\u0009\u0009while(!funcs.term())\n\u0009\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, pos)\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var call: \\ast@AstExprCall :: #\\ast@AstExprCall\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(call, %exprCall, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do call.args :: #list<\\ast@AstExprCallArg>\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref, %exprRef, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ref.refItem :: funcs.get()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do call.func_ :: ref\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do do_.expr :: call\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do try_.statBlock.stats.add(do_)\n\u0009\u0009\u0009\u0009\u0009do funcs.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end block\n\u0009\u0009end block\n\u0009\u0009block\n\u0009\u0009\u0009var catch_: \\ast@AstStatCatch :: #\\ast@AstStatCatch\n\u0009\u0009\u0009do @initAst(catch_, %statCatch, pos)\n\u0009\u0009\u0009do catch_.conds :: #list<\\ast@ExprPair>\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var block_: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009\u0009\u0009\u0009do @initAst(block_, %statBlock, pos)\n\u0009\u0009\u0009\u0009do block_.name :: \"$\"\n\u0009\u0009\u0009\u0009do block_.blockVar :: null\n\u0009\u0009\u0009\u0009do block_.stats :: #list<\\ast@AstStat>\n\u0009\u0009\u0009\u0009do catch_.statBlock :: block_\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: #\\ast@ExprPair\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, pos)\n\u0009\u0009\u0009\u0009\u0009do expr.varKind :: %value\n\u0009\u0009\u0009\u0009\u0009do expr.value :: 0b64\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.kind :: %int_\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do exprs.expr0 :: expr\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, pos)\n\u0009\u0009\u0009\u0009\u0009do expr.varKind :: %value\n\u0009\u0009\u0009\u0009\u0009do expr.value :: 0xFFFFFFFFb64\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.kind :: %int_\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do exprs.expr1 :: expr\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do catch_.conds.add(exprs)\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009; Make the program to call \'err\'.\n\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var call: \\ast@AstExprCall :: #\\ast@AstExprCall\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(call, %exprCall, pos)\n\u0009\u0009\u0009\u0009\u0009do call.args :: #list<\\ast@AstExprCallArg>\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var ref_: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref_, %exprRef, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do ref_.refItem :: @searchStdItem(\"kuin\", \"_err\", false)\n\u0009\u0009\u0009\u0009\u0009\u0009do call.func_ :: ref_\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var excpt: \\ast@AstExprCallArg :: #\\ast@AstExprCallArg\n\u0009\u0009\u0009\u0009\u0009\u0009do excpt.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009do excpt.skipVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var ref_: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref_, %exprRef, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ref_.refItem :: try_.blockVar\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do excpt.arg :: ref_\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do call.args.add(excpt)\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do do_.expr :: call\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do catch_.statBlock.stats.add(do_)\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do try_.catches.add(catch_)\n\u0009\u0009end block\n\u0009\u0009block\n\u0009\u0009\u0009; Make the program to call \'fin\'.\n\u0009\u0009\u0009var funcs: list<\\ast@Ast> :: #list<\\ast@Ast>\n\u0009\u0009\u0009do funcs.add(@searchStdItem(\"kuin\", \"_finVars\", false))\n\u0009\u0009\u0009do funcs.add(@searchStdItem(\"kuin\", \"_fin\", false))\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009do funcs.head()\n\u0009\u0009\u0009\u0009while(!funcs.term())\n\u0009\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, pos)\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var call: \\ast@AstExprCall :: #\\ast@AstExprCall\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(call, %exprCall, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do call.args :: #list<\\ast@AstExprCallArg>\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref, %exprRef, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ref.refItem :: funcs.get()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do call.func_ :: ref\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do do_.expr :: call\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do try_.finallyStatBlock.stats.add(do_)\n\u0009\u0009\u0009\u0009\u0009do funcs.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end block\n\u0009\u0009end block\n\u0009\u0009do entry.stats.add(try_)\n\u0009end block\n\u0009ret entry\nend func\n\nfunc rebuildRoot(key: []char, value: \\ast@Ast, data: kuin@Class): bool\n\u0009var ast: \\ast@AstRoot :: value $ \\ast@AstRoot\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret true\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009; Initialize and finalize global variables of each source file.\n\u0009var initVarsFunc: \\ast@AstFunc :: @searchStdItem(\"kuin\", \"_initVars\", false) $ \\ast@AstFunc\n\u0009var finVarsFunc: \\ast@AstFunc :: @searchStdItem(\"kuin\", \"_finVars\", false) $ \\ast@AstFunc\n\u0009var items: list<\\ast@Ast> :: ast.items\n\u0009do items.head()\n\u0009while(!items.term())\n\u0009\u0009var item: \\ast@Ast :: items.get()\n\u0009\u0009if(item.typeId = %func_)\n\u0009\u0009\u0009do @rebuildFunc(item $ \\ast@AstFunc)\n\u0009\u0009elif(item.typeId = %var_)\n\u0009\u0009\u0009var var_: \\ast@AstVar :: item $ \\ast@AstVar\n\u0009\u0009\u0009assert var_.arg.kind = %global\n\u0009\u0009\u0009if(var_.arg.expr <>& null)\n\u0009\u0009\u0009\u0009; Add initialization processing of global variables to \'_initVars\'.\n\u0009\u0009\u0009\u0009do var_.arg.expr :: @rebuildExpr(var_.arg.expr, false)\n\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var assign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(assign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do assign.kind :: %assign\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do ref.type :: var_.arg.type\n\u0009\u0009\u0009\u0009\u0009\u0009do ref.refItem :: var_.arg\n\u0009\u0009\u0009\u0009\u0009\u0009do assign.children0 :: ref\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do assign.children1 :: var_.arg.expr\n\u0009\u0009\u0009\u0009\u0009do do_.expr :: assign\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do initVarsFunc.stats.add(@rebuildStat(do_, null, null))\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(var_.arg.type <>& null & \\ast@isRef(var_.arg.type))\n\u0009\u0009\u0009\u0009; Add finalization processing of global variables to \'_finVars\'.\n\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var assign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(assign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do assign.kind :: %assign\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do ref.type :: var_.arg.type\n\u0009\u0009\u0009\u0009\u0009\u0009do ref.refItem :: var_.arg\n\u0009\u0009\u0009\u0009\u0009\u0009do assign.children0 :: ref\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do assign.children1 :: @makeExprNull(ast.pos)\n\u0009\u0009\u0009\u0009\u0009do do_.expr :: assign\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do finVarsFunc.stats.add(@rebuildStat(do_, null, null))\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009assert item.typeId = %const_ | item.typeId = %alias_ | item.typeId = %class_ | item.typeId = %enum_\n\u0009\u0009end if\n\u0009\u0009do items.next()\n\u0009end while\n\u0009ret true\nend func\n\nfunc rebuildFunc(ast: \\ast@AstFunc)\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009var items: list<\\ast@AstArg> :: ast.args\n\u0009do items.head()\n\u0009while(!items.term())\n\u0009\u0009do @rebuildArg(items.get())\n\u0009\u0009do items.next()\n\u0009end while\n\u0009\n\u0009if(ast.ret_ <>& null)\n\u0009\u0009do ast.ret_ :: @rebuildType(ast.ret_, null)\n\u0009end if\n\u0009do ast.stats :: @refreshStats(ast.stats, ast.ret_, ast)\nend func\n\nfunc rebuildVar(ast: \\ast@AstVar)\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do @rebuildArg(ast.arg)\nend func\n\nfunc rebuildAlias(ast: \\ast@AstAlias, parent: \\ast@AstAlias)\n\u0009; Make sure that the enum references do not circulate.\n\u0009if(ast = parent)\n\u0009\u0009do \\err@err(%circulatingAlias, parent.pos, [parent.name])\n\u0009\u0009do ast.type :: null\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.type :: @rebuildType(ast.type, ast)\nend func\n\nfunc rebuildClass(ast: \\ast@AstClass)\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009var dtor: \\ast@AstFunc :: null\n\u0009var copy: \\ast@AstFunc :: null\n\u0009var toBin: \\ast@AstFunc :: null\n\u0009var fromBin: \\ast@AstFunc :: null\n\u0009do process1(ast, &dtor, &copy, &toBin, &fromBin)\n\u0009do process2(ast, dtor, copy, toBin, fromBin)\n\u0009do @rebuildFunc(dtor)\n\u0009do @rebuildFunc(copy)\n\u0009do @rebuildFunc(toBin)\n\u0009do @rebuildFunc(fromBin)\n\u0009\n\u0009func process1(ast: \\ast@AstClass, dtor: &\\ast@AstFunc, copy: &\\ast@AstFunc, toBin: &\\ast@AstFunc, fromBin: &\\ast@AstFunc)\n\u0009\u0009if(ast.refItem <>& null)\n\u0009\u0009\u0009var parent: \\ast@Ast :: ast.refItem\n\u0009\u0009\u0009if(parent.typeId = %alias_)\n\u0009\u0009\u0009\u0009do @rebuildAlias(parent $ \\ast@AstAlias, null)\n\u0009\u0009\u0009\u0009do ast.refItem :: (parent $ \\ast@AstAlias).type.refItem\n\u0009\u0009\u0009\u0009assert ast.refItem.typeId = %class_\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009assert parent.typeId = %class_\n\u0009\u0009\u0009\u0009do @rebuildClass(parent $ \\ast@AstClass)\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009block\n\u0009\u0009\u0009; Make sure that the class references do not circulate.\n\u0009\u0009\u0009var parent: \\ast@AstClass :: ast\n\u0009\u0009\u0009var chk: dict<\\ast@AstClass, bool> :: #dict<\\ast@AstClass, bool>\n\u0009\u0009\u0009while(parent <>& null)\n\u0009\u0009\u0009\u0009if(chk.get(parent, &))\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%circulatingClass, ast.pos, [ast.name])\n\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do chk.add(parent, true)\n\u0009\u0009\u0009\u0009do parent :: parent.refItem $ \\ast@AstClass\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009\n\u0009\u0009block\n\u0009\u0009\u0009var astItems: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009\u0009do astItems.head()\n\u0009\u0009\u0009while(!astItems.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: astItems.get()\n\u0009\u0009\u0009\u0009var memberName: []char\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var def: \\ast@Ast :: item.def\n\u0009\u0009\u0009\u0009\u0009if(def.typeId = %var_)\n\u0009\u0009\u0009\u0009\u0009\u0009do memberName :: (def $ \\ast@AstVar).arg.name\n\u0009\u0009\u0009\u0009\u0009elif(def.typeId = %const_)\n\u0009\u0009\u0009\u0009\u0009\u0009do memberName :: (def $ \\ast@AstConst).arg.name\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do memberName :: def.name\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009; Check whether functions are overriding another.\n\u0009\u0009\u0009\u0009var parentItem: \\ast@AstClassItem :: null\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var parent: \\ast@AstClass :: ast.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009\u0009while(parentItem =& null & parent <>& null)\n\u0009\u0009\u0009\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: parent.items\n\u0009\u0009\u0009\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var parentName: []char\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var item2: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var def: \\ast@Ast :: item2.def\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(def.typeId = %var_)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do parentName :: (def $ \\ast@AstVar).arg.name\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009elif(def.typeId = %const_)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do parentName :: (def $ \\ast@AstConst).arg.name\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do parentName :: def.name\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(memberName = parentName)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do parentItem :: item2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009\u0009do parent :: parent.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009if(parentItem =& null)\n\u0009\u0009\u0009\u0009\u0009if(item.override)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%overridedMemberNotFound, item.def.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009if(!item.override)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%memberDuplicatedWithParentClass, item.def.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(!(item.def.typeId = %func_ & parentItem.def.typeId = %func_))\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%overridingNonFunc, item.def.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(item.public <> parentItem.public)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%overriddenMemberNotMatchAccessModifier, item.def.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009var func1: \\ast@AstFunc :: item.def $ \\ast@AstFunc\n\u0009\u0009\u0009\u0009\u0009var func2: \\ast@AstFunc :: parentItem.def $ \\ast@AstFunc\n\u0009\u0009\u0009\u0009\u0009if(func1.ret_ =& null & func2.ret_ <>& null |\n\u0009\u0009\u0009\u0009\u0009\u0009|func1.ret_ <>& null & func2.ret_ =& null |\n\u0009\u0009\u0009\u0009\u0009\u0009|func1.ret_ <>& null & func2.ret_ <>& null & !@cmpType(func1.ret_, func2.ret_, false) |\n\u0009\u0009\u0009\u0009\u0009\u0009|^func1.args <> ^func2.args)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%overriddenMemberNotMatchTypeOrArg, item.def.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009var items1: list<\\ast@AstArg> :: func1.args\n\u0009\u0009\u0009\u0009\u0009var items2: list<\\ast@AstArg> :: func2.args\n\u0009\u0009\u0009\u0009\u0009do items1.head()\n\u0009\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009\u0009for i(0, ^items1 - 1)\n\u0009\u0009\u0009\u0009\u0009\u0009var arg1: \\ast@AstArg :: items1.get()\n\u0009\u0009\u0009\u0009\u0009\u0009var arg2: \\ast@AstArg :: items2.get()\n\u0009\u0009\u0009\u0009\u0009\u0009if(arg1.type.typeId = %typeUser & arg1.type.refItem =& null |\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009|arg2.type.typeId = %typeUser & arg2.type.refItem =& null |\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009|!@cmpType(arg1.type, arg2.type, false) |\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009|arg1.name <>& null & arg2.name <>& null & arg1.name <> arg2.name |\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009|arg1.refVar <> arg2.refVar)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%overriddenMemberNotMatchTypeOrArg, item.def.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do items1.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009\u0009end for\n\u0009\u0009\u0009\u0009\u0009do item.parentItem :: parentItem\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009switch(memberName)\n\u0009\u0009\u0009\u0009case \"_dtor\", \"_copy\", \"_toBin\", \"_fromBin\"\n\u0009\u0009\u0009\u0009\u0009assert item.def.typeId = %func_\n\u0009\u0009\u0009\u0009\u0009var func_: \\ast@AstFunc :: item.def $ \\ast@AstFunc\n\u0009\u0009\u0009\u0009\u0009if(item.override & (item.def $ \\ast@AstFunc).funcOption.and(%frc) = %none)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%notAllowedToBeOverridden, func_.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009switch(memberName[1])\n\u0009\u0009\u0009\u0009\u0009case \'d\'\n\u0009\u0009\u0009\u0009\u0009\u0009do dtor :: func_\n\u0009\u0009\u0009\u0009\u0009case \'c\'\n\u0009\u0009\u0009\u0009\u0009\u0009do copy :: func_\n\u0009\u0009\u0009\u0009\u0009case \'t\'\n\u0009\u0009\u0009\u0009\u0009\u0009do toBin :: func_\n\u0009\u0009\u0009\u0009\u0009case \'f\'\n\u0009\u0009\u0009\u0009\u0009\u0009do fromBin :: func_\n\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009; Skip \'RebuildFunc\' to add the contents later.\n\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009; Analyze functions and variables in classes because they can be referred to as instances.\n\u0009\u0009\u0009\u0009\u0009var def: \\ast@Ast :: item.def\n\u0009\u0009\u0009\u0009\u0009if(def.typeId = %func_)\n\u0009\u0009\u0009\u0009\u0009\u0009var idx: int :: astItems.idx()\n\u0009\u0009\u0009\u0009\u0009\u0009assert idx <> -1\n\u0009\u0009\u0009\u0009\u0009\u0009do @rebuildFunc(def $ \\ast@AstFunc)\n\u0009\u0009\u0009\u0009\u0009\u0009do astItems.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do astItems.moveOffset(idx)\n\u0009\u0009\u0009\u0009\u0009elif(def.typeId = %var_)\n\u0009\u0009\u0009\u0009\u0009\u0009do @rebuildVar(def $ \\ast@AstVar)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009do astItems.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009\n\u0009\u0009\u0009; Get \'me\' of special functions.\n\u0009\u0009\u0009if(dtor =& null)\n\u0009\u0009\u0009\u0009do dtor :: @addSpecialFunc(ast, \"_dtor\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(copy =& null)\n\u0009\u0009\u0009\u0009do copy :: @addSpecialFunc(ast, \"_copy\")\n\u0009\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009\u0009do @initAst(type, %typeUser, ast.pos)\n\u0009\u0009\u0009\u0009do type.refItem :: ast\n\u0009\u0009\u0009\u0009do copy.ret_ :: type\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(toBin =& null)\n\u0009\u0009\u0009\u0009do toBin :: @addSpecialFunc(ast, \"_toBin\")\n\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var type2: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009\u0009\u0009\u0009do @initAst(type2, %typeBit, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do type2.size :: 1\n\u0009\u0009\u0009\u0009\u0009do type.itemType :: type2\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do toBin.ret_ :: type\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(fromBin =& null)\n\u0009\u0009\u0009\u0009do fromBin :: @addSpecialFunc(ast, \"_fromBin\")\n\u0009\u0009\u0009\u0009; \'bin\'.\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009\u0009\u0009do @initAst(arg, %arg, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do arg.kind :: %localArg\n\u0009\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009\u0009do arg.expr :: null\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var type2: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type2, %typeBit, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type2.size :: 1\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type.itemType :: type2\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do fromBin.args.add(arg)\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009; \'idx\'.\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009\u0009\u0009do @initAst(arg, %arg, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do arg.kind :: %localArg\n\u0009\u0009\u0009\u0009\u0009do arg.refVar :: true\n\u0009\u0009\u0009\u0009\u0009do arg.expr :: null\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.kind :: %int_\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do fromBin.args.add(arg)\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do fromBin.args.head()\n\u0009\u0009\u0009\u0009do fromBin.ret_ :: fromBin.args.get().type\n\u0009\u0009\u0009end if\n\u0009\u0009end block\n\u0009end func\n\u0009\n\u0009func process2(ast: \\ast@AstClass, dtor: \\ast@AstFunc, copy: \\ast@AstFunc, toBin: \\ast@AstFunc, fromBin: \\ast@AstFunc)\n\u0009\u0009; The \'_dtor\' function.\n\u0009\u0009block\n\u0009\u0009\u0009var ptr: \\ast@AstClass :: ast\n\u0009\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: ptr.items\n\u0009\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009\u0009if(item.def.typeId = %var_ & \\ast@isRef((item.def $ \\ast@AstVar).arg.type))\n\u0009\u0009\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var assign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(assign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.kind :: %assign\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dtor.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children0 :: @makeMeDot(ast, dtor.args.get(), (item.def $ \\ast@AstVar).arg.name)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children1 :: @makeExprNull(ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do do_.expr :: assign\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do dtor.stats.add(@rebuildStat(do_, dtor.ret_, dtor))\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009\n\u0009\u0009; The \'_copy\' function.\n\u0009\u0009block\n\u0009\u0009\u0009var result: \\ast@AstExpr\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var var_: \\ast@AstStatVar :: #\\ast@AstStatVar\n\u0009\u0009\u0009\u0009do @initAst(var_, %statVar, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var var2: \\ast@AstVar :: #\\ast@AstVar\n\u0009\u0009\u0009\u0009\u0009do @initAst(var2, %var_, ast.pos)\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(arg, %arg, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.kind :: %localVar\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeUser, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type.refItem :: ast\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.type :: type\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var new_: \\ast@AstExprNew :: #\\ast@AstExprNew\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(new_, %exprNew, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do new_.itemType :: arg.type\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.expr :: new_\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do var2.arg :: arg\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do var_.def :: var2\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do copy.stats.add(@rebuildStat(var_, copy.ret_, copy))\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009do result :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(result, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do result.refName :: \"me\"\n\u0009\u0009\u0009\u0009\u0009do result.refItem :: var_.def.arg\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeUser, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.refItem :: ast\n\u0009\u0009\u0009\u0009\u0009\u0009do result.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var ptr: \\ast@AstClass :: ast\n\u0009\u0009\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: ptr.items\n\u0009\u0009\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009\u0009\u0009if(item.def.typeId = %var_)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var member: \\ast@AstArg :: (item.def $ \\ast@AstVar).arg\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var assign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(assign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.kind :: %assign\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var dot: \\ast@AstExprDot :: #\\ast@AstExprDot\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(dot, %exprDot, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.var_ :: result\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.member :: member.name\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.classItem :: null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children0 :: dot\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(\\ast@isRef(member.type))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var copy2: \\ast@AstExpr1 :: #\\ast@AstExpr1\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(copy2, %expr1, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do copy2.kind :: %copy\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do copy.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do copy2.child :: @makeMeDot(ast, copy.args.get(), member.name)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children1 :: copy2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do copy.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children1 :: @makeMeDot(ast, copy.args.get(), member.name)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do do_.expr :: assign\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do copy.stats.add(@rebuildStat(do_, copy.ret_, copy))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var ret_: \\ast@AstStatRet :: #\\ast@AstStatRet\n\u0009\u0009\u0009\u0009do @initAst(ret_, %statRet, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var as: \\ast@AstExprAs :: #\\ast@AstExprAs\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(as, %exprAs, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do as.kind :: %as\n\u0009\u0009\u0009\u0009\u0009do as.child :: result\n\u0009\u0009\u0009\u0009\u0009do as.childType :: copy.ret_\n\u0009\u0009\u0009\u0009\u0009do ret_.value :: as\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do copy.stats.add(@rebuildStat(ret_, copy.ret_, copy))\n\u0009\u0009\u0009end block\n\u0009\u0009end block\n\u0009\u0009\n\u0009\u0009; The \'_toBin\' function.\n\u0009\u0009block\n\u0009\u0009\u0009var result: \\ast@AstExpr\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var var_: \\ast@AstStatVar :: #\\ast@AstStatVar\n\u0009\u0009\u0009\u0009do @initAst(var_, %statVar, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var var2: \\ast@AstVar :: #\\ast@AstVar\n\u0009\u0009\u0009\u0009\u0009do @initAst(var2, %var_, ast.pos)\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(arg, %arg, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.kind :: %localVar\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var new_: \\ast@AstExprNewArray :: #\\ast@AstExprNewArray\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(new_, %exprNewArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do new_.idces :: #list<\\ast@AstExpr>\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var value: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(value, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value.value :: 8b64\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var prim: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(prim, %typePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do prim.kind :: %int_\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value.type :: prim\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do new_.idces.add(value)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeBit, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type.size :: 1\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do new_.itemType :: type\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.expr :: new_\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var type2: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type2, %typeBit, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type2.size :: 1\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type.itemType :: type2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.type :: type\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do var2.arg :: arg\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do var_.def :: var2\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do toBin.stats.add(@rebuildStat(var_, toBin.ret_, toBin))\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009do result :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(result, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do result.refItem :: var_.def.arg\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeUser, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.refItem :: ast\n\u0009\u0009\u0009\u0009\u0009\u0009do result.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var ptr: \\ast@AstClass :: ast\n\u0009\u0009\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: ptr.items\n\u0009\u0009\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009\u0009\u0009if(item.def.typeId = %var_)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var member: \\ast@AstArg :: (item.def $ \\ast@AstVar).arg\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var assign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(assign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.kind :: %assignCat\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children0 :: result\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprToBin :: #\\ast@AstExprToBin\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprToBin, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do toBin.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.child :: @makeMeDot(ast, toBin.args.get(), member.name)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var array_: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(array_, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var bit: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(bit, %typeBit, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do bit.size :: 1\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do array_.itemType :: bit\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.childType :: array_\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children1 :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do do_.expr :: assign\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do toBin.stats.add(@rebuildStat(do_, toBin.ret_, toBin))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var ret_: \\ast@AstStatRet :: #\\ast@AstStatRet\n\u0009\u0009\u0009\u0009do @initAst(ret_, %statRet, ast.pos)\n\u0009\u0009\u0009\u0009do ret_.value :: result\n\u0009\u0009\u0009\u0009do toBin.stats.add(@rebuildStat(ret_, toBin.ret_, toBin))\n\u0009\u0009\u0009end block\n\u0009\u0009end block\n\u0009\u0009\n\u0009\u0009; The \'_fromBin\' function.\n\u0009\u0009block\n\u0009\u0009\u0009var result: \\ast@AstExpr\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var var_: \\ast@AstStatVar :: #\\ast@AstStatVar\n\u0009\u0009\u0009\u0009do @initAst(var_, %statVar, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var var2: \\ast@AstVar :: #\\ast@AstVar\n\u0009\u0009\u0009\u0009\u0009do @initAst(var2, %var_, ast.pos)\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(arg, %arg, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.kind :: %localVar\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.type :: fromBin.args.get().type\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var new_: \\ast@AstExprNew :: #\\ast@AstExprNew\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(new_, %exprNew, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do new_.itemType :: arg.type\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.expr :: new_\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do var2.arg :: arg\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do var_.def :: var2\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do fromBin.stats.add(@rebuildStat(var_, fromBin.ret_, fromBin))\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009do result :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(result, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do result.refItem :: var_.def.arg\n\u0009\u0009\u0009\u0009\u0009do result.refName :: \"me\" {In fact, the referenced member name is not \'me\', but it needs to be set to \'me\' to access private members.}\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeUser, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.refItem :: ast\n\u0009\u0009\u0009\u0009\u0009\u0009do result.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var ptr: \\ast@AstClass :: ast\n\u0009\u0009\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: ptr.items\n\u0009\u0009\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009\u0009\u0009if(item.def.typeId = %var_)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var member: \\ast@AstArg :: (item.def $ \\ast@AstVar).arg\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var assign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(assign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.kind :: %assign\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var dot: \\ast@AstExprDot :: #\\ast@AstExprDot\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(dot, %exprDot, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.classItem :: null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.var_ :: result\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.member :: member.name\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children0 :: dot\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprFromBin :: #\\ast@AstExprFromBin\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprFromBin, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ref.refItem :: fromBin.args.get()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert ref.refItem <>& null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.child :: ref\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.childType :: member.type\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ref.refItem :: fromBin.args.get()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert ref.refItem <>& null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.offset :: ref\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children1 :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do do_.expr :: assign\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.stats.add(@rebuildStat(do_, fromBin.ret_, fromBin))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var ret_: \\ast@AstStatRet :: #\\ast@AstStatRet\n\u0009\u0009\u0009\u0009do @initAst(ret_, %statRet, ast.pos)\n\u0009\u0009\u0009\u0009do ret_.value :: result\n\u0009\u0009\u0009\u0009do fromBin.stats.add(@rebuildStat(ret_, fromBin.ret_, fromBin))\n\u0009\u0009\u0009end block\n\u0009\u0009end block\n\u0009end func\nend func\n\nfunc rebuildEnum(ast: \\ast@AstEnum)\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009do @initAst(type, %typeUser, ast.pos)\n\u0009do type.extra :: type\n\u0009do type.refItem :: ast\n\u0009\n\u0009; Assign values to items.\n\u0009var defaultNum: int :: -1\n\u0009var enumValues: dict<int, bool> :: #dict<int, bool>\n\u0009var items: list<\\ast@AstExpr> :: ast.items\n\u0009do items.head()\n\u0009while loop(!items.term())\n\u0009\u0009var item: \\ast@AstExpr :: items.get()\n\u0009\u0009var itemName: []char :: item.name\n\u0009\u0009do item :: @rebuildExpr(item, item.type =& null)\n\u0009\u0009if(item =& null)\n\u0009\u0009\u0009skip loop\n\u0009\u0009end if\n\u0009\u0009do item.name :: itemName\n\u0009\u0009do items.ins(item)\n\u0009\u0009do items.del()\n\u0009\u0009if(item.typeId <> %exprValuePrim | item.type <>& null & !\\ast@isInt(item.type))\n\u0009\u0009\u0009do \\err@err(%enumValueMustBeInt, ast.pos, [ast.name, item.name])\n\u0009\u0009\u0009ret\n\u0009\u0009end if\n\u0009\u0009var item2: \\ast@AstExprValuePrim :: item $ \\ast@AstExprValuePrim\n\u0009\u0009if(item.type =& null)\n\u0009\u0009\u0009; \'type\' is \'null\' when the value is not set.\n\u0009\u0009\u0009if(defaultNum = lib@intMax)\n\u0009\u0009\u0009\u0009do \\err@err(%enumValueExceedIntRange, ast.pos, [ast.name, item.name])\n\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do defaultNum :+ 1\n\u0009\u0009\u0009do item2.value :: defaultNum $ bit64\n\u0009\u0009else\n\u0009\u0009\u0009do defaultNum :: item2.value $ int\n\u0009\u0009end if\n\u0009\u0009block\n\u0009\u0009\u0009var value: int :: item2.value $ int\n\u0009\u0009\u0009if(enumValues.get(value, &))\n\u0009\u0009\u0009\u0009do \\err@err(%enumValueDuplicated, ast.pos, [ast.name, item.name, value.toStr()])\n\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do enumValues.add(value, true)\n\u0009\u0009end block\n\u0009\u0009do item.type :: type {Cast values of \'int\' to \'enum\' so as not to being treated as \'int\'.}\n\u0009\u0009; The item was already deleted so do not do \'do items.next()\'.\n\u0009end while\nend func\n\nfunc rebuildEnumElement(enumElement: \\ast@AstExpr, type: \\ast@AstType): \\ast@AstExprValuePrim\n\u0009assert enumElement.typeId = %exprValueEnumElement\n\u0009assert \\ast@isEnum(type)\n\u0009var enumElement2: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009do @initAstExpr(enumElement2, %exprValuePrim, enumElement.pos)\n\u0009do enumElement2.value :: @searchEnumElementValue(enumElement $ \\ast@AstExprValueEnumElement, type.refItem $ \\ast@AstEnum)\n\u0009do enumElement2.type :: type\n\u0009do enumElement2 :: @rebuildExprValuePrim(enumElement2) $ \\ast@AstExprValuePrim\n\u0009ret enumElement2\nend func\n\nfunc rebuildArg(ast: \\ast@AstArg)\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.type :: @rebuildType(ast.type, null)\n\u0009if(ast.expr <>& null)\n\u0009\u0009do ast.expr :: @rebuildExpr(ast.expr, false)\n\u0009\u0009if(ast.expr =& null)\n\u0009\u0009\u0009ret\n\u0009\u0009end if\n\u0009\u0009if(ast.kind = %global & ast.expr.typeId.and(%exprValue) <> %exprValue)\n\u0009\u0009\u0009do \\err@err(%valueOfGlobalVarMustBeConst, ast.pos, [ast.name])\n\u0009\u0009end if\n\u0009\u0009if(ast.kind = %const_ & ast.expr.typeId.and(%exprValue) <> %exprValue)\n\u0009\u0009\u0009do \\err@err(%valueOfConstMustBeConst, ast.pos, [ast.name])\n\u0009\u0009end if\n\u0009\u0009if(!@cmpType(ast.expr.type, ast.type, false))\n\u0009\u0009\u0009do \\err@err(%varAndValueTypeNotMatch, ast.pos, [ast.name])\n\u0009\u0009elif(ast.expr.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009do ast.expr :: @rebuildEnumElement(ast.expr, ast.type)\n\u0009\u0009end if\n\u0009end if\nend func\n\nfunc rebuildStat(ast: \\ast@AstStat, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009switch(ast.typeId)\n\u0009case %statFunc, %statConst, %statAlias, %statClass, %statEnum\n\u0009\u0009ret null\n\u0009case %statVar\n\u0009\u0009var ast2: \\ast@AstStatVar :: ast $ \\ast@AstStatVar\n\u0009\u0009do @rebuildVar(ast2.def)\n\u0009\u0009var arg: \\ast@AstArg :: ast2.def.arg\n\u0009\u0009if(arg.name <>& null & arg.name = \"super\")\n\u0009\u0009\u0009assert parentFunc <>& null & parentFunc.name <>& null\n\u0009\u0009\u0009assert arg.type.typeId = %typeFunc\n\u0009\u0009\u0009var args: list<\\ast@AstTypeFuncArg> :: (arg.type $ \\ast@AstTypeFunc).args\n\u0009\u0009\u0009do args.head()\n\u0009\u0009\u0009var refClass: \\ast@AstClass :: args.get().arg.refItem $ \\ast@AstClass\n\u0009\u0009\u0009assert refClass.typeId = %class_\n\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: refClass.items\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while loop(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009if(item.def.name <>& null & item.def.name = parentFunc.name)\n\u0009\u0009\u0009\u0009\u0009assert item.override\n\u0009\u0009\u0009\u0009\u0009var astRef: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(astRef, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do astRef.refItem :: item.parentItem.def\n\u0009\u0009\u0009\u0009\u0009do arg.expr :: astRef\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009assert !items.term()\n\u0009\u0009end if\n\u0009\u0009if(arg.expr =& null)\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009block\n\u0009\u0009\u0009; Replace initializers with assignment operators.\n\u0009\u0009\u0009var astDo: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009do @initAst(astDo, %statDo, ast.pos)\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var astAssign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009do @initAstExpr(astAssign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009do astAssign.kind :: %assign\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var astRef: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(astRef, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do astRef.refItem :: arg\n\u0009\u0009\u0009\u0009\u0009do astAssign.children0 :: astRef\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do astAssign.children1 :: arg.expr\n\u0009\u0009\u0009\u0009do astDo.expr :: astAssign\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do arg.expr :: null\n\u0009\u0009\u0009do ast :: @rebuildStat(astDo, retType, parentFunc)\n\u0009\u0009end block\n\u0009case %statIf\n\u0009\u0009do ast :: @rebuildIf(ast $ \\ast@AstStatIf, retType, parentFunc)\n\u0009case %statSwitch\n\u0009\u0009do ast :: @rebuildSwitch(ast $ \\ast@AstStatSwitch, retType, parentFunc)\n\u0009case %statWhile\n\u0009\u0009do ast :: @rebuildWhile(ast $ \\ast@AstStatWhile, retType, parentFunc)\n\u0009case %statFor\n\u0009\u0009do ast :: @rebuildFor(ast $ \\ast@AstStatFor, retType, parentFunc)\n\u0009case %statTry\n\u0009\u0009do ast :: @rebuildTry(ast $ \\ast@AstStatTry, retType, parentFunc)\n\u0009case %statThrow\n\u0009\u0009do ast :: @rebuildThrow(ast $ \\ast@AstStatThrow)\n\u0009case %statBlock\n\u0009\u0009do ast :: @rebuildBlock(ast $ \\ast@AstStatBlock, retType, parentFunc)\n\u0009case %statRet\n\u0009\u0009do ast :: @rebuildRet(ast $ \\ast@AstStatRet, retType)\n\u0009case %statDo\n\u0009\u0009do ast :: @rebuildDo(ast $ \\ast@AstStatDo)\n\u0009case %statBreak\n\u0009\u0009do ast :: @rebuildBreak(ast $ \\ast@AstStat, retType, parentFunc)\n\u0009case %statSkip\n\u0009\u0009do ast :: @rebuildSkip(ast $ \\ast@AstStat, retType, parentFunc)\n\u0009case %statAssert\n\u0009\u0009do ast :: @rebuildAssert(ast $ \\ast@AstStatAssert)\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\n\u0009if(ast =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009assert ast.extra <>& null\n\u0009ret ast\nend func\n\nfunc rebuildIf(ast: \\ast@AstStatIf, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.cond :: @rebuildExpr(ast.cond, false)\n\u0009if(ast.cond <>& null & !\\ast@isBool(ast.cond.type))\n\u0009\u0009do \\err@err(%ifCondMustBeBool, ast.cond.pos, null)\n\u0009end if\n\u0009do ast.statBlock :: @rebuildBlock(ast.statBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009block\n\u0009\u0009var items: list<\\ast@AstStatElIf> :: ast.elIfs\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var elIf: \\ast@AstStatElIf :: items.get()\n\u0009\u0009\u0009do elIf.cond :: @rebuildExpr(elIf.cond, false)\n\u0009\u0009\u0009if(elIf.cond <>& null & !\\ast@isBool(elIf.cond.type))\n\u0009\u0009\u0009\u0009do \\err@err(%elIfCondMustBeBool, elIf.cond.pos, null)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do elIf.statBlock :: @rebuildBlock(elIf.statBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009if(ast.elseStatBlock <>& null)\n\u0009\u0009do ast.elseStatBlock :: @rebuildBlock(ast.elseStatBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009end if\n\u0009if(ast.cond <>& null)\n\u0009\u0009; Optimize the code.\n\u0009\u0009var stats: \\ast@AstStatBlock :: null\n\u0009\u0009if(ast.cond.typeId <> %exprValuePrim)\n\u0009\u0009\u0009ret ast\n\u0009\u0009end if\n\u0009\u0009if((ast.cond $ \\ast@AstExprValuePrim).value <> 0b64)\n\u0009\u0009\u0009do stats :: ast.statBlock\n\u0009\u0009end if\n\u0009\u0009if(stats <>& null)\n\u0009\u0009\u0009var items: list<\\ast@AstStatElIf> :: ast.elIfs\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while loop(!items.term())\n\u0009\u0009\u0009\u0009var elIf: \\ast@AstStatElIf :: items.get()\n\u0009\u0009\u0009\u0009if(elIf.cond.typeId <> %exprValuePrim)\n\u0009\u0009\u0009\u0009\u0009ret ast\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if((elIf.cond $ \\ast@AstExprValuePrim).value <> 0b64)\n\u0009\u0009\u0009\u0009\u0009do stats :: elIf.statBlock\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009if(stats =& null)\n\u0009\u0009\u0009\u0009if(ast.elseStatBlock =& null)\n\u0009\u0009\u0009\u0009\u0009var block_: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009\u0009\u0009\u0009\u0009do @initAst(block_, %statBlock, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do block_.name :: \"$\"\n\u0009\u0009\u0009\u0009\u0009do block_.stats :: #list<\\ast@AstStat>\n\u0009\u0009\u0009\u0009\u0009do stats :: block_\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do stats :: ast.elseStatBlock\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009do ast.cond :: null\n\u0009\u0009do ast.statBlock :: stats\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildSwitch(ast: \\ast@AstStatSwitch, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.cond :: @rebuildExpr(ast.cond, false)\n\u0009if(ast.cond <>& null)\n\u0009\u0009if(!@isComparable(ast.cond.type, true))\n\u0009\u0009\u0009do \\err@err(%switchCondMustBeComparable, ast.cond.pos, null)\n\u0009\u0009end if\n\u0009\u0009do ast.blockVar.type :: ast.cond.type\n\u0009end if\n\u0009block\n\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var case_: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: case_.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009do exprs.expr0 :: @rebuildExpr(exprs.expr0, false)\n\u0009\u0009\u0009\u0009if(ast.cond <>& null & exprs.expr0 <>& null)\n\u0009\u0009\u0009\u0009\u0009if(!@cmpType(ast.cond.type, exprs.expr0.type, false))\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%caseCondNotMatchSwitch, exprs.expr0.pos, null)\n\u0009\u0009\u0009\u0009\u0009elif(exprs.expr0.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009do exprs.expr0 :: @rebuildEnumElement(exprs.expr0, ast.cond.type)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(exprs.expr1 <>& null)\n\u0009\u0009\u0009\u0009\u0009do exprs.expr1 :: @rebuildExpr(exprs.expr1, false)\n\u0009\u0009\u0009\u0009\u0009if(ast.cond <>& null & exprs.expr1 <>& null)\n\u0009\u0009\u0009\u0009\u0009\u0009if(!@cmpType(ast.cond.type, exprs.expr1.type, false))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%caseCondNotMatchSwitch, exprs.expr1.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009elif(exprs.expr1.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do exprs.expr1 :: @rebuildEnumElement(exprs.expr1, ast.cond.type)\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do case_.statBlock :: @rebuildBlock(case_.statBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009if(ast.defaultStatBlock <>& null)\n\u0009\u0009do ast.defaultStatBlock :: @rebuildBlock(ast.defaultStatBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildWhile(ast: \\ast@AstStatWhile, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009if(ast.cond <>& null)\n\u0009\u0009do ast.cond :: @rebuildExpr(ast.cond, false)\n\u0009\u0009if(ast.cond <>& null & !\\ast@isBool(ast.cond.type))\n\u0009\u0009\u0009do \\err@err(%whileCondMustBeBool, ast.cond.pos, null)\n\u0009\u0009end if\n\u0009end if\n\u0009do ast.stats :: @refreshStats(ast.stats, retType, parentFunc)\n\u0009ret ast\nend func\n\nfunc rebuildFor(ast: \\ast@AstStatFor, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.start :: @rebuildExpr(ast.start, false)\n\u0009if(ast.start <>& null)\n\u0009\u0009if(!\\ast@isInt(ast.start.type))\n\u0009\u0009\u0009do \\err@err(%forBeginValueMustBeInt, ast.start.pos, null)\n\u0009\u0009end if\n\u0009\u0009do ast.blockVar.type :: ast.start.type\n\u0009end if\n\u0009do ast.cond :: @rebuildExpr(ast.cond, false)\n\u0009if(ast.cond <>& null & !\\ast@isInt(ast.cond.type))\n\u0009\u0009do \\err@err(%forEndValueMustBeInt, ast.cond.pos, null)\n\u0009end if\n\u0009do ast.step :: @rebuildExpr(ast.step, false)\n\u0009if(ast.step <>& null)\n\u0009\u0009if(!\\ast@isInt(ast.step.type))\n\u0009\u0009\u0009do \\err@err(%forIncreaseDecreaseValueMustBeInt, ast.step.pos, null)\n\u0009\u0009end if\n\u0009\u0009if(ast.step.typeId <> %exprValuePrim)\n\u0009\u0009\u0009do \\err@err(%forIncreaseDecreaseValueMustBeConst, ast.step.pos, null)\n\u0009\u0009end if\n\u0009\u0009if((ast.step $ \\ast@AstExprValuePrim).value = 0b64)\n\u0009\u0009\u0009do \\err@err(%forIncreaseDecreaseValueMustBeOtherThanZero, ast.step.pos, null)\n\u0009\u0009end if\n\u0009end if\n\u0009do ast.stats :: @refreshStats(ast.stats, retType, parentFunc)\n\u0009ret ast\nend func\n\nfunc rebuildTry(ast: \\ast@AstStatTry, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do @rebuildArg(ast.blockVar)\n\u0009do ast.statBlock :: @rebuildBlock(ast.statBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009if(^ast.catches <> 0)\n\u0009\u0009var items: list<\\ast@AstStatCatch> :: ast.catches\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var catch_: \\ast@AstStatCatch :: items.get()\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: catch_.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009do exprs.expr0 :: @rebuildExpr(exprs.expr0, false)\n\u0009\u0009\u0009\u0009if(exprs.expr0 <>& null & (!\\ast@isInt(exprs.expr0.type) | exprs.expr0.typeId <> %exprValuePrim))\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%catchCondMustBeConstInt, exprs.expr0.pos, null)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(exprs.expr1 <>& null)\n\u0009\u0009\u0009\u0009\u0009do exprs.expr1 :: @rebuildExpr(exprs.expr1, false)\n\u0009\u0009\u0009\u0009\u0009if(exprs.expr1 <>& null & (!\\ast@isInt(exprs.expr1.type) | exprs.expr1.typeId <> %exprValuePrim))\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%catchCondMustBeConstInt, exprs.expr1.pos, null)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do catch_.statBlock :: @rebuildBlock(catch_.statBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end if\n\u0009if(ast.finallyStatBlock <>& null)\n\u0009\u0009do ast.finallyStatBlock :: @rebuildBlock(ast.finallyStatBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildThrow(ast: \\ast@AstStatThrow): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.code :: @rebuildExpr(ast.code, false)\n\u0009if(ast.code <>& null & !\\ast@isInt(ast.code.type))\n\u0009\u0009do \\err@err(%excptCodeMustBeInt, ast.code.pos, null)\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildBlock(ast: \\ast@AstStatBlock, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.stats :: @refreshStats(ast.stats, retType, parentFunc)\n\u0009ret ast\nend func\n\nfunc rebuildRet(ast: \\ast@AstStatRet, retType: \\ast@AstType): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009if(ast.value =& null)\n\u0009\u0009if(retType <>& null)\n\u0009\u0009\u0009do \\err@err(%mustRetValue, ast.pos, null)\n\u0009\u0009end if\n\u0009else\n\u0009\u0009do ast.value :: @rebuildExpr(ast.value, false)\n\u0009\u0009if(ast.value <>& null)\n\u0009\u0009\u0009if(retType =& null | !@cmpType(ast.value.type, retType, false))\n\u0009\u0009\u0009\u0009do \\err@err(%retTypeNotMatchFunc, ast.pos, null)\n\u0009\u0009\u0009elif(ast.value.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009do ast.value :: @rebuildEnumElement(ast.value, retType)\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildDo(ast: \\ast@AstStatDo): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009if(ast.expr <>& null & ast.expr.typeId = %expr2)\n\u0009\u0009; Replace all assignment operators that are not \'::\' with \'::\'\n\u0009\u0009var expr: \\ast@AstExpr2 :: ast.expr $ \\ast@AstExpr2\n\u0009\u0009var kind: \\ast@AstExpr2Kind :: %assign\n\u0009\u0009switch(expr.kind)\n\u0009\u0009case %assignAdd\n\u0009\u0009\u0009do kind :: %add\n\u0009\u0009case %assignSub\n\u0009\u0009\u0009do kind :: %sub\n\u0009\u0009case %assignMul\n\u0009\u0009\u0009do kind :: %mul\n\u0009\u0009case %assignDiv\n\u0009\u0009\u0009do kind :: %div\n\u0009\u0009case %assignMod\n\u0009\u0009\u0009do kind :: %mod\n\u0009\u0009case %assignPow\n\u0009\u0009\u0009do kind :: %pow\n\u0009\u0009case %assignCat\n\u0009\u0009\u0009do kind :: %cat\n\u0009\u0009end switch\n\u0009\u0009if(kind <> %assign)\n\u0009\u0009\u0009var block_: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009\u0009\u0009do @initAst(block_, %statBlock, ast.pos)\n\u0009\u0009\u0009do block_.extra :: block_\n\u0009\u0009\u0009do block_.name :: \"$\"\n\u0009\u0009\u0009do block_.blockVar :: null\n\u0009\u0009\u0009do block_.stats :: #list<\\ast@AstStat>\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var lhs: \\ast@AstExpr :: @rebuildExpr(expr.children0, false)\n\u0009\u0009\u0009\u0009if(lhs =& null)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(lhs.typeId = %exprDot)\n\u0009\u0009\u0009\u0009\u0009var lhs2: \\ast@AstExprDot :: lhs $ \\ast@AstExprDot\n\u0009\u0009\u0009\u0009\u0009do lhs2.var_ :: @cacheSubExpr(block_.stats, lhs2.var_, ast.pos)\n\u0009\u0009\u0009\u0009elif(lhs.typeId = %exprArray)\n\u0009\u0009\u0009\u0009\u0009var lhs2: \\ast@AstExprArray :: lhs $ \\ast@AstExprArray\n\u0009\u0009\u0009\u0009\u0009do lhs2.var_ :: @cacheSubExpr(block_.stats, lhs2.var_, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do lhs2.idx :: @cacheSubExpr(block_.stats, lhs2.idx, ast.pos)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009var exprAssign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009do @initAstExpr(exprAssign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009do exprAssign.kind :: %assign\n\u0009\u0009\u0009\u0009do exprAssign.children0 :: lhs\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var exprOne: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(exprOne, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do exprOne.kind :: kind\n\u0009\u0009\u0009\u0009\u0009do exprOne.children0 :: lhs\n\u0009\u0009\u0009\u0009\u0009do exprOne.children1 :: expr.children1\n\u0009\u0009\u0009\u0009\u0009do exprAssign.children1 :: exprOne\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do ast.expr :: @rebuildExpr(exprAssign, true)\n\u0009\u0009\u0009\u0009do block_.stats.add(ast)\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009ret block_\n\u0009\u0009end if\n\u0009end if\n\u0009do ast.expr :: @rebuildExpr(ast.expr, true)\n\u0009if(ast.expr =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009; \'do\' needs to end with side effects.\n\u0009if(!(ast.expr.typeId = %expr2 & ((ast.expr $ \\ast@AstExpr2).kind = %assign | (ast.expr $ \\ast@AstExpr2).kind = %swap) | ast.expr.typeId = %exprCall))\n\u0009\u0009do \\err@err(%noSideEffectDo, ast.expr.pos, null)\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildBreak(ast: \\ast@AstStat, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009if(ast.refItem =& null | ast.refItem.typeId.and(%statBreakable) <> %statBreakable)\n\u0009\u0009do \\err@err(%mustSpecifyBlockName, ast.pos, [\"break\"])\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.refItem :: @rebuildStat(ast.refItem $ \\ast@AstStat, retType, parentFunc)\n\u0009ret ast\nend func\n\nfunc rebuildSkip(ast: \\ast@AstStat, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009if(ast.refItem =& null | ast.refItem.typeId.and(%statBreakable) <> %statBreakable)\n\u0009\u0009do \\err@err(%mustSpecifyBlockName, ast.pos, [\"skip\"])\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.refItem :: @rebuildStat(ast.refItem $ \\ast@AstStat, retType, parentFunc)\n\u0009ret ast\nend func\n\nfunc rebuildAssert(ast: \\ast@AstStatAssert): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009\n\u0009if(\\option@rls)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009do ast.cond :: @rebuildExpr(ast.cond, false)\n\u0009if(ast.cond <>& null & !\\ast@isBool(ast.cond.type))\n\u0009\u0009do \\err@err(%assertCondMustBeBool, ast.cond.pos, null)\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildType(ast: \\ast@AstType, parentAlias: \\ast@AstAlias): \\ast@AstType\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstType\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009var type: \\ast@TypeId :: ast.typeId\n\u0009switch(type)\n\u0009case %typeUser\n\u0009\u0009var refItem: \\ast@Ast :: ast.refItem\n\u0009\u0009if(refItem =& null)\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009switch(refItem.typeId)\n\u0009\u0009case %class_\n\u0009\u0009\u0009do @rebuildClass(refItem $ \\ast@AstClass)\n\u0009\u0009case %enum_\n\u0009\u0009\u0009do @rebuildEnum(refItem $ \\ast@AstEnum)\n\u0009\u0009case %alias_\n\u0009\u0009\u0009do @rebuildAlias(refItem $ \\ast@AstAlias, parentAlias)\n\u0009\u0009\u0009do ast.extra :: (refItem $ \\ast@AstAlias).type\n\u0009\u0009\u0009do ast :: (refItem $ \\ast@AstAlias).type\n\u0009\u0009default\n\u0009\u0009\u0009do \\err@err(%nonTypeWritten, ast.pos, null)\n\u0009\u0009\u0009ret null\n\u0009\u0009end switch\n\u0009case %typeArray\n\u0009\u0009do(ast $ \\ast@AstTypeArray).itemType :: @rebuildType((ast $ \\ast@AstTypeArray).itemType, parentAlias)\n\u0009case %typeFunc\n\u0009\u0009var ast2: \\ast@AstTypeFunc :: ast $ \\ast@AstTypeFunc\n\u0009\u0009var items: list<\\ast@AstTypeFuncArg> :: ast2.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var arg: \\ast@AstTypeFuncArg :: items.get()\n\u0009\u0009\u0009do arg.arg :: @rebuildType(arg.arg, parentAlias)\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009if(ast2.ret_ <>& null)\n\u0009\u0009\u0009do ast2.ret_ :: @rebuildType(ast2.ret_, parentAlias)\n\u0009\u0009end if\n\u0009case %typeGen\n\u0009\u0009do(ast $ \\ast@AstTypeGen).itemType :: @rebuildType((ast $ \\ast@AstTypeGen).itemType, parentAlias)\n\u0009case %typeDict\n\u0009\u0009var ast2: \\ast@AstTypeDict :: ast $ \\ast@AstTypeDict\n\u0009\u0009do ast2.itemTypeKey :: @rebuildType(ast2.itemTypeKey, parentAlias)\n\u0009\u0009do ast2.itemTypeValue :: @rebuildType(ast2.itemTypeValue, parentAlias)\n\u0009default\n\u0009\u0009assert type = %none {Error}|type = %typeBit | type = %typePrim | type = %typeNull\n\u0009end switch\n\u0009ret ast\nend func\n\nfunc rebuildExpr(ast: \\ast@AstExpr, nullable: bool): \\ast@AstExpr\n\u0009if(ast =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009switch(ast.typeId)\n\u0009case %none\n\u0009\u0009ret null\n\u0009case %expr1\n\u0009\u0009do ast :: @rebuildExpr1(ast $ \\ast@AstExpr1)\n\u0009case %expr2\n\u0009\u0009do ast :: @rebuildExpr2(ast $ \\ast@AstExpr2)\n\u0009case %expr3\n\u0009\u0009do ast :: @rebuildExpr3(ast $ \\ast@AstExpr3)\n\u0009case %exprNew\n\u0009\u0009do ast :: @rebuildExprNew(ast $ \\ast@AstExprNew)\n\u0009case %exprNewArray\n\u0009\u0009do ast :: @rebuildExprNewArray(ast $ \\ast@AstExprNewArray)\n\u0009case %exprAs\n\u0009\u0009do ast :: @rebuildExprAs(ast $ \\ast@AstExprAs)\n\u0009case %exprToBin\n\u0009\u0009do ast :: @rebuildExprToBin(ast $ \\ast@AstExprToBin)\n\u0009case %exprFromBin\n\u0009\u0009do ast :: @rebuildExprFromBin(ast $ \\ast@AstExprFromBin)\n\u0009case %exprCall\n\u0009\u0009do ast :: @rebuildExprCall(ast $ \\ast@AstExprCall)\n\u0009case %exprArray\n\u0009\u0009do ast :: @rebuildExprArray(ast $ \\ast@AstExprArray)\n\u0009case %exprDot\n\u0009\u0009do ast :: @rebuildExprDot(ast $ \\ast@AstExprDot)\n\u0009case %exprValue\n\u0009\u0009do ast :: @rebuildExprValue(ast $ \\ast@AstExprValue)\n\u0009case %exprValuePrim\n\u0009\u0009do ast :: @rebuildExprValuePrim(ast $ \\ast@AstExprValuePrim)\n\u0009case %exprValueStr\n\u0009\u0009do ast :: @rebuildExprValueStr(ast $ \\ast@AstExprValueStr)\n\u0009case %exprValueEnumElement\n\u0009\u0009do ast :: @rebuildExprValueEnumElement(ast $ \\ast@AstExprValueEnumElement)\n\u0009case %exprValueFloat\n\u0009\u0009do ast :: @rebuildExprValueFloat(ast $ \\ast@AstExprValueFloat)\n\u0009case %exprValueArray\n\u0009\u0009do ast :: @rebuildExprValueArray(ast $ \\ast@AstExprValueArray)\n\u0009case %exprRef\n\u0009\u0009do ast :: @rebuildExprRef(ast)\n\u0009end switch\n\u0009if(ast =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(!nullable & ast.type =& null)\n\u0009\u0009; \'type\' is null, for example, when calling a function whose return value is \'void\'.\n\u0009\u0009do \\err@err(%noValuePassed, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildExpr1(ast: \\ast@AstExpr1): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.child :: @rebuildExpr(ast.child, false)\n\u0009if(ast.child =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009assert ast.type =& null\n\u0009var childType: \\ast@AstType :: ast.child.type\n\u0009switch(ast.kind)\n\u0009case %plus\n\u0009\u0009if(\\ast@isInt(childType) | \\ast@isFloat(childType) | childType.typeId = %typeBit)\n\u0009\u0009\u0009if(ast.child.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009do ast.extra :: ast.child\n\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.type :: childType\n\u0009\u0009end if\n\u0009case %minus\n\u0009\u0009if(\\ast@isInt(childType) | \\ast@isFloat(childType))\n\u0009\u0009\u0009if(ast.child.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009if(\\ast@isInt(childType))\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do expr.type :: childType\n\u0009\u0009\u0009\u0009\u0009do expr.value :: (-((ast.child $ \\ast@AstExprValuePrim).value $ int)) $ bit64\n\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009assert \\ast@isFloat(childType)\n\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValueFloat :: #\\ast@AstExprValueFloat\n\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValueFloat, ast.pos)\n\u0009\u0009\u0009\u0009do expr.type :: childType\n\u0009\u0009\u0009\u0009do expr.value :: -(ast.child $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009do expr :: @rebuildExprValueFloat(expr) $ \\ast@AstExprValueFloat\n\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.type :: childType\n\u0009\u0009end if\n\u0009case %not\n\u0009\u0009if(\\ast@isBool(childType))\n\u0009\u0009\u0009if(ast.child.typeId = %exprValuePrim)\n\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009do expr.type :: childType\n\u0009\u0009\u0009\u0009do expr.value :: (ast.child $ \\ast@AstExprValuePrim).value <> 0b64 ?(0b64, 1b64)\n\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.type :: childType\n\u0009\u0009end if\n\u0009case %copy\n\u0009\u0009if(\\ast@isClass(childType) | childType.typeId = %typeArray | childType.typeId = %typeGen | childType.typeId = %typeDict)\n\u0009\u0009\u0009do ast.type :: childType\n\u0009\u0009end if\n\u0009case %len\n\u0009\u0009if(childType.typeId = %typeArray | childType.typeId = %typeGen | childType.typeId = %typeDict)\n\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009do @initAst(type, %typePrim, ast.pos)\n\u0009\u0009\u0009do type.kind :: %int_\n\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009end if\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\n\u0009if(ast.type =& null)\n\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExpr2(ast: \\ast@AstExpr2): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.children0 :: @rebuildExpr(ast.children0, false)\n\u0009if(ast.children0 =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.children1 :: @rebuildExpr(ast.children1, false)\n\u0009if(ast.children1 =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(!@cmpType(ast.children1.type, ast.children0.type, false))\n\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009block\n\u0009\u0009var correct: bool :: false\n\u0009\u0009switch(ast.kind)\n\u0009\u0009case %assign\n\u0009\u0009\u0009if(ast.children0.varKind = %value)\n\u0009\u0009\u0009\u0009do \\err@err(%wrongLeftValueOfAssignOperator, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(\\ast@isClass(ast.children0.type) & \\ast@isClass(ast.children1.type))\n\u0009\u0009\u0009\u0009var ptr: \\ast@AstClass :: ast.children1.type.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009while(ast.children0.type.refItem <>& ptr)\n\u0009\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009\u0009if(ptr =& null)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(ast.children1.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009do ast.children1 :: @rebuildEnumElement(ast.children1, ast.children0.type)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.type :: null\n\u0009\u0009\u0009do correct :: true\n\u0009\u0009case %or, %and\n\u0009\u0009\u0009if(\\ast@isBool(ast.children0.type))\n\u0009\u0009\u0009\u0009if(ast.children0.typeId = %exprValuePrim)\n\u0009\u0009\u0009\u0009\u0009var value: bool :: (ast.children0 $ \\ast@AstExprValuePrim).value <> 0b64\n\u0009\u0009\u0009\u0009\u0009; \'true | x\' becomes \'true\'. \'false & x\' becomes \'false\'.\n\u0009\u0009\u0009\u0009\u0009if(ast.kind = %or)\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: value ?(ast.children0, ast.children1)\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert ast.kind = %and\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: !value ?(ast.children0, ast.children1)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: ast.children0.type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %lt, %gt, %le, %ge\n\u0009\u0009\u0009if(ast.children0.type.typeId = %typeNull | ast.children1.type.typeId = %typeNull)\n\u0009\u0009\u0009\u0009do \\err@err(%comparingNullByValue, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(@isComparable(ast.children0.type, true))\n\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, ast.pos)\n\u0009\u0009\u0009\u0009do type.kind :: %bool_\n\u0009\u0009\u0009\u0009if(ast.children0.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009if(ast.children1.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009assert(ast.children0.typeId = %exprValueEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%enumTypeNotInferred, ast.pos, [(ast.children0 $ \\ast@AstExprValueEnumElement).identifier])\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do ast.children0 :: @rebuildEnumElement(ast.children0, ast.children1.type)\n\u0009\u0009\u0009\u0009elif(ast.children1.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009do ast.children1 :: @rebuildEnumElement(ast.children1, ast.children0.type)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(ast.children0.typeId.and(%exprValue) = %exprValue & ast.children1.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009\u0009var value: bool :: false\n\u0009\u0009\u0009\u0009\u0009var children0Type: \\ast@AstType :: ast.children0.type\n\u0009\u0009\u0009\u0009\u0009if(children0Type.typeId = %typeBit | \\ast@isChar(children0Type))\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: bit64 :: (ast.children0 $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: bit64 :: (ast.children1 $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %lt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 < n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %gt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 > n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %le\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 <= n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %ge\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 >= n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isInt(children0Type) | \\ast@isEnum(children0Type))\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: int :: (ast.children0 $ \\ast@AstExprValuePrim).value $ int\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: int :: (ast.children1 $ \\ast@AstExprValuePrim).value $ int\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %lt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 < n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %gt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 > n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %le\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 <= n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %ge\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 >= n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isFloat(children0Type))\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: float :: (ast.children0 $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: float :: (ast.children1 $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %lt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 < n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %gt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 > n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %le\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 <= n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %ge\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 >= n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isStr(children0Type)\n\u0009\u0009\u0009\u0009\u0009\u0009var cmp: int :: lib@cmp((ast.children0 $ \\ast@AstExprValueStr).value, (ast.children1 $ \\ast@AstExprValueStr).value)\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %lt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: cmp < 0\n\u0009\u0009\u0009\u0009\u0009\u0009case %gt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: cmp > 0\n\u0009\u0009\u0009\u0009\u0009\u0009case %le\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: cmp <= 0\n\u0009\u0009\u0009\u0009\u0009\u0009case %ge\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: cmp >= 0\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do expr.type :: type\n\u0009\u0009\u0009\u0009\u0009do expr.value :: value ?(1b64, 0b64)\n\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %eq, %nEq\n\u0009\u0009\u0009if(ast.children0.type.typeId = %typeNull | ast.children1.type.typeId = %typeNull)\n\u0009\u0009\u0009\u0009do \\err@err(%comparingNullByValue, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(@isComparable(ast.children0.type, false))\n\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, ast.pos)\n\u0009\u0009\u0009\u0009do type.kind :: %bool_\n\u0009\u0009\u0009\u0009if(ast.children0.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009if(ast.children1.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009assert(ast.children0.typeId = %exprValueEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%enumTypeNotInferred, ast.pos, [(ast.children0 $ \\ast@AstExprValueEnumElement).identifier])\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do ast.children0 :: @rebuildEnumElement(ast.children0, ast.children1.type)\n\u0009\u0009\u0009\u0009elif(ast.children1.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009do ast.children1 :: @rebuildEnumElement(ast.children1, ast.children0.type)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(ast.children0.typeId.and(%exprValue) = %exprValue & ast.children1.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009\u0009var value: bool :: false\n\u0009\u0009\u0009\u0009\u0009var children0Type: \\ast@AstType :: ast.children0.type\n\u0009\u0009\u0009\u0009\u0009if(children0Type.typeId = %typeBit | \\ast@isInt(children0Type) | \\ast@isFloat(children0Type) | \\ast@isChar(children0Type) | \\ast@isBool(children0Type) | \\ast@isEnum(children0Type))\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: bit64 :: (ast.children0 $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: bit64 :: (ast.children1 $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %eq\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 = n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %nEq\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 <> n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isStr(children0Type)\n\u0009\u0009\u0009\u0009\u0009\u0009var cmp: int :: lib@cmp((ast.children0 $ \\ast@AstExprValueStr).value, (ast.children1 $ \\ast@AstExprValueStr).value)\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %eq\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: cmp = 0\n\u0009\u0009\u0009\u0009\u0009\u0009case %nEq\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: cmp <> 0\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do expr.type :: type\n\u0009\u0009\u0009\u0009\u0009do expr.value :: value ?(1b64, 0b64)\n\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %eqRef, %nEqRef\n\u0009\u0009\u0009if(\\ast@isNullable(ast.children0.type) | ast.children0.type.typeId = %typeNull)\n\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, ast.pos)\n\u0009\u0009\u0009\u0009do type.kind :: %bool_\n\u0009\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %cat\n\u0009\u0009\u0009if(ast.children0.type.typeId = %typeNull | ast.children1.type.typeId = %typeNull)\n\u0009\u0009\u0009\u0009do \\err@err(%concatNull, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(ast.children0.type.typeId = %typeArray)\n\u0009\u0009\u0009\u0009if(ast.children0.typeId.and(%exprValue) = %exprValue & ast.children1.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009\u0009if(\\ast@isStr(ast.children0.type))\n\u0009\u0009\u0009\u0009\u0009\u0009var s1: []char :: (ast.children0 $ \\ast@AstExprValueStr).value\n\u0009\u0009\u0009\u0009\u0009\u0009var s2: []char :: (ast.children1 $ \\ast@AstExprValueStr).value\n\u0009\u0009\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValueStr :: #\\ast@AstExprValueStr\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValueStr, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.children0.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: s1 ~ s2\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValueStr(expr) $ \\ast@AstExprValueStr\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: ast.children0.type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %add, %sub, %mul, %div, %mod\n\u0009\u0009\u0009if(ast.children0.type.typeId = %typeBit | \\ast@isInt(ast.children0.type) | \\ast@isFloat(ast.children0.type))\n\u0009\u0009\u0009\u0009if(ast.children0.typeId.and(%exprValue) = %exprValue & ast.children1.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009\u0009if(ast.children0.type.typeId = %typeBit)\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: bit64 :: (ast.children0 $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: bit64 :: (ast.children1 $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %add\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :+ n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %sub\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :- n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %mul\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :* n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %div\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(n2 = 0b64)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%dividedBy0, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :/ n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %mod\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(n2 = 0b64)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%dividedBy0, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :% n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.children0.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: @bitCast((ast.children0.type $ \\ast@AstTypeBit).size, n1)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isInt(ast.children0.type))\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: int :: (ast.children0 $ \\ast@AstExprValuePrim).value $ int\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: int :: (ast.children1 $ \\ast@AstExprValuePrim).value $ int\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %add\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :+ n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %sub\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :- n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %mul\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :* n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %div\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(n2 = 0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%dividedBy0, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :/ n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %mod\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(n2 = 0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%dividedBy0, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :% n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.children0.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n1 $ bit64\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isFloat(ast.children0.type)\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: float :: (ast.children0 $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: float :: (ast.children1 $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %add\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :+ n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %sub\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :- n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %mul\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :* n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %div\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(n1 = 0.0 & n2 = 0.0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%dividedBy0, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :/ n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %mod\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(n1 = 0.0 & n2 = 0.0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%dividedBy0, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :% n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValueFloat :: #\\ast@AstExprValueFloat\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValueFloat, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.children0.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n1\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValueFloat(expr) $ \\ast@AstExprValueFloat\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: ast.children0.type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %pow\n\u0009\u0009\u0009if(\\ast@isInt(ast.children0.type) | \\ast@isFloat(ast.children0.type))\n\u0009\u0009\u0009\u0009do ast.type :: ast.children0.type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %swap\n\u0009\u0009\u0009if(ast.children0.varKind = %value | ast.children1.varKind = %value)\n\u0009\u0009\u0009\u0009do \\err@err(%wrongLeftOrRightValueOfSwapOperator, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!\\ast@isClass(ast.children0.type) & ast.children0.type.refItem <>& ast.children1.type.refItem)\n\u0009\u0009\u0009\u0009do ast.type :: ast.children0.type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009end switch\n\u0009\u0009if(!correct)\n\u0009\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009end block\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExpr3(ast: \\ast@AstExpr3): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.children0 :: @rebuildExpr(ast.children0, false)\n\u0009if(ast.children0 =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.children1 :: @rebuildExpr(ast.children1, false)\n\u0009if(ast.children1 =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.children2 :: @rebuildExpr(ast.children2, false)\n\u0009if(ast.children2 =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(!\\ast@isBool(ast.children0.type))\n\u0009\u0009do \\err@err(%condForCondOperatorMustBeBool, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(!@cmpType(ast.children1.type, ast.children2.type, false) & !@cmpType(ast.children2.type, ast.children1.type, false))\n\u0009\u0009do \\err@err(%twoValueForCondOperatorMustSameType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(ast.children0.typeId = %exprValuePrim)\n\u0009\u0009do ast.extra :: (ast.children0 $ \\ast@AstExprValuePrim).value <> 0b64 ?(ast.children1, ast.children2)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009if(ast.children1.type.typeId = %typeEnumElement)\n\u0009\u0009if(ast.children2.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009assert ast.children1.typeId = %exprValueEnumElement\n\u0009\u0009\u0009do \\err@err(%enumTypeNotInferred, ast.pos, [(ast.children1 $ \\ast@AstExprValueEnumElement).identifier])\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009do ast.children1 :: @rebuildEnumElement(ast.children1, ast.children2.type)\n\u0009elif(ast.children2.type.typeId = %typeEnumElement)\n\u0009\u0009do ast.children2 :: @rebuildEnumElement(ast.children2, ast.children1.type)\n\u0009end if\n\u0009if(@cmpType(ast.children1.type, ast.children2.type, false))\n\u0009\u0009do ast.type :: ast.children2.type.typeId = %typeNull ?(ast.children1.type, ast.children2.type)\n\u0009else\n\u0009\u0009do ast.type :: ast.children1.type.typeId = %typeNull ?(ast.children2.type, ast.children1.type)\n\u0009end if\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprNew(ast: \\ast@AstExprNew): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.itemType :: @rebuildType(ast.itemType, null)\n\u0009if(ast.itemType =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009if(\\ast@isClass(ast.itemType) & ast.itemType.refItem =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009if(!(\\ast@isClass(ast.itemType) | ast.itemType.typeId = %typeGen | ast.itemType.typeId = %typeDict))\n\u0009\u0009do \\err@err(%wrongTypeForNewOperator, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.type :: ast.itemType\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprNewArray(ast: \\ast@AstExprNewArray): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009block\n\u0009\u0009var items: list<\\ast@AstExpr> :: ast.idces\n\u0009\u0009do items.head()\n\u0009\u0009while loop(!items.term())\n\u0009\u0009\u0009var data: \\ast@AstExpr :: items.get()\n\u0009\u0009\u0009do data :: @rebuildExpr(data, false)\n\u0009\u0009\u0009if(data =& null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!\\ast@isInt(data.type))\n\u0009\u0009\u0009\u0009do \\err@err(%numOfElementsMustBeInt, data.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.ins(data)\n\u0009\u0009\u0009do items.del()\n\u0009\u0009end while\n\u0009end block\n\u0009\n\u0009do ast.itemType :: @rebuildType(ast.itemType, null)\n\u0009if(ast.itemType =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009block\n\u0009\u0009; Make a type of \'[][]...[]type\'.\n\u0009\u0009var type: \\ast@AstType :: ast.itemType\n\u0009\u0009for i(0, ^ast.idces - 1)\n\u0009\u0009\u0009var type2: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009do @initAst(type2, %typeArray, ast.pos)\n\u0009\u0009\u0009do type2.itemType :: type\n\u0009\u0009\u0009do type :: type2\n\u0009\u0009end for\n\u0009\u0009do ast.type :: type\n\u0009end block\n\u0009\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprAs(ast: \\ast@AstExprAs): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.child :: @rebuildExpr(ast.child, false)\n\u0009if(ast.child =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.childType :: @rebuildType(ast.childType, null)\n\u0009if(ast.childType =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009assert ast.type =& null\n\u0009switch(ast.kind)\n\u0009case %as\n\u0009\u0009var t1: \\ast@AstType :: ast.child.type\n\u0009\u0009var t2: \\ast@AstType :: ast.childType\n\u0009\u0009if(t1.typeId = %typeBit | \\ast@isInt(t1))\n\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2) | \\ast@isFloat(t2) | \\ast@isChar(t2) | \\ast@isBool(t2) | \\ast@isEnum(t2))\n\u0009\u0009\u0009\u0009if(@cmpType(t1, t2, false))\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: ast.child\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009elif(\\ast@isFloat(t1))\n\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2) | \\ast@isFloat(t2))\n\u0009\u0009\u0009\u0009if(@cmpType(t1, t2, false))\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: ast.child\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009elif(\\ast@isChar(t1))\n\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2) | \\ast@isChar(t2))\n\u0009\u0009\u0009\u0009if(@cmpType(t1, t2, false))\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: ast.child\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009elif(\\ast@isBool(t1))\n\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2) | \\ast@isBool(t2))\n\u0009\u0009\u0009\u0009if(@cmpType(t1, t2, false))\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: ast.child\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009elif(\\ast@isClass(t1))\n\u0009\u0009\u0009if(\\ast@isClass(t2))\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009elif(\\ast@isEnum(t1))\n\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2) | \\ast@isEnum(t2))\n\u0009\u0009\u0009\u0009if(@cmpType(t1, t2, false))\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: ast.child\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009elif(t1.typeId = %typeEnumElement)\n\u0009\u0009\u0009if(\\ast@isEnum(t2))\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(ast.type <>& null)\n\u0009\u0009\u0009if(ast.child.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009if(t1.typeId = %typeBit | \\ast@isChar(t1) | \\ast@isBool(t1) | \\ast@isInt(t1) | \\ast@isEnum(t1))\n\u0009\u0009\u0009\u0009\u0009var n: bit64 :: (ast.child $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009if(t2.typeId = %typeBit)\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: @bitCast((t2 $ \\ast@AstTypeBit).size, n)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isInt(t2) | \\ast@isEnum(t2))\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isFloat(t2))\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValueFloat :: #\\ast@AstExprValueFloat\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValueFloat, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009if(\\ast@isInt(t1) | \\ast@isEnum(t1))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n $ int $ float\n\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n $ float\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValueFloat(expr) $ \\ast@AstExprValueFloat\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isChar(t2))\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: @bitCast(2, n)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isBool(t2)\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n <> 0b64 ?(1b64, 0b64)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009elif(t1.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009assert t2.refItem.typeId = %enum_\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009do expr.value :: @searchEnumElementValue(ast.child $ \\ast@AstExprValueEnumElement, t2.refItem $ \\ast@AstEnum)\n\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert \\ast@isFloat(t1)\n\u0009\u0009\u0009\u0009\u0009var n: float :: (ast.child $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009\u0009if(t2.typeId = %typeBit)\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: @bitCast((t2 $ \\ast@AstTypeBit).size, n $ bit64)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(t2)\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n $ bit64\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009case %is, %nIs\n\u0009\u0009if(\\ast@isClass(ast.child.type) & \\ast@isClass(ast.childType))\n\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009do @initAst(type, %typePrim, ast.pos)\n\u0009\u0009\u0009do type.kind :: %bool_\n\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009end if\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\n\u0009if(ast.type =& null)\n\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprToBin(ast: \\ast@AstExprToBin): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.child :: @rebuildExpr(ast.child, false)\n\u0009if(ast.child =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(ast.child.type.typeId = %typeNull | ast.child.type.typeId = %typeEnumElement)\n\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(ast.childType.typeId <> %typeArray | (ast.childType $ \\ast@AstTypeArray).itemType.typeId <> %typeBit | ((ast.childType $ \\ast@AstTypeArray).itemType $ \\ast@AstTypeBit).size <> 1)\n\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.type :: ast.childType\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprFromBin(ast: \\ast@AstExprFromBin): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.child :: @rebuildExpr(ast.child, false)\n\u0009if(ast.child =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(ast.child.type.typeId <> %typeArray | ((ast.child.type) $ \\ast@AstTypeArray).itemType.typeId <> %typeBit | ((ast.child.type $ \\ast@AstTypeArray).itemType $ \\ast@AstTypeBit).size <> 1)\n\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.type :: ast.childType\n\u0009do ast.varKind :: %value\n\u0009do ast.offset :: @rebuildExpr(ast.offset, false)\n\u0009ret ast\nend func\n\nfunc rebuildExprCall(ast: \\ast@AstExprCall): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.func_ :: @rebuildExpr(ast.func_, false)\n\u0009if(ast.func_ =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009block\n\u0009\u0009var type: \\ast@AstTypeFunc :: ast.func_.type $ \\ast@AstTypeFunc\n\u0009\u0009if(type.funcOption.and(%mki) <> %none)\n\u0009\u0009\u0009; Make an instance and add it to the second argument when \'__mki\' is specified.\n\u0009\u0009\u0009var valueType: \\ast@AstExprCallArg :: #\\ast@AstExprCallArg\n\u0009\u0009\u0009assert type.ret_ <>& null\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var expr: \\ast@AstExprNew :: #\\ast@AstExprNew\n\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprNew, ast.pos)\n\u0009\u0009\u0009\u0009do expr.itemType :: type.ret_\n\u0009\u0009\u0009\u0009do valueType.arg :: @rebuildExpr(expr, false)\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do valueType.refVar :: false\n\u0009\u0009\u0009do valueType.skipVar :: false\n\u0009\u0009\u0009if(^ast.args = 0)\n\u0009\u0009\u0009\u0009do ast.args.add(valueType)\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do ast.args.head()\n\u0009\u0009\u0009\u0009do ast.args.ins(valueType)\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(ast.func_.typeId = %exprDot & ast.func_.type.typeId = %typeFunc)\n\u0009\u0009\u0009var me_: \\ast@AstExprCallArg :: #\\ast@AstExprCallArg\n\u0009\u0009\u0009do me_.arg :: (ast.func_ $ \\ast@AstExprDot).var_\n\u0009\u0009\u0009do me_.refVar :: false\n\u0009\u0009\u0009do me_.skipVar :: false\n\u0009\u0009\u0009if(^ast.args = 0)\n\u0009\u0009\u0009\u0009do ast.args.add(me_)\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do ast.args.head()\n\u0009\u0009\u0009\u0009do ast.args.ins(me_)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(type.funcOption.and(%any) <> %none)\n\u0009\u0009\u0009\u0009; Add the type of \'me\' to the second argument when \'_any_type\' is specified.\n\u0009\u0009\u0009\u0009var meType: \\ast@AstExprCallArg :: #\\ast@AstExprCallArg\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValueArray :: #\\ast@AstExprValueArray\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValueArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do expr.values :: #list<\\ast@AstExpr>\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var value: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(value, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do value.value :: 0b64\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var prim: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(prim, %typePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do prim.kind :: %int_\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value.type :: prim\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.values.add(value)\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do meType.arg :: @rebuildExpr(expr, false)\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do meType.refVar :: false\n\u0009\u0009\u0009\u0009do meType.skipVar :: false\n\u0009\u0009\u0009\u0009if(^ast.args = 1)\n\u0009\u0009\u0009\u0009\u0009do ast.args.add(meType)\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert ^ ast.args >= 2\n\u0009\u0009\u0009\u0009\u0009do ast.args.head()\n\u0009\u0009\u0009\u0009\u0009do ast.args.next()\n\u0009\u0009\u0009\u0009\u0009do ast.args.ins(meType)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009if(type.typeId <> %typeFunc)\n\u0009\u0009\u0009\u0009do \\err@err(%callNonFunction, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do type :: ast.func_.type $ \\ast@AstTypeFunc\n\u0009\u0009end if\n\u0009\u0009do ast.type :: type.ret_\n\u0009\u0009if(^ast.args <> ^type.args)\n\u0009\u0009\u0009do \\err@err(%wrongArgNumInFunc, ast.pos, [(^type.args).toStr(), (^ast.args).toStr(), @getTypeName(type)])\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009block\n\u0009\u0009\u0009var n: int :: 0\n\u0009\u0009\u0009var itemsExpr: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009\u0009var itemsType: list<\\ast@AstTypeFuncArg> :: type.args\n\u0009\u0009\u0009do itemsExpr.head()\n\u0009\u0009\u0009do itemsType.head()\n\u0009\u0009\u0009while(!itemsExpr.term())\n\u0009\u0009\u0009\u0009var argExpr: \\ast@AstExprCallArg :: itemsExpr.get()\n\u0009\u0009\u0009\u0009var argType: \\ast@AstTypeFuncArg :: itemsType.get()\n\u0009\u0009\u0009\u0009if(argExpr.skipVar)\n\u0009\u0009\u0009\u0009\u0009do(argExpr.arg.refItem $ \\ast@AstArg).type :: argType.arg\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do argExpr.arg :: @rebuildExpr(argExpr.arg, false)\n\u0009\u0009\u0009\u0009if(argExpr.arg <>& null)\n\u0009\u0009\u0009\u0009\u0009if(argExpr.refVar & !argExpr.skipVar & argExpr.arg.varKind = %value)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%nonRefArgPassed, ast.pos, [(n + 1).toStr()])\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(argExpr.refVar <> argType.refVar | !@cmpType(argExpr.arg.type, argType.arg, false))\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%wrongArgTypeInFunc, ast.pos, [(n + 1).toStr(), (argType.refVar ?(\"&\", \"\")) ~ @getTypeName(argType.arg), (argExpr.refVar ?(\"&\", \"\")) ~ @getTypeName(argExpr.arg.type)])\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(argExpr.arg.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009do argExpr.arg :: @rebuildEnumElement(argExpr.arg, argType.arg)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do itemsExpr.next()\n\u0009\u0009\u0009\u0009do itemsType.next()\n\u0009\u0009\u0009\u0009do n :+ 1\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009end block\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprArray(ast: \\ast@AstExprArray): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.var_ :: @rebuildExpr(ast.var_, false)\n\u0009if(ast.var_ =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(ast.var_.type.typeId <> %typeArray)\n\u0009\u0009do \\err@err(%nonArrayAccess, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.idx :: @rebuildExpr(ast.idx, false)\n\u0009if(ast.idx =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(!\\ast@isInt(ast.idx.type))\n\u0009\u0009do \\err@err(%arrayIdxMustBeInt, ast.idx.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.type :: (ast.var_.type $ \\ast@AstTypeArray).itemType\n\u0009do ast.varKind :: %globalVar {An array can be an left value.}\n\u0009ret ast\nend func\n\nfunc rebuildExprDot(ast: \\ast@AstExprDot): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.var_ :: @rebuildExpr(ast.var_, false)\n\u0009if(ast.var_ =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(\\ast@isClass(ast.var_.type))\n\u0009\u0009var found: bool :: false\n\u0009\u0009var ptr: \\ast@AstClass :: ast.var_.type.refItem $ \\ast@AstClass\n\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: ptr.items\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009if(item.def.typeId = %var_ & ast.member = (item.def $ \\ast@AstVar).arg.name)\n\u0009\u0009\u0009\u0009\u0009do ast.type :: (item.def $ \\ast@AstVar).arg.type\n\u0009\u0009\u0009\u0009\u0009do ast.varKind :: %globalVar {The addresses of properties are treated as those of global variables. They can be left values.}\n\u0009\u0009\u0009\u0009\u0009do found :: true\n\u0009\u0009\u0009\u0009elif(item.def.typeId = %func_ & ast.member = item.def.name)\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeFunc :: #\\ast@AstTypeFunc\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeFunc, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do type.funcOption :: (item.def $ \\ast@AstFunc).funcOption\n\u0009\u0009\u0009\u0009\u0009do type.funcAttr :: (item.def $ \\ast@AstFunc).funcAttr\n\u0009\u0009\u0009\u0009\u0009do type.args :: #list<\\ast@AstTypeFuncArg>\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var items2: list<\\ast@AstArg> :: (item.def $ \\ast@AstFunc).args\n\u0009\u0009\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: items2.get()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var arg2: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg2.arg :: arg.type\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg2.refVar :: arg.refVar\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type.args.add(arg2)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do type.ret_ :: (item.def $ \\ast@AstFunc).ret_\n\u0009\u0009\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009\u0009\u0009\u0009do ast.varKind :: %value\n\u0009\u0009\u0009\u0009\u0009do found :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(found)\n\u0009\u0009\u0009\u0009\u0009; \'me\' and automatically generated arguments can be accessed even though they are private.\n\u0009\u0009\u0009\u0009\u0009if(!item.public & (ast.var_.refName =& null | ast.var_.refName <> \"me\"))\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%refUnpublishedMember, ast.pos, [ast.member])\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do ast.classItem :: item\n\u0009\u0009\u0009\u0009\u0009ret ast\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009end while\n\u0009else\n\u0009\u0009; Built-in methods.\n\u0009\u0009var varType: \\ast@AstType :: ast.var_.type\n\u0009\u0009if(varType.typeId = %typeEnumElement)\n\u0009\u0009\u0009assert ast.var_.typeId = %exprValueEnumElement\n\u0009\u0009\u0009do \\err@err(%enumTypeNotInferred, ast.pos, [(ast.var_ $ \\ast@AstExprValueEnumElement).identifier])\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009var member: []char :: ast.member\n\u0009\u0009if(\\builtin_func@chkBuiltinFuncType(&member, varType))\n\u0009\u0009\u0009var expr: \\ast@AstExpr :: @searchStdItem(\"kuin\", \"_\" ~ member, true) $ \\ast@AstExpr\n\u0009\u0009\u0009if(expr =& null)\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var func_: \\ast@AstTypeFunc :: expr.type $ \\ast@AstTypeFunc\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%any) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert ^ func_.args >= 2\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.args.get().arg)\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009var argType: \\ast@AstType :: func_.args.get().arg\n\u0009\u0009\u0009\u0009\u0009\u0009assert argType.typeId = %typeArray & \\ast@isInt((argType $ \\ast@AstTypeArray).itemType)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: varType\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%tme) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tkv) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%kvf) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert ^ func_.args >= 3\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.args.get().arg)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: varType\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%tch) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tkv) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%kvf) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert ^ func_.args >= 3\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.args.get().arg)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009if(varType.typeId = %typeArray)\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: (varType $ \\ast@AstTypeArray).itemType\n\u0009\u0009\u0009\u0009\u0009elif(varType.typeId = %typeGen)\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: (varType $ \\ast@AstTypeGen).itemType\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: (varType $ \\ast@AstTypeDict).itemTypeKey\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%tkv) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%kvf) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert ^ func_.args >= 4\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.args.get().arg)\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.args.get().arg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: (varType $ \\ast@AstTypeDict).itemTypeKey\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: (varType $ \\ast@AstTypeDict).itemTypeValue\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%kvf) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tkv) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert ^ func_.args >= 3\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.args.get().arg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeFunc :: #\\ast@AstTypeFunc\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeFunc, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do type.funcOption :: %none\n\u0009\u0009\u0009\u0009\u0009do type.funcAttr :: #list<[]char>\n\u0009\u0009\u0009\u0009\u0009do type.args :: #list<\\ast@AstTypeFuncArg>\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009\u0009do item.arg :: (varType $ \\ast@AstTypeDict).itemTypeKey\n\u0009\u0009\u0009\u0009\u0009\u0009do item.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009do type.args.add(item)\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009\u0009do item.arg :: (varType $ \\ast@AstTypeDict).itemTypeValue\n\u0009\u0009\u0009\u0009\u0009\u0009do item.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009do type.args.add(item)\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do item.arg :: func_.args.get().arg\n\u0009\u0009\u0009\u0009\u0009\u0009do item.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009do type.args.add(item)\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do type.ret_ :: func_.ret_\n\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: type\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%rme) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rac) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rak) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rav) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.ret_)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: varType\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%rch) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rac) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rak) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rav) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.ret_)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(varType.typeId = %typeArray)\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: (varType $ \\ast@AstTypeArray).itemType\n\u0009\u0009\u0009\u0009\u0009elif(varType.typeId = %typeGen)\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: (varType $ \\ast@AstTypeGen).itemType\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: (varType $ \\ast@AstTypeDict).itemTypeValue\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%rac) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rak) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rav) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.ret_)\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeGen\n\u0009\u0009\u0009\u0009\u0009\u0009assert(varType $ \\ast@AstTypeGen).kind = %list_\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do type.itemType :: (varType $ \\ast@AstTypeGen).itemType\n\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: type\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%rak) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rac) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rav) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.ret_)\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do type.itemType :: (varType $ \\ast@AstTypeDict).itemTypeKey\n\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: type\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%rav) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rac) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rak) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.ret_)\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do type.itemType :: (varType $ \\ast@AstTypeDict).itemTypeValue\n\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: type\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009\n\u0009\u0009\u0009do ast.refItem :: expr\n\u0009\u0009\u0009do ast.type :: expr.type\n\u0009\u0009\u0009do ast.varKind :: %value\n\u0009\u0009\u0009ret ast\n\u0009\u0009end if\n\u0009end if\n\u0009do \\err@err(%memberNotExist, ast.pos, [ast.member])\n\u0009ret null\nend func\n\nfunc rebuildExprValue(ast: \\ast@AstExprValue): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009assert ast.typeId = %exprValue\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprValuePrim(ast: \\ast@AstExprValuePrim): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprValueStr(ast: \\ast@AstExprValueStr): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprValueEnumElement(ast: \\ast@AstExprValueEnumElement): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprValueFloat(ast: \\ast@AstExprValueFloat): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprValueArray(ast: \\ast@AstExprValueArray): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009assert ast.type =& null\n\u0009\n\u0009block\n\u0009\u0009var nullSet: bool :: false\n\u0009\u0009var enumSet: bool :: false\n\u0009\u0009var items: list<\\ast@AstExpr> :: ast.values\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var data: \\ast@AstExpr :: items.get()\n\u0009\u0009\u0009do data :: @rebuildExpr(data, false)\n\u0009\u0009\u0009if(data =& null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var dataType: \\ast@AstType :: data.type\n\u0009\u0009\u0009\u0009if(ast.type =& null)\n\u0009\u0009\u0009\u0009\u0009if(dataType.typeId = %typeNull)\n\u0009\u0009\u0009\u0009\u0009\u0009if(enumSet)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%elementTypesOfArrayInitNotMatch, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do nullSet :: true\n\u0009\u0009\u0009\u0009\u0009elif(dataType.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009if(nullSet)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%nullForValueTypeArrayInit, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do enumSet :: true\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009; Determine the type of the array initializer when a value other than \'null\' is specified.\n\u0009\u0009\u0009\u0009\u0009\u0009if(nullSet & !\\ast@isNullable(dataType))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%nullForValueTypeArrayInit, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009if(enumSet & !\\ast@isEnum(dataType))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%elementTypesOfArrayInitNotMatch, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, dataType.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.itemType :: dataType\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009elif(!@cmpType((ast.type $ \\ast@AstTypeArray).itemType, dataType, false))\n\u0009\u0009\u0009\u0009\u0009; The types of the second and subsequent elements of the array initializer do not match the type of the first element.\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%elementTypesOfArrayInitNotMatch, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do items.ins(data)\n\u0009\u0009\u0009do items.del()\n\u0009\u0009end while\n\u0009\u0009if(ast.type =& null)\n\u0009\u0009\u0009if(enumSet)\n\u0009\u0009\u0009\u0009do \\err@err(%allElementsAreEnum, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do \\err@err(%allElementsAreNull, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009if(\\ast@isEnum((ast.type $ \\ast@AstTypeArray).itemType))\n\u0009\u0009var items: list<\\ast@AstExpr> :: ast.values\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstExpr :: items.get()\n\u0009\u0009\u0009if(item.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009do item :: @rebuildEnumElement(item, (ast.type $ \\ast@AstTypeArray).itemType)\n\u0009\u0009\u0009\u0009do items.ins(item)\n\u0009\u0009\u0009\u0009do items.del()\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end if\n\u0009\u0009end while\n\u0009end if\n\u0009\n\u0009if(\\ast@isStr(ast.type))\n\u0009\u0009; Replace constants consisting only of characters with string literals.\n\u0009\u0009var isConst: bool :: true\n\u0009\u0009block\n\u0009\u0009\u0009var items: list<\\ast@AstExpr> :: ast.values\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while loop(!items.term())\n\u0009\u0009\u0009\u0009if(items.get().typeId <> %exprValue)\n\u0009\u0009\u0009\u0009\u0009do isConst :: false\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009if(isConst)\n\u0009\u0009\u0009var ast2: \\ast@AstExprValueStr :: #\\ast@AstExprValueStr\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprValueStr, ast.pos)\n\u0009\u0009\u0009do ast2.type :: ast.type\n\u0009\u0009\u0009var s: []char :: #[^ast.values]char\n\u0009\u0009\u0009var idx: int :: 0\n\u0009\u0009\u0009var items: list<\\ast@AstExpr> :: ast.values\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009do s[idx] :: (items.get() $ \\ast@AstExprValuePrim).value $ char\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do ast2.value :: s\n\u0009\u0009\u0009do ast2 :: @rebuildExprValueStr(ast2) $ \\ast@AstExprValueStr\n\u0009\u0009\u0009do ast.extra :: ast\n\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009end if\n\u0009end if\n\u0009\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprRef(ast: \\ast@AstExpr): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009assert ast.typeId = %exprRef\n\u0009var refItem: \\ast@Ast :: ast.refItem\n\u0009if(refItem =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009switch(refItem.typeId)\n\u0009case %func_\n\u0009\u0009var func_: \\ast@AstFunc :: ast.refItem $ \\ast@AstFunc\n\u0009\u0009do @rebuildFunc(func_)\n\u0009\u0009block\n\u0009\u0009\u0009var type: \\ast@AstTypeFunc :: #\\ast@AstTypeFunc\n\u0009\u0009\u0009do @initAst(type, %typeFunc, ast.pos)\n\u0009\u0009\u0009do type.funcOption :: func_.funcOption\n\u0009\u0009\u0009do type.funcAttr :: func_.funcAttr\n\u0009\u0009\u0009do type.args :: #list<\\ast@AstTypeFuncArg>\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var items: list<\\ast@AstArg> :: func_.args\n\u0009\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: items.get()\n\u0009\u0009\u0009\u0009\u0009var arg2: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009do arg2.refVar :: arg.refVar\n\u0009\u0009\u0009\u0009\u0009do arg2.arg :: arg.type\n\u0009\u0009\u0009\u0009\u0009do type.args.add(arg2)\n\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do type.ret_ :: func_.ret_\n\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009end block\n\u0009\u0009do ast.varKind :: %value\n\u0009case %arg\n\u0009\u0009var arg: \\ast@AstArg :: ast.refItem $ \\ast@AstArg\n\u0009\u0009do @rebuildArg(arg)\n\u0009\u0009switch(arg.kind)\n\u0009\u0009case %global\n\u0009\u0009\u0009do ast.type :: arg.type\n\u0009\u0009\u0009do ast.varKind :: %globalVar\n\u0009\u0009case %localArg\n\u0009\u0009\u0009do ast.type :: arg.type\n\u0009\u0009\u0009do ast.varKind :: arg.refVar ?(%refVar $ \\ast@AstExprVarKind, %localVar)\n\u0009\u0009case %localVar\n\u0009\u0009\u0009do ast.type :: arg.type\n\u0009\u0009\u0009do ast.varKind :: %localVar\n\u0009\u0009case %const_\n\u0009\u0009\u0009if(arg.expr =& null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009assert arg.expr.typeId.and(%exprValue) = %exprValue\n\u0009\u0009\u0009do ast.extra :: arg.expr\n\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009case %member\n\u0009\u0009\u0009do \\err@err(%accessMemberWithoutMe, ast.pos, [ast.refName])\n\u0009\u0009\u0009ret null\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009case %statSwitch, %statFor, %statTry\n\u0009\u0009assert refItem.extra <>& null\n\u0009\u0009do ast.refItem :: (refItem $ \\ast@AstStatBreakable).blockVar\n\u0009\u0009do ast.type :: (refItem $ \\ast@AstStatBreakable).blockVar.type\n\u0009\u0009do ast.varKind :: %localVar\n\u0009default\n\u0009\u0009if(refItem.typeId.and(%expr) = %expr & refItem.extra <>& null & \\ast@isEnum((refItem.extra $ \\ast@AstExpr).type))\n\u0009\u0009\u0009do ast.extra :: refItem.extra\n\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009do \\err@err(%inaccessibleElement, ast.pos, [ast.refName])\n\u0009\u0009ret null\n\u0009end switch\n\u0009ret ast\nend func\n\nfunc searchStdItem(src: []char, identifier: []char, makeExprRef: bool): \\ast@Ast\n\u0009var ast: \\ast@Ast :: @asts.get(src, &)\n\u0009if(ast =& null)\n\u0009\u0009do \\err@err(%sysFileOpenFailed, null, [src])\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009var ast2: \\ast@Ast :: ast.scopeChildren.get(identifier, &)\n\u0009if(ast =& null)\n\u0009\u0009do \\err@err(%sysFileBroken, null, [src])\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009if(makeExprRef)\n\u0009\u0009var expr: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009do @initAstExpr(expr, %exprRef, \\pos@make(\"kuin\", 1, 1))\n\u0009\u0009do expr.refItem :: ast2\n\u0009\u0009ret @rebuildExprRef(expr)\n\u0009end if\n\u0009ret ast2\nend func\n\nfunc initAst(ast: \\ast@Ast, typeId: \\ast@TypeId, pos: \\pos@Pos)\n\u0009assert ast <>$ \\ast@AstExpr\n\u0009do @initAstImpl(ast, typeId, pos)\nend func\n\nfunc initAstExpr(ast: \\ast@AstExpr, typeId: \\ast@TypeId, pos: \\pos@Pos)\n\u0009assert ast =$ \\ast@AstExpr\n\u0009do @initAstImpl(ast, typeId, pos)\n\u0009do ast.type :: null\n\u0009do ast.varKind :: %unknown\nend func\n\nfunc initAstImpl(ast: \\ast@Ast, typeId: \\ast@TypeId, pos: \\pos@Pos)\n\u0009do ast.typeId :: typeId\n\u0009do ast.pos :: pos\n\u0009do ast.name :: null\n\u0009do ast.scopeParent :: null\n\u0009do ast.scopeChildren :: null\n\u0009do ast.refName :: null\n\u0009do ast.refItem :: null\n\u0009do ast.extra :: null\n\u0009do ast.publicInSrc :: false\nend func\n\nfunc makeExprNull(pos: \\pos@Pos): \\ast@AstExprValue\n\u0009var value: \\ast@AstExprValue :: #\\ast@AstExprValue\n\u0009do @initAstExpr(value, %exprValue, pos)\n\u0009block\n\u0009\u0009var type: \\ast@AstTypeNull :: #\\ast@AstTypeNull\n\u0009\u0009do @initAst(type, %typeNull, pos)\n\u0009\u0009do value.type :: type\n\u0009end block\n\u0009ret value\nend func\n\nfunc refreshStats(stats: list<\\ast@AstStat>, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): list<\\ast@AstStat>\n\u0009var stats2: list<\\ast@AstStat> :: #list<\\ast@AstStat>\n\u0009do stats.head()\n\u0009while(!stats.term())\n\u0009\u0009var stat: \\ast@AstStat :: @rebuildStat(stats.get(), retType, parentFunc)\n\u0009\u0009if(stat <>& null)\n\u0009\u0009\u0009do stats2.add(stat)\n\u0009\u0009end if\n\u0009\u0009do stats.next()\n\u0009end while\n\u0009ret stats2\nend func\n\nfunc addSpecialFunc(class_: \\ast@AstClass, name: []char): \\ast@AstFunc\n\u0009; Make frameworks for \'_dtor\', \'_copy\', \'_toBin\', and \'_fromBin\'.\n\u0009var ast: \\ast@AstFunc :: #\\ast@AstFunc\n\u0009do @initAst(ast, %func_, class_.pos)\n\u0009do ast.name :: name\n\u0009do ast.funcOption :: %none\n\u0009do ast.funcAttr :: #list<[]char>\n\u0009do ast.args :: #list<\\ast@AstArg>\n\u0009do ast.ret_ :: null\n\u0009do ast.stats :: #list<\\ast@AstStat>\n\u0009block\n\u0009\u0009var me_: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009do @initAst(me_, %arg, class_.pos)\n\u0009\u0009do me_.kind :: %localArg\n\u0009\u0009do me_.refVar :: false\n\u0009\u0009do me_.expr :: null\n\u0009\u0009block\n\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009do @initAst(type, %typeUser, class_.pos)\n\u0009\u0009\u0009do type.refItem :: class_\n\u0009\u0009\u0009do me_.type :: type\n\u0009\u0009end block\n\u0009\u0009do ast.args.add(me_)\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009; These functions override functions of the root class.\n\u0009\u0009var item: \\ast@AstClassItem :: #\\ast@AstClassItem\n\u0009\u0009do item.override :: true\n\u0009\u0009do item.def :: ast\n\u0009\u0009do item.parentItem :: null\n\u0009\u0009var ptr: \\ast@AstClass :: class_.refItem $ \\ast@AstClass\n\u0009\u0009while(ptr.refItem <>& null)\n\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009end while\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ptr.items\n\u0009\u0009do items.head()\n\u0009\u0009while loop(!items.term())\n\u0009\u0009\u0009var item2: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item2.def.name = name)\n\u0009\u0009\u0009\u0009do item.parentItem :: item2\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009assert item.parentItem <>& null\n\u0009\u0009do item.public :: item.parentItem.public\n\u0009\u0009do class_.items.add(item)\n\u0009end block\n\u0009\n\u0009ret ast\nend func\n\nfunc cmpType(type1: \\ast@AstType, type2: \\ast@AstType, strict: bool): bool\n\u0009if(type1 =& null | type2 =& null)\n\u0009\u0009ret false\n\u0009end if\n\u0009var typeId1: \\ast@TypeId :: type1.typeId\n\u0009var typeId2: \\ast@TypeId :: type2.typeId\n\u0009block\n\u0009\u0009; Comparing \'null\' and \'nullable\' should be true.\n\u0009\u0009var nullable1: bool :: typeId1 = %typeUser & type1.refItem.typeId = %enum_ ?(false, typeId1.and(%typeNullable) = %typeNullable)\n\u0009\u0009var nullable2: bool :: typeId2 = %typeUser & type2.refItem.typeId = %enum_ ?(false, typeId2.and(%typeNullable) = %typeNullable)\n\u0009\u0009if(nullable1 & typeId2 = %typeNull | typeId1 = %typeNull & nullable2 | typeId1 = %typeNull & typeId2 = %typeNull)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009end block\n\u0009if(typeId1 = %typeArray & typeId2 = %typeArray)\n\u0009\u0009ret @cmpType((type1 $ \\ast@AstTypeArray).itemType, (type2 $ \\ast@AstTypeArray).itemType, true)\n\u0009end if\n\u0009if(typeId1 = %typeBit & typeId2 = %typeBit)\n\u0009\u0009ret(type1 $ \\ast@AstTypeBit).size = (type2 $ \\ast@AstTypeBit).size\n\u0009end if\n\u0009if(typeId1 = %typeFunc & typeId2 = %typeFunc)\n\u0009\u0009var func1: \\ast@AstTypeFunc :: type1 $ \\ast@AstTypeFunc\n\u0009\u0009var func2: \\ast@AstTypeFunc :: type2 $ \\ast@AstTypeFunc\n\u0009\u0009; TODO:\n\u0009\u0009{\n\u0009\u0009if(func1.funcOption <> func2.funcOption)\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009var attrs1: list<[]char> :: func1.funcAttr\n\u0009\u0009var attrs2: list<[]char> :: func2.funcAttr\n\u0009\u0009do attrs1.head()\n\u0009\u0009do attrs2.head()\n\u0009\u0009while(!attrs1.term() & !attrs2.term())\n\u0009\u0009\u0009if(attrs1.get() <> attrs2.get())\n\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do attrs1.next()\n\u0009\u0009\u0009do attrs2.next()\n\u0009\u0009end while\n\u0009\u0009if(!(attrs1.term() & attrs2.term()))\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009}\n\u0009\u0009var args1: list<\\ast@AstTypeFuncArg> :: func1.args\n\u0009\u0009var args2: list<\\ast@AstTypeFuncArg> :: func2.args\n\u0009\u0009do args1.head()\n\u0009\u0009do args2.head()\n\u0009\u0009while(!args1.term() & !args2.term())\n\u0009\u0009\u0009var arg1: \\ast@AstTypeFuncArg :: args1.get()\n\u0009\u0009\u0009var arg2: \\ast@AstTypeFuncArg :: args2.get()\n\u0009\u0009\u0009if(arg1.refVar <> arg2.refVar | !@cmpType(arg1.arg, arg2.arg, true))\n\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do args1.next()\n\u0009\u0009\u0009do args2.next()\n\u0009\u0009end while\n\u0009\u0009if(!(args1.term() & args2.term()))\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009if(func1.ret_ =& null & func2.ret_ =& null)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009\u0009if(func1.ret_ =& null | func2.ret_ =& null)\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009ret @cmpType(func1.ret_, func2.ret_, true)\n\u0009end if\n\u0009if(typeId1 = %typeGen & typeId2 = %typeGen)\n\u0009\u0009if((type1 $ \\ast@AstTypeGen).kind <> (type2 $ \\ast@AstTypeGen).kind)\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009ret @cmpType((type1 $ \\ast@AstTypeGen).itemType, (type2 $ \\ast@AstTypeGen).itemType, true)\n\u0009end if\n\u0009if(typeId1 = %typeDict & typeId2 = %typeDict)\n\u0009\u0009var dict1: \\ast@AstTypeDict :: type1 $ \\ast@AstTypeDict\n\u0009\u0009var dict2: \\ast@AstTypeDict :: type2 $ \\ast@AstTypeDict\n\u0009\u0009ret @cmpType(dict1.itemTypeKey, dict2.itemTypeKey, true) & @cmpType(dict1.itemTypeValue, dict2.itemTypeValue, true)\n\u0009end if\n\u0009if(typeId1 = %typePrim & typeId2 = %typePrim)\n\u0009\u0009ret(type1 $ \\ast@AstTypePrim).kind = (type2 $ \\ast@AstTypePrim).kind\n\u0009end if\n\u0009if(typeId1 = %typeUser & typeId2 = %typeUser)\n\u0009\u0009assert type1.refItem.typeId <> %alias_ & type2.refItem.typeId <> %alias_\n\u0009\u0009if(type1.refItem.typeId = %class_ & type2.refItem.typeId = %class_)\n\u0009\u0009\u0009if(strict)\n\u0009\u0009\u0009\u0009ret type1.refItem $ \\ast@AstClass =& type2.refItem $ \\ast@AstClass\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009; Check whether they are parent-child relationship.\n\u0009\u0009\u0009\u0009var class1: \\ast@AstClass :: type1.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009var class2: \\ast@AstClass :: type2.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009var ptr: \\ast@AstClass\n\u0009\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009\u0009{\n\u0009\u0009\u0009\u0009do ptr :: class2\n\u0009\u0009\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009\u0009\u0009if(ptr =& class1)\n\u0009\u0009\u0009\u0009\u0009\u0009ret true\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009}\n\u0009\u0009\u0009\u0009do ptr :: class1\n\u0009\u0009\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009\u0009\u0009if(ptr =& class2)\n\u0009\u0009\u0009\u0009\u0009\u0009ret true\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009ret type1.refItem =& type2.refItem\n\u0009end if\n\u0009if((typeId1 = %typeUser & type1.refItem.typeId = %enum_ | typeId1 = %typeEnumElement) &\n\u0009\u0009|(typeId2 = %typeUser & type2.refItem.typeId = %enum_ | typeId2 = %typeEnumElement) &\n\u0009\u0009|!(typeId1 = %typeEnumElement & typeId2 = %typeEnumElement))\n\u0009\u0009ret true\n\u0009end if\n\u0009ret false\nend func\n\nfunc makeMeDot(class_: \\ast@AstClass, arg: \\ast@AstArg, name: []char): \\ast@AstExprDot\n\u0009var ast: \\ast@AstExprDot :: #\\ast@AstExprDot\n\u0009do @initAstExpr(ast, %exprDot, class_.pos)\n\u0009do ast.member :: name\n\u0009do ast.classItem :: null\n\u0009block\n\u0009\u0009var me_: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009do @initAstExpr(me_, %exprRef, class_.pos)\n\u0009\u0009do me_.refName :: \"me\"\n\u0009\u0009do me_.refItem :: arg\n\u0009\u0009block\n\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009do @initAst(type, %typeUser, class_.pos)\n\u0009\u0009\u0009do type.refItem :: class_\n\u0009\u0009\u0009do me_.type :: type\n\u0009\u0009end block\n\u0009\u0009do ast.var_ :: me_\n\u0009end block\n\u0009ret ast\nend func\n\nfunc isComparable(type: \\ast@AstType, lessOrGreater: bool): bool\n\u0009; Note: \'null\' itself is an incomparable type.\n\u0009; The following types can be compared.\n\u0009if(type.typeId = %typeBit | \\ast@isInt(type) | \\ast@isFloat(type) | \\ast@isChar(type) | \\ast@isEnum(type) | \\ast@isClass(type) | \\ast@isStr(type) | type.typeId = %typeEnumElement)\n\u0009\u0009ret true\n\u0009end if\n\u0009\n\u0009; \'bool\' can be just determined whether the values match.\n\u0009if(!lessOrGreater & \\ast@isBool(type))\n\u0009\u0009ret true\n\u0009end if\n\u0009ret false\nend func\n\nfunc searchEnumElementValue(ast: \\ast@AstExprValueEnumElement, enum_: \\ast@AstEnum): bit64\n\u0009assert ast.type.typeId = %typeEnumElement\n\u0009do @rebuildEnum(enum_)\n\u0009var name: []char :: ast.identifier\n\u0009var items: list<\\ast@AstExpr> :: enum_.items\n\u0009do items.head()\n\u0009while(!items.term())\n\u0009\u0009var item: \\ast@AstExpr :: items.get()\n\u0009\u0009if(name = item.name)\n\u0009\u0009\u0009if(item.typeId <> %exprValuePrim)\n\u0009\u0009\u0009\u0009ret 0b64\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009ret(item $ \\ast@AstExprValuePrim).value\n\u0009\u0009end if\n\u0009\u0009do items.next()\n\u0009end while\n\u0009do \\err@err(%notExistedElementName, ast.pos, [name])\n\u0009ret 0b64\nend func\n\nfunc cacheSubExpr(stats: list<\\ast@AstStat>, ast: \\ast@AstExpr, pos: \\pos@Pos): \\ast@AstExpr\n\u0009if(ast =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(ast.typeId = %exprRef | ast.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009ret ast\n\u0009end if\n\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009do @initAstExpr(ref, %exprRef, pos)\n\u0009do ref.refName :: \"$\"\n\u0009do ref.varKind :: %localVar\n\u0009do ref.extra :: ref\n\u0009block\n\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009do @initAst(arg, %arg, pos)\n\u0009\u0009do arg.kind :: %localVar\n\u0009\u0009do arg.refVar :: false\n\u0009\u0009do arg.type :: ast.type\n\u0009\u0009do arg.expr :: null\n\u0009\u0009do arg.extra :: arg\n\u0009\u0009do ref.refItem :: arg\n\u0009\u0009do ref.type :: arg.type\n\u0009end block\n\u0009block\n\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009do @initAst(do_, %statDo, pos)\n\u0009\u0009block\n\u0009\u0009\u0009var exprAssign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(exprAssign, %expr2, pos)\n\u0009\u0009\u0009do exprAssign.kind :: %assign\n\u0009\u0009\u0009do exprAssign.children0 :: ref\n\u0009\u0009\u0009do exprAssign.children1 :: ast\n\u0009\u0009\u0009do do_.expr :: exprAssign\n\u0009\u0009end block\n\u0009\u0009do stats.add(@rebuildDo(do_))\n\u0009end block\n\u0009ret ref\nend func\n\nfunc bitCast(size: int, n: bit64): bit64\n\u0009switch(size)\n\u0009case 1\n\u0009\u0009ret n $ bit8 $ bit64\n\u0009case 2\n\u0009\u0009ret n $ bit16 $ bit64\n\u0009case 4\n\u0009\u0009ret n $ bit32 $ bit64\n\u0009case 8\n\u0009\u0009ret n\n\u0009\u0009assert false\n\u0009end switch\n\u0009ret 0b64\nend func\n\nfunc getTypeName(type: \\ast@AstType): []char\n\u0009if(type =& null)\n\u0009\u0009ret \"\"\n\u0009end if\n\u0009switch(type.typeId)\n\u0009case %typeArray\n\u0009\u0009ret \"[]\" ~ @getTypeName((type $ \\ast@AstTypeArray).itemType)\n\u0009case %typeBit\n\u0009\u0009ret \"bit\" ~ ((type $ \\ast@AstTypeBit).size * 8).toStr()\n\u0009case %typeFunc\n\u0009\u0009var type2: \\ast@AstTypeFunc :: type $ \\ast@AstTypeFunc\n\u0009\u0009var s: []char :: \"func<(\"\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstTypeFuncArg> :: type2.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var arg: \\ast@AstTypeFuncArg :: items.get()\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do s :~ \", \"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(arg.refVar)\n\u0009\u0009\u0009\u0009do s :~ \"&\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do s :~ @getTypeName(arg.arg)\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009if(type2.ret_ =& null)\n\u0009\u0009\u0009do s :~ \")>\"\n\u0009\u0009else\n\u0009\u0009\u0009do s :~ \"): \" ~ @getTypeName(type2.ret_) ~ \">\"\n\u0009\u0009end if\n\u0009\u0009ret s\n\u0009case %typeGen\n\u0009\u0009var type2: \\ast@AstTypeGen :: type $ \\ast@AstTypeGen\n\u0009\u0009var s: []char\n\u0009\u0009switch(type2.kind)\n\u0009\u0009case %list_\n\u0009\u0009\u0009do s :: \"list<\"\n\u0009\u0009case %stack_\n\u0009\u0009\u0009do s :: \"stack<\"\n\u0009\u0009case %queue_\n\u0009\u0009\u0009do s :: \"queue<\"\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009ret s ~ @getTypeName(type2.itemType) ~ \">\"\n\u0009case %typeDict\n\u0009\u0009var type2: \\ast@AstTypeDict :: type $ \\ast@AstTypeDict\n\u0009\u0009ret \"dict<\" ~ @getTypeName(type2.itemTypeKey) ~ \", \" ~ @getTypeName(type2.itemTypeValue) ~ \">\"\n\u0009case %typePrim\n\u0009\u0009var type2: \\ast@AstTypePrim :: type $ \\ast@AstTypePrim\n\u0009\u0009switch(type2.kind)\n\u0009\u0009case %int_\n\u0009\u0009\u0009ret \"int\"\n\u0009\u0009case %float_\n\u0009\u0009\u0009ret \"float\"\n\u0009\u0009case %char_\n\u0009\u0009\u0009ret \"char\"\n\u0009\u0009case %bool_\n\u0009\u0009\u0009ret \"bool\"\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009case %typeUser\n\u0009\u0009ret(type.refName = \"@\" ?(type.pos.srcName, \"\")) ~ type.refName\n\u0009case %typeEnumElement\n\u0009\u0009ret \"(UNKNOWN)\"\n\u0009default\n\u0009\u0009assert false\n\u0009\u0009ret \"\"\n\u0009end switch\nend func\n";
else if(p==="res/ast.kn")
return "+enum TypeId\n\u0009none :: 0x00\n\u0009root :: 0x01\n\u0009func_ :: 0x0100\n\u0009var_ :: 0x02\n\u0009const_ :: 0x03\n\u0009alias_ :: 0x04\n\u0009class_ :: 0x05\n\u0009enum_ :: 0x06\n\u0009arg :: 0x07\n\u0009stat :: 0x0200\n\u0009statBreakable :: 0x00010200\n\u0009statSkipable :: 0x01010200\n\u0009statEnd :: 0x0201\n\u0009statFunc :: 0x0202\n\u0009statVar :: 0x0203\n\u0009statConst :: 0x0204\n\u0009statAlias :: 0x0205\n\u0009statClass :: 0x0206\n\u0009statEnum :: 0x0207\n\u0009statIf :: 0x00010201\n\u0009statElIf :: 0x0208\n\u0009statElse :: 0x0209\n\u0009statSwitch :: 0x00010202\n\u0009statCase :: 0x020A\n\u0009statDefault :: 0x020B\n\u0009statWhile :: 0x01010201\n\u0009statFor :: 0x01010202\n\u0009statTry :: 0x00010203\n\u0009statCatch :: 0x020C\n\u0009statFinally :: 0x020D\n\u0009statThrow :: 0x020E\n\u0009statBlock :: 0x00010204\n\u0009statRet :: 0x020F\n\u0009statDo :: 0x0210\n\u0009statBreak :: 0x0211\n\u0009statSkip :: 0x0212\n\u0009statAssert :: 0x0213\n\u0009type :: 0x0400\n\u0009typeNullable :: 0x00010400\n\u0009typeArray :: 0x00010401\n\u0009typeBit :: 0x0401\n\u0009typeFunc :: 0x00010402\n\u0009typeGen :: 0x00010403\n\u0009typeDict :: 0x00010404\n\u0009typePrim :: 0x0402\n\u0009typeUser :: 0x00010405\n\u0009typeNull :: 0x0403\n\u0009typeEnumElement :: 0x0404\n\u0009expr :: 0x0800\n\u0009expr1 :: 0x0801\n\u0009expr2 :: 0x0802\n\u0009expr3 :: 0x0803\n\u0009exprNew :: 0x0804\n\u0009exprNewArray :: 0x0805\n\u0009exprAs :: 0x0806\n\u0009exprToBin :: 0x0807\n\u0009exprFromBin :: 0x0808\n\u0009exprCall :: 0x0809\n\u0009exprArray :: 0x080A\n\u0009exprDot :: 0x080B\n\u0009exprValue :: 0x00010800\n\u0009exprValuePrim :: 0x00010801\n\u0009exprValueStr :: 0x00010802\n\u0009exprValueEnumElement :: 0x00010803\n\u0009exprValueFloat :: 0x00010804\n\u0009exprValueArray :: 0x080C\n\u0009exprRef :: 0x080E\n\u0009info :: 0x10000000\nend enum\n\n+class HasType()\n\u0009+var typeId: @TypeId\nend class\n\n+class Ast(@HasType)\n\u0009+*func cmp(t: @Ast): int\n\u0009\u0009var meAddr: bit64 :: lib@addr(me)\n\u0009\u0009var tAddr: bit64 :: lib@addr(t)\n\u0009\u0009ret meAddr > tAddr ?(1, meAddr < tAddr ?(-1, 0))\n\u0009end func\n\u0009\n\u0009+var pos: \\pos@Pos\n\u0009+var name: []char\n\u0009+var scopeParent: @Ast\n\u0009+var scopeChildren: dict<[]char, @Ast>\n\u0009+var refName: []char\n\u0009+var refItem: @Ast\n\u0009+var extra: @HasType {\'AnalyzedCache\' etc.}\n\u0009+var publicInSrc: bool\nend class\n\n+class ScopeRefedItem()\n\u0009+var def: @Ast\n\u0009+var scope: @Ast\nend class\n\n+class AstRoot(@Ast)\n\u0009+var items: list<@Ast>\n\u0009+var scopeRefedItems: list<@ScopeRefedItem>\nend class\n\n+enum AstFuncOption\n\u0009none :: 0x00\n\u0009any :: 0x01 {Ignore type checking of \'me\' and the add the type of it to the second argument.}\n\u0009tme :: 0x02 {The function receives a value of the same type as \'me\' in the third argument.}\n\u0009rme :: 0x04 {The function returns a value of the same type as \'me\'.}\n\u0009tch :: 0x08 {The function receives a value of the type of elements of \'me\' in the third argument.}\n\u0009rch :: 0x10 {The function returns a value of the type of elements of \'me\'.}\n\u0009tkv :: 0x20 {The function receives a value of the type of \'key\' in the third argument and a value of the type of \'value\' in the fourth.}\n\u0009rac :: 0x40 {The function returns an array of the type of list elements of \'me\'.}\n\u0009frc :: 0x0080 {Force to define a method that cannot be overridden.}\n\u0009kvf :: 0x0100 {The function receives a callback function that receives key-value pairs.}\n\u0009rak :: 0x0200 {Return array of dictionary key.}\n\u0009rav :: 0x0400 {Return array of dictionary value.}\n\u0009mki :: 0x0800 {Make an instance automatically.}\n\u0009raw :: 0x1000 {Raw function.}\nend enum\n\n+class AstFunc(@Ast)\n\u0009+var funcOption: @AstFuncOption\n\u0009+var funcAttr: list<[]char>\n\u0009+var args: list<@AstArg>\n\u0009+var ret_: @AstType\n\u0009+var stats: list<@AstStat>\nend class\n\n+class AstVar(@Ast)\n\u0009+var arg: @AstArg\nend class\n\n+class AstConst(@Ast)\n\u0009+var arg: @AstArg\nend class\n\n+class AstAlias(@Ast)\n\u0009+var type: @AstType\nend class\n\n+class AstClassItem()\n\u0009+var public: bool\n\u0009+var override: bool\n\u0009+var def: @Ast\n\u0009+var parentItem: @AstClassItem\nend class\n\n+class AstClass(@Ast)\n\u0009+var items: list<@AstClassItem>\nend class\n\n+class AstEnum(@Ast)\n\u0009+var items: list<@AstExpr>\nend class\n\n+enum AstArgKind\n\u0009unknown\n\u0009global\n\u0009localArg\n\u0009localVar\n\u0009const_\n\u0009member\nend enum\n\n+class AstArg(@Ast)\n\u0009+var kind: @AstArgKind\n\u0009+var refVar: bool\n\u0009+var type: @AstType\n\u0009+var expr: @AstExpr\nend class\n\n+class AstStat(@Ast)\nend class\n\n+class AstStatBreakable(@AstStat)\n\u0009+var blockVar: @AstArg\nend class\n\n+class AstStatSkipable(@AstStatBreakable)\nend class\n\n+class AstStatFunc(@AstStat)\n\u0009+var def: @AstFunc\nend class\n\n+class AstStatVar(@AstStat)\n\u0009+var def: @AstVar\nend class\n\n+class AstStatConst(@AstStat)\n\u0009+var def: @AstConst\nend class\n\n+class AstStatAlias(@AstStat)\n\u0009+var def: @AstAlias\nend class\n\n+class AstStatClass(@AstStat)\n\u0009+var def: @AstClass\nend class\n\n+class AstStatEnum(@AstStat)\n\u0009+var def: @AstEnum\nend class\n\n+class AstStatIf(@AstStatBreakable)\n\u0009+var cond: @AstExpr\n\u0009+var statBlock: @AstStatBlock\n\u0009+var elIfs: list<@AstStatElIf>\n\u0009+var elseStatBlock: @AstStatBlock\nend class\n\n+class AstStatElIf(@AstStat)\n\u0009+var cond: @AstExpr\n\u0009+var statBlock: @AstStatBlock\nend class\n\n+class AstStatSwitch(@AstStatBreakable)\n\u0009+var cond: @AstExpr\n\u0009+var cases: list<@AstStatCase>\n\u0009+var defaultStatBlock: @AstStatBlock\nend class\n\n+class ExprPair()\n\u0009+var expr0: @AstExpr\n\u0009+var expr1: @AstExpr\nend class\n\n+class AstStatCase(@AstStat)\n\u0009+var conds: list<@ExprPair>\n\u0009+var statBlock: @AstStatBlock\nend class\n\n+class AstStatWhile(@AstStatSkipable)\n\u0009+var cond: @AstExpr\n\u0009+var skip_: bool\n\u0009+var stats: list<@AstStat>\nend class\n\n+class AstStatFor(@AstStatSkipable)\n\u0009+var start: @AstExpr\n\u0009+var cond: @AstExpr\n\u0009+var step: @AstExpr\n\u0009+var stats: list<@AstStat>\nend class\n\n+class AstStatTry(@AstStatBreakable)\n\u0009+var statBlock: @AstStatBlock\n\u0009+var catches: list<@AstStatCatch>\n\u0009+var finallyStatBlock: @AstStatBlock\nend class\n\n+class AstStatCatch(@AstStat)\n\u0009+var conds: list<@ExprPair>\n\u0009+var statBlock: @AstStatBlock\nend class\n\n+class AstStatThrow(@AstStat)\n\u0009+var code: @AstExpr\nend class\n\n+class AstStatBlock(@AstStatBreakable)\n\u0009+var stats: list<@AstStat>\nend class\n\n+class AstStatRet(@AstStat)\n\u0009+var value: @AstExpr\nend class\n\n+class AstStatDo(@AstStat)\n\u0009+var expr: @AstExpr\nend class\n\n+class AstStatAssert(@AstStat)\n\u0009+var cond: @AstExpr\nend class\n\n+class AstType(@Ast)\nend class\n\n+class AstTypeNullable(@AstType)\nend class\n\n+class AstTypeArray(@AstTypeNullable)\n\u0009+var itemType: @AstType\nend class\n\n+class AstTypeBit(@AstType)\n\u0009+var size: int\nend class\n\n+class AstTypeFuncArg()\n\u0009+var arg: @AstType\n\u0009+var refVar: bool\nend class\n\n+class AstTypeFunc(@AstTypeNullable)\n\u0009+var funcOption: @AstFuncOption\n\u0009+var funcAttr: list<[]char>\n\u0009+var args: list<@AstTypeFuncArg>\n\u0009+var ret_: @AstType\nend class\n\n+enum AstTypeGenKind\n\u0009list_\n\u0009stack_\n\u0009queue_\nend enum\n\n+class AstTypeGen(@AstTypeNullable)\n\u0009+var kind: @AstTypeGenKind\n\u0009+var itemType: @AstType\nend class\n\n+class AstTypeDict(@AstTypeNullable)\n\u0009+var itemTypeKey: @AstType\n\u0009+var itemTypeValue: @AstType\nend class\n\n+enum AstTypePrimKind\n\u0009int_\n\u0009float_\n\u0009char_\n\u0009bool_\nend enum\n\n+class AstTypePrim(@AstType)\n\u0009+var kind: @AstTypePrimKind\nend class\n\n+class AstTypeUser(@AstTypeNullable)\nend class\n\n+class AstTypeNull(@AstType)\nend class\n\n+class AstTypeEnumElement(@AstType)\nend class\n\n+enum AstExprVarKind\n\u0009unknown\n\u0009value\n\u0009localVar\n\u0009globalVar\n\u0009refVar\nend enum\n\n+class AstExpr(@Ast)\n\u0009+var type: @AstType\n\u0009+var varKind: @AstExprVarKind\nend class\n\n+enum AstExpr1Kind\n\u0009plus\n\u0009minus\n\u0009not\n\u0009copy\n\u0009len\nend enum\n\n+class AstExpr1(@AstExpr)\n\u0009+var kind: @AstExpr1Kind\n\u0009+var child: @AstExpr\nend class\n\n+enum AstExpr2Kind\n\u0009assign\n\u0009assignAdd\n\u0009assignSub\n\u0009assignMul\n\u0009assignDiv\n\u0009assignMod\n\u0009assignPow\n\u0009assignCat\n\u0009or\n\u0009and\n\u0009lt\n\u0009gt\n\u0009le\n\u0009ge\n\u0009eq\n\u0009nEq\n\u0009eqRef\n\u0009nEqRef\n\u0009cat\n\u0009add\n\u0009sub\n\u0009mul\n\u0009div\n\u0009mod\n\u0009pow\n\u0009swap\nend enum\n\n+class AstExpr2(@AstExpr)\n\u0009+var kind: @AstExpr2Kind\n\u0009+var children0: @AstExpr\n\u0009+var children1: @AstExpr\nend class\n\n+class AstExpr3(@AstExpr)\n\u0009+var children0: @AstExpr\n\u0009+var children1: @AstExpr\n\u0009+var children2: @AstExpr\nend class\n\n+class AstExprNew(@AstExpr)\n\u0009+var itemType: @AstType\nend class\n\n+class AstExprNewArray(@AstExpr)\n\u0009+var idces: list<@AstExpr>\n\u0009+var itemType: @AstType\nend class\n\n+enum AstExprAsKind\n\u0009as\n\u0009is\n\u0009nIs\nend enum\n\n+class AstExprAs(@AstExpr)\n\u0009+var kind: @AstExprAsKind\n\u0009+var child: @AstExpr\n\u0009+var childType: @AstType\nend class\n\n+class AstExprToBin(@AstExpr)\n\u0009+var child: @AstExpr\n\u0009+var childType: @AstType\nend class\n\n+class AstExprFromBin(@AstExpr)\n\u0009+var child: @AstExpr\n\u0009+var childType: @AstType\n\u0009+var offset: @AstExpr\nend class\n\n+class AstExprCallArg()\n\u0009+var arg: @AstExpr\n\u0009+var refVar: bool\n\u0009+var skipVar: bool\nend class\n\n+class AstExprCall(@AstExpr)\n\u0009+var func_: @AstExpr\n\u0009+var args: list<@AstExprCallArg>\nend class\n\n+class AstExprArray(@AstExpr)\n\u0009+var var_: @AstExpr\n\u0009+var idx: @AstExpr\nend class\n\n+class AstExprDot(@AstExpr)\n\u0009+var var_: @AstExpr\n\u0009+var member: []char\n\u0009+var classItem: @AstClassItem {For caching to store class references.}\nend class\n\n+class AstExprValue(@AstExpr)\nend class\n\n+class AstExprValuePrim(@AstExprValue)\n\u0009+var value: bit64\nend class\n\n+class AstExprValueStr(@AstExprValue)\n\u0009+var value: []char\nend class\n\n+class AstExprValueEnumElement(@AstExprValue)\n\u0009+var identifier: []char\nend class\n\n+class AstExprValueFloat(@AstExprValue)\n\u0009+var value: float\nend class\n\n+class AstExprValueArray(@AstExpr)\n\u0009+var values: list<@AstExpr>\nend class\n\n+func isInt(type: @AstType): bool\n\u0009ret type.typeId = %typePrim & (type $ @AstTypePrim).kind = %int_\nend func\n\n+func isFloat(type: @AstType): bool\n\u0009ret type.typeId = %typePrim & (type $ @AstTypePrim).kind = %float_\nend func\n\n+func isChar(type: @AstType): bool\n\u0009ret type.typeId = %typePrim & (type $ @AstTypePrim).kind = %char_\nend func\n\n+func isBool(type: @AstType): bool\n\u0009ret type.typeId = %typePrim & (type $ @AstTypePrim).kind = %bool_\nend func\n\n+func isRef(type: @AstType): bool\n\u0009var typeId: @TypeId :: type.typeId\n\u0009ret typeId = %typeArray | typeId = %typeGen | typeId = %typeDict | @isClass(type)\nend func\n\n+func isNullable(type: @AstType): bool\n\u0009ret type.typeId.and(%typeNullable) = %typeNullable & !@isEnum(type)\nend func\n\n+func isClass(type: @AstType): bool\n\u0009ret type.typeId = %typeUser & type.refItem.typeId = %class_\nend func\n\n+func isEnum(type: @AstType): bool\n\u0009ret type.typeId = %typeUser & type.refItem.typeId = %enum_\nend func\n\n+func isStr(type: @AstType): bool\n\u0009if(type.typeId = %typeArray)\n\u0009\u0009var itemType: @AstType :: (type $ @AstTypeArray).itemType\n\u0009\u0009if(itemType.typeId = %typePrim & (itemType $ @AstTypePrim).kind = %char_)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009end if\n\u0009ret false\nend func\n";
else if(p==="res/builtin_func.kn")
return "enum BuiltinFuncKind\n\u0009toStr\n\u0009bitEnum\n\u0009char_\n\u0009bit\n\u0009array\n\u0009str\n\u0009addGenDict\n\u0009getGenDict\n\u0009list_\n\u0009peekStackQueue\n\u0009intFloat\n\u0009arrayOfStr\n\u0009dict_\n\u0009arrayList\n\u0009delListDict\nend enum\n\nvar builtinFuncs: dict<[]char, @BuiltinFuncKind>\n\n+func chkBuiltinFuncType(member: &[]char, type: \\ast@AstType): bool\n\u0009if(@builtinFuncs =& null)\n\u0009\u0009do @builtinFuncs :: #dict<[]char, @BuiltinFuncKind>\n\u0009\u0009do @builtinFuncs.add(\"abs\", %intFloat)\n\u0009\u0009do @builtinFuncs.add(\"add\", %addGenDict)\n\u0009\u0009do @builtinFuncs.add(\"and\", %bitEnum)\n\u0009\u0009do @builtinFuncs.add(\"clamp\", %intFloat)\n\u0009\u0009do @builtinFuncs.add(\"clampMax\", %intFloat)\n\u0009\u0009do @builtinFuncs.add(\"clampMin\", %intFloat)\n\u0009\u0009do @builtinFuncs.add(\"del\", %delListDict)\n\u0009\u0009do @builtinFuncs.add(\"delNext\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"endian\", %bit)\n\u0009\u0009do @builtinFuncs.add(\"exist\", %dict_)\n\u0009\u0009do @builtinFuncs.add(\"fill\", %array)\n\u0009\u0009do @builtinFuncs.add(\"find\", %arrayList)\n\u0009\u0009do @builtinFuncs.add(\"findBin\", %array)\n\u0009\u0009do @builtinFuncs.add(\"findLast\", %arrayList)\n\u0009\u0009do @builtinFuncs.add(\"findStr\", %str)\n\u0009\u0009do @builtinFuncs.add(\"findStrEx\", %str)\n\u0009\u0009do @builtinFuncs.add(\"findStrLast\", %str)\n\u0009\u0009do @builtinFuncs.add(\"forEach\", %dict_)\n\u0009\u0009do @builtinFuncs.add(\"get\", %getGenDict)\n\u0009\u0009do @builtinFuncs.add(\"getOffset\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"head\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"idx\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"ins\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"join\", %arrayOfStr)\n\u0009\u0009do @builtinFuncs.add(\"lower\", %str)\n\u0009\u0009do @builtinFuncs.add(\"max\", %array)\n\u0009\u0009do @builtinFuncs.add(\"min\", %array)\n\u0009\u0009do @builtinFuncs.add(\"moveOffset\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"next\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"not\", %bitEnum)\n\u0009\u0009do @builtinFuncs.add(\"offset\", %char_)\n\u0009\u0009do @builtinFuncs.add(\"or\", %bitEnum)\n\u0009\u0009do @builtinFuncs.add(\"peek\", %peekStackQueue)\n\u0009\u0009do @builtinFuncs.add(\"prev\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"repeat\", %array)\n\u0009\u0009do @builtinFuncs.add(\"replace\", %str)\n\u0009\u0009do @builtinFuncs.add(\"reverse\", %array)\n\u0009\u0009do @builtinFuncs.add(\"sar\", %bit)\n\u0009\u0009do @builtinFuncs.add(\"shl\", %bit)\n\u0009\u0009do @builtinFuncs.add(\"shr\", %bit)\n\u0009\u0009do @builtinFuncs.add(\"shuffle\", %array)\n\u0009\u0009do @builtinFuncs.add(\"sign\", %intFloat)\n\u0009\u0009do @builtinFuncs.add(\"sort\", %arrayList)\n\u0009\u0009do @builtinFuncs.add(\"sortDesc\", %arrayList)\n\u0009\u0009do @builtinFuncs.add(\"split\", %str)\n\u0009\u0009do @builtinFuncs.add(\"sub\", %array)\n\u0009\u0009do @builtinFuncs.add(\"tail\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"term\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"termOffset\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"toArray\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"toArrayKey\", %dict_)\n\u0009\u0009do @builtinFuncs.add(\"toArrayValue\", %dict_)\n\u0009\u0009do @builtinFuncs.add(\"toBit64\", %str)\n\u0009\u0009do @builtinFuncs.add(\"toFloat\", %str)\n\u0009\u0009do @builtinFuncs.add(\"toInt\", %str)\n\u0009\u0009do @builtinFuncs.add(\"toStr\", %toStr)\n\u0009\u0009do @builtinFuncs.add(\"toStrFmt\", %intFloat)\n\u0009\u0009do @builtinFuncs.add(\"trim\", %str)\n\u0009\u0009do @builtinFuncs.add(\"trimLeft\", %str)\n\u0009\u0009do @builtinFuncs.add(\"trimRight\", %str)\n\u0009\u0009do @builtinFuncs.add(\"upper\", %str)\n\u0009\u0009do @builtinFuncs.add(\"xor\", %bitEnum)\n\u0009end if\n\u0009\n\u0009var found: bool\n\u0009var kind: @BuiltinFuncKind :: @builtinFuncs.get(member, &found)\n\u0009if(!found)\n\u0009\u0009ret false\n\u0009end if\n\u0009\n\u0009switch(kind)\n\u0009case %toStr\n\u0009\u0009if(\\ast@isInt(type) | \\ast@isFloat(type) | \\ast@isChar(type) | \\ast@isBool(type) | type.typeId = %typeBit | \\ast@isStr(type))\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %bitEnum\n\u0009\u0009if(type.typeId = %typeBit | \\ast@isEnum(type))\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %char_\n\u0009\u0009if(\\ast@isChar(type))\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %bit\n\u0009\u0009if(type.typeId = %typeBit)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %array\n\u0009\u0009if(type.typeId = %typeArray)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %str\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %addGenDict\n\u0009\u0009if(type.typeId = %typeGen)\n\u0009\u0009\u0009switch((type $ \\ast@AstTypeGen).kind)\n\u0009\u0009\u0009case %list_\n\u0009\u0009\u0009\u0009do member :: \"addList\"\n\u0009\u0009\u0009case %stack_\n\u0009\u0009\u0009\u0009do member :: \"addStack\"\n\u0009\u0009\u0009case %queue_\n\u0009\u0009\u0009\u0009do member :: \"addQueue\"\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009\u0009if(type.typeId = %typeDict)\n\u0009\u0009\u0009do member :: \"addDict\"\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %getGenDict\n\u0009\u0009if(type.typeId = %typeGen)\n\u0009\u0009\u0009switch((type $ \\ast@AstTypeGen).kind)\n\u0009\u0009\u0009case %list_\n\u0009\u0009\u0009\u0009do member :: \"getList\"\n\u0009\u0009\u0009case %stack_\n\u0009\u0009\u0009\u0009do member :: \"getStack\"\n\u0009\u0009\u0009case %queue_\n\u0009\u0009\u0009\u0009do member :: \"getQueue\"\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009\u0009if(type.typeId = %typeDict)\n\u0009\u0009\u0009do member :: \"getDict\"\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %list_\n\u0009\u0009if(type.typeId = %typeGen & (type $ \\ast@AstTypeGen).kind = %list_)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %peekStackQueue\n\u0009\u0009if(type.typeId = %typeGen)\n\u0009\u0009\u0009if((type $ \\ast@AstTypeGen).kind = %stack_)\n\u0009\u0009\u0009\u0009do member :: \"peekStack\"\n\u0009\u0009\u0009\u0009ret true\n\u0009\u0009\u0009elif((type $ \\ast@AstTypeGen).kind = %queue_)\n\u0009\u0009\u0009\u0009do member :: \"peekQueue\"\n\u0009\u0009\u0009\u0009ret true\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009case %intFloat\n\u0009\u0009if(\\ast@isInt(type))\n\u0009\u0009\u0009switch(member)\n\u0009\u0009\u0009case \"abs\"\n\u0009\u0009\u0009\u0009do member :: \"absInt\"\n\u0009\u0009\u0009case \"clamp\"\n\u0009\u0009\u0009\u0009do member :: \"clampInt\"\n\u0009\u0009\u0009case \"clampMin\"\n\u0009\u0009\u0009\u0009do member :: \"clampMinInt\"\n\u0009\u0009\u0009case \"clampMax\"\n\u0009\u0009\u0009\u0009do member :: \"clampMaxInt\"\n\u0009\u0009\u0009case \"sign\"\n\u0009\u0009\u0009\u0009do member :: \"signInt\"\n\u0009\u0009\u0009case \"toStrFmt\"\n\u0009\u0009\u0009\u0009do member :: \"toStrFmtInt\"\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009\u0009if(\\ast@isFloat(type))\n\u0009\u0009\u0009switch(member)\n\u0009\u0009\u0009case \"abs\"\n\u0009\u0009\u0009\u0009do member :: \"absFloat\"\n\u0009\u0009\u0009case \"clamp\"\n\u0009\u0009\u0009\u0009do member :: \"clampFloat\"\n\u0009\u0009\u0009case \"clampMin\"\n\u0009\u0009\u0009\u0009do member :: \"clampMinFloat\"\n\u0009\u0009\u0009case \"clampMax\"\n\u0009\u0009\u0009\u0009do member :: \"clampMaxFloat\"\n\u0009\u0009\u0009case \"sign\"\n\u0009\u0009\u0009\u0009do member :: \"signFloat\"\n\u0009\u0009\u0009case \"toStrFmt\"\n\u0009\u0009\u0009\u0009do member :: \"toStrFmtFloat\"\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %arrayOfStr\n\u0009\u0009if(type.typeId = %typeArray & \\ast@isStr((type $ \\ast@AstTypeArray).itemType))\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %dict_\n\u0009\u0009if(type.typeId = %typeDict)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %arrayList\n\u0009\u0009if(type.typeId = %typeArray)\n\u0009\u0009\u0009switch(member)\n\u0009\u0009\u0009case \"sort\"\n\u0009\u0009\u0009\u0009do member :: \"sortArray\"\n\u0009\u0009\u0009case \"sortDesc\"\n\u0009\u0009\u0009\u0009do member :: \"sortDescArray\"\n\u0009\u0009\u0009case \"find\"\n\u0009\u0009\u0009\u0009do member :: \"findArray\"\n\u0009\u0009\u0009case \"findLast\"\n\u0009\u0009\u0009\u0009do member :: \"findLastArray\"\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009\u0009if(type.typeId = %typeGen & (type $ \\ast@AstTypeGen).kind = %list_)\n\u0009\u0009\u0009switch(member)\n\u0009\u0009\u0009case \"sort\"\n\u0009\u0009\u0009\u0009do member :: \"sortList\"\n\u0009\u0009\u0009case \"sortDesc\"\n\u0009\u0009\u0009\u0009do member :: \"sortDescList\"\n\u0009\u0009\u0009case \"find\"\n\u0009\u0009\u0009\u0009do member :: \"findList\"\n\u0009\u0009\u0009case \"findLast\"\n\u0009\u0009\u0009\u0009do member :: \"findLastList\"\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %delListDict\n\u0009\u0009if(type.typeId = %typeGen & (type $ \\ast@AstTypeGen).kind = %list_)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009\u0009if(type.typeId = %typeDict)\n\u0009\u0009\u0009do member :: \"delDict\"\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009end switch\n\u0009\n\u0009ret false\nend func\n";
else if(p==="res/convert.kn")
return "+enum runtimeTypeId\n\u0009int_\n\u0009float_\n\u0009char_\n\u0009bool_\n\u0009bit8_\n\u0009bit16_\n\u0009bit32_\n\u0009bit64_\n\u0009func_\n\u0009enum_\n\u0009ref :: 0x80\n\u0009array\n\u0009list_\n\u0009stack_\n\u0009queue_\n\u0009dict_\n\u0009class_\nend enum\n\n+func getTypeId(type: \\ast@AstType): list<int>\n\u0009var result: list<int> :: #list<int>\n\u0009do @makeTypeIdRecursion(type, result)\n\u0009ret result\nend func\n\nfunc makeTypeIdRecursion(type: \\ast@AstType, output: list<int>)\n\u0009if(\\ast@isInt(type))\n\u0009\u0009do output.add(%int_ $ @runtimeTypeId $ int)\n\u0009\u0009ret\n\u0009end if\n\u0009if(\\ast@isFloat(type))\n\u0009\u0009do output.add(%float_ $ @runtimeTypeId $ int)\n\u0009\u0009ret\n\u0009end if\n\u0009if(\\ast@isChar(type))\n\u0009\u0009do output.add(%char_ $ @runtimeTypeId $ int)\n\u0009\u0009ret\n\u0009end if\n\u0009if(\\ast@isBool(type))\n\u0009\u0009do output.add(%bool_ $ @runtimeTypeId $ int)\n\u0009\u0009ret\n\u0009end if\n\u0009if(type.typeId = %typeBit)\n\u0009\u0009switch((type $ \\ast@AstTypeBit).size)\n\u0009\u0009case 1\n\u0009\u0009\u0009do output.add(%bit8_ $ @runtimeTypeId $ int)\n\u0009\u0009case 2\n\u0009\u0009\u0009do output.add(%bit16_ $ @runtimeTypeId $ int)\n\u0009\u0009case 4\n\u0009\u0009\u0009do output.add(%bit32_ $ @runtimeTypeId $ int)\n\u0009\u0009case 8\n\u0009\u0009\u0009do output.add(%bit64_ $ @runtimeTypeId $ int)\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009ret\n\u0009end if\n\u0009if(type.typeId = %typeFunc)\n\u0009\u0009do output.add(%func_ $ @runtimeTypeId $ int)\n\u0009\u0009ret\n\u0009end if\n\u0009if(\\ast@isEnum(type))\n\u0009\u0009do output.add(%enum_ $ @runtimeTypeId $ int)\n\u0009\u0009ret\n\u0009end if\n\u0009if(type.typeId = %typeArray)\n\u0009\u0009do output.add(%array $ @runtimeTypeId $ int)\n\u0009\u0009do @makeTypeIdRecursion((type $ \\ast@AstTypeArray).itemType, output)\n\u0009\u0009ret\n\u0009end if\n\u0009if(type.typeId = %typeGen)\n\u0009\u0009switch((type $ \\ast@AstTypeGen).kind)\n\u0009\u0009case %list_\n\u0009\u0009\u0009do output.add(%list_ $ @runtimeTypeId $ int)\n\u0009\u0009case %stack_\n\u0009\u0009\u0009do output.add(%stack_ $ @runtimeTypeId $ int)\n\u0009\u0009case %queue_\n\u0009\u0009\u0009do output.add(%queue_ $ @runtimeTypeId $ int)\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009do @makeTypeIdRecursion((type $ \\ast@AstTypeGen).itemType, output)\n\u0009\u0009ret\n\u0009end if\n\u0009if(type.typeId = %typeDict)\n\u0009\u0009do output.add(%dict_ $ @runtimeTypeId $ int)\n\u0009\u0009do @makeTypeIdRecursion((type $ \\ast@AstTypeDict).itemTypeKey, output)\n\u0009\u0009do @makeTypeIdRecursion((type $ \\ast@AstTypeDict).itemTypeValue, output)\n\u0009\u0009ret\n\u0009end if\n\u0009assert \\ast@isClass(type)\n\u0009do output.add(%class_ $ @runtimeTypeId $ int)\nend func\n";
else if(p==="res/cpp/output.kn")
return "const classTableItemSize: int :: 2\n\nvar funcs: queue<\\ast@AstFunc>\nvar classes: queue<\\ast@AstClass>\n\nvar uniqueId: []char\nvar classDefs: list<[]char>\nvar funcPrototypes: list<[]char>\nvar codes: list<[]char>\nvar classFuncs: list<[]char>\nvar tmpVars: list<@TmpVar>\nvar globalVars: list<\\ast@AstArg>\nvar localVars: list<\\ast@AstArg>\nvar classTableSize: int\nvar classTable: list<[]char>\n\n+class CppInfo(\\ast@HasType)\n\u0009+var id: []char\n\u0009+var breakLabel: []char\n\u0009+var skipLabel: []char\n\u0009+var classTableOffset: int\n\u0009+var alreadyWritten: bool\n\u0009+var breakLabelUsed: bool\n\u0009+var skipLabelUsed: bool\nend class\n\nclass TmpVar()\n\u0009+var identifier: []char\n\u0009+var type: \\ast@AstType\nend class\n\n+func output(entry: \\ast@AstFunc, resFiles: list<[]char>): bool\n\u0009do @funcs :: #queue<\\ast@AstFunc>\n\u0009do @funcs.add(entry)\n\u0009do @classes :: #queue<\\ast@AstClass>\n\u0009\n\u0009do @uniqueId :: \"a\"\n\u0009do @classDefs :: #list<[]char>\n\u0009do @funcPrototypes :: #list<[]char>\n\u0009do @codes :: #list<[]char>\n\u0009do @classFuncs :: #list<[]char>\n\u0009do @tmpVars :: #list<@TmpVar>\n\u0009do @globalVars :: #list<\\ast@AstArg>\n\u0009do @localVars :: #list<\\ast@AstArg>\n\u0009do @classTableSize :: 0\n\u0009do @classTable :: #list<[]char>\n\u0009\n\u0009while(^@funcs > 0 | ^@classes > 0)\n\u0009\u0009while(^@funcs > 0)\n\u0009\u0009\u0009var func_: \\ast@AstFunc :: @funcs.get()\n\u0009\u0009\u0009do @buildFunc(func_)\n\u0009\u0009end while\n\u0009\u0009while(^@classes > 0)\n\u0009\u0009\u0009var class_: \\ast@AstClass :: @classes.get()\n\u0009\u0009\u0009do @buildClass(class_)\n\u0009\u0009end while\n\u0009end while\n\u0009\n\u0009do @write(resFiles)\n\u0009ret true\nend func\n\nfunc buildFunc(ast: \\ast@AstFunc)\n\u0009var info: @CppInfo :: @getInfo(ast)\n\u0009if(info.alreadyWritten)\n\u0009\u0009ret\n\u0009end if\n\u0009do info.alreadyWritten :: true\n\u0009\n\u0009var template: []char :: \"\"\n\u0009if(ast.funcOption.and(%any) = %any)\n\u0009\u0009if(ast.funcOption.and(%tkv) = %tkv)\n\u0009\u0009\u0009do template :: \"template<typename T_, typename K_, typename V_> \"\n\u0009\u0009elif(ast.funcOption.and(%tch) = %tch)\n\u0009\u0009\u0009if(ast.funcOption.and(%rch) = %rch)\n\u0009\u0009\u0009\u0009do template :: \"template<typename T_, typename C_, typename R_> \"\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do template :: \"template<typename T_, typename C_> \"\n\u0009\u0009\u0009end if\n\u0009\u0009elif(ast.funcOption.and(%rch) = %rch)\n\u0009\u0009\u0009do template :: \"template<typename T_, typename R_> \"\n\u0009\u0009elif(ast.funcOption.and(%kvf) = %kvf)\n\u0009\u0009\u0009do template :: \"template<typename T_, typename K_, typename V_> \"\n\u0009\u0009else\n\u0009\u0009\u0009do template :: \"template<typename T_> \"\n\u0009\u0009end if\n\u0009end if\n\u0009\n\u0009var retType: []char\n\u0009if(ast.funcOption.and(%rch) = %rch)\n\u0009\u0009do retType :: \"R_\"\n\u0009elif(ast.funcOption.and(%rme) = %rme)\n\u0009\u0009do retType :: \"T_\"\n\u0009else\n\u0009\u0009do retType :: @getType(ast.ret_)\n\u0009end if\n\u0009\n\u0009var arg: []char :: \"\"\n\u0009block\n\u0009\u0009var idx: int :: 0\n\u0009\u0009var items: list<\\ast@AstArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstArg :: items.get()\n\u0009\u0009\u0009if(idx <> 0)\n\u0009\u0009\u0009\u0009do arg :~ \", \"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009var info2: @CppInfo :: @getInfo(item)\n\u0009\u0009\u0009if(ast.funcOption.and(%any) = %any & idx = 0)\n\u0009\u0009\u0009\u0009assert \\ast@isInt(item.type)\n\u0009\u0009\u0009\u0009do arg :~ \"T_\"\n\u0009\u0009\u0009elif(ast.funcOption.and(%tkv) = %tkv & idx = 2)\n\u0009\u0009\u0009\u0009assert \\ast@isInt(item.type)\n\u0009\u0009\u0009\u0009do arg :~ \"K_\"\n\u0009\u0009\u0009elif(ast.funcOption.and(%tkv) = %tkv & idx = 3)\n\u0009\u0009\u0009\u0009assert \\ast@isInt(item.type)\n\u0009\u0009\u0009\u0009do arg :~ \"V_\"\n\u0009\u0009\u0009elif(ast.funcOption.and(%tch) = %tch & idx = 2)\n\u0009\u0009\u0009\u0009assert \\ast@isInt(item.type)\n\u0009\u0009\u0009\u0009do arg :~ \"C_\"\n\u0009\u0009\u0009elif(ast.funcOption.and(%tme) = %tme & idx = 2)\n\u0009\u0009\u0009\u0009assert \\ast@isInt(item.type)\n\u0009\u0009\u0009\u0009do arg :~ \"T_\"\n\u0009\u0009\u0009elif(ast.funcOption.and(%kvf) = %kvf & idx = 2)\n\u0009\u0009\u0009\u0009assert \\ast@isInt(item.type)\n\u0009\u0009\u0009\u0009do arg :~ \"const void*\"\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do arg :~ \"\\{@getType(item.type)}\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(item.refVar)\n\u0009\u0009\u0009\u0009do arg :~ \"*\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do arg :~ \" \\{info2.id}\"\n\u0009\u0009\u0009if(item.name <>& null)\n\u0009\u0009\u0009\u0009do arg :~ \" /*\\{item.name}*/\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009end while\n\u0009end block\n\u0009\n\u0009if(ast.name <>& null)\n\u0009\u0009do @codes.add(\"// \\{ast.name}\\n\")\n\u0009end if\n\u0009do @funcPrototypes.add(\"\\{template}static \\{retType} \\{info.id}(\\{arg});\\n\")\n\u0009do @codes.add(\"\\{template}static \\{retType} \\{info.id}(\\{arg}){\\n\")\n\u0009\n\u0009if(ast.funcOption.and(%raw) = %raw)\n\u0009\u0009if(^ast.funcAttr = 1)\n\u0009\u0009\u0009do ast.funcAttr.head()\n\u0009\u0009\u0009var hasMembers: bool :: false\n\u0009\u0009\u0009if(^ast.args > 0)\n\u0009\u0009\u0009\u0009do ast.args.head()\n\u0009\u0009\u0009\u0009var arg2: \\ast@AstArg :: ast.args.get()\n\u0009\u0009\u0009\u0009if(arg2.type.refItem <>& null & arg2.type.refItem.typeId = %class_)\n\u0009\u0009\u0009\u0009\u0009var members: list<\\ast@AstClassItem> :: (arg2.type.refItem $ \\ast@AstClass).items\n\u0009\u0009\u0009\u0009\u0009do \\cpp\\raw_funcs@write(@codes, ast.funcAttr.get(), ast.args, members)\n\u0009\u0009\u0009\u0009\u0009do hasMembers :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!hasMembers)\n\u0009\u0009\u0009\u0009do \\cpp\\raw_funcs@write(@codes, ast.funcAttr.get(), ast.args, null)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009end if\n\u0009else\n\u0009\u0009do @codes.tail()\n\u0009\u0009var localVarPos: int :: @codes.idx()\n\u0009\u0009\n\u0009\u0009do @buildStats(ast.stats, null, null)\n\u0009\u0009\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\n\u0009\u0009do @codes.head()\n\u0009\u0009do @codes.moveOffset(localVarPos)\n\u0009\u0009do @codes.next()\n\u0009\u0009do @localVars.head()\n\u0009\u0009while(!@localVars.term())\n\u0009\u0009\u0009var localVar: \\ast@AstArg :: @localVars.get()\n\u0009\u0009\u0009var info2: @CppInfo :: @getInfo(localVar)\n\u0009\u0009\u0009if(localVar.name =& null)\n\u0009\u0009\u0009\u0009do @codes.ins(\"\\{@getType(localVar.type)} \\{info2.id} = \\{@getDefaultValue(localVar.type)};\\n\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.ins(\"\\{@getType(localVar.type)} \\{info2.id} = \\{@getDefaultValue(localVar.type)}; // \\{localVar.name}\\n\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @localVars.del()\n\u0009\u0009end while\n\u0009\u0009do @tmpVars.head()\n\u0009\u0009while(!@tmpVars.term())\n\u0009\u0009\u0009var tmpVar: @TmpVar :: @tmpVars.get()\n\u0009\u0009\u0009do @codes.ins(\"\\{@getType(tmpVar.type)} \\{tmpVar.identifier} = \\{@getDefaultValue(tmpVar.type)};\\n\")\n\u0009\u0009\u0009do @tmpVars.del()\n\u0009\u0009end while\n\u0009end if\nend func\n\nfunc buildClass(ast: \\ast@AstClass)\n\u0009var parentId: []char :: null\n\u0009if(ast.refItem <>& null)\n\u0009\u0009do parentId :: @refClass(ast.refItem $ \\ast@AstClass)\n\u0009end if\n\u0009if(parentId =& null)\n\u0009\u0009do parentId :: \"Class_\"\n\u0009end if\n\u0009var info: @CppInfo :: @getInfo(ast)\n\u0009block\n\u0009\u0009assert info.classTableOffset <> -1\n\u0009\u0009var parentOffset: int\n\u0009\u0009if(ast.refItem =& null)\n\u0009\u0009\u0009do parentOffset :: 0\n\u0009\u0009else\n\u0009\u0009\u0009var parentInfo: @CppInfo :: @getInfo(ast.refItem)\n\u0009\u0009\u0009assert parentInfo.classTableOffset <> -1\n\u0009\u0009\u0009do parentOffset :: parentInfo.classTableOffset\n\u0009\u0009end if\n\u0009\u0009do @classTable.add(\"classTable_[\\{info.classTableOffset * @classTableItemSize}] = \\{parentOffset * @classTableItemSize};\\n\")\n\u0009end block\n\u0009if(ast.name <>& null)\n\u0009\u0009do @classDefs.add(\"// \\{ast.name}\\n\")\n\u0009end if\n\u0009do @classDefs.add(\"class \\{info.id} : public \\{parentId}{\\npublic:\\n\")\n\u0009do @classDefs.add(\"\\{info.id}();\\n\")\n\u0009do @classFuncs.add(\"\\{info.id}::\\{info.id}(): \\{parentId}()\")\n\u0009block\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item.def.typeId = %var_)\n\u0009\u0009\u0009\u0009var var_: \\ast@AstVar :: item.def $ \\ast@AstVar\n\u0009\u0009\u0009\u0009var info2: @CppInfo :: @getInfo(var_.arg)\n\u0009\u0009\u0009\u0009do @classFuncs.add(\", \\{info2.id}()\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do @classFuncs.add(\"{\\n\")\n\u0009do @classFuncs.add(\"Y = \\{info.classTableOffset * @classTableItemSize};\\n\")\n\u0009block\n\u0009\u0009var ctor: \\ast@AstFunc :: findFunc(ast, \"ctor\")\n\u0009\u0009if(ctor <>& null)\n\u0009\u0009\u0009var ctorInfo: @CppInfo :: @getInfo(ctor)\n\u0009\u0009\u0009do @classFuncs.add(\"\\{ctorInfo.id}(this);\\n\")\n\u0009\u0009end if\n\u0009end block\n\u0009do @classFuncs.add(\"}\\n\")\n\u0009; TODO: Destructor.\n\u0009block\n\u0009\u0009var cmp: \\ast@AstFunc :: findFunc(ast, \"cmp\")\n\u0009\u0009if(cmp <>& null)\n\u0009\u0009\u0009var cmpInfo: @CppInfo :: @getInfo(cmp)\n\u0009\u0009\u0009do @classDefs.add(\"virtual int64_t cmp_(Class_* t) override;\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"int64_t \\{info.id}::cmp_(Class_* t){\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"\\{info.id}* u = reinterpret_cast<\\{info.id}*>(t);\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"return \\{cmpInfo.id}(this, u);\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"}\\n\")\n\u0009\u0009end if\n\u0009\u0009var copy: \\ast@AstFunc :: findFunc(ast, \"_copy\")\n\u0009\u0009block\n\u0009\u0009\u0009assert copy <>& null\n\u0009\u0009\u0009var copyInfo: @CppInfo :: @getInfo(copy)\n\u0009\u0009\u0009do @classDefs.add(\"virtual Class_* copy_(Class_* t) override;\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"Class_* \\{info.id}::copy_(Class_* t){\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"return \\{copyInfo.id}(this);\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"}\\n\")\n\u0009\u0009end block\n\u0009end block\n\u0009block\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item.def.typeId = %var_)\n\u0009\u0009\u0009\u0009var var_: \\ast@AstVar :: item.def $ \\ast@AstVar\n\u0009\u0009\u0009\u0009var info2: @CppInfo :: @getInfo(var_.arg)\n\u0009\u0009\u0009\u0009if(var_.arg.name =& null)\n\u0009\u0009\u0009\u0009\u0009do @classDefs.add(\"\\{@getType(var_.arg.type)} \\{info2.id};\\n\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @classDefs.add(\"\\{@getType(var_.arg.type)} \\{info2.id}; // \\{var_.arg.name}\\n\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do @classDefs.add(\"};\\n\")\n\u0009\n\u0009func findFunc(ast: \\ast@AstClass, name: []char): \\ast@AstFunc\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item.def.typeId = %func_ & item.def.name = name)\n\u0009\u0009\u0009\u0009ret item.def $ \\ast@AstFunc\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009ret null\n\u0009end func\nend func\n\nfunc buildStats(stats: list<\\ast@AstStat>, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009do stats.head()\n\u0009while(!stats.term())\n\u0009\u0009var stat: \\ast@AstStat :: stats.get()\n\u0009\u0009switch(stat.typeId)\n\u0009\u0009case %statIf\n\u0009\u0009\u0009do @buildIf(stat $ \\ast@AstStatIf, breakStat, skipStat)\n\u0009\u0009case %statSwitch\n\u0009\u0009\u0009do @buildSwitch(stat $ \\ast@AstStatSwitch, breakStat, skipStat)\n\u0009\u0009case %statWhile\n\u0009\u0009\u0009do @buildWhile(stat $ \\ast@AstStatWhile, breakStat, skipStat)\n\u0009\u0009case %statFor\n\u0009\u0009\u0009do @buildFor(stat $ \\ast@AstStatFor, breakStat, skipStat)\n\u0009\u0009case %statTry\n\u0009\u0009\u0009do @buildTry(stat $ \\ast@AstStatTry, breakStat, skipStat)\n\u0009\u0009case %statThrow\n\u0009\u0009\u0009do @buildThrow(stat $ \\ast@AstStatThrow)\n\u0009\u0009case %statBlock\n\u0009\u0009\u0009do @buildBlock(stat $ \\ast@AstStatBlock, breakStat, skipStat)\n\u0009\u0009case %statRet\n\u0009\u0009\u0009do @buildRet(stat $ \\ast@AstStatRet)\n\u0009\u0009case %statDo\n\u0009\u0009\u0009do @buildDo(stat $ \\ast@AstStatDo)\n\u0009\u0009case %statBreak\n\u0009\u0009\u0009do @buildBreak(stat $ \\ast@AstStat, breakStat)\n\u0009\u0009case %statSkip\n\u0009\u0009\u0009do @buildSkip(stat $ \\ast@AstStat, skipStat)\n\u0009\u0009case %statAssert\n\u0009\u0009\u0009do @buildAssert(stat $ \\ast@AstStatAssert)\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009do stats.next()\n\u0009end while\nend func\n\nfunc buildIf(ast: \\ast@AstStatIf, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009var infoMe: @CppInfo :: @getInfo(ast)\n\u0009if(ast.cond =& null)\n\u0009\u0009; Optimized code.\n\u0009\u0009do @buildBlock(ast.statBlock, breakStat, skipStat)\n\u0009\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009\u0009end if\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009do @codes.add(\"if(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\"){\\n\")\n\u0009do @buildBlock(ast.statBlock, breakStat, skipStat)\n\u0009do @codes.add(\"}\\n\")\n\u0009block\n\u0009\u0009var items: list<\\ast@AstStatElIf> :: ast.elIfs\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatElIf :: items.get()\n\u0009\u0009\u0009do @codes.add(\"else if(\")\n\u0009\u0009\u0009do @buildExpr(item.cond)\n\u0009\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009\u0009do @buildBlock(item.statBlock, breakStat, skipStat)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009if(ast.elseStatBlock <>& null)\n\u0009\u0009do @codes.add(\"else{\\n\")\n\u0009\u0009do @buildBlock(ast.elseStatBlock, breakStat, skipStat)\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009end if\n\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009end if\nend func\n\nfunc buildSwitch(ast: \\ast@AstStatSwitch, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009var infoMe: @CppInfo :: @getInfo(ast)\n\u0009var info: @CppInfo :: @getInfo(ast.blockVar)\n\u0009if(!info.alreadyWritten)\n\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009do @localVars.add(ast.blockVar)\n\u0009end if\n\u0009var useSwitch: bool :: false\n\u0009if chk(\\ast@isInt(ast.cond.type) | \\ast@isChar(ast.cond.type) | \\ast@isEnum(ast.cond.type) | ast.cond.type.typeId = %typeBit)\n\u0009\u0009do useSwitch :: true\n\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009if(exprs.expr0.typeId.and(%exprValue) <> %exprValue | exprs.expr1 <>& null)\n\u0009\u0009\u0009\u0009\u0009do useSwitch :: false\n\u0009\u0009\u0009\u0009\u0009break chk\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end if\n\u0009if(useSwitch)\n\u0009\u0009do @codes.add(\"switch(\")\n\u0009\u0009do @buildExpr(ast.cond)\n\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009block\n\u0009\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009\u0009assert exprs.expr1 =& null\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"case \")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\":\\n\")\n\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @buildBlock(item.statBlock, ast, skipStat)\n\u0009\u0009\u0009\u0009do @codes.add(\"break;\\n\")\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009if(ast.defaultStatBlock <>& null)\n\u0009\u0009\u0009do @codes.add(\"default:\\n\")\n\u0009\u0009\u0009do @buildBlock(ast.defaultStatBlock, ast, skipStat)\n\u0009\u0009\u0009do @codes.add(\"break;\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009else\n\u0009\u0009do @codes.add(\"\\{info.id} = \")\n\u0009\u0009do @buildExpr(ast.cond)\n\u0009\u0009do @codes.add(\";\\n\")\n\u0009\u0009block\n\u0009\u0009\u0009var first: bool :: true\n\u0009\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"if(\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"else if(\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009var first2: bool :: true\n\u0009\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009\u0009if(first2)\n\u0009\u0009\u0009\u0009\u0009\u0009do first2 :: false\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\" || \")\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(exprs.expr1 =& null)\n\u0009\u0009\u0009\u0009\u0009\u0009if(\\ast@isRef(ast.cond.type))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"cmp_(\\{info.id}, (\")\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\")) == 0\")\n\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"\\{info.id} == (\")\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\") <= \\{info.id} && \\{info.id} <= (\")\n\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr1)\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009\u0009\u0009do @buildBlock(item.statBlock, breakStat, skipStat)\n\u0009\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009if(ast.defaultStatBlock <>& null)\n\u0009\u0009\u0009do @codes.add(\"else{\")\n\u0009\u0009\u0009do @buildBlock(ast.defaultStatBlock, breakStat, skipStat)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009end if\n\u0009end if\n\u0009\n\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009end if\nend func\n\nfunc buildWhile(ast: \\ast@AstStatWhile, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009var infoMe: @CppInfo :: @getInfo(ast)\n\u0009if(ast.cond =& null)\n\u0009\u0009do @codes.add(\"for(;;){\\n\")\n\u0009\u0009do @buildStats(ast.stats, ast, ast)\n\u0009\u0009if(infoMe.skipLabel <>& null & infoMe.skipLabelUsed)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.skipLabel}:;\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009\u0009end if\n\u0009\u0009ret\n\u0009end if\n\u0009if(ast.skip_)\n\u0009\u0009do @codes.add(\"do{\\n\")\n\u0009\u0009do @buildStats(ast.stats, ast, ast)\n\u0009\u0009if(infoMe.skipLabel <>& null & infoMe.skipLabelUsed)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.skipLabel}:;\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"}while(\")\n\u0009\u0009do @buildExpr(ast.cond)\n\u0009\u0009do @codes.add(\");\\n\")\n\u0009\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009\u0009end if\n\u0009\u0009ret\n\u0009end if\n\u0009do @codes.add(\"while(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\"){\\n\")\n\u0009do @buildStats(ast.stats, ast, ast)\n\u0009if(infoMe.skipLabel <>& null & infoMe.skipLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.skipLabel}:;\\n\")\n\u0009end if\n\u0009do @codes.add(\"}\\n\")\n\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009end if\nend func\n\nfunc buildFor(ast: \\ast@AstStatFor, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009var infoMe: @CppInfo :: @getInfo(ast)\n\u0009var info: @CppInfo :: @getInfo(ast.blockVar)\n\u0009if(!info.alreadyWritten)\n\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009do @localVars.add(ast.blockVar)\n\u0009end if\n\u0009var endId: []char :: @addTmpVar(ast.cond.type)\n\u0009do @codes.add(\"for(\\{info.id} = (\")\n\u0009do @buildExpr(ast.start)\n\u0009do @codes.add(\"), \\{endId} = (\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\"); \\{info.id} \")\n\u0009assert ast.step.typeId = %exprValuePrim & \\ast@isInt(ast.cond.type)\n\u0009var step: int :: (ast.step $ \\ast@AstExprValuePrim).value $ int\n\u0009if(step > 0)\n\u0009\u0009do @codes.add(\"<=\")\n\u0009else\n\u0009\u0009do @codes.add(\">=\")\n\u0009end if\n\u0009do @codes.add(\" \\{endId}; \\{info.id} \")\n\u0009if(step > 0)\n\u0009\u0009do @codes.add(\"+= (\")\n\u0009else\n\u0009\u0009do @codes.add(\"-= (\")\n\u0009end if\n\u0009do @buildExpr(ast.step)\n\u0009do @codes.add(\")){\\n\")\n\u0009do @buildStats(ast.stats, ast, ast)\n\u0009if(infoMe.skipLabel <>& null & infoMe.skipLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.skipLabel}:;\\n\")\n\u0009end if\n\u0009do @codes.add(\"}\\n\")\n\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009end if\nend func\n\nfunc buildTry(ast: \\ast@AstStatTry, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009var infoMe: @CppInfo :: @getInfo(ast)\n\u0009var info: @CppInfo :: @getInfo(ast.blockVar)\n\u0009if(!info.alreadyWritten)\n\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009do @localVars.add(ast.blockVar)\n\u0009end if\n\u0009if(ast.finallyStatBlock <>& null)\n\u0009\u0009do @codes.add(\"try{\\n\")\n\u0009end if\n\u0009do @codes.add(\"try{\\n\")\n\u0009do @buildBlock(ast.statBlock, breakStat, skipStat)\n\u0009if(ast.finallyStatBlock <>& null)\n\u0009\u0009do @buildBlock(ast.finallyStatBlock, breakStat, skipStat)\n\u0009end if\n\u0009do @codes.add(\"}catch(int64_t \\{info.id}){\\n\")\n\u0009block\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstStatCatch> :: ast.catches\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatCatch :: items.get()\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009do @codes.add(\"if(\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"else if(\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009var first2: bool :: true\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009if(first2)\n\u0009\u0009\u0009\u0009\u0009do first2 :: false\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\" || \")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(exprs.expr1 =& null)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"\\{info.id} == (\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\") <= \\{info.id} && \\{info.id} <= (\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr1)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009\u0009do @buildBlock(item.statBlock, breakStat, skipStat)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009if(first)\n\u0009\u0009\u0009do @codes.add(\"{\\n\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"else{\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"throw;\\n}\\n\")\n\u0009end block\n\u0009do @codes.add(\"}\\n\")\n\u0009if(ast.finallyStatBlock <>& null)\n\u0009\u0009do @codes.add(\"}\\ncatch(...){\\n\")\n\u0009\u0009do @buildBlock(ast.finallyStatBlock, breakStat, skipStat)\n\u0009\u0009do @codes.add(\"throw;\\n}\\n\")\n\u0009end if\n\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009end if\nend func\n\nfunc buildThrow(ast: \\ast@AstStatThrow)\n\u0009do @codes.add(\"throw \")\n\u0009do @buildExpr(ast.code)\n\u0009do @codes.add(\";\\n\")\nend func\n\nfunc buildBlock(ast: \\ast@AstStatBlock, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009var infoMe: @CppInfo :: @getInfo(ast)\n\u0009do @buildStats(ast.stats, breakStat, skipStat)\n\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009end if\nend func\n\nfunc buildRet(ast: \\ast@AstStatRet)\n\u0009if(ast.value =& null)\n\u0009\u0009do @codes.add(\"return;\\n\")\n\u0009else\n\u0009\u0009do @codes.add(\"return \")\n\u0009\u0009do @buildExpr(ast.value)\n\u0009\u0009do @codes.add(\";\\n\")\n\u0009end if\nend func\n\nfunc buildDo(ast: \\ast@AstStatDo)\n\u0009do @buildExpr(ast.expr)\n\u0009do @codes.add(\";\\n\")\nend func\n\nfunc buildBreak(ast: \\ast@AstStat, breakStat: \\ast@AstStat)\n\u0009assert ast.refItem.typeId.and(%statBreakable) = %statBreakable\n\u0009if(ast.refItem =& breakStat)\n\u0009\u0009do @codes.add(\"break;\\n\")\n\u0009else\n\u0009\u0009var info: @CppInfo :: @getInfo(ast.refItem)\n\u0009\u0009do info.breakLabelUsed :: true\n\u0009\u0009do @codes.add(\"goto \\{info.breakLabel};\\n\")\n\u0009end if\nend func\n\nfunc buildSkip(ast: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009assert ast.refItem.typeId.and(%statSkipable) = %statSkipable\n\u0009if(ast.refItem =& skipStat)\n\u0009\u0009do @codes.add(\"continue;\\n\")\n\u0009else\n\u0009\u0009var info: @CppInfo :: @getInfo(ast.refItem)\n\u0009\u0009do info.skipLabelUsed :: true\n\u0009\u0009do @codes.add(\"goto \\{info.skipLabel};\\n\")\n\u0009end if\nend func\n\nfunc buildAssert(ast: \\ast@AstStatAssert)\n\u0009do @codes.add(\"if(!(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\")){\\nthrow \\{excpt@dbgAssertFailed $ bit32}U;\\n}\\n\")\nend func\n\nfunc buildExpr(ast: \\ast@AstExpr)\n\u0009switch(ast.typeId)\n\u0009case %expr1\n\u0009\u0009do @buildExpr1(ast $ \\ast@AstExpr1)\n\u0009case %expr2\n\u0009\u0009do @buildExpr2(ast $ \\ast@AstExpr2)\n\u0009case %expr3\n\u0009\u0009do @buildExpr3(ast $ \\ast@AstExpr3)\n\u0009case %exprNew\n\u0009\u0009do @buildExprNew(ast $ \\ast@AstExprNew)\n\u0009case %exprNewArray\n\u0009\u0009do @buildExprNewArray(ast $ \\ast@AstExprNewArray)\n\u0009case %exprAs\n\u0009\u0009do @buildExprAs(ast $ \\ast@AstExprAs)\n\u0009case %exprToBin\n\u0009\u0009do @buildExprToBin(ast $ \\ast@AstExprToBin)\n\u0009case %exprFromBin\n\u0009\u0009do @buildExprFromBin(ast $ \\ast@AstExprFromBin)\n\u0009case %exprCall\n\u0009\u0009do @buildExprCall(ast $ \\ast@AstExprCall)\n\u0009case %exprArray\n\u0009\u0009do @buildExprArray(ast $ \\ast@AstExprArray)\n\u0009case %exprDot\n\u0009\u0009do @buildExprDot(ast $ \\ast@AstExprDot)\n\u0009case %exprValue\n\u0009\u0009do @buildExprValue(ast $ \\ast@AstExprValue)\n\u0009case %exprValuePrim\n\u0009\u0009do @buildExprValuePrim(ast $ \\ast@AstExprValuePrim)\n\u0009case %exprValueStr\n\u0009\u0009do @buildExprValueStr(ast $ \\ast@AstExprValueStr)\n\u0009case %exprValueFloat\n\u0009\u0009do @buildExprValueFloat(ast $ \\ast@AstExprValueFloat)\n\u0009case %exprValueArray\n\u0009\u0009do @buildExprValueArray(ast $ \\ast@AstExprValueArray)\n\u0009case %exprRef\n\u0009\u0009do @buildExprRef(ast $ \\ast@AstExpr)\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExpr1(ast: \\ast@AstExpr1)\n\u0009assert ast.varKind <> %unknown\n\u0009switch(ast.kind)\n\u0009case %plus\n\u0009\u0009do @buildExpr(ast.child)\n\u0009case %minus\n\u0009\u0009do @codes.add(\"-(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %not\n\u0009\u0009do @codes.add(\"!(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %copy\n\u0009\u0009do @codes.add(\"copy_(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %len\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")->Len()\")\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExpr2(ast: \\ast@AstExpr2)\n\u0009assert ast.varKind <> %unknown\n\u0009var type: \\ast@AstType :: ast.children0.type\n\u0009switch(ast.kind)\n\u0009case %assign\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") = (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %or\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") || (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %and\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") && (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %lt\n\u0009\u0009if(\\ast@isRef(type))\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")) < 0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") < (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %gt\n\u0009\u0009if(\\ast@isRef(type))\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")) > 0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") > (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %le\n\u0009\u0009if(\\ast@isRef(type))\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")) <= 0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") <= (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %ge\n\u0009\u0009if(\\ast@isRef(type))\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")) >= 0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") >= (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %eq\n\u0009\u0009if(\\ast@isRef(type))\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")) == 0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") == (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %nEq\n\u0009\u0009if(\\ast@isRef(type))\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")) != 0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") != (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %eqRef\n\u0009\u0009do @codes.add(\"eqAddr_((\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\"))\")\n\u0009case %nEqRef\n\u0009\u0009do @codes.add(\"!eqAddr_((\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\"))\")\n\u0009case %cat\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")->Cat(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %add\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") + (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %sub\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") - (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %mul\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") * (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %div\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") / (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %mod\n\u0009\u0009if(\\ast@isInt(type) | type.typeId.and(%typeBit) = %typeBit)\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") % (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009else\n\u0009\u0009\u0009assert \\ast@isFloat(type)\n\u0009\u0009\u0009do @codes.add(\"fmod((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))\")\n\u0009\u0009end if\n\u0009case %pow\n\u0009\u0009if(\\ast@isInt(type) | type.typeId.and(%typeBit) = %typeBit)\n\u0009\u0009\u0009do @codes.add(\"PowI_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))\")\n\u0009\u0009else\n\u0009\u0009\u0009assert \\ast@isFloat(type)\n\u0009\u0009\u0009do @codes.add(\"pow((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))\")\n\u0009\u0009end if\n\u0009case %swap\n\u0009\u0009var tmpVar: []char :: @addTmpVar(type)\n\u0009\u0009do @codes.add(\"\\{tmpVar} = (\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") = (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\") = (\\{tmpVar})\")\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExpr3(ast: \\ast@AstExpr3)\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"(\")\n\u0009do @buildExpr(ast.children0)\n\u0009do @codes.add(\") ? (\")\n\u0009do @buildExpr(ast.children1)\n\u0009do @codes.add(\") : (\")\n\u0009do @buildExpr(ast.children2)\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprNew(ast: \\ast@AstExprNew)\n\u0009assert ast.varKind <> %unknown\n\u0009if(\\ast@isClass(ast.itemType))\n\u0009\u0009var class_: \\ast@AstClass :: ast.itemType.refItem $ \\ast@AstClass\n\u0009\u0009var id: []char :: @refClass(class_)\n\u0009\u0009do @codes.add(\"new \\{id}()\")\n\u0009else\n\u0009\u0009if(ast.itemType.typeId = %typeGen)\n\u0009\u0009\u0009var gen: \\ast@AstTypeGen :: ast.itemType $ \\ast@AstTypeGen\n\u0009\u0009\u0009switch(gen.kind)\n\u0009\u0009\u0009case %list_\n\u0009\u0009\u0009\u0009do @codes.add(\"new List_<\\{@getType(gen.itemType)}>()\")\n\u0009\u0009\u0009case %stack_\n\u0009\u0009\u0009\u0009do @codes.add(\"new Stack_<\\{@getType(gen.itemType)}>()\")\n\u0009\u0009\u0009case %queue_\n\u0009\u0009\u0009\u0009do @codes.add(\"new Queue_<\\{@getType(gen.itemType)}>()\")\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009else\n\u0009\u0009\u0009assert ast.itemType.typeId = %typeDict\n\u0009\u0009\u0009var dict_: \\ast@AstTypeDict :: ast.itemType $ \\ast@AstTypeDict\n\u0009\u0009\u0009do @codes.add(\"new Dict_<\\{@getType(dict_.itemTypeKey)}, \\{@getType(dict_.itemTypeValue)}>()\")\n\u0009\u0009end if\n\u0009end if\nend func\n\nfunc buildExprNewArray(ast: \\ast@AstExprNewArray)\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"newArray_<\\{@getType(ast.itemType)}, \\{@getType(ast.type)}>(\\{^ast.idces}\")\n\u0009block\n\u0009\u0009var items: list<\\ast@AstExpr> :: ast.idces\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009do @codes.add(\", (\")\n\u0009\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprAs(ast: \\ast@AstExprAs)\n\u0009assert ast.varKind <> %unknown\n\u0009switch(ast.kind)\n\u0009case %as\n\u0009\u0009var t1: \\ast@AstType :: ast.child.type\n\u0009\u0009var t2: \\ast@AstType :: ast.childType\n\u0009\u0009if(\\ast@isClass(t1))\n\u0009\u0009\u0009assert \\ast@isClass(t2)\n\u0009\u0009\u0009var id: []char :: @refClass(t2.refItem $ \\ast@AstClass)\n\u0009\u0009\u0009var info: @CppInfo :: @getInfo(t2.refItem)\n\u0009\u0009\u0009do @codes.add(\"as_<\\{id}>(classTable_, (\")\n\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009do @codes.add(\"), \\{info.classTableOffset * @classTableItemSize})\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"static_cast<\\{@getType(ast.childType)}>(\")\n\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %is\n\u0009\u0009do @refClass(ast.childType.refItem $ \\ast@AstClass)\n\u0009\u0009var info: @CppInfo :: @getInfo(ast.childType.refItem)\n\u0009\u0009do @codes.add(\"is_(classTable_, (\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\"), \\{info.classTableOffset * @classTableItemSize})\")\n\u0009case %nIs\n\u0009\u0009do @refClass(ast.childType.refItem $ \\ast@AstClass)\n\u0009\u0009var info: @CppInfo :: @getInfo(ast.childType.refItem)\n\u0009\u0009do @codes.add(\"!is_(classTable_, (\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\"), \\{info.classTableOffset * @classTableItemSize})\")\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExprToBin(ast: \\ast@AstExprToBin)\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"toBin_(\")\n\u0009do @buildExpr(ast.child)\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprFromBin(ast: \\ast@AstExprFromBin)\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"fromBin_<\\{@getType(ast.childType)}>((\")\n\u0009do @buildExpr(ast.child)\n\u0009do @codes.add(\"), (\")\n\u0009do @buildExpr(ast.offset)\n\u0009do @codes.add(\"))\")\nend func\n\nfunc buildExprCall(ast: \\ast@AstExprCall)\n\u0009assert ast.varKind <> %unknown\n\u0009var funcType: \\ast@AstTypeFunc :: ast.func_.type $ \\ast@AstTypeFunc\n\u0009var template: []char :: null\n\u0009if(funcType <>& null & funcType.funcOption.and(%any) = %any)\n\u0009\u0009var items: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009var meType: \\ast@AstType :: items.get().arg.type\n\u0009\u0009if(funcType.funcOption.and(%tkv) = %tkv)\n\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}, \\{@getType((meType $ \\ast@AstTypeDict).itemTypeKey)}, \\{@getType((meType $ \\ast@AstTypeDict).itemTypeValue)}>\"\n\u0009\u0009elif(funcType.funcOption.and(%tch) = %tch)\n\u0009\u0009\u0009if(funcType.funcOption.and(%rch) = %rch)\n\u0009\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}, \"\n\u0009\u0009\u0009\u0009if(meType.typeId = %typeGen)\n\u0009\u0009\u0009\u0009\u0009do template :~ \"\\{@getType((meType $ \\ast@AstTypeGen).itemType)}, \"\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert meType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009do template :~ \"\\{@getType((meType $ \\ast@AstTypeDict).itemTypeKey)}, \"\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do template :~ \"\\{@getType(funcType.ret_)}>\"\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}, \"\n\u0009\u0009\u0009\u0009if(meType.typeId = %typeArray)\n\u0009\u0009\u0009\u0009\u0009do template :~ \"\\{@getType((meType $ \\ast@AstTypeArray).itemType)}>\"\n\u0009\u0009\u0009\u0009elif(meType.typeId = %typeGen)\n\u0009\u0009\u0009\u0009\u0009do template :~ \"\\{@getType((meType $ \\ast@AstTypeGen).itemType)}>\"\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert meType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009do template :~ \"\\{@getType((meType $ \\ast@AstTypeDict).itemTypeKey)}>\"\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009elif(funcType.funcOption.and(%rch) = %rch)\n\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}, \\{@getType(funcType.ret_)}>\"\n\u0009\u0009elif(funcType.funcOption.and(%kvf) = %kvf)\n\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}, \\{@getType((meType $ \\ast@AstTypeDict).itemTypeKey)}, \\{@getType((meType $ \\ast@AstTypeDict).itemTypeValue)}>\"\n\u0009\u0009else\n\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}>\"\n\u0009\u0009end if\n\u0009end if\n\u0009if(template =& null)\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.func_)\n\u0009\u0009do @codes.add(\")\")\n\u0009else\n\u0009\u0009do @buildExpr(ast.func_)\n\u0009\u0009do @codes.add(template)\n\u0009end if\n\u0009do @codes.add(\"(\")\n\u0009block\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstExprCallArg :: items.get()\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\", (\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(item.refVar)\n\u0009\u0009\u0009\u0009do @codes.add(\"&\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @buildExpr(item.arg)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do @codes.add(\")\")\n\u0009\n\u0009block\n\u0009\u0009var type: \\ast@AstType :: ast.type\n\u0009\u0009if(type <>& null)\n\u0009\u0009\u0009if(\\ast@isClass(type))\n\u0009\u0009\u0009\u0009do @refClass(type.refItem $ \\ast@AstClass)\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009end block\nend func\n\nfunc buildExprArray(ast: \\ast@AstExprArray)\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"(\")\n\u0009do @buildExpr(ast.var_)\n\u0009do @codes.add(\")->At(\")\n\u0009do @buildExpr(ast.idx)\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprDot(ast: \\ast@AstExprDot)\n\u0009assert ast.varKind <> %unknown\n\u0009if(\\ast@isClass(ast.var_.type))\n\u0009\u0009var classItem: \\ast@AstClassItem :: ast.classItem\n\u0009\u0009assert classItem <>& null\n\u0009\u0009do @refClass(ast.var_.type.refItem $ \\ast@AstClass)\n\u0009\u0009var info: @CppInfo\n\u0009\u0009if(classItem.def.typeId = %var_)\n\u0009\u0009\u0009do info :: @getInfo((classItem.def $ \\ast@AstVar).arg)\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.var_)\n\u0009\u0009\u0009do @codes.add(\")->\\{info.id}\")\n\u0009\u0009else\n\u0009\u0009\u0009assert classItem.def.typeId = %func_\n\u0009\u0009\u0009do info :: @getInfo(classItem.def)\n\u0009\u0009\u0009; \'ast.var_\' is calculated elsewhere.\n\u0009\u0009\u0009do @codes.add(\"\\{info.id}\")\n\u0009\u0009end if\n\u0009else\n\u0009\u0009assert ast.refItem.typeId = %exprRef\n\u0009\u0009do @buildExprRef(ast.refItem $ \\ast@AstExpr)\n\u0009end if\nend func\n\nfunc buildExprValue(ast: \\ast@AstExprValue)\n\u0009assert ast.type.typeId = %typeNull\n\u0009do @codes.add(\"nullptr\")\nend func\n\nfunc buildExprValuePrim(ast: \\ast@AstExprValuePrim)\n\u0009var type: \\ast@AstType :: ast.type\n\u0009if(\\ast@isInt(type) | \\ast@isEnum(type))\n\u0009\u0009do @codes.add((ast.value $ int).toStr() ~ \"LL\")\n\u0009elif(\\ast@isChar(type))\n\u0009\u0009do @codes.add(\"u\'\\\\u\\{(ast.value $ bit16).toStr().sub(2, -1)}\'\")\n\u0009elif(\\ast@isBool(type))\n\u0009\u0009do @codes.add(ast.value = 0b64 ?(\"false\", \"true\"))\n\u0009elif(type.typeId = %typeBit)\n\u0009\u0009switch((type $ \\ast@AstTypeBit).size)\n\u0009\u0009case 1\n\u0009\u0009\u0009do @codes.add(\"static_cast<uint8_t>(\\{ast.value $ bit8}U)\")\n\u0009\u0009case 2\n\u0009\u0009\u0009do @codes.add(\"static_cast<uint16_t>(\\{ast.value $ bit16}U)\")\n\u0009\u0009case 4\n\u0009\u0009\u0009do @codes.add(\"\\{ast.value $ bit32}U\")\n\u0009\u0009case 8\n\u0009\u0009\u0009do @codes.add(\"\\{ast.value $ bit64}ULL\")\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009else\n\u0009\u0009assert false\n\u0009end if\nend func\n\nfunc buildExprValueStr(ast: \\ast@AstExprValueStr)\n\u0009var value: []char :: ast.value\n\u0009var s: []char :: \"new Array_<char16_t>(\\{^value}\"\n\u0009for i(0, ^value - 1)\n\u0009\u0009do s :~ \", u\'\\\\u\\{(value[i] $ bit16).toStr().sub(2, -1)}\'\"\n\u0009end for\n\u0009do s :~ \")\"\n\u0009do @codes.add(s)\nend func\n\nfunc buildExprValueFloat(ast: \\ast@AstExprValueFloat)\n\u0009var value: []char :: ast.value.toStr()\n\u0009if(value = \"inf\")\n\u0009\u0009do @codes.add(\"std::numeric_limits<double>::infinity()\")\n\u0009elif(value.find(\'.\', -1) = -1)\n\u0009\u0009do @codes.add(value ~ \".0\")\n\u0009else\n\u0009\u0009do @codes.add(value)\n\u0009end if\nend func\n\nfunc buildExprValueArray(ast: \\ast@AstExprValueArray)\n\u0009; Note that constant string values are handled by \'ExprValueStr\'.\n\u0009do @codes.add(\"new Array_<\\{@getType((ast.type $ \\ast@AstTypeArray).itemType)}>(\\{^ast.values}\")\n\u0009var items: list<\\ast@AstExpr> :: ast.values\n\u0009do items.head()\n\u0009while(!items.term())\n\u0009\u0009do @codes.add(\", (\")\n\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009do @codes.add(\")\")\n\u0009\u0009do items.next()\n\u0009end while\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprRef(ast: \\ast@AstExpr)\n\u0009var ast2: \\ast@Ast :: ast.refItem\n\u0009var info: @CppInfo :: @getInfo(ast2)\n\u0009if(ast2.typeId = %func_)\n\u0009\u0009do @funcs.add(ast2 $ \\ast@AstFunc)\n\u0009else\n\u0009\u0009assert ast2.typeId = %arg\n\u0009\u0009var arg: \\ast@AstArg :: ast2 $ \\ast@AstArg\n\u0009\u0009switch(arg.kind)\n\u0009\u0009case %global\n\u0009\u0009\u0009if(!info.alreadyWritten)\n\u0009\u0009\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009\u0009\u0009do @globalVars.add(arg)\n\u0009\u0009\u0009end if\n\u0009\u0009case %localArg\n\u0009\u0009\u0009; Do nothing.\n\u0009\u0009case %localVar\n\u0009\u0009\u0009if(!info.alreadyWritten)\n\u0009\u0009\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009\u0009\u0009do @localVars.add(arg)\n\u0009\u0009\u0009end if\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009if(arg.refVar)\n\u0009\u0009\u0009do @codes.add(\"*\")\n\u0009\u0009end if\n\u0009end if\n\u0009do @codes.add(info.id)\nend func\n\nfunc write(resFiles: list<[]char>)\n\u0009do file@copyFile(\\option@outputDir ~ \"common.h\", \\option@sysDir ~ \"common.h\")\n\u0009\n\u0009var writer: file@Writer :: file@makeWriter(\\option@outputFile ~ \".cpp\", false)\n\u0009do writer.writeStr(\"#include \\\"common.h\\\"\\n\")\n\u0009do writer.writeStr(\"namespace {\\n\")\n\u0009\n\u0009do @classDefs.head()\n\u0009while(!@classDefs.term())\n\u0009\u0009do writer.writeStr(@classDefs.get())\n\u0009\u0009do @classDefs.next()\n\u0009end while\n\u0009do @funcPrototypes.head()\n\u0009while(!@funcPrototypes.term())\n\u0009\u0009do writer.writeStr(@funcPrototypes.get())\n\u0009\u0009do @funcPrototypes.next()\n\u0009end while\n\u0009; TODO: ResFiles\n\u0009if(@classTableSize <> 0)\n\u0009\u0009do writer.writeStr(\"static int64_t classTable_[\\{@classTableSize * @classTableItemSize}];\\n\")\n\u0009end if\n\u0009do writer.writeStr(\"static int64_t argc_;\\n\")\n\u0009do writer.writeStr(\"static char** argv_;\\n\")\n\u0009do @globalVars.head()\n\u0009while(!@globalVars.term())\n\u0009\u0009var globalVar: \\ast@AstArg :: @globalVars.get()\n\u0009\u0009var info: @CppInfo :: @getInfo(globalVar)\n\u0009\u0009do writer.writeStr(\"static \\{@getType(globalVar.type)} \\{info.id};\\n\")\n\u0009\u0009do @globalVars.next()\n\u0009end while\n\u0009do @classFuncs.head()\n\u0009while(!@classFuncs.term())\n\u0009\u0009do writer.writeStr(@classFuncs.get())\n\u0009\u0009do @classFuncs.next()\n\u0009end while\n\u0009do @codes.head()\n\u0009while(!@codes.term())\n\u0009\u0009do writer.writeStr(@codes.get())\n\u0009\u0009do @codes.next()\n\u0009end while\n\u0009do writer.writeStr(\"}\\n\")\n\u0009do writer.writeStr(\"int main(int c_, char** v_){\\n\")\n\u0009do writer.writeStr(\"argc_ = c_ - 1;\\n\")\n\u0009do writer.writeStr(\"argv_ = v_ + 1;\\n\")\n\u0009block\n\u0009\u0009do @classTable.head()\n\u0009\u0009while(!@classTable.term())\n\u0009\u0009\u0009var item: []char :: @classTable.get()\n\u0009\u0009\u0009do writer.writeStr(item)\n\u0009\u0009\u0009do @classTable.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do writer.writeStr(\"init_();\\n\")\n\u0009do writer.writeStr(\"a();\\n\")\n\u0009do writer.writeStr(\"return 0;\\n\")\n\u0009do writer.writeStr(\"}\\n\")\n\u0009do writer.fin()\nend func\n\nfunc getType(type: \\ast@AstType): []char\n\u0009if(type =& null)\n\u0009\u0009ret \"void\"\n\u0009end if\n\u0009switch(type.typeId)\n\u0009case %typeArray\n\u0009\u0009ret \"Array_<\\{@getType((type $ \\ast@AstTypeArray).itemType)}>*\"\n\u0009case %typeBit\n\u0009\u0009ret \"uint\\{(type $ \\ast@AstTypeBit).size * 8}_t\"\n\u0009case %typeFunc\n\u0009\u0009var func_: \\ast@AstTypeFunc :: type $ \\ast@AstTypeFunc\n\u0009\u0009var id: []char :: @getId()\n\u0009\u0009do @funcPrototypes.add(\"typedef \\{@getType(func_.ret_)}(*\\{id})(\")\n\u0009\u0009block\n\u0009\u0009\u0009var arg: []char :: \"\"\n\u0009\u0009\u0009var first: bool :: true\n\u0009\u0009\u0009var items: list<\\ast@AstTypeFuncArg> :: func_.args\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstTypeFuncArg :: items.get()\n\u0009\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do arg :~ \", \"\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do arg :~ \"\\{@getType(item.arg)}\"\n\u0009\u0009\u0009\u0009if(item.refVar)\n\u0009\u0009\u0009\u0009\u0009do arg :~ \"*\"\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do @funcPrototypes.add(\"\\{arg});\\n\")\n\u0009\u0009end block\n\u0009\u0009ret id\n\u0009case %typeGen\n\u0009\u0009var gen: \\ast@AstTypeGen :: type $ \\ast@AstTypeGen\n\u0009\u0009switch(gen.kind)\n\u0009\u0009case %list_\n\u0009\u0009\u0009ret \"List_<\\{@getType(gen.itemType)}>*\"\n\u0009\u0009case %stack_\n\u0009\u0009\u0009ret \"Stack_<\\{@getType(gen.itemType)}>*\"\n\u0009\u0009case %queue_\n\u0009\u0009\u0009ret \"Queue_<\\{@getType(gen.itemType)}>*\"\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009case %typeDict\n\u0009\u0009var dict_: \\ast@AstTypeDict :: type $ \\ast@AstTypeDict\n\u0009\u0009ret \"Dict_<\\{@getType(dict_.itemTypeKey)}, \\{@getType(dict_.itemTypeValue)}>*\"\n\u0009case %typePrim\n\u0009\u0009var prim: \\ast@AstTypePrim :: type $ \\ast@AstTypePrim\n\u0009\u0009switch(prim.kind)\n\u0009\u0009case %int_\n\u0009\u0009\u0009ret \"int64_t\"\n\u0009\u0009case %float_\n\u0009\u0009\u0009ret \"double\"\n\u0009\u0009case %char_\n\u0009\u0009\u0009ret \"char16_t\"\n\u0009\u0009case %bool_\n\u0009\u0009\u0009ret \"bool\"\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009case %typeUser\n\u0009\u0009var ref: \\ast@Ast :: type.refItem\n\u0009\u0009if(ref.typeId = %class_)\n\u0009\u0009\u0009do @refClass(ref $ \\ast@AstClass)\n\u0009\u0009\u0009var info: @CppInfo :: @getInfo(ref)\n\u0009\u0009\u0009ret info.id ~ \"*\"\n\u0009\u0009else\n\u0009\u0009\u0009assert ref.typeId = %enum_\n\u0009\u0009\u0009ret \"int64_t\"\n\u0009\u0009end if\n\u0009case %typeNull\n\u0009\u0009assert false\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc getId(): []char\n\u0009var curId: []char :: @uniqueId\n\u0009var newId: []char :: ##@uniqueId\n\u0009while loop2(true)\n\u0009\u0009var idx: int :: ^newId - 1\n\u0009\u0009while loop(true)\n\u0009\u0009\u0009if(newId[idx] = \'z\')\n\u0009\u0009\u0009\u0009if(idx = 0)\n\u0009\u0009\u0009\u0009\u0009do newId :: #[^newId + 1]char\n\u0009\u0009\u0009\u0009\u0009do newId.fill(\'a\')\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do newId[idx] :: \'a\'\n\u0009\u0009\u0009\u0009\u0009do idx :- 1\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do newId[idx] :: newId[idx].offset(1)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009break loop\n\u0009\u0009end while\n\u0009\u0009switch(^newId)\n\u0009\u0009case 2\n\u0009\u0009\u0009switch(newId)\n\u0009\u0009\u0009case \"do\", \"if\", \"or\"\n\u0009\u0009\u0009\u0009skip loop2\n\u0009\u0009\u0009end switch\n\u0009\u0009case 3\n\u0009\u0009\u0009switch(newId)\n\u0009\u0009\u0009case \"and\", \"asm\", \"for\", \"int\", \"new\", \"not\", \"try\", \"xor\"\n\u0009\u0009\u0009\u0009skip loop2\n\u0009\u0009\u0009end switch\n\u0009\u0009case 4\n\u0009\u0009\u0009switch(newId)\n\u0009\u0009\u0009case \"auto\", \"bool\", \"case\", \"char\", \"else\", \"enum\", \"goto\", \"long\", \"main\", \"this\", \"true\", \"void\"\n\u0009\u0009\u0009\u0009skip loop2\n\u0009\u0009\u0009end switch\n\u0009\u0009end switch\n\u0009\u0009break loop2\n\u0009end while\n\u0009do @uniqueId :: newId\n\u0009ret curId\nend func\n\n+func getInfo(ast: \\ast@Ast): @CppInfo\n\u0009if(ast.extra =& null | ast.extra.typeId <> %info)\n\u0009\u0009var info: @CppInfo :: #@CppInfo\n\u0009\u0009do info.typeId :: %info\n\u0009\u0009do info.id :: @getId()\n\u0009\u0009if(ast.typeId.and(%statBreakable) = %statBreakable & ast.name <>& null & ast.name <> \"$\")\n\u0009\u0009\u0009do info.breakLabel :: @getId()\n\u0009\u0009\u0009if(ast.typeId.and(%statSkipable) = %statSkipable)\n\u0009\u0009\u0009\u0009do info.skipLabel :: @getId()\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do info.skipLabel :: null\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009do info.breakLabel :: null\n\u0009\u0009\u0009do info.skipLabel :: null\n\u0009\u0009end if\n\u0009\u0009do info.classTableOffset :: -1\n\u0009\u0009do info.alreadyWritten :: false\n\u0009\u0009do info.breakLabelUsed :: false\n\u0009\u0009do info.skipLabelUsed :: false\n\u0009\u0009do ast.extra :: info\n\u0009end if\n\u0009ret ast.extra $ @CppInfo\nend func\n\nfunc addTmpVar(type: \\ast@AstType): []char\n\u0009var tmpVar: @TmpVar :: #@TmpVar\n\u0009do tmpVar.identifier :: @getId()\n\u0009do tmpVar.type :: type\n\u0009do @tmpVars.add(tmpVar)\n\u0009ret tmpVar.identifier\nend func\n\nfunc refClass(ast: \\ast@AstClass): []char\n\u0009var info: @CppInfo :: @getInfo(ast)\n\u0009if(info.alreadyWritten)\n\u0009\u0009ret info.id\n\u0009end if\n\u0009do info.alreadyWritten :: true\n\u0009if(ast.refItem <>& null)\n\u0009\u0009do @refClass(ast.refItem $ \\ast@AstClass)\n\u0009end if\n\u0009if(info.classTableOffset = -1)\n\u0009\u0009do info.classTableOffset :: @classTableSize\n\u0009\u0009do @classTableSize :+ 1\n\u0009end if\n\u0009block\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item.def.typeId = %func_)\n\u0009\u0009\u0009\u0009var func_: \\ast@AstFunc :: item.def $ \\ast@AstFunc\n\u0009\u0009\u0009\u0009if(func_.ret_ <>& null)\n\u0009\u0009\u0009\u0009\u0009do @getType(func_.ret_)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009var items2: list<\\ast@AstArg> :: func_.args\n\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: items2.get()\n\u0009\u0009\u0009\u0009\u0009do @getType(arg.type)\n\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @funcs.add(func_)\n\u0009\u0009\u0009elif(item.def.typeId = %var_)\n\u0009\u0009\u0009\u0009var var_: \\ast@AstVar :: item.def $ \\ast@AstVar\n\u0009\u0009\u0009\u0009do @getType(var_.arg.type)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do @classes.add(ast)\n\u0009ret info.id\nend func\n\nfunc getDefaultValue(type: \\ast@AstType): []char\n\u0009if(\\ast@isNullable(type))\n\u0009\u0009ret \"nullptr\"\n\u0009end if\n\u0009switch(type.typeId)\n\u0009case %typeUser\n\u0009\u0009assert \\ast@isEnum(type)\n\u0009\u0009ret \"0\"\n\u0009case %typeBit\n\u0009\u0009ret \"0\"\n\u0009case %typePrim\n\u0009\u0009switch((type $ \\ast@AstTypePrim).kind)\n\u0009\u0009case %int_, %char_\n\u0009\u0009\u0009ret \"0\"\n\u0009\u0009case %float_\n\u0009\u0009\u0009ret \"0.0\"\n\u0009\u0009case %bool_\n\u0009\u0009\u0009ret \"false\"\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n";
else if(p==="res/cpp/raw_funcs.kn")
return "+func write(codes: list<[]char>, attr: []char, args: list<\\ast@AstArg>, members: list<\\ast@AstClassItem>)\n\u0009switch(attr)\n\u0009case \"addr\"\n\u0009\u0009do args.head()\n\u0009\u0009var class_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return reinterpret_cast<uint64_t>(\\{class_.id});\\n\")\n\u0009case \"addDict\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var key: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->Add(\\{key.id}, \\{item.id});\\n\")\n\u0009case \"addList\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->B.push_back(\\{item.id});\\n\")\n\u0009case \"addQueue\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->B.push(\\{item.id});\\n\")\n\u0009case \"addStack\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->B.push(\\{item.id});\\n\")\n\u0009case \"and\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id} & \\{n.id};\\n\")\n\u0009case \"cmdLine\"\n\u0009\u0009do codes.add(\"Array_<Array_<char16_t>*>* a_ = new Array_<Array_<char16_t>*>();\\n\")\n\u0009\u0009do codes.add(\"a_->L = argc_;\\n\")\n\u0009\u0009do codes.add(\"a_->B = new Array_<char16_t>*[static_cast<size_t>(argc_)];\\n\")\n\u0009\u0009do codes.add(\"for (int64_t i_ = 0; i_ < argc_; i_++){\\n\")\n\u0009\u0009do codes.add(\"std::string s_ = argv_[i_];\\n\")\n\u0009\u0009do codes.add(\"const std::u16string t_ = utf8ToUtf16_(s_);\\n\")\n\u0009\u0009do codes.add(\"a_->B[i_] = new Array_<char16_t>();\\n\")\n\u0009\u0009do codes.add(\"a_->B[i_]->L = static_cast<int64_t>(t_.size());\\n\")\n\u0009\u0009do codes.add(\"a_->B[i_]->B = new char16_t[t_.size() + 1];\\n\")\n\u0009\u0009do codes.add(\"std::memcpy(a_->B[i_]->B, t_.c_str(), sizeof(char16_t) * (t_.size() + 1));\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return a_;\\n\")\n\u0009case \"del\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"auto& i_ = \\{me_.id}->I++;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}->B.erase(i_);\\n\")\n\u0009case \"fill\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var value: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"for(int64_t i_ = 0; i_ < \\{me_.id}->L; i_++) \\{me_.id}->B[i_] = \\{value.id};\\n\")\n\u0009case \"findArray\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var start: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{start.id} == -1) \\{start.id} = 0;\\n\")\n\u0009\u0009do codes.add(\"if(\\{start.id} < 0) return -1;\\n\")\n\u0009\u0009do codes.add(\"for(int64_t i_ = \\{start.id}; i_ < \\{me_.id}->L; i_++){\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}->B[i_] == \\{item.id}) return i_;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return -1;\\n\")\n\u0009case \"findBin\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"int64_t a_ = 0, b_ = \\{me_.id}->L - 1;\\n\")\n\u0009\u0009do codes.add(\"while (a_ <= b_) {\\n\")\n\u0009\u0009do codes.add(\"int64_t c_ = (a_ + b_) / 2;\\n\")\n\u0009\u0009do codes.add(\"int64_t m_ = cmp_(\\{item.id}, \\{me_.id}->B[c_]);\\n\")\n\u0009\u0009do codes.add(\"if(m_ < 0) b_ = c_ - 1;\\n\")\n\u0009\u0009do codes.add(\"else if(m_ > 0) a_ = c_ + 1;\\n\")\n\u0009\u0009do codes.add(\"else return c_;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return -1;\\n\")\n\u0009case \"forEach\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var callback: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var data: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return dictForEach_(\\{me_.id}->B, static_cast<bool(*)(K_, V_, Class_*)>(\\{callback.id}), \\{data.id});\\n\")\n\u0009case \"getDict\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var key: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var existed: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return dictSearch_(\\{me_.id}->B, \\{key.id}, \\{existed.id});\\n\")\n\u0009case \"getList\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return *\\{me_.id}->I;\\n\")\n\u0009case \"getQueue\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"R_ r_ = \\{me_.id}->B.front();\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}->B.pop();\\n\")\n\u0009\u0009do codes.add(\"return r_;\\n\")\n\u0009case \"getStack\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"R_ r_ = \\{me_.id}->B.top();\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}->B.pop();\\n\")\n\u0009\u0009do codes.add(\"return r_;\\n\")\n\u0009case \"head\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->I = \\{me_.id}->B.begin();\\n\")\n\u0009case \"idx\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"int64_t i_ = 0;\\n\")\n\u0009\u0009do codes.add(\"for(auto& t_ = \\{me_.id}->B.begin(); t_ != \\{me_.id}->B.end(); ++t_){\\n\")\n\u0009\u0009do codes.add(\"if(t_ == \\{me_.id}->I) return i_;\\n\")\n\u0009\u0009do codes.add(\"i_++;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return -1;\\n\")\n\u0009case \"ins\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->B.insert(\\{me_.id}->I, \\{item.id});\\n\")\n\u0009case \"moveOffset\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var offset: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{offset.id} >= 0){\\n\")\n\u0009\u0009do codes.add(\"for(int64_t i_ = 0; i_ < \\{offset.id}; i_++){\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}->I == \\{me_.id}->B.end()) break;\\n\")\n\u0009\u0009do codes.add(\"++\\{me_.id}->I;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"for(int64_t i_ = 0; i_ > \\{offset.id}; i_--){\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}->I == \\{me_.id}->B.end()) break;\\n\")\n\u0009\u0009do codes.add(\"--\\{me_.id}->I;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"next\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"++\\{me_.id}->I;\\n\")\n\u0009case \"or\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id} | \\{n.id};\\n\")\n\u0009case \"peekQueue\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}->B.front();\\n\")\n\u0009case \"peekStack\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}->B.top();\\n\")\n\u0009case \"rnd\"\n\u0009\u0009do args.head()\n\u0009\u0009var min: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var max: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return rnd_(\\{min.id}, \\{max.id});\\n\")\n\u0009case \"rndFloat\"\n\u0009\u0009do args.head()\n\u0009\u0009var min: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var max: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return rndFloat_(\\{min.id}, \\{max.id});\\n\")\n\u0009case \"sub\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var start: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var len: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return sub_(\\{me_.id}, \\{start.id}, \\{len.id});\\n\")\n\u0009case \"sysTime\"\n\u0009\u0009do codes.add(\"return static_cast<int64_t>(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());\\n\")\n\u0009case \"tail\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->I = \\{me_.id}->B.end();\\n\")\n\u0009\u0009do codes.add(\"--\\{me_.id}->I;\\n\")\n\u0009case \"term\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}->I == \\{me_.id}->B.end();\\n\")\n\u0009case \"toBit64\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var success: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"std::u16string s_ = \\{me_.id}->B;\\n\")\n\u0009\u0009do codes.add(\"const std::string& t_ = utf16ToUtf8_(s_);\\n\")\n\u0009\u0009do codes.add(\"try{\\n\")\n\u0009\u0009do codes.add(\"size_t s_;\\n\")\n\u0009\u0009do codes.add(\"uint64_t v_ = t_.size() > 2 && t_[0] == \'0\' && t_[1] == \'x\' ? std::stoull(t_, &s_, 16) : std::stoull(t_, &s_);\\n\")\n\u0009\u0009do codes.add(\"if(s_ == t_.size()){\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = true;\\n\")\n\u0009\u0009do codes.add(\"return v_;\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = false;\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}catch(...){\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = false;\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"toFloat\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var success: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"std::u16string s_ = \\{me_.id}->B;\\n\")\n\u0009\u0009do codes.add(\"const std::string& t_ = utf16ToUtf8_(s_);\\n\")\n\u0009\u0009do codes.add(\"try{\\n\")\n\u0009\u0009do codes.add(\"size_t s_;\\n\")\n\u0009\u0009do codes.add(\"double v_ = std::stod(t_, &s_);\\n\")\n\u0009\u0009do codes.add(\"if(s_ == t_.size()){\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = true;\\n\")\n\u0009\u0009do codes.add(\"return v_;\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = false;\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}catch(...){\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = false;\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"toInt\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var success: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"std::u16string s_ = \\{me_.id}->B;\\n\")\n\u0009\u0009do codes.add(\"const std::string& t_ = utf16ToUtf8_(s_);\\n\")\n\u0009\u0009do codes.add(\"try{\\n\")\n\u0009\u0009do codes.add(\"size_t s_;\\n\")\n\u0009\u0009do codes.add(\"int64_t v_ = t_.size() > 2 && t_[0] == \'0\' && t_[1] == \'x\' ? std::stoll(t_, &s_, 16) : std::stoull(t_, &s_);\\n\")\n\u0009\u0009do codes.add(\"if(s_ == t_.size()){\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = true;\\n\")\n\u0009\u0009do codes.add(\"return v_;\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = false;\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}catch(...){\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = false;\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"toStr\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return toStr_(\\{me_.id});\\n\")\n\u0009case \"cui_print\"\n\u0009\u0009do args.head()\n\u0009\u0009var str: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"std::u16string s_ = \\{str.id}->B;\\n\")\n\u0009\u0009do codes.add(\"const std::string& t_ = utf16ToUtf8_(s_);\\n\")\n\u0009\u0009do codes.add(\"std::cout << t_ << std::flush;\\n\")\n\u0009case \"file_copyFile\"\n\u0009\u0009do args.head()\n\u0009\u0009var dst: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var src: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return copyFile_(\\{dst.id}->B, \\{src.id}->B);\\n\")\n\u0009case \"file_exist\"\n\u0009\u0009do args.head()\n\u0009\u0009var path: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"return false;\\n\")\n\u0009case \"file_forEach\"\n\u0009\u0009do args.head()\n\u0009\u0009var path: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var recursion: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var callback: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var data: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"return false;\\n\")\n\u0009case \"file_makeReader\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var path: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"\\{me_.id}->\\{handle.id} = reinterpret_cast<int64_t>(new reader_());\\n\")\n\u0009\u0009do codes.add(\"std::u16string s_ = \\{path.id}->B;\\n\")\n\u0009\u0009do codes.add(\"const std::string& t_ = utf16ToUtf8_(s_);\\n\")\n\u0009\u0009do codes.add(\"reader_* r_ = reinterpret_cast<reader_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"r_->F = new std::ifstream(t_.c_str(), std::ios::in | std::ios::binary);\\n\")\n\u0009\u0009do codes.add(\"if(!*r_->F) return nullptr;\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id};\\n\")\n\u0009case \"file_makeWriter\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var path: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var append: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"\\{me_.id}->\\{handle.id} = reinterpret_cast<int64_t>(new writer_());\\n\")\n\u0009\u0009do codes.add(\"std::u16string s_ = \\{path.id}->B;\\n\")\n\u0009\u0009do codes.add(\"const std::string& t_ = utf16ToUtf8_(s_);\\n\")\n\u0009\u0009do codes.add(\"writer_* r_ = reinterpret_cast<writer_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"r_->F = new std::ofstream(t_.c_str(), std::ios::out | std::ios::binary | (\\{append.id} ? std::ios::app : std::ios::trunc));\\n\")\n\u0009\u0009do codes.add(\"if(!*r_->F) return nullptr;\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id};\\n\")\n\u0009case \"file_readerFin\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"reader_* r_ = reinterpret_cast<reader_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"r_->F->close();\\n\")\n\u0009case \"file_readerGetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"reader_* r_ = reinterpret_cast<reader_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"return static_cast<int64_t>(r_->F->tellg());\\n\")\n\u0009case \"file_readerReadLetter\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"reader_* r_ = reinterpret_cast<reader_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"return readUtf8_(r_->F);\\n\")\n\u0009case \"file_readerSetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var origin: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var pos: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"reader_* r_ = reinterpret_cast<reader_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"std::ios_base::seekdir o_ = std::ios_base::beg;\\n\")\n\u0009\u0009do codes.add(\"switch(\\{origin.id}){\\n\")\n\u0009\u0009do codes.add(\"case 0: o_ = std::ios_base::beg; break;\\n\")\n\u0009\u0009do codes.add(\"case 1: o_ = std::ios_base::cur; break;\\n\")\n\u0009\u0009do codes.add(\"case 2: o_ = std::ios_base::end; break;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"r_->F->seekg(\\{pos.id}, o_);\\n\")\n\u0009case \"file_readerTerm\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"reader_* r_ = reinterpret_cast<reader_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"char c_;\\n\")\n\u0009\u0009do codes.add(\"if(r_->F->get(c_)) {\\n\")\n\u0009\u0009do codes.add(\"r_->F->seekg(-1, std::ios_base::cur);\\n\")\n\u0009\u0009do codes.add(\"return false;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return true;\\n\")\n\u0009case \"file_writerFin\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"writer_* r_ = reinterpret_cast<writer_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"r_->F->close();\\n\")\n\u0009case \"file_writerGetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"writer_* r_ = reinterpret_cast<writer_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"return static_cast<int64_t>(r_->F->tellp());\\n\")\n\u0009case \"file_writerSetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var origin: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var pos: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"writer_* r_ = reinterpret_cast<writer_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"std::ios_base::seekdir o_ = std::ios_base::beg;\\n\")\n\u0009\u0009do codes.add(\"switch(\\{origin.id}){\\n\")\n\u0009\u0009do codes.add(\"case 0: o_ = std::ios_base::beg; break;\\n\")\n\u0009\u0009do codes.add(\"case 1: o_ = std::ios_base::cur; break;\\n\")\n\u0009\u0009do codes.add(\"case 2: o_ = std::ios_base::end; break;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"r_->F->seekp(\\{pos.id}, o_);\\n\")\n\u0009case \"file_writerWrite\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"writer_* r_ = reinterpret_cast<writer_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"r_->F->write(reinterpret_cast<char*>(\\{n.id}->B), \\{n.id}->L);\\n\")\n\u0009case \"file_writerWriteChar\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"writer_* r_ = reinterpret_cast<writer_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"writeUtf8_(r_->F, \\{n.id});\\n\")\n\u0009case \"wnd_editBaseGetText\"\n\u0009\u0009; TODO:\n\u0009case \"wnd_makeEditMulti\"\n\u0009\u0009; TODO:\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\n\u0009\n\u0009func search(members: list<\\ast@AstClassItem>, name: []char): \\cpp\\output@CppInfo\n\u0009\u0009do members.head()\n\u0009\u0009while(!members.term())\n\u0009\u0009\u0009var def: \\ast@Ast :: members.get().def\n\u0009\u0009\u0009if(def.typeId = %var_ & (def $ \\ast@AstVar).arg.name <>& null & (def $ \\ast@AstVar).arg.name = name)\n\u0009\u0009\u0009\u0009ret \\cpp\\output@getInfo((def $ \\ast@AstVar).arg)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do members.next()\n\u0009\u0009end while\n\u0009\u0009assert false\n\u0009\u0009ret null\n\u0009end func\nend func\n";
else if(p==="res/err.kn")
return "+var errCnt: int\n\n+func err(id: \\msg@Id, pos: \\pos@Pos, args: [][]char)\n\u0009if(id < %_nonErrs & @errCnt >= 100)\n\u0009\u0009ret {Stop error detection at 100 pieces.}\n\u0009end if\n\u0009\n\u0009var msg: []char :: \\msg@get(id, args)\n\u0009do cui@print((id $ bit32).toStr() ~ \": \")\n\u0009if(pos <>& null)\n\u0009\u0009do cui@print(\"[\\{pos.srcName}: \\{pos.row}, \\{pos.col}]\")\n\u0009end if\n\u0009do cui@print(msg ~ \"\\n\")\n\u0009if(id < %_nonErrs)\n\u0009\u0009do @errCnt :+ 1\n\u0009end if\nend func\n";
else if(p==="res/main.kn")
return "const major: int :: 2019\nconst minor: int :: 10\nconst micro: int :: 17\n\nfunc main()\n\u0009if(!\\option@acquireOption())\n\u0009\u0009do lib@exitCode(1)\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009if(\\option@version)\n\u0009\u0009do cui@print(\"Kuin Programming Language v.\\{@major}.\\{@minor}.\\{@micro}\\n\")\n\u0009\u0009do cui@print(\"(C)Kuina-chan\\n\")\n\u0009\u0009do lib@exitCode(0)\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009if(\\option@help | \\option@inputFile =& null)\n\u0009\u0009do cui@print(\"Usage: kuincl [-i input.kn] [-o output.kn] [-s \'sys\' directory] [-c icon.ico] [-e environment] [-a appcode] [-r] [-h] [-v] [-q]\\n\")\n\u0009\u0009do lib@exitCode(0)\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009if(@build())\n\u0009\u0009do \\err@err(%success, null, null)\n\u0009\u0009do lib@exitCode(0)\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009if(!\\option@quiet)\n\u0009\u0009do \\err@err(%failure, null, null)\n\u0009end if\n\u0009do lib@exitCode(1)\nend func\n\nfunc build(): bool\n\u0009var asts: dict<[]char, \\ast@Ast>\n\u0009var entry: \\ast@AstFunc\n\u0009\n\u0009do \\err@errCnt :: 0\n\u0009var beginTime: int :: lib@sysTime()\n\u0009do \\err@err(%compilationStarted, null, [((lib@sysTime() - beginTime) $ float / 1000.0).toStr()])\n\u0009\n\u0009; \'Parse\'\n\u0009do asts :: \\parse@parse()\n\u0009do \\err@err(%parsingCompleted, null, [((lib@sysTime() - beginTime) $ float / 1000.0).toStr()])\n\u0009\n\u0009; \'Analyze\'\n\u0009do entry :: \\analyze@analyze(asts)\n\u0009do \\err@err(%semanticAnalysisCompleted, null, [((lib@sysTime() - beginTime) $ float / 1000.0).toStr()])\n\u0009\n\u0009; Stop compilation if some errors occur.\n\u0009if(\\err@errCnt > 0)\n\u0009\u0009ret false\n\u0009end if\n\u0009\n\u0009; \'Res\' files.\n\u0009var resDir: []char :: \\option@inputDir ~ \"res/\"\n\u0009class ResFiles()\n\u0009\u0009+var files: list<[]char>\n\u0009end class\n\u0009var resFiles: ResFiles :: #ResFiles\n\u0009do resFiles.files :: #list<[]char>\n\u0009if(file@exist(resDir))\n\u0009\u0009do file@forEach(resDir, true, searchResFiles, resFiles)\n\u0009end if\n\u0009\n\u0009; \'Output\'\n\u0009switch(\\option@env_)\n\u0009case %cpp\n\u0009\u0009if(!\\cpp\\output@output(entry, resFiles.files))\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009case %web\n\u0009\u0009if(!\\web\\output@output(entry, resFiles.files))\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\n\u0009\n\u0009do \\err@err(%generationProcessCompleted, null, [((lib@sysTime() - beginTime) $ float / 1000.0).toStr()])\n\u0009\n\u0009ret true\n\u0009\n\u0009func searchResFiles(path: []char, isDir: bool, data: kuin@Class): bool\n\u0009\u0009if(!isDir)\n\u0009\u0009\u0009var data2: ResFiles :: data $ ResFiles\n\u0009\u0009\u0009do data2.files.add(path)\n\u0009\u0009end if\n\u0009\u0009ret true\n\u0009end func\nend func\n";
else if(p==="res/msg.kn")
return "+var lang: @Lang :: %en\n\n+enum Lang\n\u0009ja\n\u0009en\nend enum\n\n+enum Id\n\u0009_generalErrs :: 0x00000000\n\u0009incorrectOption\n\u0009unexpectedOption\n\u0009incorrectExt\n\u0009incorrectSrcName\n\u0009fileOpenFailed\n\u0009sysFileOpenFailed\n\u0009sysFileBroken\n\u0009\n\u0009_parsingErrs :: 0x00010000\n\u0009sameIdentifierInSameScope\n\u0009sameIdentifierInUpperScope\n\u0009noBrace\n\u0009tabInStr\n\u0009lineBreakInStr\n\u0009wrongCharacterInIdentifier\n\u0009wrongAtInIdentifier\n\u0009uppercaseFileName\n\u0009wrongBackslashInIdentifier\n\u0009tooLongIdentifier\n\u0009incorrectBlockOrSentence\n\u0009wrongCharacterInFuncAttr\n\u0009tooLongFuncAttr\n\u0009charShouldBeWritten\n\u0009noEnd\n\u0009overrideNonFunctionMember\n\u0009exposeNonFunctionOrVariableMember\n\u0009wrongEnd\n\u0009wrongMember\n\u0009ampersandInNonArgument\n\u0009initializerInArgument\n\u0009initializerInMember\n\u0009noInitializerInConst\n\u0009noEndUnspecified\n\u0009wrongEndUnspecified\n\u0009nonCorrespondingEnd\n\u0009elifOrElseAfterElse\n\u0009caseOrDefaultAfterDefault\n\u0009catchOrFinallyAfterFinally\n\u0009wrongClause\n\u0009wrongClauseInSwitch\n\u0009wrongWord\n\u0009wrongOperator\n\u0009tooLongStringLiteral\n\u0009wrongEscSequence\n\u0009wrongCharCodeRepresentation\n\u0009nonClosingStrLiteral\n\u0009tooLongCharLiteral\n\u0009emptyCharLiteral\n\u0009noParenthesis\n\u0009wrongNumericLiteral\n\u0009tooLongNumericLiteral\n\u0009wrongHexadecimalLiteral\n\u0009wrongExponentialNotationLiteral\n\u0009wrongFloatingPointLiteral\n\u0009wrongBitTypeLiteral\n\u0009integerLiteralOverflowed\n\u0009\n\u0009_analysisErrs :: 0x00020000\n\u0009noMainFunc\n\u0009wrongMainFunc\n\u0009accessMemberWithoutMe\n\u0009nonOmittingAt\n\u0009accessUnpublishedElement\n\u0009identifierNotFound\n\u0009circulatingAlias\n\u0009circulatingClass\n\u0009overridedMemberNotFound\n\u0009memberDuplicatedWithParentClass\n\u0009overridingNonFunc\n\u0009overriddenMemberNotMatchAccessModifier\n\u0009overriddenMemberNotMatchTypeOrArg\n\u0009notAllowedToBeOverridden\n\u0009enumValueMustBeInt\n\u0009enumValueExceedIntRange\n\u0009enumValueDuplicated\n\u0009notExistedElementName\n\u0009valueOfGlobalVarMustBeConst\n\u0009valueOfConstMustBeConst\n\u0009varAndValueTypeNotMatch\n\u0009ifCondMustBeBool\n\u0009elIfCondMustBeBool\n\u0009switchCondMustBeComparable\n\u0009caseCondNotMatchSwitch\n\u0009whileCondMustBeBool\n\u0009forBeginValueMustBeInt\n\u0009forEndValueMustBeInt\n\u0009forIncreaseDecreaseValueMustBeInt\n\u0009forIncreaseDecreaseValueMustBeConst\n\u0009forIncreaseDecreaseValueMustBeOtherThanZero\n\u0009catchCondMustBeConstInt\n\u0009excptCodeMustBeInt\n\u0009mustRetValue\n\u0009retTypeNotMatchFunc\n\u0009noSideEffectDo\n\u0009mustSpecifyBlockName\n\u0009assertCondMustBeBool\n\u0009nonTypeWritten\n\u0009noValuePassed\n\u0009wrongOperatorType\n\u0009wrongLeftValueOfAssignOperator\n\u0009comparingNullByValue\n\u0009enumTypeNotInferred\n\u0009concatNull\n\u0009dividedBy0\n\u0009wrongLeftOrRightValueOfSwapOperator\n\u0009condForCondOperatorMustBeBool\n\u0009twoValueForCondOperatorMustSameType\n\u0009wrongTypeForNewOperator\n\u0009numOfElementsMustBeInt\n\u0009callNonFunction\n\u0009wrongArgNumInFunc\n\u0009nonRefArgPassed\n\u0009wrongArgTypeInFunc\n\u0009nonArrayAccess\n\u0009arrayIdxMustBeInt\n\u0009memberNotExist\n\u0009refUnpublishedMember\n\u0009elementTypesOfArrayInitNotMatch\n\u0009nullForValueTypeArrayInit\n\u0009allElementsAreEnum\n\u0009allElementsAreNull\n\u0009inaccessibleElement\n\u0009\n\u0009_nonErrs :: 0x00030000\n\u0009success\n\u0009failure\n\u0009compilationStarted\n\u0009parsingCompleted\n\u0009semanticAnalysisCompleted\n\u0009generationProcessCompleted\nend enum\n\n+func get(id: @Id, args: [][]char): []char\n\u0009switch(id)\n\u0009case %incorrectOption\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30AA\u30D7\u30B7\u30E7\u30F3\u300C\\{args[0]}\u300D\u306E\u4F7F\u308F\u308C\u65B9\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The option \'\\{args[0]}\' was used incorrectly.\"\n\u0009\u0009end switch\n\u0009case %unexpectedOption\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u4E0D\u660E\u306A\u30AA\u30D7\u30B7\u30E7\u30F3\u300C\\{args[0]}\u300D\u304C\u6307\u5B9A\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Unexpected option: \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %incorrectExt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5165\u529B\u30D5\u30A1\u30A4\u30EB\u300C\\{args[0]}\u300D\u306E\u62E1\u5F35\u5B50\u306F\u300C.kn\u300D\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The extension of the input file \'\\{args[0]}\' must be \'.kn\'.\"\n\u0009\u0009end switch\n\u0009case %incorrectSrcName\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u540D\u300C\\{args[0]}\u300D\u306B\u4F7F\u3048\u306A\u3044\u6587\u5B57\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The source file name \'\\{args[0]}\' contains characters that cannot be used.\"\n\u0009\u0009end switch\n\u0009case %fileOpenFailed\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u300C\\{args[0]}\u300D\u304C\u958B\u3051\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Cannot open source file \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %sysFileOpenFailed\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30B7\u30B9\u30C6\u30E0\u30D5\u30A1\u30A4\u30EB\u300C\\{args[0]}\u300D\u304C\u958B\u3051\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The system file \'\\{args[0]}\' could not be opened.\"\n\u0009\u0009end switch\n\u0009case %sysFileBroken\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30B7\u30B9\u30C6\u30E0\u30D5\u30A1\u30A4\u30EB\u300C\\{args[0]}\u300D\u304C\u58CA\u308C\u3066\u3044\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The system file \'\\{args[0]}\' is broken.\"\n\u0009\u0009end switch\n\u0009case %sameIdentifierInSameScope\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u540C\u3058\u30B9\u30B3\u30FC\u30D7\u5185\u306B\u65E2\u306B\u540C\u3058\u8B58\u5225\u5B50\u300C\\{args[0]}\u300D\u304C\u5B58\u5728\u3057\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The same identifier \'\\{args[0]}\' already exists in the same scope.\"\n\u0009\u0009end switch\n\u0009case %sameIdentifierInUpperScope\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u4E0A\u4F4D\u306E\u30B9\u30B3\u30FC\u30D7\u5185\u306B\u65E2\u306B\u540C\u3058\u8B58\u5225\u5B50\u300C\\{args[0]}\u300D\u304C\u5B58\u5728\u3057\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The same identifier \'\\{args[0]}\' already exists in the upper scope.\"\n\u0009\u0009end switch\n\u0009case %noBrace\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30B3\u30E1\u30F3\u30C8\u306E\u300C{\u300D\u306B\u5BFE\u5FDC\u3059\u308B\u300C}\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"There is no \'}\' corresponding to \'{\' for comment.\"\n\u0009\u0009end switch\n\u0009case %tabInStr\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3084\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u4E2D\u306B\u30BF\u30D6\u6587\u5B57\u306F\u8A18\u8FF0\u3067\u304D\u307E\u305B\u3093\u3002 \u30A8\u30B9\u30B1\u30FC\u30D7\u30B7\u30FC\u30B1\u30F3\u30B9\u300C\\\\t\u300D\u3092\u4EE3\u7528\u3057\u3066\u304F\u3060\u3055\u3044\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Tab characters cannot be written in character literals and string literals. Use the escape sequence \'\\\\t\' instead.\"\n\u0009\u0009end switch\n\u0009case %lineBreakInStr\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3084\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u4E2D\u3067\u306F\u6539\u884C\u3067\u304D\u307E\u305B\u3093\u3002 \u30A8\u30B9\u30B1\u30FC\u30D7\u30B7\u30FC\u30B1\u30F3\u30B9\u300C\\\\n\u300D\u3092\u4EE3\u7528\u3057\u3066\u304F\u3060\u3055\u3044\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Line breaks are not allowed in character literals and string literals. Use the escape sequence \'\\\\n\' instead.\"\n\u0009\u0009end switch\n\u0009case %wrongCharacterInIdentifier\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u8B58\u5225\u5B50\u306B\u306F\u4F7F\u3048\u306A\u3044\u6587\u5B57\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The character \'\\{args[0]}\' that cannot be used in identifiers was written.\"\n\u0009\u0009end switch\n\u0009case %wrongAtInIdentifier\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u8B58\u5225\u5B50\u306B\u6B63\u3057\u304F\u306A\u3044\u5F62\u5F0F\u3067\u300C@\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Incorrect \'@\' was written in an identifier.\"\n\u0009\u0009end switch\n\u0009case %uppercaseFileName\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u540D\u306E\u6307\u5B9A\u300C\\{args[0]}\u300D\u306B\u5927\u6587\u5B57\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A source file name description \'\\{args[0]}\' contains uppercase letters.\"\n\u0009\u0009end switch\n\u0009case %wrongBackslashInIdentifier\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u8B58\u5225\u5B50\u306B\u6B63\u3057\u304F\u306A\u3044\u5F62\u5F0F\u3067\u300C\\\\\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Incorrect \'\\\\\' was written in an identifier.\"\n\u0009\u0009end switch\n\u0009case %tooLongIdentifier\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u8B58\u5225\u5B50\u300C\\{args[0]}...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 128\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The identifier \'\\{args[0]}...\' is too long. Must be 128 characters or less.\"\n\u0009\u0009end switch\n\u0009case %incorrectBlockOrSentence\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u30D6\u30ED\u30C3\u30AF\u3082\u3057\u304F\u306F\u6587\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An incorrect block or sentence \'\\{args[0]}\' was written.\"\n\u0009\u0009end switch\n\u0009case %wrongCharacterInFuncAttr\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u5C5E\u6027\u306B\u306F\u4F7F\u3048\u306A\u3044\u6587\u5B57\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The character \'\\{args[0]}\' that cannot be used in function attributes was written.\"\n\u0009\u0009end switch\n\u0009case %tooLongFuncAttr\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u5C5E\u6027\u300C\\{args[0]}...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 128\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The function attribute \'\\{args[0]}...\' is too long. Must be 128 characters or less.\"\n\u0009\u0009end switch\n\u0009case %charShouldBeWritten\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u308B\u3079\u304D\u7B87\u6240\u306B\u3001\u4E0D\u6B63\u306A\u6587\u5B57\u300C\\{args[1]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An invalid character \'\\{args[1]}\' was written in a place where the character \'\\{args[0]}\' should be written.\"\n\u0009\u0009end switch\n\u0009case %noEnd\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\\{args[0]}\u300D\u306B\u5BFE\u5FDC\u3059\u308B\u300Cend \\{args[0]}\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"There is no \'end \\{args[0]}\' corresponding to \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %overrideNonFunctionMember\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u4EE5\u5916\u306E\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Overridden non-function member \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %exposeNonFunctionOrVariableMember\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u304A\u3088\u3073\u5909\u6570\u4EE5\u5916\u306E\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3092\u516C\u958B\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The member \'\\{args[0]}\' other than functions and variables has been released.\"\n\u0009\u0009end switch\n\u0009case %wrongEnd\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\\{args[0]}\u300D\u304C\u300Cend \\{args[0]}\u300D\u3067\u306F\u306A\u304F\u4E0D\u6B63\u306A\u300Cend \\{args[1]}\u300D\u3067\u9589\u3058\u3089\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'\\{args[0]}\' was closed with invalid \'end \\{args[1]}\' instead of \'end \\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %wrongMember\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6B63\u3057\u304F\u306A\u3044\u5F62\u5F0F\u306E\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Incorrectly formatted member \'\\{args[0]}\' was written.\"\n\u0009\u0009end switch\n\u0009case %ampersandInNonArgument\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5F15\u6570\u4EE5\u5916\u306E\u5909\u6570\u306B\u4E0D\u6B63\u306A\u300C&\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An invalid \'&\' was written in other than an argument.\"\n\u0009\u0009end switch\n\u0009case %initializerInArgument\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5F15\u6570\u306B\u521D\u671F\u5316\u5B50\u300C::\u300D\u3092\u8A18\u8FF0\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The initializer \'::\' cannot be written in arguments.\"\n\u0009\u0009end switch\n\u0009case %initializerInMember\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30E1\u30F3\u30D0\u306B\u521D\u671F\u5316\u5B50\u300C::\u300D\u3092\u8A18\u8FF0\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The initializer \'::\' cannot be written in members.\"\n\u0009\u0009end switch\n\u0009case %noInitializerInConst\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"const\u6587\u306B\u306F\u521D\u671F\u5316\u5B50\u300C::\u300D\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The initializer \'::\' must be written in const statements.\"\n\u0009\u0009end switch\n\u0009case %noEndUnspecified\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30D6\u30ED\u30C3\u30AF\u306B\u5BFE\u5FDC\u3059\u308B\u300Cend\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"There is no \'end\' corresponding to a block.\"\n\u0009\u0009end switch\n\u0009case %wrongEndUnspecified\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cend \\{args[0]}\u300D\u306F\u4E0D\u6B63\u306A\u5F62\u5F0F\u3067\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'end \\{args[0]}\' is incorrectly formatted.\"\n\u0009\u0009end switch\n\u0009case %nonCorrespondingEnd\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30D6\u30ED\u30C3\u30AF\u3068\u5BFE\u5FDC\u3057\u306A\u3044\u4E0D\u6B63\u306A\u300Cend \\{args[0]}\u300D\u3067\u9589\u3058\u3089\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Closed with invalid \'end \\{args[0]}\' that does not correspond to the block.\"\n\u0009\u0009end switch\n\u0009case %elifOrElseAfterElse\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cif\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Celse\u300D\u7BC0\u306E\u5F8C\u306B\u4E0D\u6B63\u306A\u300Celif\u300D\u7BC0\u3084\u300Celse\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"In an \'if\' block, an invalid \'elif\' or \'else\' clauses is written after an \'else\' clause.\"\n\u0009\u0009end switch\n\u0009case %caseOrDefaultAfterDefault\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Cdefault\u300D\u7BC0\u306E\u5F8C\u306B\u4E0D\u6B63\u306A\u300Ccase\u300D\u7BC0\u3084\u300Cdefault\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"In a \'switch\' block, an invalid \'case\' or \'default\' clauses is written after a \'default\' clause.\"\n\u0009\u0009end switch\n\u0009case %catchOrFinallyAfterFinally\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Ctry\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Cfinally\u300D\u7BC0\u306E\u5F8C\u306B\u4E0D\u6B63\u306A\u300Ccatch\u300D\u7BC0\u3084\u300Cfinally\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"In a \'try\' block, an invalid \'catch\' or \'finally\' clauses is written after a \'finally\' clause.\"\n\u0009\u0009end switch\n\u0009case %wrongClause\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\\{args[0]}\u300D\u30D6\u30ED\u30C3\u30AF\u4EE5\u5916\u3067\u4E0D\u6B63\u306A\u300C\\{args[1]}\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A invalid \'\\{args[1]}\' clause was written outside \'\\{args[0]}\' blocks.\"\n\u0009\u0009end switch\n\u0009case %wrongClauseInSwitch\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Ccase\u300D\u300Cdefault\u300D\u300Cend switch\u300D\u306E\u3044\u305A\u308C\u304B\u304C\u8A18\u8FF0\u3055\u308C\u308B\u3079\u304D\u7B87\u6240\u306B\u305D\u308C\u4EE5\u5916\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"In a \'switch\' block, clauses other than \'case\', \'default\' and \'end switch\' were written.\"\n\u0009\u0009end switch\n\u0009case %wrongWord\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u308B\u3079\u304D\u7B87\u6240\u306B\u4E0D\u6B63\u306A\u300C\\{args[1]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An invalid \'\\{args[1]}\' was written where \'\\{args[0]}\' should be written.\"\n\u0009\u0009end switch\n\u0009case %wrongOperator\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u6F14\u7B97\u5B50\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An incorrect operator \'\\{args[0]}\' was written.\"\n\u0009\u0009end switch\n\u0009case %tooLongStringLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u300C\\{args[0]}...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 1024\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The string literal \'\\{args[0]}\' is too long. Must be 1024 characters or less.\"\n\u0009\u0009end switch\n\u0009case %wrongEscSequence\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u30A8\u30B9\u30B1\u30FC\u30D7\u30B7\u30FC\u30B1\u30F3\u30B9\u300C\\\\\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A invalid escape sequence \'\\\\\\{args[0]}\' was written.\"\n\u0009\u0009end switch\n\u0009case %wrongCharCodeRepresentation\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u30B3\u30FC\u30C9\u8868\u8A18\u306F\u300C\\\\u\u300D\u306B\u7D9A\u3044\u3066\u3001\u6570\u5B57\u307E\u305F\u306F\u5927\u6587\u5B57\u30A2\u30EB\u30D5\u30A1\u30D9\u30C3\u30C8\u30674\u6841\u306E16\u9032\u6570\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Character code representations must be \'\\\\u\' followed by a 4-digit hexadecimal number in numbers or capital letters.\"\n\u0009\u0009end switch\n\u0009case %nonClosingStrLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3082\u3057\u304F\u306F\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u304C\u9589\u3058\u3089\u308C\u3066\u3044\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A character literal or string literal is not closed.\"\n\u0009\u0009end switch\n\u0009case %tooLongCharLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u300C\\{args[0]}...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 1\u6587\u5B57\u5206\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The character literal \'\\{args[0]}...\' is too long. A character literal must contain one character.\"\n\u0009\u0009end switch\n\u0009case %emptyCharLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u304C\u7A7A\u3067\u3059\u3002 1\u6587\u5B57\u5206\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"There is an empty character literal. A character literal must contain one character.\"\n\u0009\u0009end switch\n\u0009case %noParenthesis\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u62EC\u5F27\u300C(\u300D\u306B\u5BFE\u5FDC\u3059\u308B\u300C)\u300D\u304C\u3001\u3042\u308B\u3079\u304D\u5834\u6240\u306B\u5B58\u5728\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The \')\' corresponding to the parenthesis \'(\' does not exist where it should be.\"\n\u0009\u0009end switch\n\u0009case %wrongNumericLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6570\u5024\u30EA\u30C6\u30E9\u30EB\u306B\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An invalid \'\\{args[0]}\' was written in a numeric literal.\"\n\u0009\u0009end switch\n\u0009case %tooLongNumericLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6570\u5024\u30EA\u30C6\u30E9\u30EB\u300C\\{args[0]}...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 1024\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The numeric literal \'\\{args[0]}\' is too long. Must be 1024 characters or less.\"\n\u0009\u0009end switch\n\u0009case %wrongHexadecimalLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"16\u9032\u6570\u30EA\u30C6\u30E9\u30EB\u306F\u300C0x\u300D\u304B\u3089\u59CB\u3081\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Hexadecimal literals must start with \'0x\'.\"\n\u0009\u0009end switch\n\u0009case %wrongExponentialNotationLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6307\u6570\u8868\u8A18\u30EA\u30C6\u30E9\u30EB\u306F\u300Ce+\u300D\u3082\u3057\u304F\u306F\u300Ce-\u300D\u304B\u3089\u59CB\u3081\u3066\u6307\u6570\u90E8\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Exponential notation literals must start with \'e+\' or \'e-\' and write the exponent part.\"\n\u0009\u0009end switch\n\u0009case %wrongFloatingPointLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6D6E\u52D5\u5C0F\u6570\u70B9\u30EA\u30C6\u30E9\u30EB\u300C\\{args[0]}\u300D\u304C\u89E3\u91C8\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002 \u5024\u304C\u5927\u304D\u3059\u304E\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The floating point literal \'\\{args[0]}\' could not be interpreted. The value may be too large.\"\n\u0009\u0009end switch\n\u0009case %wrongBitTypeLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30D3\u30C3\u30C8\u578B\u30EA\u30C6\u30E9\u30EB\u300C\\{args[0]}\u300D\u306E\u63A5\u5C3E\u8F9E\u306F\u300Cb8\u300D\u300Cb16\u300D\u300Cb32\u300D\u300Cb64\u300D\u306E\u3044\u305A\u308C\u304B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The suffix of bit type literal \'\\{args[0]}\' must be either \'b8\', \'b16\', \'b32\' or \'b64\'.\"\n\u0009\u0009end switch\n\u0009case %integerLiteralOverflowed\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6574\u6570\u30EA\u30C6\u30E9\u30EB\u300C\\{args[0]}\u300D\u304C\u30AA\u30FC\u30D0\u30FC\u30D5\u30ED\u30FC\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The integer literal \'\\{args[0]}\' has overflowed.\"\n\u0009\u0009end switch\n\u0009case %noMainFunc\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cmain\u300D\u95A2\u6570\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002 \u30B3\u30F3\u30D1\u30A4\u30EB\u3059\u308B\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u306B\u300Cfunc main()\u300D\u3092\u5B9A\u7FA9\u3057\u3066\u304F\u3060\u3055\u3044\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'main\' function does not exist. Define \'func main()\' in the source files to be compiled.\"\n\u0009\u0009end switch\n\u0009case %wrongMainFunc\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cmain\u300D\u95A2\u6570\u306E\u5B9A\u7FA9\u306F\u300Cfunc main()\u300D\u3068\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The definition of the \'main\' function must be \'func main()\'.\"\n\u0009\u0009end switch\n\u0009case %accessMemberWithoutMe\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30E1\u30F3\u30D0\u3082\u3057\u304F\u306F\u5909\u6570\u300C\\{args[0]}\u300D\u306B\u3001\u300Cme\u300D\u3092\u4ECB\u3055\u305A\u76F4\u63A5\u30A2\u30AF\u30BB\u30B9\u3057\u305F\u304B\u3001\u95A2\u6570\u3092\u8D85\u3048\u3066\u30A2\u30AF\u30BB\u30B9\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The member or variable \'\\{args[0]}\' was accessed directly without \'me\', or accessed beyond the function.\"\n\u0009\u0009end switch\n\u0009case %nonOmittingAt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\\{args[0]}@\u300D\u306B\u3064\u3044\u3066\u3001\u81EA\u8EAB\u306E\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u306E\u30B0\u30ED\u30FC\u30D0\u30EB\u8981\u7D20\u3092\u53C2\u7167\u3059\u308B\u3068\u304D\u306F\u3001\u300C@\u300D\u306E\u524D\u306E\u30BD\u30FC\u30B9\u540D\u3092\u7701\u7565\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"For \'\\{args[0]}@\', when referring to global elements in its own source file, the source name before the \'@\' must be omitted.\"\n\u0009\u0009end switch\n\u0009case %accessUnpublishedElement\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u4ED6\u306E\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u306E\u516C\u958B\u3055\u308C\u3066\u3044\u306A\u3044\u8981\u7D20\u300C\\{args[0]}\u300D\u3092\u53C2\u7167\u3057\u307E\u3057\u305F\u3002\u8981\u7D20\u306E\u5148\u982D\u306B\u300C+\u300D\u304C\u4ED8\u3044\u3066\u3044\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A non-public element \'\\{args[0]}\' in another souce file was referenced. The element must start with a \'+\'.\"\n\u0009\u0009end switch\n\u0009case %identifierNotFound\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u8B58\u5225\u5B50\u300C\\{args[0]}\u300D\u306E\u5B9A\u7FA9\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002\u540D\u524D\u3092\u9593\u9055\u3048\u3066\u3044\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The definition of identifier \'\\{args[0]}\' was not be found. The name may have been written incorrectly.\"\n\u0009\u0009end switch\n\u0009case %circulatingAlias\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Calias \\{args[0]}\u300D\u306E\u5B9A\u7FA9\u304C\u5FAA\u74B0\u3057\u3066\u3044\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The definition of \'alias \\{args[0]}\' is circulating.\"\n\u0009\u0009end switch\n\u0009case %circulatingClass\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cclass \\{args[0]}\u300D\u306E\u7D99\u627F\u304C\u5FAA\u74B0\u3057\u3066\u3044\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The inheritance of \'class \\{args[0]}\' is circulating.\"\n\u0009\u0009end switch\n\u0009case %overridedMemberNotFound\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B\u89AA\u30AF\u30E9\u30B9\u306E\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The member \'\\{args[0]}\' of the parent class to override cannot be found.\"\n\u0009\u0009end switch\n\u0009case %memberDuplicatedWithParentClass\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30E1\u30F3\u30D0\u540D\u300C\\{args[0]}\u300D\u304C\u89AA\u30AF\u30E9\u30B9\u306E\u3082\u306E\u3068\u91CD\u8907\u3057\u3066\u3044\u307E\u3059\u3002 \u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B\u5834\u5408\u306F\u300C*\u300D\u3092\u4ED8\u3051\u3066\u304F\u3060\u3055\u3044\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The member name \'\\{args[0]}\' is duplicated with that of the parent class. Add \'*\' when overriding.\"\n\u0009\u0009end switch\n\u0009case %overridingNonFunc\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u4EE5\u5916\u306E\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Overridden non-function member \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %overriddenMemberNotMatchAccessModifier\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u305F\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3068\u30A2\u30AF\u30BB\u30B9\u4FEE\u98FE\u5B50\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The access modifier does not match that of the overridden member \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %overriddenMemberNotMatchTypeOrArg\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u305F\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3068\u578B\u3082\u3057\u304F\u306F\u5F15\u6570\u540D\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The types or argument names do not match that of the overridden member \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %notAllowedToBeOverridden\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u304C\u8A31\u53EF\u3055\u308C\u3066\u3044\u306A\u3044\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The member \'\\{args[0]}\' that is not allowed to be overridden was overridden.\"\n\u0009\u0009end switch\n\u0009case %enumValueMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5217\u6319\u578B\u300C\\{args[0]}\u300D\u306E\u8981\u7D20\u300C%\\{args[1]}\u300D\u306E\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u300Cint\u300D\u578B\u306E\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The value of the element \'%\\{args[1]}\' of enumeration type \'\\{args[0]}\' must be an \'int\' value that can be made a constant at compile time.\"\n\u0009\u0009end switch\n\u0009case %enumValueExceedIntRange\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5217\u6319\u578B\u300C\\{args[0]}\u300D\u306E\u8981\u7D20\u300C%\\{args[1]}\u300D\u306E\u5024\u304C\u300Cint\u300D\u578B\u306E\u6709\u52B9\u7BC4\u56F2\u3092\u8D85\u3048\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The value of the element \'%\\{args[1]}\' of enumeration type \'\\{args[0]}\' exceeds the valid range of \'int\' type.\"\n\u0009\u0009end switch\n\u0009case %enumValueDuplicated\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5217\u6319\u578B\u300C\\{args[0]}\u300D\u306E\u8981\u7D20\u300C%\\{args[1]}\u300D\u306E\u5024\u300C\\{args[2]}\u300D\u304C\u5225\u306E\u8981\u7D20\u306E\u5024\u3068\u91CD\u8907\u3057\u3066\u3044\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The value \'\\{args[2]}\' of the element \'%\\{args[1]}\' of enumeration type \'\\{args[0]}\' is duplicated with the value of another element.\"\n\u0009\u0009end switch\n\u0009case %notExistedElementName\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5217\u6319\u578B\u5185\u306B\u5B58\u5728\u3057\u306A\u3044\u8981\u7D20\u540D\u300C%\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The element name \'%\\{args[0]}\' that does not exist in the enumeration type was written.\"\n\u0009\u0009end switch\n\u0009case %valueOfGlobalVarMustBeConst\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30B0\u30ED\u30FC\u30D0\u30EB\u5909\u6570\u300C\\{args[0]}\u300D\u306E\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The value of global variable \'\\{args[0]}\' must be a constant at compile time.\"\n\u0009\u0009end switch\n\u0009case %valueOfConstMustBeConst\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cconst\u300D\u6587\u300C\\{args[0]}\u300D\u306E\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The value of \'const\' statement \'\\{args[0]}\' must be a constant at compile time.\"\n\u0009\u0009end switch\n\u0009case %varAndValueTypeNotMatch\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5909\u6570\u300C\\{args[0]}\u300D\u306E\u578B\u3068\u5024\u306E\u578B\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type of the variable \'\\{args[0]}\' does not match the value type.\"\n\u0009\u0009end switch\n\u0009case %ifCondMustBeBool\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cif\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The conditional expression of the \'if\' block must be \'bool\' type.\"\n\u0009\u0009end switch\n\u0009case %elIfCondMustBeBool\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Celif\u300D\u7BC0\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The conditional expression of the \'elif\' clause must be \'bool\' type.\"\n\u0009\u0009end switch\n\u0009case %switchCondMustBeComparable\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306F\u6BD4\u8F03\u53EF\u80FD\u306A\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The conditional expression of the \'switch\' block must be a comparable type.\"\n\u0009\u0009end switch\n\u0009case %caseCondNotMatchSwitch\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Ccase\u300D\u7BC0\u306E\u578B\u304C\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306E\u578B\u3068\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type of the \'case\' clause does not match the type of the conditional expression in the \'switch\' block.\"\n\u0009\u0009end switch\n\u0009case %whileCondMustBeBool\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cwhile\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The conditional expression of the \'while\' block must be \'bool\' type.\"\n\u0009\u0009end switch\n\u0009case %forBeginValueMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u521D\u671F\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The begin value of the \'for\' block must be \'int\' type.\"\n\u0009\u0009end switch\n\u0009case %forEndValueMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u7D42\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The end value of the \'for\' block must be \'int\' type.\"\n\u0009\u0009end switch\n\u0009case %forIncreaseDecreaseValueMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u5897\u6E1B\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The increase / decrease value of the \'for\' block must be \'int\' type.\"\n\u0009\u0009end switch\n\u0009case %forIncreaseDecreaseValueMustBeConst\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u5897\u6E1B\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The increase / decrease value of the \'for\' block must be a constant at compile time.\"\n\u0009\u0009end switch\n\u0009case %forIncreaseDecreaseValueMustBeOtherThanZero\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u5897\u6E1B\u5024\u306F\u300C0\u300D\u4EE5\u5916\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The increase / decrease value of the \'for\' block must be other than \'0\'.\"\n\u0009\u0009end switch\n\u0009case %catchCondMustBeConstInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Ccatch\u300D\u7BC0\u306E\u6761\u4EF6\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u300Cint\u300D\u578B\u306E\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The condition value in the \'catch\' clause must be an \'int\' value that can be a constant at compile time.\"\n\u0009\u0009end switch\n\u0009case %excptCodeMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cthrow\u300D\u6587\u306E\u4F8B\u5916\u30B3\u30FC\u30C9\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The exception code for the \'throw\' statement must be \'int\'.\"\n\u0009\u0009end switch\n\u0009case %mustRetValue\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u623B\u308A\u5024\u3092\u8FD4\u3059\u95A2\u6570\u3067\u306F\u300Cret\u300D\u6587\u306F\u5024\u3092\u8FD4\u3055\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"For functions that return a value, \'ret\' statements must return a value.\"\n\u0009\u0009end switch\n\u0009case %retTypeNotMatchFunc\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cret\u300D\u6587\u306E\u5024\u306E\u578B\u304C\u95A2\u6570\u306E\u623B\u308A\u5024\u306E\u578B\u3068\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type of the \'ret\' statement does not match the return type of the function.\"\n\u0009\u0009end switch\n\u0009case %noSideEffectDo\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cdo\u300D\u6587\u3067\u6700\u5F8C\u306B\u884C\u3046\u6F14\u7B97\u306F\u300C::\u300D\u6F14\u7B97\u5B50\u3084\u95A2\u6570\u547C\u3073\u51FA\u3057\u306A\u3069\u306E\u526F\u4F5C\u7528\u306E\u3042\u308B\u6F14\u7B97\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The last operation in \'do\' statements must be with side effects such as \'::\' operator or function calls.\"\n\u0009\u0009end switch\n\u0009case %mustSpecifyBlockName\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\\{args[0]}\u300D\u6587\u306B\u306F\u30D6\u30ED\u30C3\u30AF\u540D\u3092\u6307\u5B9A\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'\\{args[0]}\' statements must be given block names.\"\n\u0009\u0009end switch\n\u0009case %assertCondMustBeBool\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cassert\u300D\u6587\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The conditional expression of the \'assert\' statement must be \'bool\' type.\"\n\u0009\u0009end switch\n\u0009case %nonTypeWritten\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u578B\u3092\u8A18\u8FF0\u3059\u3079\u304D\u3068\u3053\u308D\u306B\u578B\u4EE5\u5916\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A non-type was written where a type should be written.\"\n\u0009\u0009end switch\n\u0009case %noValuePassed\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5024\u304C\u8A2D\u5B9A\u3055\u308C\u308B\u3079\u304D\u5834\u6240\u306B\u5024\u304C\u6E21\u3055\u308C\u307E\u305B\u3093\u3067\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"No value was passed where some value should be set.\"\n\u0009\u0009end switch\n\u0009case %wrongOperatorType\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6F14\u7B97\u5B50\u306E\u578B\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Incorrect type for operator.\"\n\u0009\u0009end switch\n\u0009case %wrongLeftValueOfAssignOperator\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u4EE3\u5165\u6F14\u7B97\u5B50\u306E\u5DE6\u8FBA\u5024\u304C\u4EE3\u5165\u53EF\u80FD\u306A\u5909\u6570\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The left value of the assignment operator is not an assignable variable.\"\n\u0009\u0009end switch\n\u0009case %comparingNullByValue\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cnull\u300D\u306F\u5024\u6BD4\u8F03\u304C\u3067\u304D\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'null\' cannot be compared by value.\"\n\u0009\u0009end switch\n\u0009case %enumTypeNotInferred\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cenum\u300D\u306E\u8981\u7D20\u540D\u300C\\{args[0]}\u300D\u304B\u3089\u578B\u304C\u63A8\u6E2C\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type could not be inferred from the element name \'\\{args[0]}\' of \'enum\'.\"\n\u0009\u0009end switch\n\u0009case %concatNull\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cnull\u300D\u306F\u300C~\u300D\u6F14\u7B97\u5B50\u3067\u9023\u7D50\u3067\u304D\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'null\' cannot be concatenated with the \'~\' operator.\"\n\u0009\u0009end switch\n\u0009case %dividedBy0\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"0\u3067\u9664\u7B97\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Divided by 0.\"\n\u0009\u0009end switch\n\u0009case %wrongLeftOrRightValueOfSwapOperator\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C:$\u300D\u6F14\u7B97\u5B50\u306E\u5DE6\u8FBA\u5024\u3082\u3057\u304F\u306F\u53F3\u8FBA\u5024\u304C\u4EE3\u5165\u53EF\u80FD\u306A\u5909\u6570\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The left or right value of the \':$\' operator is not an assignable variable.\"\n\u0009\u0009end switch\n\u0009case %condForCondOperatorMustBeBool\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C?(,)\u300D\u6F14\u7B97\u5B50\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The conditional expression for the \'?(,)\' operator must be \'bool\'.\"\n\u0009\u0009end switch\n\u0009case %twoValueForCondOperatorMustSameType\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C?(,)\u300D\u6F14\u7B97\u5B50\u306E\u62EC\u5F27\u5185\u306E2\u3064\u306E\u5024\u306F\u540C\u3058\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The two values in the parenthesis for the \'?(,)\' operator must be the same type.\"\n\u0009\u0009end switch\n\u0009case %wrongTypeForNewOperator\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C#\u300D\u6F14\u7B97\u5B50\u306F\u30AF\u30E9\u30B9\u3084\u300Clist\u300D\u300Cdict\u300D\u306A\u3069\u306E\u53C2\u7167\u578B\u306B\u3057\u304B\u4F7F\u3048\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The \'#\' operator can only be used for reference types such as classes, \'list\' and \'dict\'.\"\n\u0009\u0009end switch\n\u0009case %numOfElementsMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C#\u300D\u6F14\u7B97\u5B50\u306B\u8A18\u8FF0\u3059\u308B\u914D\u5217\u306E\u8981\u7D20\u6570\u306E\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The number of array elements written in the \'#\' operator must be \'int\'.\"\n\u0009\u0009end switch\n\u0009case %callNonFunction\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u3067\u306A\u3044\u3082\u306E\u3092\u95A2\u6570\u547C\u3073\u51FA\u3057\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A non-function was called as if it were a function.\"\n\u0009\u0009end switch\n\u0009case %wrongArgNumInFunc\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\\{args[0]}\u500B\u306E\u5F15\u6570\u3092\u53D7\u3051\u53D6\u308B\u95A2\u6570\u547C\u3073\u51FA\u3057\u306B\\{args[1]}\u500B\u306E\u5F15\u6570\u304C\u6307\u5B9A\u3055\u308C\u307E\u3057\u305F\u3002 \u95A2\u6570\u306E\u578B\u306F\u300C\\{args[2]}\u300D\u3067\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\\{args[1]} arguments were written in the function call that received \\{args[0]} arguments. The function type is \'\\{args[2]}\'\"\n\u0009\u0009end switch\n\u0009case %nonRefArgPassed\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u547C\u3073\u51FA\u3057\u306E\\{args[0]}\u756A\u76EE\u306E\u53C2\u7167\u6E21\u3057\u306E\u5F15\u6570\u306B\u3001\u53C2\u7167\u3092\u53D6\u308C\u306A\u3044\u5024\u304C\u6E21\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A value that cannot be referenced was passed to the \\{args[0]}th/st/nd/rd argument, which is a reference argument, of the function call.\"\n\u0009\u0009end switch\n\u0009case %wrongArgTypeInFunc\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u547C\u3073\u51FA\u3057\u306E\u5F15\u6570\u306E\u578B\u304C\u7570\u306A\u308A\u307E\u3059\u3002 \\{args[0]}\u756A\u76EE\u306E\u5F15\u6570\u3067\u300C\\{args[1]}\u300D\u3092\u6307\u5B9A\u3059\u3079\u304D\u3068\u3053\u308D\u306B\u300C\\{args[2]}\u300D\u304C\u6E21\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type of arguments of the function call is different. \'\\{args[2]}\' has been passed where \'\\{args[1]}\' should be written in the \\{args[0]}th/st/nd/rd argument.\"\n\u0009\u0009end switch\n\u0009case %nonArrayAccess\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u914D\u5217\u3067\u306A\u3044\u3082\u306E\u306B\u914D\u5217\u30A2\u30AF\u30BB\u30B9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A non-array was accessed as an array.\"\n\u0009\u0009end switch\n\u0009case %arrayIdxMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u914D\u5217\u306E\u6DFB\u5B57\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Array indices must be \'int\'.\"\n\u0009\u0009end switch\n\u0009case %memberNotExist\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u53C2\u7167\u5148\u306E\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The referenced member \'\\{args[0]}\' does not exist.\"\n\u0009\u0009end switch\n\u0009case %refUnpublishedMember\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u516C\u958B\u3055\u308C\u3066\u3044\u306A\u3044\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3092\u53C2\u7167\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An unpublished member \'\\{args[0]}\' was referenced.\"\n\u0009\u0009end switch\n\u0009case %elementTypesOfArrayInitNotMatch\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306E\u8981\u7D20\u306E\u578B\u304C\u4E00\u81F4\u3057\u3066\u3044\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The element types of the array initializer \'[]\' do not match.\"\n\u0009\u0009end switch\n\u0009case %nullForValueTypeArrayInit\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5024\u578B\u306E\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306B\u300Cnull\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'null\' was written in the value type array initializer \'[]\'.\"\n\u0009\u0009end switch\n\u0009case %allElementsAreEnum\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306E\u3059\u3079\u3066\u306E\u8981\u7D20\u304C\u300Cenum\u300D\u306E\u8981\u7D20\u540D\u306E\u305F\u3081\u3001\u578B\u304C\u6C7A\u5B9A\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002 \u3044\u305A\u308C\u304B\u306E\u8981\u7D20\u540D\u3092\u30AD\u30E3\u30B9\u30C8\u3057\u3066\u578B\u3092\u793A\u3057\u3066\u304F\u3060\u3055\u3044\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type could not be determined because all elements of the array initializer \'[]\' are element names of \'enum\'. Cast one of the element names to indicate the type.\"\n\u0009\u0009end switch\n\u0009case %allElementsAreNull\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306E\u3059\u3079\u3066\u306E\u8981\u7D20\u304C\u300Cnull\u300D\u306E\u305F\u3081\u3001\u578B\u304C\u6C7A\u5B9A\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002 \u3044\u305A\u308C\u304B\u306E\u300Cnull\u300D\u3092\u30AD\u30E3\u30B9\u30C8\u3057\u3066\u578B\u3092\u793A\u3057\u3066\u304F\u3060\u3055\u3044\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type could not be determined because all elements of the array initializer \'[]\' are \'null\'. Cast one of \'null\' to indicate the type.\"\n\u0009\u0009end switch\n\u0009case %inaccessibleElement\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u306A\u3044\u8981\u7D20\u300C\\{args[0]}\u300D\u306B\u30A2\u30AF\u30BB\u30B9\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Accessed inaccessible element \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %success\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6210\u529F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Success.\"\n\u0009\u0009end switch\n\u0009case %failure\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5931\u6557\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Failure.\"\n\u0009\u0009end switch\n\u0009case %compilationStarted\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30B3\u30F3\u30D1\u30A4\u30EB\u958B\u59CB: \\{args[0]}\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Compilation started: \\{args[0]}.\"\n\u0009\u0009end switch\n\u0009case %parsingCompleted\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5B57\u53E5\u69CB\u6587\u89E3\u6790\u5B8C\u4E86: \\{args[0]}\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Parsing is complete: \\{args[0]}.\"\n\u0009\u0009end switch\n\u0009case %semanticAnalysisCompleted\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u610F\u5473\u89E3\u6790\u5B8C\u4E86: \\{args[0]}\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Semantic analysis is complete: \\{args[0]}.\"\n\u0009\u0009end switch\n\u0009case %generationProcessCompleted\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u751F\u6210\u51E6\u7406\u5B8C\u4E86: \\{args[0]}\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Generation process is complete: \\{args[0]}.\"\n\u0009\u0009end switch\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n";
else if(p==="res/option.kn")
return "+enum Env\n\u0009cui\n\u0009wnd\n\u0009web\n\u0009cpp\nend enum\n\n+var inputFile: []char\n+var outputFile: []char\n+var sysDir: []char\n+var icon: []char\n+var rls: bool\n+var env_: @Env\n+var help: bool\n+var version: bool\n+var quiet: bool\n+var appCode: int\n+var notDeploy: bool\n+var extra: dict<[]char, bool>\n\n+var inputDir: []char\n+var inputName: []char\n+var outputDir: []char\n\n+func acquireOption(): bool\n\u0009var cmdLines: [][]char :: lib@cmdLine()\n\u0009var envStr: []char\n\u0009var appCodeStr: []char\n\u0009do @extra :: #dict<[]char, bool>\n\u0009\n\u0009for i(0, ^cmdLines - 1)\n\u0009\u0009var cmdLine: []char :: cmdLines[i]\n\u0009\u0009if(^cmdLine = 2 & cmdLine[0] = \'-\')\n\u0009\u0009\u0009switch c(cmdLine[1])\n\u0009\u0009\u0009case \'i\'\n\u0009\u0009\u0009\u0009if(!getArg1(&@inputFile, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'o\'\n\u0009\u0009\u0009\u0009if(!getArg1(&@outputFile, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'s\'\n\u0009\u0009\u0009\u0009if(!getArg1(&@sysDir, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'c\'\n\u0009\u0009\u0009\u0009if(!getArg1(&@icon, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'r\'\n\u0009\u0009\u0009\u0009if(!getArg0(&@rls, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'e\'\n\u0009\u0009\u0009\u0009if(!getArg1(&envStr, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'h\'\n\u0009\u0009\u0009\u0009if(!getArg0(&@help, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'v\'\n\u0009\u0009\u0009\u0009if(!getArg0(&@version, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'q\'\n\u0009\u0009\u0009\u0009if(!getArg0(&@quiet, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'a\'\n\u0009\u0009\u0009\u0009if(!getArg1(&appCodeStr, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'d\' {This option is only used in Kuin Editor builds.}\n\u0009\u0009\u0009\u0009if(!getArg0(&@notDeploy, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'x\'\n\u0009\u0009\u0009\u0009var extra: []char\n\u0009\u0009\u0009\u0009if(!getArg1(&extra, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do @extra.add(extra, true)\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do \\err@err(%unexpectedOption, null, [\"-\\{c}\"])\n\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009end switch\n\u0009\u0009else\n\u0009\u0009\u0009do \\err@err(%unexpectedOption, null, [\"\\{cmdLine}\"])\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009end for\n\u0009\n\u0009if(@inputFile =& null)\n\u0009\u0009ret true\n\u0009end if\n\u0009\n\u0009if(envStr =& null)\n\u0009\u0009do @env_ :: %cui\n\u0009else\n\u0009\u0009switch(envStr)\n\u0009\u0009case \"cui\"\n\u0009\u0009\u0009do @env_ :: %cui\n\u0009\u0009case \"wnd\"\n\u0009\u0009\u0009do @env_ :: %wnd\n\u0009\u0009case \"web\"\n\u0009\u0009\u0009do @env_ :: %web\n\u0009\u0009case \"cpp\"\n\u0009\u0009\u0009do @env_ :: %cpp\n\u0009\u0009default\n\u0009\u0009\u0009do \\err@err(%incorrectOption, null, [\"-e\"])\n\u0009\u0009end switch\n\u0009end if\n\u0009\n\u0009if(appCodeStr =& null)\n\u0009\u0009do @appCode :: lib@rnd(1, 0xFFFFFFFF)\n\u0009else\n\u0009\u0009var success: bool\n\u0009\u0009do @appCode :: appCodeStr.toInt(&success)\n\u0009\u0009if(!success)\n\u0009\u0009\u0009do \\err@err(%incorrectOption, null, [\"-a\"])\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009end if\n\u0009\n\u0009if(@outputFile =& null)\n\u0009\u0009do @outputFile :: file@dir(@inputFile) ~ \"out\"\n\u0009else\n\u0009\u0009do @outputFile :: file@delExt(@outputFile)\n\u0009end if\n\u0009\n\u0009if(@sysDir =& null)\n\u0009\u0009do @sysDir :: \"sys/\"\n\u0009end if\n\u0009\n\u0009if(@icon =& null)\n\u0009\u0009do @icon :: @sysDir ~ \"default.ico\"\n\u0009end if\n\u0009\n\u0009do @inputDir :: file@dir(@inputFile)\n\u0009do @inputName :: file@delExt(file@fileName(@inputFile))\n\u0009do @outputDir :: file@dir(@outputFile)\n\u0009\n\u0009if(file@ext(@inputFile) <> \"kn\")\n\u0009\u0009do \\err@err(%incorrectExt, null, [@inputName])\n\u0009end if\n\u0009\n\u0009ret true\n\u0009\n\u0009func getArg0(out: &bool, option: char): bool\n\u0009\u0009if(out <> false)\n\u0009\u0009\u0009do \\err@err(%incorrectOption, null, [\"-\\{option}\"])\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009do out :: true\n\u0009\u0009ret true\n\u0009end func\n\u0009\n\u0009func getArg1(out: &[]char, cmdLines: [][]char, idx: &int, option: char): bool\n\u0009\u0009if(out <>& null | idx + 1 >= ^cmdLines)\n\u0009\u0009\u0009do \\err@err(%incorrectOption, null, [\"-\\{option}\"])\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009do out :: cmdLines[idx + 1]\n\u0009\u0009do idx :+ 1\n\u0009\u0009ret true\n\u0009end func\nend func\n";
else if(p==="res/parse.kn")
return "var reserved: [][]char\n\nvar srcesCur: dict<[]char, \\ast@Ast>\nvar srcesNext: dict<[]char, \\ast@Ast>\nvar filePtr: file@Reader\n\nvar srcName: []char\nvar row: int\nvar col: int\n\nvar fileBuf: char\nvar fileBufTmp: char {For single line comments and line breaking.}\nvar fileLast: bool\nvar scope: stack<\\ast@Ast>\nvar uniqueCnt: int\nvar scopeRefedItems: list<\\ast@ScopeRefedItem>\n\n+func parse(): dict<[]char, \\ast@Ast>\n\u0009do @srcesCur :: #dict<[]char, \\ast@Ast>\n\u0009do @srcesCur.add(\"\\\\\" ~ \\option@inputName, null)\n\u0009do @srcesCur.add(\"kuin\", null)\n\u0009\n\u0009var endFlag: lib@Bool :: #lib@Bool\n\u0009do endFlag.value :: false\n\u0009while(!endFlag.value)\n\u0009\u0009do endFlag.value :: true\n\u0009\u0009do @srcesNext :: #dict<[]char, \\ast@Ast>\n\u0009\u0009do @srcesCur.forEach(@parseSrc, endFlag)\n\u0009\u0009do @srcesCur :: @srcesNext\n\u0009end while\n\u0009\n\u0009ret @srcesCur\nend func\n\nfunc parseSrc(key: []char, value: \\ast@Ast, data: kuin@Class): bool\n\u0009if(value <>& null)\n\u0009\u0009do @srcesNext.add(key, value)\n\u0009\u0009ret true\n\u0009end if\n\u0009\n\u0009if(!isCorrectSrcName(key))\n\u0009\u0009do \\err@err(%incorrectSrcName, null, [key])\n\u0009\u0009ret true\n\u0009end if\n\u0009do(data $ lib@Bool).value :: false\n\u0009\n\u0009var truePath: []char\n\u0009if(key[0] = \'\\\\\')\n\u0009\u0009do truePath :: \\option@inputDir ~ replacePath(key.sub(1, -1)) ~ \".kn\"\n\u0009else\n\u0009\u0009do truePath :: \\option@sysDir ~ replacePath(key) ~ \".kn\"\n\u0009end if\n\u0009do @filePtr :: file@makeReader(truePath)\n\u0009if(@filePtr =& null)\n\u0009\u0009do \\err@err(%fileOpenFailed, null, [truePath])\n\u0009\u0009ret true\n\u0009end if\n\u0009\n\u0009do @srcName :: key\n\u0009do @row :: 1\n\u0009do @col :: 0\n\u0009do @fileBuf :: \'\\0\'\n\u0009do @fileBufTmp :: \'\\0\'\n\u0009do @fileLast :: false\n\u0009do @scope :: #stack<\\ast@Ast>\n\u0009do @uniqueCnt :: 0\n\u0009do @scopeRefedItems :: null\n\u0009\n\u0009var ast: \\ast@AstRoot :: @parseRoot()\n\u0009do @filePtr.fin()\n\u0009do @srcesNext.add(key, ast)\n\u0009ret true\n\u0009\n\u0009func isCorrectSrcName(name: []char): bool\n\u0009\u0009var idx: int :: 0\n\u0009\u0009if(idx < ^name & name[idx] = \'\\\\\')\n\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009end if\n\u0009\u0009while(true)\n\u0009\u0009\u0009if(idx >= ^name | !(\'a\' <= name[idx] & name[idx] <= \'z\' | name[idx] = \'_\'))\n\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009\u0009\u0009if(idx >= ^name)\n\u0009\u0009\u0009\u0009\u0009ret true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(\'a\' <= name[idx] & name[idx] <= \'z\' | name[idx] = \'_\' | \'0\' <= name[idx] & name[idx] <= \'9\')\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(name[idx] = \'\\\\\')\n\u0009\u0009\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009end while\n\u0009\u0009end while\n\u0009end func\n\u0009\n\u0009func replacePath(path: []char): []char\n\u0009\u0009var r: []char :: #[^path]char\n\u0009\u0009for i(0, ^path - 1)\n\u0009\u0009\u0009do r[i] :: path[i] = \'\\\\\' ?(\'/\', path[i])\n\u0009\u0009end for\n\u0009\u0009ret r\n\u0009end func\nend func\n\nfunc parseRoot(): \\ast@AstRoot\n\u0009var ast: \\ast@AstRoot :: #\\ast@AstRoot\n\u0009do @initAst(ast, %root, \\pos@make(@srcName, 1, 1), null, false)\n\u0009do ast.scopeRefedItems :: #list<\\ast@ScopeRefedItem>\n\u0009do ast.items :: #list<\\ast@Ast>\n\u0009do @scopeRefedItems :: ast.scopeRefedItems\n\u0009\n\u0009do ast.scopeChildren :: #dict<[]char, \\ast@Ast>\n\u0009do @scope.add(ast)\n\u0009\n\u0009; For the case where there is a single line comment at the beginning of source codes.\n\u0009do @fileBuf :: \'\\n\'\n\u0009do @fileBuf :: @readChar()\n\u0009\n\u0009while loop(true)\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009skip loop\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009var item: \\ast@Ast\n\u0009\u0009var itemPublic: bool :: false\n\u0009\u0009if(c = \'+\')\n\u0009\u0009\u0009do itemPublic :: true\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009block\n\u0009\u0009\u0009var row: int :: @row\n\u0009\u0009\u0009var col: int :: @col\n\u0009\u0009\u0009var id: []char :: @readIdentifier(true, false)\n\u0009\u0009\u0009switch(id)\n\u0009\u0009\u0009case \"func\"\n\u0009\u0009\u0009\u0009do item :: @parseFunc(null, false)\n\u0009\u0009\u0009case \"var\"\n\u0009\u0009\u0009\u0009do item :: @parseVar(%global, null)\n\u0009\u0009\u0009case \"const\"\n\u0009\u0009\u0009\u0009do item :: @parseConst()\n\u0009\u0009\u0009case \"alias\"\n\u0009\u0009\u0009\u0009do item :: @parseAlias()\n\u0009\u0009\u0009case \"include\"\n\u0009\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009case \"class\"\n\u0009\u0009\u0009\u0009do item :: @parseClass()\n\u0009\u0009\u0009case \"enum\"\n\u0009\u0009\u0009\u0009do item :: @parseEnum()\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do \\err@err(%incorrectBlockOrSentence, \\pos@make(@srcName, row, col), [id])\n\u0009\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end switch\n\u0009\u0009end block\n\u0009\u0009\n\u0009\u0009if(item.typeId = %var_)\n\u0009\u0009\u0009do(item $ \\ast@AstVar).arg.publicInSrc :: itemPublic\n\u0009\u0009elif(item.typeId = %const_)\n\u0009\u0009\u0009do(item $ \\ast@AstConst).arg.publicInSrc :: itemPublic\n\u0009\u0009else\n\u0009\u0009\u0009do item.publicInSrc :: itemPublic\n\u0009\u0009end if\n\u0009\u0009do ast.items.add(item)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseFunc(parentClass: []char, overritten: bool): \\ast@AstFunc\n\u0009var ast: \\ast@AstFunc :: #\\ast@AstFunc\n\u0009\n\u0009block\n\u0009\u0009do ast.funcOption :: %none\n\u0009\u0009do ast.funcAttr :: #list<[]char>\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'[\')\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009var row: int :: @row\n\u0009\u0009\u0009\u0009var col: int :: @col\n\u0009\u0009\u0009\u0009var s: []char :: @readFuncAttr()\n\u0009\u0009\u0009\u0009if(^s = 5 & s[0] = \'_\' & s[1] = \'_\')\n\u0009\u0009\u0009\u0009\u0009switch(s[2])\n\u0009\u0009\u0009\u0009\u0009case \'a\'\n\u0009\u0009\u0009\u0009\u0009\u0009if(s[3] = \'n\' & s[4] = \'y\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%any)\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009case \'f\'\n\u0009\u0009\u0009\u0009\u0009\u0009if(s[3] = \'r\' & s[4] = \'c\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%frc)\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009case \'k\'\n\u0009\u0009\u0009\u0009\u0009\u0009if(s[3] = \'v\' & s[4] = \'f\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%kvf)\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009case \'m\'\n\u0009\u0009\u0009\u0009\u0009\u0009if(s[3] = \'k\' & s[4] = \'i\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%mki)\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009case \'r\'\n\u0009\u0009\u0009\u0009\u0009\u0009if(s[3] = \'a\' & s[4] = \'w\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%raw)\n\u0009\u0009\u0009\u0009\u0009\u0009elif(s[3] = \'m\' & s[4] = \'e\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%rme)\n\u0009\u0009\u0009\u0009\u0009\u0009elif(s[3] = \'c\' & s[4] = \'h\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%rch)\n\u0009\u0009\u0009\u0009\u0009\u0009elif(s[3] = \'a\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(s[4] = \'c\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%rac)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009elif(s[4] = \'k\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%rak)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009elif(s[4] = \'v\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%rav)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009case \'t\'\n\u0009\u0009\u0009\u0009\u0009\u0009if(s[3] = \'m\' & s[4] = \'e\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%tme)\n\u0009\u0009\u0009\u0009\u0009\u0009elif(s[3] = \'c\' & s[4] = \'h\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%tch)\n\u0009\u0009\u0009\u0009\u0009\u0009elif(s[3] = \'k\' & s[4] = \'v\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%tkv)\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do ast.funcAttr.add(s)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \']\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009do @initAst(ast, %func_, @makePos(), @readIdentifier(true, false), true)\n\u0009do ast.args :: #list<\\ast@AstArg>\n\u0009do ast.ret_ :: null\n\u0009do ast.stats :: #list<\\ast@AstStat>\n\u0009\n\u0009do ast.scopeChildren :: #dict<[]char, \\ast@Ast>\n\u0009do @scope.add(ast)\n\u0009\n\u0009if(parentClass <>& null)\n\u0009\u0009do @addScopeRefeds(ast, parentClass)\n\u0009end if\n\u0009do @assertNextChar(\'(\', true)\n\u0009if(parentClass <>& null)\n\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009do @initAst(arg, %arg, ast.pos, null, false)\n\u0009\u0009do arg.name :: \"me\"\n\u0009\u0009do arg.kind :: %localArg\n\u0009\u0009do arg.refVar :: false\n\u0009\u0009do arg.expr :: null\n\u0009\u0009do @addScopeName(arg, false)\n\u0009\u0009block\n\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009do @initAst(type, %typeUser, ast.pos, null, false)\n\u0009\u0009\u0009do @addScopeRefeds(type, parentClass)\n\u0009\u0009\u0009do arg.type :: type\n\u0009\u0009end block\n\u0009\u0009do ast.args.add(arg)\n\u0009end if\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c <> \')\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009do ast.args.add(@parseArg(%localArg, null))\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \')\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \':\')\n\u0009\u0009\u0009do ast.ret_ :: @parseType()\n\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009end if\n\u0009\u0009if(c <> \'\\n\')\n\u0009\u0009\u0009do @nextCharErr(\'\\n\', c)\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009; TODO:\n\u0009{\n\u0009if(overritten)\n\u0009\u0009var statVar: \\ast@AstStatVar :: #\\ast@AstStatVar\n\u0009\u0009do @initAst(statVar, %statVar, ast.pos, null, false)\n\u0009\u0009block\n\u0009\u0009\u0009var var_: \\ast@AstVar :: #\\ast@AstVar\n\u0009\u0009\u0009do @initAst(var_, %var_, ast.pos, null, false)\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009\u0009do @initAst(arg, %arg, ast.pos, null, false)\n\u0009\u0009\u0009\u0009do arg.name :: \"super\"\n\u0009\u0009\u0009\u0009do arg.kind :: %localVar\n\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009do arg.expr :: null\n\u0009\u0009\u0009\u0009do @addScopeName(arg, false)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeFunc :: #\\ast@AstTypeFunc\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeFunc, ast.pos, null, false)\n\u0009\u0009\u0009\u0009\u0009do type.funcOption :: ast.funcOption\n\u0009\u0009\u0009\u0009\u0009do type.funcAttr :: ast.funcAttr\n\u0009\u0009\u0009\u0009\u0009do type.args :: #list<\\ast@AstTypeFuncArg>\n\u0009\u0009\u0009\u0009\u0009do type.ret_ :: ast.ret_\n\u0009\u0009\u0009\u0009\u0009var args: list<\\ast@AstArg> :: ast.args\n\u0009\u0009\u0009\u0009\u0009do args.head()\n\u0009\u0009\u0009\u0009\u0009while(!args.term())\n\u0009\u0009\u0009\u0009\u0009\u0009var data: \\ast@AstArg :: args.get()\n\u0009\u0009\u0009\u0009\u0009\u0009var arg2: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009\u0009do arg2.arg :: data.type\n\u0009\u0009\u0009\u0009\u0009\u0009do arg2.refVar :: data.refVar\n\u0009\u0009\u0009\u0009\u0009\u0009do type.args.add(arg2)\n\u0009\u0009\u0009\u0009\u0009\u0009do args.next()\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009do arg.type :: type\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do var_.arg :: arg\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do statVar.def :: var_\n\u0009\u0009end block\n\u0009\u0009do ast.stats.add(statVar)\n\u0009end if\n\u0009}\n\u0009\n\u0009while loop(true)\n\u0009\u0009var stat: \\ast@AstStat :: @parseStat(ast)\n\u0009\u0009if(stat =& null)\n\u0009\u0009\u0009if(@fileLast)\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(stat.typeId = %statEnd)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do ast.stats.add(stat)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseVar(kind: \\ast@AstArgKind, parentClass: []char): \\ast@AstVar\n\u0009var ast: \\ast@AstVar :: #\\ast@AstVar\n\u0009do @initAst(ast, %var_, @makePos(), null, false)\n\u0009do ast.arg :: @parseArg(kind, parentClass)\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseConst(): \\ast@AstConst\n\u0009var ast: \\ast@AstConst :: #\\ast@AstConst\n\u0009do @initAst(ast, %const_, @makePos(), null, false)\n\u0009do ast.arg :: @parseArg(%const_, null)\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseAlias(): \\ast@AstAlias\n\u0009var ast: \\ast@AstAlias :: #\\ast@AstAlias\n\u0009do @initAst(ast, %alias_, @makePos(), @readIdentifier(true, false), true)\n\u0009do @assertNextChar(\':\', true)\n\u0009do ast.type :: @parseType()\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseClass(): \\ast@AstClass\n\u0009var ast: \\ast@AstClass :: #\\ast@AstClass\n\u0009do @initAst(ast, %class_, @makePos(), @readIdentifier(true, false), true)\n\u0009do ast.items :: #list<\\ast@AstClassItem>\n\u0009do @assertNextChar(\'(\', true)\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c <> \')\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009do @addScopeRefeds(ast, @readIdentifier(true, true))\n\u0009\u0009\u0009do @assertNextChar(\')\', true)\n\u0009\u0009else\n\u0009\u0009\u0009var kuinSrc: bool :: @srcName = \"kuin\"\n\u0009\u0009\u0009if(!(kuinSrc & ast.name = \"Class\"))\n\u0009\u0009\u0009\u0009do @addScopeRefeds(ast, kuinSrc ?(\"@Class\", \"kuin@Class\"))\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009\n\u0009do ast.scopeChildren :: #dict<[]char, \\ast@Ast>\n\u0009do @scope.add(ast)\n\u0009\n\u0009while loop(true)\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009do \\err@err(%noEnd, @makePos(), [\"class\"])\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009skip loop\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var item: \\ast@AstClassItem :: #\\ast@AstClassItem\n\u0009\u0009do item.public :: false\n\u0009\u0009do item.override :: false\n\u0009\u0009do item.parentItem :: null\n\u0009\u0009if(c = \'+\')\n\u0009\u0009\u0009do item.public :: true\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009\u0009do c :: @readChar()\n\u0009\u0009if(c = \'*\')\n\u0009\u0009\u0009do item.override :: true\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009var id: []char :: @readIdentifier(true, false)\n\u0009\u0009var className: []char :: ast.scopeParent.typeId = %root ?(\"@\" ~ ast.name, ast.name)\n\u0009\u0009if(id = \"func\")\n\u0009\u0009\u0009do item.def :: @parseFunc(className, item.override)\n\u0009\u0009elif(id = \"var\")\n\u0009\u0009\u0009if(item.override)\n\u0009\u0009\u0009\u0009do \\err@err(%overrideNonFunctionMember, \\pos@make(@srcName, row, col), [id])\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do item.def :: @parseVar(%member, className)\n\u0009\u0009else\n\u0009\u0009\u0009if(item.public)\n\u0009\u0009\u0009\u0009do \\err@err(%exposeNonFunctionOrVariableMember, \\pos@make(@srcName, row, col), [id])\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(item.override)\n\u0009\u0009\u0009\u0009do \\err@err(%overrideNonFunctionMember, \\pos@make(@srcName, row, col), [id])\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009switch(id)\n\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009case \"end\"\n\u0009\u0009\u0009\u0009var id2: []char :: @readIdentifier(true, false)\n\u0009\u0009\u0009\u0009if(id2 <> \"class\")\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%wrongEnd, \\pos@make(@srcName, row, col), [\"class\", id2])\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009var astEndClass: \\ast@Ast :: #\\ast@Ast\n\u0009\u0009\u0009\u0009do @initAst(astEndClass, %none, \\pos@make(@srcName, row, col), null, false)\n\u0009\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009case \"const\"\n\u0009\u0009\u0009\u0009do item.def :: @parseConst()\n\u0009\u0009\u0009case \"alias\"\n\u0009\u0009\u0009\u0009do item.def :: @parseAlias()\n\u0009\u0009\u0009case \"class\"\n\u0009\u0009\u0009\u0009do item.def :: @parseClass()\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do \\err@err(%wrongMember, \\pos@make(@srcName, row, col), [id])\n\u0009\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end switch\n\u0009\u0009end if\n\u0009\u0009do ast.items.add(item)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseEnum(): \\ast@AstEnum\n\u0009var ast: \\ast@AstEnum :: #\\ast@AstEnum\n\u0009do @initAst(ast, %enum_, @makePos(), @readIdentifier(true, false), true)\n\u0009do ast.items :: #list<\\ast@AstExpr>\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009\n\u0009do ast.scopeChildren :: #dict<[]char, \\ast@Ast>\n\u0009do @scope.add(ast)\n\u0009\n\u0009while loop(true)\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009do \\err@err(%noEnd, @makePos(), [\"enum\"])\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009skip loop\n\u0009\u0009end if\n\u0009\u0009do @fileBuf :: c\n\u0009\u0009\n\u0009\u0009var item: \\ast@AstExpr\n\u0009\u0009var id: []char :: @readIdentifier(true, false)\n\u0009\u0009if(id = \"end\")\n\u0009\u0009\u0009var id2: []char :: @readIdentifier(true, false)\n\u0009\u0009\u0009if(id2 <> \"enum\")\n\u0009\u0009\u0009\u0009do \\err@err(%wrongEnd, @makePos(), [\"enum\", id2])\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do c :: @readChar()\n\u0009\u0009if(c = \':\')\n\u0009\u0009\u0009do @assertNextChar(\':\', false)\n\u0009\u0009\u0009do item :: @parseExpr()\n\u0009\u0009\u0009if(item =& null)\n\u0009\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009else\n\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009do expr.type :: null {Set the type to \'NULL\' when no value is specified.}\n\u0009\u0009\u0009do expr.value :: 0b64\n\u0009\u0009\u0009do item :: expr\n\u0009\u0009end if\n\u0009\u0009do item.name :: id\n\u0009\u0009if(c <> \'\\n\')\n\u0009\u0009\u0009do @nextCharErr(\'\\n\', c)\n\u0009\u0009end if\n\u0009\u0009do ast.items.add(item)\n\u0009\u0009do @addScopeName(item, true)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseArg(kind: \\ast@AstArgKind, parentClass: []char): \\ast@AstArg\n\u0009var ast: \\ast@AstArg :: #\\ast@AstArg\n\u0009do @initAst(ast, %arg, @makePos(), @readIdentifier(true, false), false)\n\u0009do ast.kind :: kind\n\u0009do ast.refVar :: false\n\u0009if(parentClass <>& null)\n\u0009\u0009do @addScopeRefeds(ast, parentClass)\n\u0009end if\n\u0009do @assertNextChar(\':\', true)\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'&\')\n\u0009\u0009\u0009if(kind <> %localArg)\n\u0009\u0009\u0009\u0009do \\err@err(%ampersandInNonArgument, @makePos(), null)\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do ast.refVar :: true\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009do ast.type :: @parseType()\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \':\')\n\u0009\u0009\u0009do @assertNextChar(\':\', false)\n\u0009\u0009\u0009assert kind <> %unknown\n\u0009\u0009\u0009switch(kind)\n\u0009\u0009\u0009case %localArg\n\u0009\u0009\u0009\u0009do \\err@err(%initializerInArgument, @makePos(), null)\n\u0009\u0009\u0009\u0009do ast.expr :: null\n\u0009\u0009\u0009case %member\n\u0009\u0009\u0009\u0009do \\err@err(%initializerInMember, @makePos(), null)\n\u0009\u0009\u0009\u0009do ast.expr :: null\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do ast.expr :: @parseExpr()\n\u0009\u0009\u0009end switch\n\u0009\u0009else\n\u0009\u0009\u0009if(kind = %const_)\n\u0009\u0009\u0009\u0009do \\err@err(%noInitializerInConst, @makePos(), null)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.expr :: null\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009ret ast\nend func\n\nfunc parseStat(block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStat\n\u0009\n\u0009block\n\u0009\u0009var c: char\n\u0009\u0009while(c = \'\\n\', skip)\n\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009do \\err@err(%noEndUnspecified, @makePos(), null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009end while\n\u0009\u0009do @fileBuf :: c\n\u0009end block\n\u0009\n\u0009var row: int :: @row\n\u0009var col: int :: @col\n\u0009var id: []char :: @readIdentifier(true, false)\n\u0009switch(id)\n\u0009case \"end\"\n\u0009\u0009do ast :: @parseStatEnd(row, col, block_)\n\u0009case \"func\"\n\u0009\u0009do ast :: @parseStatFunc()\n\u0009case \"var\"\n\u0009\u0009do ast :: @parseStatVar()\n\u0009case \"const\"\n\u0009\u0009do ast :: @parseStatConst()\n\u0009case \"alias\"\n\u0009\u0009do ast :: @parseStatAlias()\n\u0009case \"class\"\n\u0009\u0009do ast :: @parseStatClass()\n\u0009case \"enum\"\n\u0009\u0009do ast :: @parseStatEnum()\n\u0009case \"if\"\n\u0009\u0009do ast :: @parseStatIf()\n\u0009case \"elif\"\n\u0009\u0009do ast :: @parseStatElIf(row, col, block_)\n\u0009case \"else\"\n\u0009\u0009do ast :: @parseStatElse(row, col, block_)\n\u0009case \"switch\"\n\u0009\u0009do ast :: @parseStatSwitch(row, col)\n\u0009case \"case\"\n\u0009\u0009do ast :: @parseStatCase(row, col, block_)\n\u0009case \"default\"\n\u0009\u0009do ast :: @parseStatDefault(row, col, block_)\n\u0009case \"while\"\n\u0009\u0009do ast :: @parseStatWhile()\n\u0009case \"for\"\n\u0009\u0009do ast :: @parseStatFor(row, col)\n\u0009case \"try\"\n\u0009\u0009do ast :: @parseStatTry(row, col)\n\u0009case \"catch\"\n\u0009\u0009do ast :: @parseStatCatch(row, col, block_)\n\u0009case \"finally\"\n\u0009\u0009do ast :: @parseStatFinally(row, col, block_)\n\u0009case \"throw\"\n\u0009\u0009do ast :: @parseStatThrow()\n\u0009case \"block\"\n\u0009\u0009do ast :: @parseStatBlock()\n\u0009case \"ret\"\n\u0009\u0009do ast :: @parseStatRet()\n\u0009case \"do\"\n\u0009\u0009do ast :: @parseStatDo()\n\u0009case \"break\"\n\u0009\u0009do ast :: @parseStatBreak()\n\u0009case \"skip\"\n\u0009\u0009do ast :: @parseStatSkip()\n\u0009case \"assert\"\n\u0009\u0009do ast :: @parseStatAssert()\n\u0009default\n\u0009\u0009do \\err@err(%incorrectBlockOrSentence, \\pos@make(@srcName, row, col), [id])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end switch\n\u0009\n\u0009if(ast =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.pos :: \\pos@make(@srcName, row, col)\n\u0009ret ast\nend func\n\nfunc parseStatEnd(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStat :: #\\ast@AstStat\n\u0009do @initAst(ast, %statEnd, \\pos@make(@srcName, row, col), null, false)\n\u0009\n\u0009var id: []char :: @readIdentifier(true, false)\n\u0009var err: bool :: false\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009switch(id)\n\u0009case \"func\"\n\u0009\u0009if(block_.typeId <> %func_)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009case \"if\"\n\u0009\u0009if(block_.typeId <> %statIf)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009case \"switch\"\n\u0009\u0009if(block_.typeId <> %statSwitch)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009case \"while\"\n\u0009\u0009if(block_.typeId <> %statWhile)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009case \"for\"\n\u0009\u0009if(block_.typeId <> %statFor)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009case \"try\"\n\u0009\u0009if(block_.typeId <> %statTry)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009case \"block\"\n\u0009\u0009if(block_.typeId <> %statBlock)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009default\n\u0009\u0009do \\err@err(%wrongEndUnspecified, \\pos@make(@srcName, row, col), [id])\n\u0009end switch\n\u0009if(err)\n\u0009\u0009do \\err@err(%nonCorrespondingEnd, \\pos@make(@srcName, row, col), [id])\n\u0009end if\n\u0009ret ast\nend func\n\nfunc parseStatFunc(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatFunc :: #\\ast@AstStatFunc\n\u0009do @initAst(ast, %statFunc, null, null, false)\n\u0009do ast.def :: @parseFunc(null, false)\n\u0009ret ast\nend func\n\nfunc parseStatVar(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatVar :: #\\ast@AstStatVar\n\u0009do @initAst(ast, %statVar, null, null, false)\n\u0009do ast.def :: @parseVar(%localVar, null)\n\u0009ret ast\nend func\n\nfunc parseStatConst(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatConst :: #\\ast@AstStatConst\n\u0009do @initAst(ast, %statConst, null, null, false)\n\u0009do ast.def :: @parseConst()\n\u0009ret ast\nend func\n\nfunc parseStatAlias(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatAlias :: #\\ast@AstStatAlias\n\u0009do @initAst(ast, %statAlias, null, null, false)\n\u0009do ast.def :: @parseAlias()\n\u0009ret ast\nend func\n\nfunc parseStatClass(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatClass :: #\\ast@AstStatClass\n\u0009do @initAst(ast, %statClass, null, null, false)\n\u0009do ast.def :: @parseClass()\n\u0009ret ast\nend func\n\nfunc parseStatEnum(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatEnum :: #\\ast@AstStatEnum\n\u0009do @initAst(ast, %statEnum, null, null, false)\n\u0009do ast.def :: @parseEnum()\n\u0009ret ast\nend func\n\nfunc parseStatIf(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatIf :: #\\ast@AstStatIf\n\u0009do @initAst(ast, %statIf, @makePos(), null, false)\n\u0009do ast.blockVar :: null\n\u0009do ast.elIfs :: #list<\\ast@AstStatElIf>\n\u0009do ast.elseStatBlock :: null\n\u0009do @pushDummyScope(ast)\n\u0009do @obtainBlockName(ast)\n\u0009do ast.cond :: @parseExpr()\n\u0009do @assertNextChar(\')\', true)\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009\n\u0009block\n\u0009\u0009var stat: \\ast@AstStat\n\u0009\u0009var typeId: \\ast@TypeId\n\u0009\u0009do ast.statBlock :: @parseDummyBlock(&stat, &typeId, %statIf, ast)\n\u0009\u0009while(typeId = %statElIf)\n\u0009\u0009\u0009var elIf: \\ast@AstStatElIf :: stat $ \\ast@AstStatElIf\n\u0009\u0009\u0009do elIf.statBlock :: @parseDummyBlock(&stat, &typeId, %statElIf, ast)\n\u0009\u0009\u0009do ast.elIfs.add(elIf)\n\u0009\u0009end while\n\u0009\u0009while(typeId = %statElse)\n\u0009\u0009\u0009do ast.elseStatBlock :: @parseDummyBlock(&stat, &typeId, %statElse, ast)\n\u0009\u0009end while\n\u0009\u0009assert typeId = %statEnd\n\u0009end block\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseStatElIf(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStatElIf :: #\\ast@AstStatElIf\n\u0009do @initAst(ast, %statElIf, null, null, false)\n\u0009do ast.statBlock :: null\n\u0009if(block_.typeId <> %statIf)\n\u0009\u0009do \\err@err(%wrongClause, \\pos@make(@srcName, row, col), [\"if\", \"elif\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009do @assertNextChar(\'(\', true)\n\u0009do ast.cond :: @parseExpr()\n\u0009do @assertNextChar(\')\', true)\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatElse(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStat :: #\\ast@AstStat\n\u0009do @initAst(ast, %statElse, null, null, false)\n\u0009if(block_.typeId <> %statIf)\n\u0009\u0009do \\err@err(%wrongClause, \\pos@make(@srcName, row, col), [\"if\", \"else\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatSwitch(row: int, col: int): \\ast@AstStat\n\u0009var ast: \\ast@AstStatSwitch :: #\\ast@AstStatSwitch\n\u0009do @initAst(ast, %statSwitch, @makePos(), null, false)\n\u0009do ast.blockVar :: @makeBlockVar(ast.pos)\n\u0009do ast.cases :: #list<\\ast@AstStatCase>\n\u0009do ast.defaultStatBlock :: null\n\u0009do @pushDummyScope(ast)\n\u0009do @obtainBlockName(ast)\n\u0009do ast.cond :: @parseExpr()\n\u0009do @assertNextChar(\')\', true)\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009\n\u0009block\n\u0009\u0009var stat: \\ast@AstStat\n\u0009\u0009var typeId: \\ast@TypeId\n\u0009\u0009while loop(true)\n\u0009\u0009\u0009do stat :: @parseStat(ast)\n\u0009\u0009\u0009if(stat =& null)\n\u0009\u0009\u0009\u0009if(@fileLast)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009break loop\n\u0009\u0009end while\n\u0009\u0009do typeId :: stat.typeId\n\u0009\u0009if(!(typeId = %statCase | typeId = %statDefault | typeId = %statEnd))\n\u0009\u0009\u0009do \\err@err(%wrongClauseInSwitch, @makePos(), null)\n\u0009\u0009end if\n\u0009\u0009while(typeId = %statCase)\n\u0009\u0009\u0009var case_: \\ast@AstStatCase :: stat $ \\ast@AstStatCase\n\u0009\u0009\u0009do case_.statBlock :: @parseDummyBlock(&stat, &typeId, %statCase, ast)\n\u0009\u0009\u0009do ast.cases.add(case_)\n\u0009\u0009end while\n\u0009\u0009while(typeId = %statDefault)\n\u0009\u0009\u0009do ast.defaultStatBlock :: @parseDummyBlock(&stat, &typeId, %statDefault, ast)\n\u0009\u0009end while\n\u0009\u0009assert typeId = %statEnd\n\u0009end block\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseStatCase(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStatCase :: #\\ast@AstStatCase\n\u0009do @initAst(ast, %statCase, null, null, false)\n\u0009do ast.conds :: #list<\\ast@ExprPair>\n\u0009do ast.statBlock :: null\n\u0009if(block_.typeId <> %statSwitch)\n\u0009\u0009do \\err@err(%wrongClause, \\pos@make(@srcName, row, col), [\"switch\", \"case\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009while loop(true)\n\u0009\u0009var exprs: \\ast@ExprPair :: #\\ast@ExprPair\n\u0009\u0009do exprs.expr0 :: @parseExpr()\n\u0009\u0009do exprs.expr1 :: null\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(c = \',\')\n\u0009\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009\u0009skip loop\n\u0009\u0009end if\n\u0009\u0009do @fileBuf :: c\n\u0009\u0009var id: []char :: @readIdentifier(true, false)\n\u0009\u0009if(id <> \"to\")\n\u0009\u0009\u0009do \\err@err(%wrongWord, @makePos(), [\"to\", id])\n\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009do exprs.expr1 :: @parseExpr()\n\u0009\u0009do c :: @readChar()\n\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009end if\n\u0009end while\n\u0009\n\u0009ret ast\nend func\n\nfunc parseStatDefault(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStat :: #\\ast@AstStat\n\u0009do @initAst(ast, %statDefault, null, null, false)\n\u0009if(block_.typeId <> %statSwitch)\n\u0009\u0009do \\err@err(%wrongClause, \\pos@make(@srcName, row, col), [\"switch\", \"default\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatWhile(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatWhile :: #\\ast@AstStatWhile\n\u0009do @initAst(ast, %statWhile, @makePos(), null, false)\n\u0009do ast.blockVar :: null\n\u0009do ast.skip_ :: false\n\u0009do ast.stats :: #list<\\ast@AstStat>\n\u0009do @pushDummyScope(ast)\n\u0009do @obtainBlockName(ast)\n\u0009do ast.cond :: @parseExpr()\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \',\')\n\u0009\u0009\u0009var id: []char :: @readIdentifier(true, false)\n\u0009\u0009\u0009if(id <> \"skip\")\n\u0009\u0009\u0009\u0009do \\err@err(%wrongWord, @makePos(), [\"skip\", id])\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.skip_ :: true\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009\u0009do @assertNextChar(\')\', true)\n\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009end block\n\u0009\n\u0009while loop(true)\n\u0009\u0009var stat: \\ast@AstStat :: @parseStat(ast)\n\u0009\u0009if(stat =& null)\n\u0009\u0009\u0009if(@fileLast)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(stat.typeId = %statEnd)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do ast.stats.add(stat)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseStatFor(row: int, col: int): \\ast@AstStat\n\u0009var ast: \\ast@AstStatFor :: #\\ast@AstStatFor\n\u0009do @initAst(ast, %statFor, @makePos(), null, false)\n\u0009do ast.blockVar :: @makeBlockVar(ast.pos)\n\u0009do ast.stats :: #list<\\ast@AstStat>\n\u0009do @pushDummyScope(ast)\n\u0009do @obtainBlockName(ast)\n\u0009do ast.start :: @parseExpr()\n\u0009do @assertNextChar(\',\', true)\n\u0009do ast.cond :: @parseExpr()\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \',\')\n\u0009\u0009\u0009do ast.step :: @parseExpr()\n\u0009\u0009\u0009do @assertNextChar(\')\', true)\n\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009else\n\u0009\u0009\u0009do ast.step :: @makePrimValue(@makePos(), %int_, 1b64)\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009do @assertNextChar(\')\', true)\n\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009while loop(true)\n\u0009\u0009var stat: \\ast@AstStat :: @parseStat(ast)\n\u0009\u0009if(stat =& null)\n\u0009\u0009\u0009if(@fileLast)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(stat.typeId = %statEnd)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do ast.stats.add(stat)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseStatTry(row: int, col: int): \\ast@AstStat\n\u0009var ast: \\ast@AstStatTry :: #\\ast@AstStatTry\n\u0009do @initAst(ast, %statTry, @makePos(), null, false)\n\u0009do ast.blockVar :: @makeBlockVar(ast.pos)\n\u0009do ast.catches :: #list<\\ast@AstStatCatch>\n\u0009do ast.finallyStatBlock :: null\n\u0009do @pushDummyScope(ast)\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c <> \'\\n\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009do ast.name :: @readIdentifier(true, false)\n\u0009\u0009\u0009do @addScopeName(ast, true)\n\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009else\n\u0009\u0009\u0009do ast.name :: \"$\"\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009do @initAst(type, %typePrim, \\pos@make(@srcName, row, col), null, false)\n\u0009\u0009do type.kind :: %int_\n\u0009\u0009do ast.blockVar.type :: type\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var stat: \\ast@AstStat\n\u0009\u0009var typeId: \\ast@TypeId\n\u0009\u0009do ast.statBlock :: @parseDummyBlock(&stat, &typeId, %statTry, ast)\n\u0009\u0009while(typeId = %statCatch)\n\u0009\u0009\u0009var catch_: \\ast@AstStatCatch :: stat $ \\ast@AstStatCatch\n\u0009\u0009\u0009do catch_.statBlock :: @parseDummyBlock(&stat, &typeId, %statCatch, ast)\n\u0009\u0009\u0009do ast.catches.add(catch_)\n\u0009\u0009end while\n\u0009\u0009if(typeId = %statFinally)\n\u0009\u0009\u0009do ast.finallyStatBlock :: @parseDummyBlock(&stat, &typeId, %statFinally, ast)\n\u0009\u0009end if\n\u0009\u0009assert typeId = %statEnd\n\u0009end block\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseStatCatch(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStatCatch :: #\\ast@AstStatCatch\n\u0009do @initAst(ast, %statCatch, null, null, false)\n\u0009do ast.conds :: #list<\\ast@ExprPair>\n\u0009do ast.statBlock :: null\n\u0009if(block_.typeId <> %statTry)\n\u0009\u0009do \\err@err(%wrongClause, \\pos@make(@srcName, row, col), [\"try\", \"catch\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009var exprs: \\ast@ExprPair :: #\\ast@ExprPair\n\u0009\u0009\u0009var pos: \\pos@Pos :: @makePos()\n\u0009\u0009\u0009do exprs.expr0 :: @makePrimValue(pos, %int_, 0b64)\n\u0009\u0009\u0009do exprs.expr1 :: @makePrimValue(pos, %int_, 0xFFFFFFFFb64)\n\u0009\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: #\\ast@ExprPair\n\u0009\u0009\u0009\u0009do exprs.expr0 :: @parseExpr()\n\u0009\u0009\u0009\u0009do exprs.expr1 :: null\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \',\')\n\u0009\u0009\u0009\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009var id: []char :: @readIdentifier(true, false)\n\u0009\u0009\u0009\u0009if(id <> \"to\")\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%wrongWord, @makePos(), [\"to\", id])\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do exprs.expr1 :: @parseExpr()\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009ret ast\nend func\n\nfunc parseStatFinally(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStat :: #\\ast@AstStat\n\u0009do @initAst(ast, %statFinally, null, null, false)\n\u0009if(block_.typeId <> %statTry)\n\u0009\u0009do \\err@err(%wrongClause, \\pos@make(@srcName, row, col), [\"try\", \"finally\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatThrow(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatThrow :: #\\ast@AstStatThrow\n\u0009do @initAst(ast, %statThrow, @makePos(), null, false)\n\u0009do ast.code :: @parseExpr()\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatBlock(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009do @initAst(ast, %statBlock, @makePos(), null, false)\n\u0009do ast.blockVar :: null\n\u0009do ast.stats :: #list<\\ast@AstStat>\n\u0009do @pushDummyScope(ast)\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c <> \'\\n\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009do ast.name :: @readIdentifier(true, false)\n\u0009\u0009\u0009do @addScopeName(ast, true)\n\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009else\n\u0009\u0009\u0009do ast.name :: \"$\"\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009while loop(true)\n\u0009\u0009var stat: \\ast@AstStat :: @parseStat(ast)\n\u0009\u0009if(stat =& null)\n\u0009\u0009\u0009if(@fileLast)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(stat.typeId = %statEnd)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do ast.stats.add(stat)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseStatRet(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatRet :: #\\ast@AstStatRet\n\u0009do @initAst(ast, %statRet, @makePos(), null, false)\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c <> \'\\n\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009do ast.value :: @parseExpr()\n\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009else\n\u0009\u0009\u0009do ast.value :: null\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009ret ast\nend func\n\nfunc parseStatDo(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009do @initAst(ast, %statDo, @makePos(), null, false)\n\u0009do ast.expr :: @parseExpr()\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatBreak(): \\ast@AstStat\n\u0009var ast: \\ast@AstStat :: #\\ast@AstStat\n\u0009do @initAst(ast, %statBreak, @makePos(), null, false)\n\u0009do @addScopeRefeds(ast, @readIdentifier(true, false))\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatSkip(): \\ast@AstStat\n\u0009var ast: \\ast@AstStat :: #\\ast@AstStat\n\u0009do @initAst(ast, %statSkip, @makePos(), null, false)\n\u0009do @addScopeRefeds(ast, @readIdentifier(true, false))\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatAssert(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatAssert :: #\\ast@AstStatAssert\n\u0009do @initAst(ast, %statAssert, @makePos(), null, false)\n\u0009do ast.cond :: @parseExpr()\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseType(): \\ast@AstType\n\u0009var pos: \\pos@Pos :: @makePos()\n\u0009var ast: \\ast@AstType :: null\n\u0009var c: char :: @readChar()\n\u0009if(c = \'[\')\n\u0009\u0009do @assertNextChar(\']\', true)\n\u0009\u0009\n\u0009\u0009var ast2: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009do @initAst(ast2, %typeArray, pos, null, false)\n\u0009\u0009do ast2.itemType :: @parseType()\n\u0009\u0009do ast :: ast2\n\u0009else\n\u0009\u0009do @fileBuf :: c\n\u0009\u0009var id: []char :: @readIdentifier(true, true)\n\u0009\u0009if(^id >= 4 & id[0] = \'b\' & id[1] = \'i\' & id[2] = \'t\')\n\u0009\u0009\u0009var size: []char :: id.sub(3, ^id - 3)\n\u0009\u0009\u0009if(size = \"8\" | size = \"16\" | size = \"32\" | size = \"64\")\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeBit, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.size :: size.toInt(&) / 8\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(ast =& null)\n\u0009\u0009\u0009switch(id)\n\u0009\u0009\u0009case \"func\"\n\u0009\u0009\u0009\u0009do @assertNextChar(\'<\', true)\n\u0009\u0009\u0009\u0009do @assertNextChar(\'(\', true)\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeFunc :: #\\ast@AstTypeFunc\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeFunc, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.funcOption :: %none\n\u0009\u0009\u0009\u0009do ast2.funcAttr :: #list<[]char>\n\u0009\u0009\u0009\u0009do ast2.args :: #list<\\ast@AstTypeFuncArg>\n\u0009\u0009\u0009\u0009do ast2.ret_ :: null\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c <> \')\')\n\u0009\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009if(c = \'&\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: true\n\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.arg :: @parseType()\n\u0009\u0009\u0009\u0009\u0009\u0009do ast2.args.add(arg)\n\u0009\u0009\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009\u0009\u0009if(c = \')\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \':\')\n\u0009\u0009\u0009\u0009\u0009do ast2.ret_ :: @parseType()\n\u0009\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c <> \'>\')\n\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\'>\', c)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"list\"\n\u0009\u0009\u0009\u0009do @assertNextChar(\'<\', true)\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeGen :: #\\ast@AstTypeGen\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeGen, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %list_\n\u0009\u0009\u0009\u0009do ast2.itemType :: @parseType()\n\u0009\u0009\u0009\u0009do @assertNextChar(\'>\', true)\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"stack\"\n\u0009\u0009\u0009\u0009do @assertNextChar(\'<\', true)\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeGen :: #\\ast@AstTypeGen\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeGen, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %stack_\n\u0009\u0009\u0009\u0009do ast2.itemType :: @parseType()\n\u0009\u0009\u0009\u0009do @assertNextChar(\'>\', true)\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"queue\"\n\u0009\u0009\u0009\u0009do @assertNextChar(\'<\', true)\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeGen :: #\\ast@AstTypeGen\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeGen, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %queue_\n\u0009\u0009\u0009\u0009do ast2.itemType :: @parseType()\n\u0009\u0009\u0009\u0009do @assertNextChar(\'>\', true)\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"dict\"\n\u0009\u0009\u0009\u0009do @assertNextChar(\'<\', true)\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeDict :: #\\ast@AstTypeDict\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeDict, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.itemTypeKey :: @parseType()\n\u0009\u0009\u0009\u0009do @assertNextChar(\',\', true)\n\u0009\u0009\u0009\u0009do ast2.itemTypeValue :: @parseType()\n\u0009\u0009\u0009\u0009do @assertNextChar(\'>\', true)\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"int\"\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typePrim, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %int_\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"float\"\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typePrim, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %float_\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"char\"\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typePrim, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %char_\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"bool\"\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typePrim, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %bool_\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeUser, pos, null, false)\n\u0009\u0009\u0009\u0009do @addScopeRefeds(ast2, id)\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009end switch\n\u0009\u0009end if\n\u0009end if\n\u0009ret ast\nend func\n\n; parseExprAssign\nfunc parseExpr(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprThree()\n\u0009var row: int :: @row\n\u0009var col: int :: @col\n\u0009var c: char :: @readChar()\n\u0009if(c = \':\')\n\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009var c2: char :: @read()\n\u0009\u0009switch(c2)\n\u0009\u0009case \':\'\n\u0009\u0009\u0009do ast2.kind :: %assign\n\u0009\u0009case \'+\'\n\u0009\u0009\u0009do ast2.kind :: %assignAdd\n\u0009\u0009case \'-\'\n\u0009\u0009\u0009do ast2.kind :: %assignSub\n\u0009\u0009case \'*\'\n\u0009\u0009\u0009do ast2.kind :: %assignMul\n\u0009\u0009case \'/\'\n\u0009\u0009\u0009do ast2.kind :: %assignDiv\n\u0009\u0009case \'%\'\n\u0009\u0009\u0009do ast2.kind :: %assignMod\n\u0009\u0009case \'^\'\n\u0009\u0009\u0009do ast2.kind :: %assignPow\n\u0009\u0009case \'~\'\n\u0009\u0009\u0009do ast2.kind :: %assignCat\n\u0009\u0009case \'$\'\n\u0009\u0009\u0009do ast2.kind :: %swap\n\u0009\u0009default\n\u0009\u0009\u0009do \\err@err(%wrongOperator, ast2.pos, [@charToStr(c2)])\n\u0009\u0009\u0009do @readUntilRet(c2)\n\u0009\u0009\u0009ret null\n\u0009\u0009end switch\n\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009do ast2.children1 :: @parseExpr()\n\u0009\u0009do ast :: ast2\n\u0009else\n\u0009\u0009do @fileBuf :: c\n\u0009end if\n\u0009ret ast\nend func\n\nfunc parseExprThree(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprOr()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'?\')\n\u0009\u0009\u0009do @assertNextChar(\'(\', false)\n\u0009\u0009\u0009var ast2: \\ast@AstExpr3 :: #\\ast@AstExpr3\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr3, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExpr()\n\u0009\u0009\u0009do @assertNextChar(\',\', true)\n\u0009\u0009\u0009do ast2.children2 :: @parseExpr()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009do @assertNextChar(\')\', true)\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprOr(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprAnd()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'|\')\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %or\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprAnd()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprAnd(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprCmp()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'&\')\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %and\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprCmp()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprCmp(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprCat()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009switch(c)\n\u0009\u0009case \'<\'\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009switch(c)\n\u0009\u0009\u0009case \'=\'\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.kind :: %le\n\u0009\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \'>\'\n\u0009\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009\u0009switch(c)\n\u0009\u0009\u0009\u0009case \'&\'\n\u0009\u0009\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009\u0009do ast2.kind :: %nEqRef\n\u0009\u0009\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009\u0009case \'$\'\n\u0009\u0009\u0009\u0009\u0009var ast2: \\ast@AstExprAs :: #\\ast@AstExprAs\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %exprAs, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009\u0009do ast2.kind :: %nIs\n\u0009\u0009\u0009\u0009\u0009do ast2.child :: ast\n\u0009\u0009\u0009\u0009\u0009do ast2.childType :: @parseType()\n\u0009\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009\u0009do ast2.kind :: %nEq\n\u0009\u0009\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.kind :: %lt\n\u0009\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009end switch\n\u0009\u0009case \'>\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009if(c = \'=\')\n\u0009\u0009\u0009\u0009do ast2.kind :: %ge\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009do ast2.kind :: %gt\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'=\'\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009switch(c)\n\u0009\u0009\u0009case \'&\'\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.kind :: %eqRef\n\u0009\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \'$\'\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExprAs :: #\\ast@AstExprAs\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %exprAs, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.kind :: %is\n\u0009\u0009\u0009\u0009do ast2.child :: ast\n\u0009\u0009\u0009\u0009do ast2.childType :: @parseType()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.kind :: %eq\n\u0009\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009end switch\n\u0009\u0009default\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end switch\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprCat(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprAdd()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'~\')\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %cat\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprAdd()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprAdd(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprMul()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009switch(c)\n\u0009\u0009case \'+\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %add\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprMul()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'-\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %sub\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprMul()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009default\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end switch\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprMul(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprPlus()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009switch(c)\n\u0009\u0009case \'*\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %mul\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprPlus()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'/\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %div\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprPlus()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'%\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %mod\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprPlus()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009default\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end switch\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprPlus(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprPow()\n\u0009if(ast <>& null)\n\u0009\u0009ret ast\n\u0009end if\n\u0009var row: int :: @row\n\u0009var col: int :: @col\n\u0009var c: char :: @readChar()\n\u0009if(c = \'#\')\n\u0009\u0009do c :: @read()\n\u0009\u0009switch(c)\n\u0009\u0009case \'[\'\n\u0009\u0009\u0009var ast2: \\ast@AstExprNewArray :: #\\ast@AstExprNewArray\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprNewArray, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.idces :: #list<\\ast@AstExpr>\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009do ast2.idces.add(@parseExpr())\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \']\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do ast2.itemType :: @parseType()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'#\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr1 :: #\\ast@AstExpr1\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr1, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %copy\n\u0009\u0009\u0009do ast2.child :: @parseExprPlus()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009default\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009var ast2: \\ast@AstExprNew :: #\\ast@AstExprNew\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprNew, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.itemType :: @parseType()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009end switch\n\u0009else\n\u0009\u0009var ast2: \\ast@AstExpr1 :: #\\ast@AstExpr1\n\u0009\u0009do @initAstExpr(ast2, %expr1, \\pos@make(@srcName, row, col))\n\u0009\u0009switch(c)\n\u0009\u0009case \'+\'\n\u0009\u0009\u0009do ast2.kind :: %plus\n\u0009\u0009case \'-\'\n\u0009\u0009\u0009do ast2.kind :: %minus\n\u0009\u0009case \'!\'\n\u0009\u0009\u0009do ast2.kind :: %not\n\u0009\u0009case \'^\'\n\u0009\u0009\u0009do ast2.kind :: %len\n\u0009\u0009default\n\u0009\u0009\u0009do \\err@err(%wrongOperator, ast2.pos, [@charToStr(c)])\n\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009ret null\n\u0009\u0009end switch\n\u0009\u0009do ast2.child :: @parseExprPlus()\n\u0009\u0009do ast :: ast2\n\u0009end if\n\u0009ret ast\nend func\n\nfunc parseExprPow(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprCall()\n\u0009if(ast =& null)\n\u0009\u0009ret ast {Interpret as a unary operator.}\n\u0009end if\n\u0009var row: int :: @row\n\u0009var col: int :: @col\n\u0009var c: char :: @readChar()\n\u0009if(c = \'^\')\n\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009do ast2.kind :: %pow\n\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009do ast2.children1 :: @parseExprPlus()\n\u0009\u0009do ast :: ast2\n\u0009else\n\u0009\u0009do @fileBuf :: c\n\u0009end if\n\u0009ret ast\nend func\n\nfunc parseExprCall(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprValue()\n\u0009if(ast =& null)\n\u0009\u0009ret ast\n\u0009end if\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009switch(c)\n\u0009\u0009case \'(\'\n\u0009\u0009\u0009assert ast <>& null\n\u0009\u0009\u0009var ast2: \\ast@AstExprCall :: #\\ast@AstExprCall\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprCall, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.func_ :: ast\n\u0009\u0009\u0009do ast2.args :: #list<\\ast@AstExprCallArg>\n\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009if(c <> \')\')\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009while loop2(true)\n\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstExprCallArg :: #\\ast@AstExprCallArg\n\u0009\u0009\u0009\u0009\u0009do arg.skipVar :: false\n\u0009\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009\u0009if(c = \'&\')\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: true\n\u0009\u0009\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009\u0009\u0009if(c = \',\' | c = \')\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.skipVar :: true\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009\u0009if(arg.skipVar)\n\u0009\u0009\u0009\u0009\u0009\u0009var ast3: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ast3, %exprRef, ast2.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do ast3.refName :: \"$\"\n\u0009\u0009\u0009\u0009\u0009\u0009do ast3.refItem :: @makeBlockVar(ast3.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.arg :: ast3\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.arg :: @parseExpr()\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do ast2.args.add(arg)\n\u0009\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009\u0009break loop2\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(c = \')\')\n\u0009\u0009\u0009\u0009\u0009\u0009break loop2\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'[\'\n\u0009\u0009\u0009assert ast <>& null\n\u0009\u0009\u0009var ast2: \\ast@AstExprArray :: #\\ast@AstExprArray\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprArray, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.var_ :: ast\n\u0009\u0009\u0009do ast2.idx :: @parseExpr()\n\u0009\u0009\u0009do @assertNextChar(\']\', true)\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'.\'\n\u0009\u0009\u0009assert ast <>& null\n\u0009\u0009\u0009var ast2: \\ast@AstExprDot :: #\\ast@AstExprDot\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprDot, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.var_ :: ast\n\u0009\u0009\u0009do ast2.member :: @readIdentifier(true, false)\n\u0009\u0009\u0009do ast2.classItem :: null\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'$\'\n\u0009\u0009\u0009assert ast <>& null\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009switch(c)\n\u0009\u0009\u0009case \'>\'\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExprToBin :: #\\ast@AstExprToBin\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %exprToBin, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.child :: ast\n\u0009\u0009\u0009\u0009do ast2.childType :: @parseType()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \'<\'\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExprFromBin :: #\\ast@AstExprFromBin\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %exprFromBin, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.child :: ast\n\u0009\u0009\u0009\u0009do ast2.childType :: @parseType()\n\u0009\u0009\u0009\u0009do ast2.offset :: @makePrimValue(ast2.pos, %int_, 0b64)\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExprAs :: #\\ast@AstExprAs\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %exprAs, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.kind :: %as\n\u0009\u0009\u0009\u0009do ast2.child :: ast\n\u0009\u0009\u0009\u0009do ast2.childType :: @parseType()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009end switch\n\u0009\u0009default\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end switch\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprValue(): \\ast@AstExpr\n\u0009var row: int :: @row\n\u0009var col: int :: @col\n\u0009var c: char :: @readChar()\n\u0009var pos: \\pos@Pos :: \\pos@make(@srcName, row, col)\n\u0009switch(c)\n\u0009case \'\"\'\n\u0009\u0009var buf: []char :: #[1024]char\n\u0009\u0009var len: int :: 0\n\u0009\u0009var esc: bool :: false\n\u0009\u0009while loop(true)\n\u0009\u0009\u0009do c :: @readInStr()\n\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009do \\err@err(%nonClosingStrLiteral, pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(esc)\n\u0009\u0009\u0009\u0009if(c = \'{\')\n\u0009\u0009\u0009\u0009\u0009var cat: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(cat, %expr2, pos)\n\u0009\u0009\u0009\u0009\u0009do cat.kind :: %cat\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var cat2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(cat2, %expr2, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do cat2.kind :: %cat\n\u0009\u0009\u0009\u0009\u0009\u0009do cat2.children0 :: @makeStrValue(pos, buf.sub(0, len))\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var call: \\ast@AstExprCall :: #\\ast@AstExprCall\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(call, %exprCall, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do call.args :: #list<\\ast@AstExprCallArg>\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var dot: \\ast@AstExprDot :: #\\ast@AstExprDot\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(dot, %exprDot, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.var_ :: @parseExpr()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.member :: \"toStr\"\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.classItem :: null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do call.func_ :: dot\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do cat2.children1 :: call\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do @assertNextChar(\'}\', false)\n\u0009\u0009\u0009\u0009\u0009\u0009do cat.children0 :: cat2\n\u0009\u0009\u0009\u0009\u0009\u0009do @fileBuf :: \'\"\'\n\u0009\u0009\u0009\u0009\u0009\u0009do cat.children1 :: @parseExprValue()\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009ret cat\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%tooLongStringLiteral, pos, [buf])\n\u0009\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do buf[len] :: @escChar(c)\n\u0009\u0009\u0009\u0009do len :+ 1\n\u0009\u0009\u0009\u0009do esc :: false\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(c = \'\"\')\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(c = \'\\\\\')\n\u0009\u0009\u0009\u0009do esc :: true\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009do \\err@err(%tooLongStringLiteral, pos, [buf])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf[len] :: c\n\u0009\u0009\u0009do len :+ 1\n\u0009\u0009end while\n\u0009\u0009ret @makeStrValue(pos, buf.sub(0, len))\n\u0009case \'\\\'\'\n\u0009\u0009var buf: char :: \'\\0\'\n\u0009\u0009var set: bool :: false\n\u0009\u0009var esc: bool :: false\n\u0009\u0009while loop(true)\n\u0009\u0009\u0009do c :: @readInStr()\n\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009do \\err@err(%nonClosingStrLiteral, pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(esc)\n\u0009\u0009\u0009\u0009if(set)\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%tooLongCharLiteral, pos, [@charToStr(buf)])\n\u0009\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do buf :: @escChar(c)\n\u0009\u0009\u0009\u0009do set :: true\n\u0009\u0009\u0009\u0009do esc :: false\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(c = \'\\\'\')\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(c = \'\\\\\')\n\u0009\u0009\u0009\u0009do esc :: true\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(set)\n\u0009\u0009\u0009\u0009do \\err@err(%tooLongCharLiteral, pos, [@charToStr(buf)])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf :: c\n\u0009\u0009\u0009do set :: true\n\u0009\u0009end while\n\u0009\u0009if(!set)\n\u0009\u0009\u0009do \\err@err(%emptyCharLiteral, pos, null)\n\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009ret @makePrimValue(pos, %char_, buf $ bit64)\n\u0009case \'(\'\n\u0009\u0009var ast: \\ast@AstExpr :: @parseExpr()\n\u0009\u0009do c :: @readChar()\n\u0009\u0009if(c <> \')\')\n\u0009\u0009\u0009do \\err@err(%noParenthesis, pos, null)\n\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009ret ast\n\u0009case \'[\'\n\u0009\u0009var ast: \\ast@AstExprValueArray :: #\\ast@AstExprValueArray\n\u0009\u0009do @initAstExpr(ast, %exprValueArray, pos)\n\u0009\u0009do ast.values :: #list<\\ast@AstExpr>\n\u0009\u0009do c :: @readChar()\n\u0009\u0009if(c <> \']\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009var expr: \\ast@AstExpr :: @parseExpr()\n\u0009\u0009\u0009\u0009if(expr <>& null)\n\u0009\u0009\u0009\u0009\u0009do ast.values.add(expr)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \']\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009end if\n\u0009\u0009ret ast\n\u0009case \'%\'\n\u0009\u0009var id: []char :: @readIdentifier(false, false)\n\u0009\u0009var expr: \\ast@AstExprValueEnumElement :: #\\ast@AstExprValueEnumElement\n\u0009\u0009do @initAstExpr(expr, %exprValueEnumElement, pos)\n\u0009\u0009block\n\u0009\u0009\u0009var type: \\ast@AstTypeEnumElement :: #\\ast@AstTypeEnumElement\n\u0009\u0009\u0009do @initAst(type, %typeEnumElement, pos, null, false)\n\u0009\u0009\u0009do expr.type :: type\n\u0009\u0009end block\n\u0009\u0009do expr.identifier :: id\n\u0009\u0009ret expr\n\u0009default\n\u0009\u0009if(\'0\' <= c & c <= \'9\')\n\u0009\u0009\u0009ret @parseExprNumber(row, col, c)\n\u0009\u0009end if\n\u0009\u0009if(\'a\' <= c & c <= \'z\' | \'A\' <= c & c <= \'Z\' | c = \'_\' | c = \'@\' | c = \'\\\\\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009var id: []char :: @readIdentifier(true, true)\n\u0009\u0009\u0009switch(id)\n\u0009\u0009\u0009case \"false\"\n\u0009\u0009\u0009\u0009ret @makePrimValue(pos, %bool_, 0b64)\n\u0009\u0009\u0009case \"true\"\n\u0009\u0009\u0009\u0009ret @makePrimValue(pos, %bool_, 1b64)\n\u0009\u0009\u0009case \"inf\"\n\u0009\u0009\u0009\u0009ret @makeFloatValue(pos, inf)\n\u0009\u0009\u0009case \"null\"\n\u0009\u0009\u0009\u0009var ast: \\ast@AstExprValue :: #\\ast@AstExprValue\n\u0009\u0009\u0009\u0009do @initAstExpr(ast, %exprValue, pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeNull :: #\\ast@AstTypeNull\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeNull, pos, null, false)\n\u0009\u0009\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009ret ast\n\u0009\u0009\u0009case \"dbg\"\n\u0009\u0009\u0009\u0009ret @makePrimValue(pos, %bool_, \\option@rls ?(0b64, 1b64))\n\u0009\u0009\u0009case \"env\"\n\u0009\u0009\u0009\u0009ret @makePrimValue(pos, %int_, \\option@env_ $ bit64)\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009var ast: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009do @initAstExpr(ast, %exprRef, pos)\n\u0009\u0009\u0009\u0009do @addScopeRefeds(ast, id)\n\u0009\u0009\u0009\u0009ret ast\n\u0009\u0009\u0009end switch\n\u0009\u0009end if\n\u0009end switch\n\u0009do @fileBuf :: c\n\u0009ret null\nend func\n\nfunc parseExprNumber(row: int, col: int, c: char): \\ast@AstExpr\n\u0009var ast: \\ast@AstExprValue\n\u0009var pos: \\pos@Pos :: \\pos@make(@srcName, row, col)\n\u0009var buf: []char :: #[1024]char\n\u0009var len: int :: 0\n\u0009var base: int :: 10\n\u0009var changeBase: bool :: false\n\u0009var floatType: bool :: false\n\u0009var byteSize: int :: 0 {The size for bit types.}\n\u0009while loop(true)\n\u0009\u0009switch(c)\n\u0009\u0009case \'x\'\n\u0009\u0009\u0009if(changeBase | floatType)\n\u0009\u0009\u0009\u0009do \\err@err(%wrongNumericLiteral, pos, [\"x\"])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(len <> 1 | buf[0] <> \'0\')\n\u0009\u0009\u0009\u0009do \\err@err(%wrongHexadecimalLiteral, pos, null)\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do len :: 0\n\u0009\u0009\u0009do base :: 16\n\u0009\u0009\u0009do changeBase :: true\n\u0009\u0009case \'.\'\n\u0009\u0009\u0009if(changeBase | floatType)\n\u0009\u0009\u0009\u0009do \\err@err(%wrongNumericLiteral, pos, [\".\"])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009do \\err@err(%tooLongNumericLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf[len] :: c\n\u0009\u0009\u0009do len :+ 1\n\u0009\u0009\u0009do floatType :: true\n\u0009\u0009case \'0\' to \'9\', \'A\' to \'F\'\n\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009do \\err@err(%tooLongNumericLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf[len] :: c\n\u0009\u0009\u0009do len :+ 1\n\u0009\u0009default\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end switch\n\u0009\u0009do c :: @read()\n\u0009end while\n\u0009if(len = 0 | buf[len - 1] = \'.\')\n\u0009\u0009do \\err@err(%wrongNumericLiteral, pos, [\".\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009if(floatType)\n\u0009\u0009do c :: @read()\n\u0009\u0009if(c = \'e\')\n\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009do \\err@err(%tooLongNumericLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf[len] :: c\n\u0009\u0009\u0009do len :+ 1\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009if(c <> \'+\' & c <> \'-\')\n\u0009\u0009\u0009\u0009do \\err@err(%wrongExponentialNotationLiteral, pos, null)\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009do \\err@err(%tooLongNumericLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf[len] :: c\n\u0009\u0009\u0009do len :+ 1\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009if(!(\'0\' <= c & c <= \'9\'))\n\u0009\u0009\u0009\u0009do \\err@err(%wrongExponentialNotationLiteral, pos, null)\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009while(\'0\' <= c & c <= \'9\', skip)\n\u0009\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%tooLongNumericLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do buf[len] :: c\n\u0009\u0009\u0009\u0009do len :+ 1\n\u0009\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009end while\n\u0009\u0009end if\n\u0009\u0009do @fileBuf :: c\n\u0009\u0009block\n\u0009\u0009\u0009var success: bool\n\u0009\u0009\u0009var value: float :: buf.sub(0, len).toFloat(&success)\n\u0009\u0009\u0009if(!success)\n\u0009\u0009\u0009\u0009do \\err@err(%wrongFloatingPointLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009var ast2: \\ast@AstExprValueFloat :: #\\ast@AstExprValueFloat\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprValueFloat, pos)\n\u0009\u0009\u0009do ast2.value :: value\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009end block\n\u0009else\n\u0009\u0009do c :: @read()\n\u0009\u0009if(c = \'b\')\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009switch(c)\n\u0009\u0009\u0009case \'8\'\n\u0009\u0009\u0009\u0009do byteSize :: 1\n\u0009\u0009\u0009case \'1\'\n\u0009\u0009\u0009\u0009do @assertNextChar(\'6\', false)\n\u0009\u0009\u0009\u0009do byteSize :: 2\n\u0009\u0009\u0009case \'3\'\n\u0009\u0009\u0009\u0009do @assertNextChar(\'2\', false)\n\u0009\u0009\u0009\u0009do byteSize :: 4\n\u0009\u0009\u0009case \'6\'\n\u0009\u0009\u0009\u0009do @assertNextChar(\'4\', false)\n\u0009\u0009\u0009\u0009do byteSize :: 8\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do \\err@err(%wrongBitTypeLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009end switch\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009block\n\u0009\u0009\u0009var value: bit64\n\u0009\u0009\u0009var success: bool\n\u0009\u0009\u0009if(base = 10)\n\u0009\u0009\u0009\u0009do value :: buf.sub(0, len).toBit64(&success)\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009assert base = 16\n\u0009\u0009\u0009\u0009do value :: (\"0x\" ~ buf.sub(0, len)).toBit64(&success)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!success)\n\u0009\u0009\u0009\u0009do \\err@err(%integerLiteralOverflowed, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(byteSize = 1 & value > 0xFFb64 | byteSize = 2 & value > 0xFFFFb64 | byteSize = 4 & value > 0xFFFFFFFFb64 | byteSize = 0 & value > lib@intMax $ bit64)\n\u0009\u0009\u0009\u0009do \\err@err(%integerLiteralOverflowed, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009\n\u0009\u0009\u0009var ast2: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprValuePrim, pos)\n\u0009\u0009\u0009do ast2.value :: value\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009end block\n\u0009end if\n\u0009if(byteSize = 0)\n\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009do @initAst(type, %typePrim, pos, null, false)\n\u0009\u0009if(floatType)\n\u0009\u0009\u0009do type.kind :: %float_\n\u0009\u0009else\n\u0009\u0009\u0009do type.kind :: %int_\n\u0009\u0009end if\n\u0009\u0009do ast.type :: type\n\u0009else\n\u0009\u0009var type: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009do @initAst(type, %typeBit, pos, null, false)\n\u0009\u0009do type.size :: byteSize\n\u0009\u0009do ast.type :: type\n\u0009end if\n\u0009ret ast\nend func\n\nfunc makePos(): \\pos@Pos\n\u0009ret \\pos@make(@srcName, @row, @col)\nend func\n\nfunc initAst(ast: \\ast@Ast, typeId: \\ast@TypeId, pos: \\pos@Pos, name: []char, setParent: bool)\n\u0009assert ast <>$ \\ast@AstExpr\n\u0009do @initAstImpl(ast, typeId, pos, name, setParent)\nend func\n\nfunc initAstExpr(ast: \\ast@AstExpr, typeId: \\ast@TypeId, pos: \\pos@Pos)\n\u0009assert ast =$ \\ast@AstExpr\n\u0009do @initAstImpl(ast, typeId, pos, null, false)\n\u0009do ast.type :: null\n\u0009do ast.varKind :: %unknown\nend func\n\nfunc initAstImpl(ast: \\ast@Ast, typeId: \\ast@TypeId, pos: \\pos@Pos, name: []char, setParent: bool)\n\u0009do ast.typeId :: typeId\n\u0009do ast.pos :: pos\n\u0009do ast.name :: name\n\u0009do ast.scopeParent :: null\n\u0009do ast.scopeChildren :: null\n\u0009do ast.refName :: null\n\u0009do ast.refItem :: null\n\u0009do ast.extra :: null\n\u0009do ast.publicInSrc :: false\n\u0009if(ast.name <>& null)\n\u0009\u0009do @addScopeName(ast, true)\n\u0009end if\n\u0009if(setParent)\n\u0009\u0009do ast.scopeParent :: @scope.peek()\n\u0009end if\nend func\n\nfunc addScopeName(ast: \\ast@Ast, refuseReserved: bool)\n\u0009assert ast.name <>& null\n\u0009if(refuseReserved & @isReserved(ast.name))\n\u0009\u0009do \\err@err(%sameIdentifierInSameScope, @makePos(), [ast.name])\n\u0009\u0009ret\n\u0009end if\n\u0009var scope: \\ast@Ast :: @scope.peek()\n\u0009if(scope.scopeChildren.get(ast.name, &) <>& null)\n\u0009\u0009do \\err@err(%sameIdentifierInSameScope, @makePos(), [ast.name])\n\u0009end if\n\u0009\n\u0009var parent: \\ast@Ast :: scope\n\u0009var overFunc: bool :: false\n\u0009while loop(true)\n\u0009\u0009if(parent.scopeParent =& null)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(parent.name <>& null & parent.name = ast.name & !((parent.typeId = %func_ & parent.refName <>& null)))\n\u0009\u0009\u0009do \\err@err(%sameIdentifierInUpperScope, @makePos(), [ast.name])\n\u0009\u0009\u0009ret\n\u0009\u0009end if\n\u0009\u0009var child: \\ast@Ast :: parent.scopeChildren.get(ast.name, &)\n\u0009\u0009if(child <>& null)\n\u0009\u0009\u0009var flag: bool :: false\n\u0009\u0009\u0009if(overFunc)\n\u0009\u0009\u0009\u0009if(child.typeId = %arg)\n\u0009\u0009\u0009\u0009\u0009var kind: \\ast@AstArgKind :: (child $ \\ast@AstArg).kind\n\u0009\u0009\u0009\u0009\u0009if(kind = %member | kind = %localVar | kind = %localArg)\n\u0009\u0009\u0009\u0009\u0009\u0009do flag :: true\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(!flag & child.typeId.and(%statBreakable) = %statBreakable)\n\u0009\u0009\u0009\u0009\u0009do flag :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!flag & child.typeId = %func_ & child.refName <>& null)\n\u0009\u0009\u0009\u0009do flag :: true\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!flag)\n\u0009\u0009\u0009\u0009do \\err@err(%sameIdentifierInUpperScope, @makePos(), [ast.name])\n\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(parent.typeId = %func_)\n\u0009\u0009\u0009do overFunc :: true\n\u0009\u0009end if\n\u0009\u0009do parent :: parent.scopeParent\n\u0009end while\n\u0009do scope.scopeChildren.add(ast.name, ast)\nend func\n\nfunc isReserved(name: []char): bool\n\u0009if(@reserved =& null)\n\u0009\u0009do @reserved :: [\n\u0009\u0009|\"alias\",\n\u0009\u0009|\"assert\",\n\u0009\u0009|\"bit16\",\n\u0009\u0009|\"bit32\",\n\u0009\u0009|\"bit64\",\n\u0009\u0009|\"bit8\",\n\u0009\u0009|\"block\",\n\u0009\u0009|\"bool\",\n\u0009\u0009|\"break\",\n\u0009\u0009|\"case\",\n\u0009\u0009|\"catch\",\n\u0009\u0009|\"char\",\n\u0009\u0009|\"class\",\n\u0009\u0009|\"const\",\n\u0009\u0009|\"dbg\",\n\u0009\u0009|\"default\",\n\u0009\u0009|\"dict\",\n\u0009\u0009|\"do\",\n\u0009\u0009|\"elif\",\n\u0009\u0009|\"else\",\n\u0009\u0009|\"end\",\n\u0009\u0009|\"enum\",\n\u0009\u0009|\"env\",\n\u0009\u0009|\"false\",\n\u0009\u0009|\"finally\",\n\u0009\u0009|\"float\",\n\u0009\u0009|\"for\",\n\u0009\u0009|\"func\",\n\u0009\u0009|\"if\",\n\u0009\u0009|\"include\",\n\u0009\u0009|\"inf\",\n\u0009\u0009|\"int\",\n\u0009\u0009|\"list\",\n\u0009\u0009|\"me\",\n\u0009\u0009|\"null\",\n\u0009\u0009|\"queue\",\n\u0009\u0009|\"ret\",\n\u0009\u0009|\"skip\",\n\u0009\u0009|\"stack\",\n\u0009\u0009|\"super\",\n\u0009\u0009|\"switch\",\n\u0009\u0009|\"throw\",\n\u0009\u0009|\"to\",\n\u0009\u0009|\"true\",\n\u0009\u0009|\"try\",\n\u0009\u0009|\"var\",\n\u0009\u0009|\"while\"]\n\u0009\u0009\n\u0009\u0009if(dbg)\n\u0009\u0009\u0009for i(0, ^@reserved - 2)\n\u0009\u0009\u0009\u0009assert @reserved[i] < @reserved[i + 1]\n\u0009\u0009\u0009end for\n\u0009\u0009end if\n\u0009end if\n\u0009ret @reserved.findBin(name) <> -1\nend func\n\nfunc readChar(): char\n\u0009while loop(true)\n\u0009\u0009var c: char :: @read()\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009switch(c)\n\u0009\u0009\u0009case \'\\n\'\n\u0009\u0009\u0009\u0009ret \'\\n\'\n\u0009\u0009\u0009case \';\'\n\u0009\u0009\u0009\u0009while(c <> \'\\n\', skip)\n\u0009\u0009\u0009\u0009\u0009do c :: @readBuf()\n\u0009\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009\u0009ret \'\\0\'\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009case \'|\'\n\u0009\u0009\u0009\u0009ret @readChar()\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009do @fileBufTmp :: c\n\u0009\u0009\u0009ret \'\\n\'\n\u0009\u0009end if\n\u0009\u0009if(c <> \' \')\n\u0009\u0009\u0009ret c\n\u0009\u0009end if\n\u0009end while\nend func\n\nfunc read(): char\n\u0009var c: char :: @readBuf()\n\u0009switch(c)\n\u0009case \'{\'\n\u0009\u0009do @readComment()\n\u0009\u0009ret \' \'\n\u0009case \'\\t\'\n\u0009\u0009ret \' \'\n\u0009end switch\n\u0009ret c\nend func\n\nfunc readBuf(): char\n\u0009var c: char\n\u0009if(@fileBuf = \'\\0\')\n\u0009\u0009if(@fileBufTmp = \'\\0\')\n\u0009\u0009\u0009while(c = \'\\u000D\', skip)\n\u0009\u0009\u0009\u0009do c :: @filePtr.term() ?(\'\\0\', @filePtr.readLetter())\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009\u0009do @row :+ 1\n\u0009\u0009\u0009\u0009do @col :: 0\n\u0009\u0009\u0009elif(c = \'\\0\')\n\u0009\u0009\u0009\u0009if(!@fileLast)\n\u0009\u0009\u0009\u0009\u0009do @fileLast :: true\n\u0009\u0009\u0009\u0009\u0009do c :: \'\\n\'\n\u0009\u0009\u0009\u0009\u0009do @row :+ 1\n\u0009\u0009\u0009\u0009\u0009do @col :: 0\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @col :+ 1\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009do c :: @fileBufTmp\n\u0009\u0009\u0009do @fileBufTmp :: \'\\0\'\n\u0009\u0009end if\n\u0009else\n\u0009\u0009do c :: @fileBuf\n\u0009\u0009do @fileBuf :: \'\\0\'\n\u0009end if\n\u0009ret c\nend func\n\nfunc readComment()\n\u0009var row: int :: @row\n\u0009var col: int :: @col\n\u0009var c: char\n\u0009while(c <> \'}\', skip)\n\u0009\u0009do c :: @read()\n\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009do \\err@err(%noBrace, \\pos@make(@srcName, row, col), null)\n\u0009\u0009\u0009ret\n\u0009\u0009end if\n\u0009\u0009if(c = \'\"\')\n\u0009\u0009\u0009var esc: bool :: false\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009do c :: @readInStr()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%noBrace, \\pos@make(@srcName, row, col), null)\n\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(esc)\n\u0009\u0009\u0009\u0009\u0009if(c = \'{\')\n\u0009\u0009\u0009\u0009\u0009\u0009do @readComment()\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do esc :: false\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \'\"\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \'\\\\\')\n\u0009\u0009\u0009\u0009\u0009do esc :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009elif(c = \'\\\'\')\n\u0009\u0009\u0009var esc: bool :: false\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009do c :: @readInStr()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%noBrace, \\pos@make(@srcName, row, col), null)\n\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(esc)\n\u0009\u0009\u0009\u0009\u0009do esc :: false\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \'\\\'\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \'\\\\\')\n\u0009\u0009\u0009\u0009\u0009do esc :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009elif(c = \';\')\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009do c :: @readBuf()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%noBrace, \\pos@make(@srcName, row, col), null)\n\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009end if\n\u0009end while\nend func\n\nfunc readInStr(): char\n\u0009while loop(true)\n\u0009\u0009var c: char :: @readBuf()\n\u0009\u0009switch(c)\n\u0009\u0009case \'\\t\'\n\u0009\u0009\u0009do \\err@err(%tabInStr, @makePos(), null)\n\u0009\u0009\u0009skip loop\n\u0009\u0009case \'\\n\'\n\u0009\u0009\u0009do \\err@err(%lineBreakInStr, @makePos(), null)\n\u0009\u0009end switch\n\u0009\u0009ret c\n\u0009end while\nend func\n\nfunc readIdentifier(skipSpaces: bool, refName: bool): []char\n\u0009var c: char :: skipSpaces ?(@readChar(), @read())\n\u0009if(!(\'a\' <= c & c <= \'z\' | \'A\' <= c & c <= \'Z\' | c = \'_\' | refName & (c = \'@\' | c = \'\\\\\')))\n\u0009\u0009do @fileBuf :: c\n\u0009\u0009do \\err@err(%wrongCharacterInIdentifier, @makePos(), [@charToStr(c)])\n\u0009\u0009ret \"\"\n\u0009end if\n\u0009\n\u0009var buf: []char :: #[128]char\n\u0009var pos: int :: 0\n\u0009var at: bool :: false\n\u0009while(\'a\' <= c & c <= \'z\' | \'A\' <= c & c <= \'Z\' | c = \'_\' | \'0\' <= c & c <= \'9\' | refName & (c = \'@\' | c = \'\\\\\'), skip)\n\u0009\u0009switch(c)\n\u0009\u0009case \'@\'\n\u0009\u0009\u0009if(at)\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009do \\err@err(%wrongAtInIdentifier, @makePos(), null)\n\u0009\u0009\u0009\u0009ret \"\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(pos <> 0)\n\u0009\u0009\u0009\u0009var srcName: []char :: buf.sub(0, pos)\n\u0009\u0009\u0009\u0009for i(0, ^srcName - 1)\n\u0009\u0009\u0009\u0009\u0009var c2: char :: srcName[i]\n\u0009\u0009\u0009\u0009\u0009if(\'A\' <= c2 & c2 <= \'Z\')\n\u0009\u0009\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%uppercaseFileName, @makePos(), [srcName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret \"\"\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end for\n\u0009\u0009\u0009\u0009do @addSrc(srcName)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do at :: true\n\u0009\u0009case \'\\\\\'\n\u0009\u0009\u0009if(at)\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009do \\err@err(%wrongBackslashInIdentifier, @makePos(), null)\n\u0009\u0009\u0009\u0009ret \"\"\n\u0009\u0009\u0009end if\n\u0009\u0009end switch\n\u0009\u0009if(pos = 128)\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009do \\err@err(%tooLongIdentifier, @makePos(), [buf])\n\u0009\u0009\u0009ret \"\"\n\u0009\u0009end if\n\u0009\u0009do buf[pos] :: c\n\u0009\u0009do pos :+ 1\n\u0009\u0009do c :: @read()\n\u0009end while\n\u0009do @fileBuf :: c\n\u0009ret buf.sub(0, pos)\nend func\n\nfunc readUntilRet(c: char)\n\u0009while(c <> \'\\n\' & c <> \'\\0\')\n\u0009\u0009do c :: @read()\n\u0009end while\n\u0009do @fileBuf :: c\nend func\n\nfunc readFuncAttr(): []char\n\u0009var c: char :: @readChar()\n\u0009if(!(\'a\' <= c & c <= \'z\' | \'A\' <= c & c <= \'Z\' | \'0\' <= c & c <= \'9\' | c = \'_\' | c = \'.\'))\n\u0009\u0009do \\err@err(%wrongCharacterInFuncAttr, @makePos(), [@charToStr(c)])\n\u0009\u0009ret \"\"\n\u0009end if\n\u0009\n\u0009var buf: []char :: #[128]char\n\u0009var pos: int :: 0\n\u0009while(\'a\' <= c & c <= \'z\' | \'A\' <= c & c <= \'Z\' | \'0\' <= c & c <= \'9\' | c = \'_\' | c = \'.\', skip)\n\u0009\u0009if(pos = 128)\n\u0009\u0009\u0009do \\err@err(%tooLongFuncAttr, @makePos(), [buf])\n\u0009\u0009\u0009ret \"\"\n\u0009\u0009end if\n\u0009\u0009do buf[pos] :: c\n\u0009\u0009do pos :+ 1\n\u0009\u0009do c :: @read()\n\u0009end while\n\u0009do @fileBuf :: c\n\u0009ret buf.sub(0, pos)\nend func\n\nfunc addSrc(name: []char)\n\u0009if(@srcesNext.get(name, &) =& null)\n\u0009\u0009do @srcesNext.add(name, null)\n\u0009end if\nend func\n\nfunc nextCharErr(c: char, c2: char)\n\u0009do \\err@err(%charShouldBeWritten, @makePos(), [@charToStr(c), @charToStr(c2)])\n\u0009do @readUntilRet(c2)\nend func\n\nfunc assertNextChar(c: char, skipSpaces: bool)\n\u0009var c2: char :: skipSpaces ?(@readChar(), @read())\n\u0009if(c <> c2)\n\u0009\u0009do @nextCharErr(c, c2)\n\u0009\u0009do @fileBuf :: c2\n\u0009end if\nend func\n\nfunc addScopeRefeds(ast: \\ast@Ast, name: []char)\n\u0009; \'RefName\' added here will be resolved later.\n\u0009do ast.refName :: name\n\u0009var scopeRefedItem: \\ast@ScopeRefedItem :: #\\ast@ScopeRefedItem\n\u0009do scopeRefedItem.def :: ast\n\u0009do scopeRefedItem.scope :: @scope.peek()\n\u0009do @scopeRefedItems.add(scopeRefedItem)\nend func\n\nfunc charToStr(c: char): []char\n\u0009switch(c)\n\u0009case \'\\0\'\n\u0009\u0009ret \" \"\n\u0009case \'\\u000D\'\n\u0009\u0009assert false\n\u0009case \'\\n\'\n\u0009\u0009ret \"(RETURN)\"\n\u0009case \'\\t\', \' \'\n\u0009\u0009ret \"(SPACE)\"\n\u0009end switch\n\u0009ret c.toStr()\nend func\n\nfunc obtainBlockName(ast: \\ast@Ast)\n\u0009var c: char :: @readChar()\n\u0009if(c <> \'(\')\n\u0009\u0009do @fileBuf :: c\n\u0009\u0009do ast.name :: @readIdentifier(true, false)\n\u0009\u0009do @addScopeName(ast, true)\n\u0009\u0009do @assertNextChar(\'(\', true)\n\u0009else\n\u0009\u0009do ast.name :: \"$\"\n\u0009end if\nend func\n\nfunc pushDummyScope(ast: \\ast@Ast)\n\u0009var dummy: \\ast@Ast :: #\\ast@Ast\n\u0009do @initAst(dummy, %none, null, null, true)\n\u0009do @scope.peek().scopeChildren.add(\"$\" ~ @uniqueCnt.toStr(), dummy)\n\u0009do @uniqueCnt :+ 1\n\u0009\n\u0009do dummy.scopeChildren :: #dict<[]char, \\ast@Ast>\n\u0009do @scope.add(dummy)\n\u0009\n\u0009do ast.scopeParent :: dummy\nend func\n\nfunc parseDummyBlock(outStat: &\\ast@AstStat, outTypeId: &\\ast@TypeId, typeId: \\ast@TypeId, block_: \\ast@Ast): \\ast@AstStatBlock\n\u0009var ast: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009do @initAst(ast, %statBlock, @makePos(), null, false)\n\u0009do ast.blockVar :: null\n\u0009do ast.stats :: #list<\\ast@AstStat>\n\u0009do @pushDummyScope(ast)\n\u0009do ast.name :: \"$\"\n\u0009\n\u0009while loop(true)\n\u0009\u0009var stat: \\ast@AstStat :: @parseStat(block_)\n\u0009\u0009if(stat =& null)\n\u0009\u0009\u0009if(@fileLast)\n\u0009\u0009\u0009\u0009do outStat :: null\n\u0009\u0009\u0009\u0009do outTypeId :: %statEnd\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009var endFlag: bool :: false\n\u0009\u0009switch(typeId)\n\u0009\u0009case %statIf\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statElIf, %statElse, %statEnd\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statElIf\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statElIf, %statElse, %statEnd\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statElse\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statElIf, %statElse\n\u0009\u0009\u0009\u0009do \\err@err(%elifOrElseAfterElse, @makePos(), null)\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009case %statEnd\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statCase\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statCase, %statDefault, %statEnd\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statDefault\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statCase, %statDefault\n\u0009\u0009\u0009\u0009do \\err@err(%caseOrDefaultAfterDefault, @makePos(), null)\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009case %statEnd\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statTry\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statCatch, %statFinally\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statCatch\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statCatch, %statFinally, %statElIf\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statFinally\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statCatch, %statFinally\n\u0009\u0009\u0009\u0009do \\err@err(%catchOrFinallyAfterFinally, @makePos(), null)\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009case %statEnd\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009if(endFlag)\n\u0009\u0009\u0009do outStat :: stat\n\u0009\u0009\u0009do outTypeId :: stat.typeId\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do ast.stats.add(stat)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc makePrimValue(pos: \\pos@Pos, kind: \\ast@AstTypePrimKind, value: bit64): \\ast@AstExprValuePrim\n\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009do @initAstExpr(expr, %exprValuePrim, pos)\n\u0009block\n\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009do @initAst(type, %typePrim, pos, null, false)\n\u0009\u0009do type.kind :: kind\n\u0009\u0009do expr.type :: type\n\u0009end block\n\u0009do expr.value :: value\n\u0009ret expr\nend func\n\nfunc makeStrValue(pos: \\pos@Pos, value: []char): \\ast@AstExprValueStr\n\u0009var expr: \\ast@AstExprValueStr :: #\\ast@AstExprValueStr\n\u0009do @initAstExpr(expr, %exprValueStr, pos)\n\u0009block\n\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009do @initAst(type, %typeArray, pos, null, false)\n\u0009\u0009block\n\u0009\u0009\u0009var type2: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009do @initAst(type2, %typePrim, pos, null, false)\n\u0009\u0009\u0009do type2.kind :: %char_\n\u0009\u0009\u0009do type.itemType :: type2\n\u0009\u0009end block\n\u0009\u0009do expr.type :: type\n\u0009end block\n\u0009do expr.value :: value\n\u0009ret expr\nend func\n\nfunc makeFloatValue(pos: \\pos@Pos, value: float): \\ast@AstExprValueFloat\n\u0009var expr: \\ast@AstExprValueFloat :: #\\ast@AstExprValueFloat\n\u0009do @initAstExpr(expr, %exprValueFloat, pos)\n\u0009block\n\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009do @initAst(type, %typePrim, pos, null, false)\n\u0009\u0009do type.kind :: %float_\n\u0009\u0009do expr.type :: type\n\u0009end block\n\u0009do expr.value :: value\n\u0009ret expr\nend func\n\nfunc makeBlockVar(pos: \\pos@Pos): \\ast@AstArg\n\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009do @initAst(arg, %arg, pos, null, false)\n\u0009do arg.kind :: %localVar\n\u0009do arg.refVar :: false\n\u0009do arg.type :: null\n\u0009do arg.expr :: null\n\u0009ret arg\nend func\n\nfunc escChar(c: char): char\n\u0009switch(c)\n\u0009case \'\"\', \'\\\'\', \'\\\\\'\n\u0009\u0009ret c\n\u0009case \'0\'\n\u0009\u0009ret \'\\0\'\n\u0009case \'n\'\n\u0009\u0009ret \'\\n\'\n\u0009case \'t\'\n\u0009\u0009ret \'\\t\'\n\u0009case \'u\'\n\u0009\u0009var buf: []char :: #[6]char\n\u0009\u0009do buf[0] :: \'0\'\n\u0009\u0009do buf[1] :: \'x\'\n\u0009\u0009for i(0, 3)\n\u0009\u0009\u0009do c :: @readInStr()\n\u0009\u0009\u0009if(!(\'0\' <= c & c <= \'9\' | \'A\' <= c & c <= \'F\'))\n\u0009\u0009\u0009\u0009do \\err@err(%wrongCharCodeRepresentation, @makePos(), null)\n\u0009\u0009\u0009\u0009ret \'u\'\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf[2 + i] :: c\n\u0009\u0009end for\n\u0009\u0009ret buf.toInt(&) $ char\n\u0009default\n\u0009\u0009do \\err@err(%wrongEscSequence, @makePos(), [@charToStr(c)])\n\u0009\u0009ret c\n\u0009end switch\nend func\n";
else if(p==="res/pos.kn")
return "+class Pos()\n\u0009+var srcName: []char\n\u0009+var row: int\n\u0009+var col: int\nend class\n\n+func make(srcName: []char, row: int, col: int): @Pos\n\u0009var pos: @Pos :: #@Pos\n\u0009do pos.srcName :: srcName\n\u0009do pos.row :: row\n\u0009do pos.col :: col\n\u0009ret pos\nend func\n";
else if(p==="res/res/empty")
return "";
else if(p==="res/res/test.kn")
return "func main()\n\u0009do @test1()\nend func\n\nfunc test1()\n\u0009do cui@print(\"Kuin\" ~ \" Test \" ~ \"Program\")\n\u0009\n\u0009block\n\u0009\u0009var a: int :: (7 + 7) / 7 - 7 * 7 + 7 + 7 + 7 + 7 + 7 + 7 + 7 + 7 + 7 + 7 + (+7) + (-7) {23}\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ (23 % 7).toStr() ~ \", \" ~ (7 ^ 7).toStr())\n\u0009\u0009\n\u0009\u0009var n: int :: 7\n\u0009\u0009var b: int :: (n + n) / n - n * n + n + n + n + n + n + n + n + n + n + n + (+n) + (-n) {23}\n\u0009\u0009do cui@print(b.toStr() ~ \", \" ~ (b % n).toStr() ~ \", \" ~ (n ^ n).toStr())\n\u0009\u0009\n\u0009\u0009var c: int :: -2\n\u0009\u0009do cui@print((c ^ 0).toStr() ~ \", \" ~ (c ^ 1).toStr() ~ \", \" ~ (c ^ 2).toStr() ~ \", \" ~ (c ^ 3).toStr() ~ \", \" ~ (c ^ 4).toStr() ~ \", \" ~ (c ^ 5).toStr())\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: float :: (7.0 + 7.0) / 7.0 - 7.0 * 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + (+7.0) + (-7.0) {23.0}\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ (23.00 % 7.0).toStr() ~ \", \" ~ (7 ^ 7).toStr())\n\u0009\u0009\n\u0009\u0009var n: float :: 7.0\n\u0009\u0009var b: float :: (n + n) / n - n * n + n + n + n + n + n + n + n + n + n + n + (+n) + (-n) {23.0}\n\u0009\u0009do cui@print(b.toStr() ~ \", \" ~ (b % n).toStr() ~ \", \" ~ (n ^ n).toStr())\n\u0009\u0009\n\u0009\u0009var c: float :: -2.0\n\u0009\u0009do cui@print((c ^ 0.0).toStr() ~ \", \" ~ (c ^ 1.0).toStr() ~ \", \" ~ (c ^ 2.0).toStr() ~ \", \" ~ (c ^ 3.0).toStr() ~ \", \" ~ (c ^ 4.0).toStr() ~ \", \" ~ (c ^ 5.0).toStr())\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: bit8 :: (7b8 + 7b8) / 7b8 - 7b8 * 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + (+7b8) + (-7b8) {23}\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ (23b8 % 7b8).toStr())\n\u0009\u0009\n\u0009\u0009var n: bit8 :: 7b8\n\u0009\u0009var b: bit8 :: (n + n) / n - n * n + n + n + n + n + n + n + n + n + n + n + (+n) + (-n) {23}\n\u0009\u0009do cui@print(b.toStr() ~ \", \" ~ (b % n).toStr())\n\u0009\u0009\n\u0009\u0009var c1: bit8 :: 255b8 + 2b8\n\u0009\u0009var c2: bit8 :: -1b8\n\u0009\u0009var d1: bit8 :: 255b8\n\u0009\u0009var d2: bit8 :: 1b8\n\u0009\u0009do d1 :+ 2b8\n\u0009\u0009do d2 :: -d2\n\u0009\u0009do cui@print(c1.toStr() ~ \", \" ~ d1.toStr() ~ \", \" ~ c2.toStr() ~ \", \" ~ d2.toStr())\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: bit16 :: (7b16 + 7b16) / 7b16 - 7b16 * 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + (+7b16) + (-7b16) {23}\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ (23b16 % 7b16).toStr())\n\u0009\u0009\n\u0009\u0009var n: bit16 :: 7b16\n\u0009\u0009var b: bit16 :: (n + n) / n - n * n + n + n + n + n + n + n + n + n + n + n + (+n) + (-n) {23}\n\u0009\u0009do cui@print(b.toStr() ~ \", \" ~ (b % n).toStr())\n\u0009\u0009\n\u0009\u0009var c1: bit16 :: 65535b16 + 2b16\n\u0009\u0009var c2: bit16 :: -1b16\n\u0009\u0009var d1: bit16 :: 65535b16\n\u0009\u0009var d2: bit16 :: 1b16\n\u0009\u0009do d1 :+ 2b16\n\u0009\u0009do d2 :: -d2\n\u0009\u0009do cui@print(c1.toStr() ~ \", \" ~ d1.toStr() ~ \", \" ~ c2.toStr() ~ \", \" ~ d2.toStr())\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: bit32 :: (7b32 + 7b32) / 7b32 - 7b32 * 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + (+7b32) + (-7b32) {23}\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ (23b32 % 7b32).toStr())\n\u0009\u0009\n\u0009\u0009var n: bit32 :: 7b32\n\u0009\u0009var b: bit32 :: (n + n) / n - n * n + n + n + n + n + n + n + n + n + n + n + (+n) + (-n) {23}\n\u0009\u0009do cui@print(b.toStr() ~ \", \" ~ (b % n).toStr())\n\u0009\u0009\n\u0009\u0009var c1: bit32 :: 0xFFFFFFFFb32 + 2b32\n\u0009\u0009var c2: bit32 :: -1b32\n\u0009\u0009var d1: bit32 :: 0xFFFFFFFFb32\n\u0009\u0009var d2: bit32 :: 1b32\n\u0009\u0009do d1 :+ 2b32\n\u0009\u0009do d2 :: -d2\n\u0009\u0009do cui@print(c1.toStr() ~ \", \" ~ d1.toStr() ~ \", \" ~ c2.toStr() ~ \", \" ~ d2.toStr())\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: bit64 :: (7b64 + 7b64) / 7b64 - 7b64 * 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + (+7b64) + (-7b64) {23}\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ (23b64 % 7b64).toStr())\n\u0009\u0009\n\u0009\u0009var n: bit64 :: 7b64\n\u0009\u0009var b: bit64 :: (n + n) / n - n * n + n + n + n + n + n + n + n + n + n + n + (+n) + (-n) {23}\n\u0009\u0009do cui@print(b.toStr() ~ \", \" ~ (b % n).toStr())\n\u0009end block\nend func\n";
else if(p==="res/sys/common.h")
return "#pragma once\n\n#include <chrono>\n#include <codecvt>\n#include <cstdarg>\n#include <cstdint>\n#include <cstring>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <stack>\n#include <type_traits>\n#include <vector>\n\nclass Ref_;\ntemplate<typename T> class Array_;\ntemplate<typename T> class List_;\ntemplate<typename T> class Stack_;\ntemplate<typename T> class Queue_;\ntemplate<typename T1, typename T2> class dictImpl_;\ntemplate<typename T1, typename T2> class Dict_;\nclass Class_;\n\n#if _MSC_VER >= 1900\nstatic std::string utf16ToUtf8_(const std::u16string& s)\n{\n\u0009const int16_t* p = reinterpret_cast<const int16_t*>(s.data());\n\u0009return std::wstring_convert<std::codecvt_utf8_utf16<int16_t>, int16_t>{}.to_bytes(p, p + s.size());\n}\nstatic std::u16string utf8ToUtf16_(const std::string& s)\n{\n\u0009const auto t = std::wstring_convert<std::codecvt_utf8_utf16<int16_t>, int16_t>{}.from_bytes(s);\n\u0009return std::u16string(reinterpret_cast<const char16_t*>(t.data()), t.size());\n}\n#else\nstatic std::string utf16ToUtf8_(const std::u16string& s)\n{\n\u0009return std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t>{}.to_bytes(s);\n}\nstatic std::u16string utf8ToUtf16_(const std::string& s)\n{\n\u0009return std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t>{}.from_bytes(s);\n}\n#endif\n\n#if defined(_WIN32)\n\n#define STRICT\n#define _WIN32_DCOM\n\n#include <Windows.h>\n\n#undef min\n#undef far\n#undef max\n#undef near\n\nconst char newLine_[] = { \'\\r\', \'\\n\' };\n\nstatic bool setCurDir_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::SetCurrentDirectoryA(t.c_str()) != 0;\n}\nstatic bool makeDir_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::CreateDirectoryA(t.c_str(), 0) != 0;\n}\nstatic bool delDir_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::RemoveDirectoryA(t.c_str()) != 0;\n}\nstatic bool delFile_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::DeleteFileA(t.c_str()) != 0;\n}\nstatic bool copyDir_(const char16_t* d, const char16_t* s)\n{\n\u0009std::u16string s1 = d;\n\u0009const std::string& t1 = utf16ToUtf8_(s1);\n\u0009std::u16string s2 = s;\n\u0009const std::string& t2 = utf16ToUtf8_(s2);\n\u0009return ::CreateDirectoryExA(t2.c_str(), t1.c_str(), 0) != 0;\n}\nstatic bool copyFile_(const char16_t* d, const char16_t* s)\n{\n\u0009std::u16string s1 = d;\n\u0009const std::string& t1 = utf16ToUtf8_(s1);\n\u0009std::u16string s2 = s;\n\u0009const std::string& t2 = utf16ToUtf8_(s2);\n\u0009return ::CopyFileA(t2.c_str(), t1.c_str(), false) != 0;\n}\nstatic bool moveFile_(const char16_t* d, const char16_t* s)\n{\n\u0009std::u16string s1 = d;\n\u0009const std::string& t1 = utf16ToUtf8_(s1);\n\u0009std::u16string s2 = s;\n\u0009const std::string& t2 = utf16ToUtf8_(s2);\n\u0009return ::MoveFileExA(t2.c_str(), t1.c_str(), MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED) != 0;\n}\n\n#else\n\nconst char newLine_[] = { \'\\n\' };\n\nstatic bool setCurDir_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::chdir(t.c_str()) == 0;\n}\nstatic bool makeDir_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::mkdir(t.c_str(), S_IRWXU | S_IRWXG | S_IRWXO) == 0;\n}\nstatic bool delDir_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::rmdir(t.c_str()) == 0;\n}\nstatic bool delFile_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::unlink(t.c_str()) == 0;\n}\nstatic bool copyDir_(const char16_t* d, const char16_t* s)\n{\n\u0009std::u16string s1 = d;\n\u0009const std::string& t1 = utf16ToUtf8_(s1);\n\u0009std::u16string s2 = s;\n\u0009const std::string& t2 = utf16ToUtf8_(s2);\n\u0009struct stat f;\n\u0009return !(::stat(t2.c_str(), &f) != 0 || ::mkdir(t1.c_str(), f.st_mode) != 0);\n}\nstatic bool copyFile_(const char16_t* d, const char16_t* s)\n{\n\u0009std::u16string s1 = d;\n\u0009const std::string& t1 = utf16ToUtf8_(s1);\n\u0009std::u16string s2 = s;\n\u0009const std::string& t2 = utf16ToUtf8_(s2);\n\u0009int i = ::open(t2.c_str(), O_RDONLY);\n\u0009if (i < 0)\n\u0009\u0009return false;\n\u0009struct stat f;\n\u0009if (::stat(t2.c_str(), &f) != 0)\n\u0009{\n\u0009\u0009::close(i);\n\u0009\u0009return false;\n\u0009}\n\u0009int o = ::open(t1.c_str(), O_CREAT | O_WRONLY | O_TRUNC, f.st_mode);\n\u0009if (o < 0)\n\u0009{\n\u0009\u0009::close(i);\n\u0009\u0009return false;\n\u0009}\n\u0009size_t r = 1;\n\u0009char* buf = new char[65536];\n\u0009while (r > 0 && (r = ::read(i, buf.get(), 65536)) > 0)\n\u0009{\n\u0009\u0009size_t z, w = 0;\n\u0009\u0009do\n\u0009\u0009{\n\u0009\u0009\u0009if ((z = ::write(o, buf.get() + w, r - w)) < 0)\n\u0009\u0009\u0009{\n\u0009\u0009\u0009\u0009r = z;\n\u0009\u0009\u0009\u0009break;\n\u0009\u0009\u0009}\n\u0009\u0009\u0009w += z;\n\u0009\u0009} while (w < r);\n\u0009}\n\u0009if (::close(i) < 0)\n\u0009\u0009r = -1;\n\u0009if (::close(o) < 0)\n\u0009\u0009r = -1;\n\u0009delete[] buf;\n\u0009return r >= 0;\n}\nstatic bool moveFile_(const char16_t* d, const char16_t* s)\n{\n\u0009std::u16string s1 = d;\n\u0009const std::string& t1 = utf16ToUtf8_(s1);\n\u0009std::u16string s2 = s;\n\u0009const std::string& t2 = utf16ToUtf8_(s2);\n\u0009return ::rename(t2.c_str(), t1.c_str()) == 0;\n}\n\n#   define BOOST_COPY_FILE(F,T,FailIfExistsBool)\n#   define BOOST_MOVE_FILE(OLD,NEW)()\n#endif\n\ntemplate<typename T>\nstatic size_t bufLen_() noexcept { return 0; }\ntemplate<>\nstatic size_t bufLen_<char16_t>() noexcept { return 1; }\n\ntemplate<typename T>\nstatic void* newArrayRec_(int64_t n, int64_t x, const int64_t* b) noexcept\n{\n\u0009if (x == n - 1)\n\u0009{\n\u0009\u0009Array_<T>* r = new Array_<T>();\n\u0009\u0009r->L = b[x];\n\u0009\u0009size_t s = static_cast<size_t>(b[x] + bufLen_<T>());\n\u0009\u0009r->B = new T[s];\n\u0009\u0009memset(r->B, 0, sizeof(T) * s);\n\u0009\u0009return r;\n\u0009}\n\u0009{\n\u0009\u0009Array_<void*>* r = new Array_<void*>();\n\u0009\u0009r->L = b[x];\n\u0009\u0009r->B = reinterpret_cast<void**>(new T[static_cast<size_t>(b[x])]);\n\u0009\u0009for (int64_t i = 0; i < b[x]; i++)\n\u0009\u0009\u0009r->B[i] = newArrayRec_<T>(n, x + 1, b);\n\u0009\u0009return r;\n\u0009}\n}\n\ntemplate<typename T, typename R>\nstatic R newArray_(int64_t n, ...) noexcept\n{\n\u0009if (n > 64)\n\u0009\u0009return nullptr;\n\u0009int64_t b[64];\n\u0009va_list l;\n\u0009va_start(l, n);\n\u0009for (int64_t i = 0; i < n; i++)\n\u0009{\n\u0009\u0009b[i] = va_arg(l, int64_t);\n\u0009}\n\u0009va_end(l);\n\u0009return static_cast<R>(newArrayRec_<T>(n, 0, b));\n}\n\ntemplate<typename T>\nstatic Array_<T>* copy_(Array_<T>* t) noexcept\n{\n\u0009if (t == nullptr)\n\u0009\u0009return nullptr;\n\u0009Array_<T>* r = new Array_<T>();\n\u0009r->L = t->L;\n\u0009r->B = new T[static_cast<size_t>(t->L) + bufLen_<T>()];\n\u0009for (int64_t i = 0; i < t->L + static_cast<int64_t>(bufLen_<T>()); i++)\n\u0009\u0009r->B[i] = copy_(t->B[i]);\n\u0009return r;\n}\ntemplate<typename T>\nstatic List_<T>* copy_(List_<T>* t) noexcept\n{\n\u0009if (t == nullptr)\n\u0009\u0009return nullptr;\n\u0009// TODO:\n\u0009return nullptr;\n}\ntemplate<typename T>\nstatic Stack_<T>* copy_(Stack_<T>* t) noexcept\n{\n\u0009if (t == nullptr)\n\u0009\u0009return nullptr;\n\u0009// TODO:\n\u0009return nullptr;\n}\ntemplate<typename T>\nstatic Queue_<T>* copy_(Queue_<T>* t) noexcept\n{\n\u0009if (t == nullptr)\n\u0009\u0009return nullptr;\n\u0009// TODO:\n\u0009return nullptr;\n}\ntemplate<typename T1, typename T2>\nstatic Dict_<T1, T2>* copy_(Dict_<T1, T2>* t) noexcept\n{\n\u0009if (t == nullptr)\n\u0009\u0009return nullptr;\n\u0009// TODO:\n\u0009return nullptr;\n}\ntemplate<typename T>\nstatic T* copy_(T* t) noexcept\n{\n\u0009if (t == nullptr)\n\u0009\u0009return nullptr;\n\u0009return static_cast<T*>((new T())->copy_(t));\n}\nstatic int64_t copy_(int64_t t) noexcept { return t; }\nstatic char16_t copy_(char16_t t) noexcept { return t; }\nstatic bool copy_(bool t) noexcept { return t; }\nstatic double copy_(double t) noexcept { return t; }\nstatic uint8_t copy_(uint8_t t) noexcept { return t; }\nstatic uint16_t copy_(uint16_t t) noexcept { return t; }\nstatic uint32_t copy_(uint32_t t) noexcept { return t; }\nstatic uint64_t copy_(uint64_t t) noexcept { return t; }\n\nclass Ref_\n{\npublic:\n\u0009Ref_() noexcept : R(0LL)\n\u0009{\n\u0009}\n\n\u0009bool EqAddr(const Ref_* t) noexcept\n\u0009{\n\u0009\u0009return this == t;\n\u0009}\n\n\u0009int64_t R;\n};\n\ntemplate<typename T>\nclass Array_ : public Ref_\n{\npublic:\n\u0009Array_() noexcept : Ref_()\n\u0009{\n\u0009}\n\n\u0009explicit Array_(int64_t n, ...) noexcept : Ref_()\n\u0009{\n\u0009\u0009L = n;\n\u0009\u0009B = new T[static_cast<size_t>(n + bufLen_<T>())];\n\u0009\u0009va_list l;\n\u0009\u0009va_start(l, n);\n\u0009\u0009for (int64_t i = 0; i < n; i++)\n\u0009\u0009{\n\u0009\u0009\u0009B[i] = va_arg(l, T);\n\u0009\u0009}\n\u0009\u0009va_end(l);\n\u0009\u0009if (bufLen_<T>() > 0)\n\u0009\u0009\u0009B[n] = 0;\n\u0009}\n\n\u0009Array_<T>* Cat(const Array_<T>* t) noexcept\n\u0009{\n\u0009\u0009Array_<T>* r = new Array_<T>();\n\u0009\u0009r->B = new T[static_cast<size_t>(L + t->L + bufLen_<T>())];\n\u0009\u0009memcpy(r->B, B, sizeof(T) * static_cast<size_t>(L));\n\u0009\u0009memcpy(r->B + L, t->B, sizeof(T) * static_cast<size_t>(t->L + bufLen_<T>()));\n\u0009\u0009r->L = L + t->L;\n\u0009\u0009return r;\n\u0009}\n\n\u0009int64_t Len() noexcept\n\u0009{\n\u0009\u0009return L;\n\u0009}\n\n\u0009T& At(int64_t n) noexcept\n\u0009{\n\u0009\u0009return B[n];\n\u0009}\n\n\u0009bool operator<(const Ref_& t) const\n\u0009{\n\u0009\u0009return cmp_<Array_<T>*>(this, &t);\n\u0009}\n\n\u0009int64_t L;\n\u0009T* B;\n};\n\ntemplate<typename T>\nclass List_ : public Ref_\n{\npublic:\n\u0009List_() noexcept : Ref_(), B(), I(B.end())\n\u0009{\n\u0009}\n\n\u0009int64_t Len() noexcept\n\u0009{\n\u0009\u0009return static_cast<int64_t>(B.size());\n\u0009}\n\n\u0009std::list<T> B;\n\u0009typename std::list<T>::iterator I;\n};\n\ntemplate<typename T>\nclass Stack_ : public Ref_\n{\npublic:\n\u0009Stack_() noexcept : Ref_(), B()\n\u0009{\n\u0009}\n\n\u0009int64_t Len() noexcept\n\u0009{\n\u0009\u0009return static_cast<int64_t>(B.size());\n\u0009}\n\n\u0009std::stack<T> B;\n};\n\ntemplate<typename T>\nclass Queue_ : public Ref_\n{\npublic:\n\u0009Queue_() noexcept : Ref_(), B()\n\u0009{\n\u0009}\n\n\u0009int64_t Len() noexcept\n\u0009{\n\u0009\u0009return static_cast<int64_t>(B.size());\n\u0009}\n\n\u0009std::queue<T> B;\n};\n\ntemplate<typename T1, typename T2>\nclass Dict_ : public Ref_\n{\npublic:\n\u0009Dict_() noexcept : Ref_(), L(0LL), B(nullptr)\n\u0009{\n\u0009}\n\n\u0009int64_t Len() noexcept\n\u0009{\n\u0009\u0009return L;\n\u0009}\n\n\u0009void Add(T1 k, T2 v) noexcept\n\u0009{\n\u0009\u0009bool a;\n\u0009\u0009B = dictAdd_<T1, T2>(B, k, v, &a);\n\u0009\u0009if (a)\n\u0009\u0009\u0009L++;\n\u0009}\n\n\u0009int64_t L;\n\u0009dictImpl_<T1, T2>* B;\n};\n\nclass Class_ : public Ref_\n{\npublic:\n\u0009Class_() noexcept : Ref_(), Y(0LL)\n\u0009{\n\u0009}\n\n\u0009virtual int64_t cmp_(Class_* t) = 0;\n\n\u0009virtual Class_* copy_(Class_* t) = 0;\n\n\u0009int64_t Y;\n};\n\nstatic Array_<char16_t>* toStr_(int64_t v)\n{\n\u0009std::stringstream s;\n\u0009s << v;\n\u0009const std::string& t = s.str();\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(char16_t v)\n{\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(1);\n\u0009r->B = new char16_t[2];\n\u0009r->B[0] = v;\n\u0009r->B[1] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(bool v)\n{\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009if (v)\n\u0009{\n\u0009\u0009r->L = static_cast<int64_t>(4);\n\u0009\u0009r->B = new char16_t[5];\n\u0009\u0009r->B[0] = \'t\';\n\u0009\u0009r->B[1] = \'r\';\n\u0009\u0009r->B[2] = \'u\';\n\u0009\u0009r->B[3] = \'e\';\n\u0009\u0009r->B[4] = 0;\n\u0009}\n\u0009else\n\u0009{\n\u0009\u0009r->L = static_cast<int64_t>(5);\n\u0009\u0009r->B = new char16_t[6];\n\u0009\u0009r->B[0] = \'f\';\n\u0009\u0009r->B[1] = \'a\';\n\u0009\u0009r->B[2] = \'l\';\n\u0009\u0009r->B[3] = \'s\';\n\u0009\u0009r->B[4] = \'e\';\n\u0009\u0009r->B[5] = 0;\n\u0009}\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(double v)\n{\n\u0009std::stringstream s;\n\u0009s << v;\n\u0009const std::string& t = s.str();\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(uint8_t v)\n{\n\u0009std::stringstream s;\n\u0009s << \"0x\" << std::uppercase << std::setfill(\'0\') << std::setw(2) << std::hex << v;\n\u0009const std::string& t = s.str();\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(uint16_t v)\n{\n\u0009std::stringstream s;\n\u0009s << \"0x\" << std::uppercase << std::setfill(\'0\') << std::setw(4) << std::hex << v;\n\u0009const std::string& t = s.str();\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(uint32_t v)\n{\n\u0009std::stringstream s;\n\u0009s << \"0x\" << std::uppercase << std::setfill(\'0\') << std::setw(8) << std::hex << v;\n\u0009const std::string& t = s.str();\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(uint64_t v)\n{\n\u0009std::stringstream s;\n\u0009s << \"0x\" << std::uppercase << std::setfill(\'0\') << std::setw(16) << std::hex << v;\n\u0009const std::string& t = s.str();\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(Array_<char16_t>* v)\n{\n\u0009std::u16string s = v->B;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\n\nstatic int64_t cmp_(Array_<char16_t>* a, Array_<char16_t>* b)\n{\n\u0009int64_t p = 0;\n\u0009while (p < a->L && p < b->L)\n\u0009{\n\u0009\u0009if (a->B[p] != b->B[p])\n\u0009\u0009\u0009return a->B[p] > b->B[p] ? 1 : (a->B[p] < b->B[p] ? -1 : 0);\n\u0009\u0009p++;\n\u0009}\n\u0009return a->L > b->L ? 1 : (a->L < b->L ? -1 : 0);\n}\nstatic int64_t cmp_(Class_* a, Class_* b) noexcept\n{\n\u0009return a->cmp_(b);\n}\nstatic int64_t cmp_(int64_t a, int64_t b) noexcept { return a - b; }\nstatic int64_t cmp_(char16_t a, char16_t b) noexcept { return static_cast<int64_t>(a) - static_cast<int64_t>(b); }\nstatic int64_t cmp_(double a, double b) noexcept { return a > b ? 1LL : (a < b ? -1LL : 0LL); }\nstatic int64_t cmp_(uint8_t a, uint8_t b) noexcept { return static_cast<int64_t>(a) - static_cast<int64_t>(b); }\nstatic int64_t cmp_(uint16_t a, uint16_t b) noexcept { return static_cast<int64_t>(a) - static_cast<int64_t>(b); }\nstatic int64_t cmp_(uint32_t a, uint32_t b) noexcept { return static_cast<int64_t>(a) - static_cast<int64_t>(b); }\nstatic int64_t cmp_(uint64_t a, uint64_t b) noexcept { return a > b ? 1LL : (a < b ? -1LL : 0LL); }\n\ntemplate<typename T>\nstatic Array_<uint8_t>* toBin_(T t)\n{\n\u0009// TODO:\n\u0009return nullptr;\n}\n\ntemplate<typename T>\nstatic T fromBin_(Array_<uint8_t>* t, int64_t o)\n{\n\u0009// TODO:\n\u0009return (T)0;\n}\n\ntemplate<typename T>\nstatic Array_<T>* sub_(Array_<T>* a, int64_t start, int64_t len)\n{\n\u0009if (len == -1)\n\u0009\u0009len = a->L - start;\n\u0009if (start < 0 || len < 0 || start + len > a->L)\n\u0009\u0009return nullptr;\n\u0009Array_<T>* r = new Array_<T>();\n\u0009r->L = len;\n\u0009r->B = new T[static_cast<size_t>(len + bufLen_<T>())];\n\u0009for (int64_t i = 0; i < len; i++)\n\u0009\u0009r->B[i] = a->B[start + i];\n\u0009if (bufLen_<T>() > 0)\n\u0009\u0009r->B[len] = 0;\n\u0009return r;\n}\n\ntemplate<typename T>\nstatic T* as_(const int64_t* y, Class_* c, int64_t o) noexcept\n{\n\u0009if (c == nullptr)\n\u0009\u0009return nullptr;\n\u0009int64_t m = c->Y;\n\u0009for (; ; )\n\u0009{\n\u0009\u0009if (m == o)\n\u0009\u0009\u0009return reinterpret_cast<T*>(c);\n\u0009\u0009if (m == 0)\n\u0009\u0009\u0009return nullptr;\n\u0009\u0009m = y[m];\n\u0009}\n}\n\nstatic bool is_(const int64_t* y, Class_* c, int64_t o) noexcept\n{\n\u0009int64_t m = c->Y;\n\u0009for (; ; )\n\u0009{\n\u0009\u0009if (m == o)\n\u0009\u0009\u0009return true;\n\u0009\u0009if (m == 0)\n\u0009\u0009\u0009return false;\n\u0009\u0009m = y[m];\n\u0009}\n}\n\nstatic bool eqAddr_(const Ref_* a, const Ref_* b) noexcept\n{\n\u0009return a == b;\n}\n\nstatic uint32_t rX_, rY_, rZ_, rW_;\n\nstatic uint32_t xs128_() noexcept\n{\n\u0009uint32_t t = rX_ ^ (rX_ << 11);\n\u0009rX_ = rY_;\n\u0009rY_ = rZ_;\n\u0009rZ_ = rW_;\n\u0009return rW_ = (rW_ ^ (rW_ >> 19)) ^ (t ^ (t >> 8));\n}\n\nstatic int64_t rnd_(int64_t a, int64_t b) noexcept\n{\n\u0009uint64_t n = (uint64_t)(b - a + 1);\n\u0009uint64_t m = 0 - ((0 - n) % n);\n\u0009uint64_t r;\n\u0009if (m == 0)\n\u0009\u0009r = (static_cast<uint64_t>(xs128_()) << 32) | static_cast<uint64_t>(xs128_());\n\u0009else\n\u0009{\n\u0009\u0009do\n\u0009\u0009{\n\u0009\u0009\u0009r = (static_cast<uint64_t>(xs128_()) << 32) | static_cast<uint64_t>(xs128_());\n\u0009\u0009} while (m <= r);\n\u0009}\n\u0009return static_cast<int64_t>(r % n) + a;\n}\n\nstatic double rndFloat_(double a, double b) noexcept\n{\n\u0009return (double)((static_cast<uint64_t>(xs128_()) << 32) | static_cast<uint64_t>(xs128_())) / 18446744073709551616.0 * (b - a) + a;\n}\n\ntemplate<typename T1, typename T2>\nclass dictImpl_\n{\npublic:\n\u0009dictImpl_(T1 k, T2 v) noexcept : K(k), V(v), CL(nullptr), CR(nullptr), R(true)\n\u0009{\n\u0009}\n\n\u0009T1 K;\n\u0009T2 V;\n\u0009dictImpl_* CL;\n\u0009dictImpl_* CR;\n\u0009bool R;\n};\n\ntemplate<typename T1, typename T2>\nstatic dictImpl_<T1, T2>* dictAdd_(dictImpl_<T1, T2>* r, T1 k, T2 v, bool* a) noexcept\n{\n\u0009*a = false;\n\u0009dictImpl_<T1, T2>* n = dictAddRec_(r, k, v, a);\n\u0009n->R = false;\n\u0009return n;\n}\n\ntemplate<typename T1, typename T2>\nstatic T2 dictSearch_(dictImpl_<T1, T2>* r, T1 k, bool* f) noexcept\n{\n\u0009dictImpl_<T1, T2>* n = r;\n\u0009while (n != nullptr)\n\u0009{\n\u0009\u0009int64_t c = cmp_(k, n->K);\n\u0009\u0009if (c == 0)\n\u0009\u0009{\n\u0009\u0009\u0009*f = true;\n\u0009\u0009\u0009return n->V;\n\u0009\u0009}\n\u0009\u0009if (c < 0)\n\u0009\u0009\u0009n = n->CL;\n\u0009\u0009else\n\u0009\u0009\u0009n = n->CR;\n\u0009}\n\u0009*f = false;\n\u0009return (T2)0;\n}\n\ntemplate<typename T1, typename T2>\nstatic bool dictForEach_(dictImpl_<T1, T2>* r, bool(*f)(T1, T2, Class_*), Class_* p)\n{\n\u0009if (r == nullptr)\n\u0009\u0009return true;\n\u0009if (!dictForEach_<T1, T2>(r->CL, f, p))\n\u0009\u0009return false;\n\u0009if (!f(r->K, r->V, p))\n\u0009\u0009return false;\n\u0009if (!dictForEach_<T1, T2>(r->CR, f, p))\n\u0009\u0009return false;\n\u0009return true;\n}\n\ntemplate<typename T1, typename T2>\nstatic dictImpl_<T1, T2>* dictAddRec_(dictImpl_<T1, T2>* n, T1 k, T2 v, bool* a) noexcept\n{\n\u0009if (n == nullptr)\n\u0009{\n\u0009\u0009*a = true;\n\u0009\u0009return new dictImpl_<T1, T2>(k, v);\n\u0009}\n\u0009{\n\u0009\u0009int64_t c = cmp_(k, n->K);\n\u0009\u0009if (c == 0)\n\u0009\u0009{\n\u0009\u0009\u0009n->V = v;\n\u0009\u0009\u0009return n;\n\u0009\u0009}\n\u0009\u0009if (c < 0)\n\u0009\u0009\u0009n->CL = dictAddRec_<T1, T2>(n->CL, k, v, a);\n\u0009\u0009else\n\u0009\u0009\u0009n->CR = dictAddRec_<T1, T2>(n->CR, k, v, a);\n\u0009}\n\u0009if (n->CR != nullptr && n->CR->R)\n\u0009{\n\u0009\u0009dictImpl_<T1, T2>* r = n->CR;\n\u0009\u0009n->CR = r->CL;\n\u0009\u0009r->CL = n;\n\u0009\u0009r->R = n->R;\n\u0009\u0009n->R = true;\n\u0009\u0009n = r;\n\u0009}\n\u0009if (n->CL != nullptr && n->CL->R && n->CL->CL != nullptr && n->CL->CL->R)\n\u0009{\n\u0009\u0009dictImpl_<T1, T2>* l = n->CL;\n\u0009\u0009n->CL = l->CR;\n\u0009\u0009l->CR = n;\n\u0009\u0009l->R = n->R;\n\u0009\u0009n->R = true;\n\u0009\u0009n = l;\n\u0009\u0009n->R = true;\n\u0009\u0009n->CL->R = false;\n\u0009\u0009n->CR->R = false;\n\u0009}\n\u0009return n;\n}\n\nclass reader_\n{\npublic:\n\u0009reader_() noexcept : F(new std::ifstream())\n\u0009{\n\u0009}\n\n\u0009std::ifstream* F;\n};\n\nclass writer_\n{\npublic:\n\u0009writer_() noexcept : F(new std::ofstream())\n\u0009{\n\u0009}\n\n\u0009std::ofstream* F;\n};\n\nstatic char16_t readUtf8_(std::ifstream* f)\n{\n\u0009char c;\n\u0009int64_t l;\n\u0009uint64_t u;\n\u0009if (!f->get(c))\n\u0009\u0009return 0xffff;\n\u0009if ((c & 0xc0) == 0x80)\n\u0009\u0009return 0xffff;\n\u0009if ((c & 0x80) == 0x00)\n\u0009\u0009l = 0;\n\u0009else if ((c & 0xe0) == 0xc0)\n\u0009\u0009l = 1, c &= 0x1f;\n\u0009else if ((c & 0xf0) == 0xe0)\n\u0009\u0009l = 2, c &= 0x0f;\n\u0009else if ((c & 0xf8) == 0xf0)\n\u0009\u0009l = 3, c &= 0x07;\n\u0009else if ((c & 0xfc) == 0xf8)\n\u0009\u0009l = 4, c &= 0x03;\n\u0009else if ((c & 0xfe) == 0xfc)\n\u0009\u0009l = 5, c &= 0x01;\n\u0009else\n\u0009\u0009return 0xffff;\n\u0009u = static_cast<uint64_t>(c);\n\u0009for (int64_t i = 0; i < l; i++)\n\u0009{\n\u0009\u0009if (!f->get(c) || (c & 0xc0) != 0x80)\n\u0009\u0009\u0009return 0xffff;\n\u0009\u0009u = (u << 6) | static_cast<uint64_t>(c & 0x3f);\n\u0009}\n\u0009if (0x00010000 <= u && u <= 0x0010ffff)\n\u0009\u0009u = 0x20;\n\u0009return static_cast<char16_t>(u);\n}\n\nstatic void writeUtf8_(std::ofstream* f, char16_t c)\n{\n\u0009uint64_t u;\n\u0009size_t size;\n\u0009if ((c >> 7) == 0)\n\u0009\u0009u = c, size = 1;\n\u0009else\n\u0009{\n\u0009\u0009u = (0x80 | (c & 0x3f)) << 8;\n\u0009\u0009c >>= 6;\n\u0009\u0009if ((c >> 5) == 0)\n\u0009\u0009\u0009u |= 0xc0 | c, size = 2;\n\u0009\u0009else\n\u0009\u0009{\n\u0009\u0009\u0009u = (u | 0x80 | (c & 0x3f)) << 8;\n\u0009\u0009\u0009c >>= 6;\n\u0009\u0009\u0009if ((c >> 4) == 0)\n\u0009\u0009\u0009\u0009u |= 0xe0 | c, size = 3;\n\u0009\u0009\u0009else\n\u0009\u0009\u0009{\n\u0009\u0009\u0009\u0009u = (u | 0x80 | (c & 0x3f)) << 8;\n\u0009\u0009\u0009\u0009c >>= 6;\n\u0009\u0009\u0009\u0009if ((c >> 3) == 0)\n\u0009\u0009\u0009\u0009\u0009u |= 0xf0 | c, size = 4;\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009{\n\u0009\u0009\u0009\u0009\u0009u = (u | 0x80 | (c & 0x3f)) << 8;\n\u0009\u0009\u0009\u0009\u0009c >>= 6;\n\u0009\u0009\u0009\u0009\u0009if ((c >> 2) == 0)\n\u0009\u0009\u0009\u0009\u0009\u0009u |= 0xf8 | c, size = 5;\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009{\n\u0009\u0009\u0009\u0009\u0009\u0009u = (u | 0x80 | (c & 0x3f)) << 8;\n\u0009\u0009\u0009\u0009\u0009\u0009c >>= 6;\n\u0009\u0009\u0009\u0009\u0009\u0009if ((c >> 1) == 0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009u |= 0xfc | c, size = 6;\n\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009return;\n\u0009\u0009\u0009\u0009\u0009}\n\u0009\u0009\u0009\u0009}\n\u0009\u0009\u0009}\n\u0009\u0009}\n\u0009}\n\u0009if (size == 1 && u == 0x0a)\n\u0009\u0009f->write(newLine_, static_cast<std::streamsize>(sizeof(newLine_)));\n\u0009else\n\u0009\u0009f->write(reinterpret_cast<char*>(&u), static_cast<std::streamsize>(size));\n}\n\nstatic void init_()\n{\n\u0009uint32_t t = static_cast<uint32_t>(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());\n\u0009rX_ = 123456789;\n\u0009rY_ = 362436069;\n\u0009rZ_ = 521288629 * t;\n\u0009rW_ = 88675123 * (rZ_ >> 1);\n}\n";
else if(p==="res/sys/cui.kn")
return "func [d0002.knd, _init] _init()\nend func\n\nfunc [d0002.knd] _fin()\nend func\n\n+func [d0002.knd, _delimiter] delimiter(delimiters: []char)\nend func\n\n+func [__raw, cui_print] print(str: []char)\nend func\n\n+func [d0002.knd, _inputLetter] inputLetter(): char\nend func\n\n+func [d0002.knd, _inputInt] inputInt(): int\nend func\n\n+func [d0002.knd, _inputFloat] inputFloat(): float\nend func\n\n+func [d0002.knd, _inputChar] inputChar(): char\nend func\n\n+func [d0002.knd, _inputStr] inputStr(): []char\nend func\n\n+func [d0002.knd, _input] input(): []char\nend func\n";
else if(p==="res/sys/dbg.kn")
return "+func [d0000.knd, _dbgPrint] print(str: []char)\nend func\n";
else if(p==="res/sys/excpt.kn")
return "+const userMin: int :: 0x00000001\n+const userMax: int :: 0x0000FFFF\n+const accessViolation: int :: 0xC0000005\n+const noMem: int :: 0xC0000017\n+const floatInvalidOperation: int :: 0xC0000090\n+const intDivideByZero: int :: 0xC0000094\n+const stackOverflow: int :: 0xC00000FD\n+const ctrlCExit: int :: 0xC000013A\n+const dbgAssertFailed: int :: 0xE9170000\n+const classCastFailed: int :: 0xE9170001\n+const dbgArrayIdxOutOfRange: int :: 0xE9170002\n+const dbgIntOverflow: int :: 0xE9170003\n+const invalidCmp: int :: 0xE9170004\n+const dbgArgOutDomain: int :: 0xE9170006\n+const fileReadFailed: int :: 0xE9170007\n+const invalidDataFmt: int :: 0xE9170008\n+const deviceInitFailed: int :: 0xE9170009\n+const dbgInoperableState: int :: 0xE917000A\n";
else if(p==="res/sys/file.kn")
return "+enum Origin\n\u0009head\n\u0009cur\n\u0009tail\nend enum\n\n+class Reader()\n\u0009*func [d0000.knd, _readerDtor, __frc] _dtor()\n\u0009end func\n\n\u0009+func [__raw, file_readerFin] fin()\n\u0009end func\n\n\u0009+func [__raw, file_readerSetPos] setPos(origin: @Origin, pos: int)\n\u0009end func\n\n\u0009+func [__raw, file_readerGetPos] getPos(): int\n\u0009end func\n\n\u0009+func [d0000.knd, _readerDelimiter] delimiter(delimiters: []char)\n\u0009end func\n\n\u0009+func [d0000.knd, _readerRead] read(size: int): []bit8\n\u0009end func\n\n\u0009+func [__raw, file_readerReadLetter] readLetter(): char\n\u0009end func\n\n\u0009+func [d0000.knd, _readerReadInt] readInt(): int\n\u0009end func\n\n\u0009+func [d0000.knd, _readerReadFloat] readFloat(): float\n\u0009end func\n\n\u0009+func [d0000.knd, _readerReadChar] readChar(): char\n\u0009end func\n\n\u0009+func [d0000.knd, _readerReadStr] readStr(): []char\n\u0009end func\n\n\u0009+func [d0000.knd, _readerReadLine] readLine(): []char\n\u0009\u0009ret null {TODO:}\n\u0009end func\n\n\u0009+func [d0000.knd, _readerFileSize] fileSize(): int\n\u0009end func\n\n\u0009+func [__raw, file_readerTerm] term(): bool\n\u0009end func\n\n\u0009var handle: int\n\u0009var delimiterNum: int\n\u0009var delimiters: int\n\u0009var fileSize_: int\nend class\n\n+class Writer()\n\u0009*func [d0000.knd, _writerDtor, __frc] _dtor()\n\u0009end func\n\n\u0009+func [__raw, file_writerFin] fin()\n\u0009end func\n\n\u0009+func [__raw, file_writerSetPos] setPos(origin: @Origin, pos: int)\n\u0009end func\n\n\u0009+func [__raw, file_writerGetPos] getPos(): int\n\u0009end func\n\n\u0009+func [__raw, file_writerWrite] write(bin: []bit8)\n\u0009end func\n\n\u0009+func writeInt(n: int)\n\u0009\u0009var s: []char :: n.toStr()\n\u0009\u0009for i(0, ^s - 1)\n\u0009\u0009\u0009do me.writeChar(s[i])\n\u0009\u0009end for\n\u0009end func\n\n\u0009+func writeFloat(n: float)\n\u0009\u0009var s: []char :: n.toStr()\n\u0009\u0009for i(0, ^s - 1)\n\u0009\u0009\u0009do me.writeChar(s[i])\n\u0009\u0009end for\n\u0009end func\n\n\u0009+func [__raw, file_writerWriteChar] writeChar(n: char)\n\u0009end func\n\n\u0009+func writeStr(n: []char)\n\u0009\u0009for i(0, ^n - 1)\n\u0009\u0009\u0009do me.writeChar(n[i])\n\u0009\u0009end for\n\u0009end func\n\n\u0009var handle: int\nend class\n\n+func [__mki, __raw, file_makeReader] makeReader(me2: @Reader, path: []char): @Reader\nend func\n\n+func [__mki, __raw, file_makeWriter] makeWriter(me2: @Writer, path: []char, append: bool): @Writer\nend func\n\n+enum SysDir\n\u0009desktop :: 0x00\n\u0009fonts :: 0x14\n\u0009appData :: 0x1A\n\u0009windows :: 0x24\n\u0009system32 :: 0x25\n\u0009programFiles :: 0x26\nend enum\n\n+func [d0000.knd, _makeDir] makeDir(path: []char): bool\nend func\n\n+func [__raw, file_forEach] forEach(path: []char, recursion: bool, callback: func<([]char, bool, kuin@Class): bool>, data: kuin@Class): bool\nend func\n\n+func [__raw, file_exist] exist(path: []char): bool\nend func\n\n+func [d0000.knd, _delDir] delDir(path: []char): bool\nend func\n\n+func [d0000.knd, _delFile] delFile(path: []char): bool\nend func\n\n+func [d0000.knd, _copyDir] copyDir(dst: []char, src: []char): bool\nend func\n\n+func [__raw, file_copyFile] copyFile(dst: []char, src: []char): bool\nend func\n\n+func [d0000.knd, _moveDir] moveDir(dst: []char, src: []char): bool\nend func\n\n+func [d0000.knd, _moveFile] moveFile(dst: []char, src: []char): bool\nend func\n\n+func dir(path: []char): []char\n\u0009assert path <>& null\n\u0009var p: int :: ^path - 1\n\u0009while(p >= 0 & path[p] <> \'/\' & path[p] <> \'\\\\\')\n\u0009\u0009do p :- 1\n\u0009end while\n\u0009if(p < 0)\n\u0009\u0009ret \"./\"\n\u0009else\n\u0009\u0009var r: []char :: #[p + 1]char\n\u0009\u0009for i(0, p)\n\u0009\u0009\u0009do r[i] :: path[i] = \'\\\\\' ?(\'/\', path[i])\n\u0009\u0009end for\n\u0009\u0009ret r\n\u0009end if\nend func\n\n+func ext(path: []char): []char\n\u0009assert path <>& null\n\u0009var p: int :: ^path - 1\n\u0009while(p >= 0 & path[p] <> \'/\' & path[p] <> \'\\\\\' & path[p] <> \'.\')\n\u0009\u0009do p :- 1\n\u0009end while\n\u0009if(path[p] <> \'.\')\n\u0009\u0009ret \"\"\n\u0009else\n\u0009\u0009do p :+ 1\n\u0009\u0009var r: []char :: #[^path - p]char\n\u0009\u0009for i(0, ^path - p - 1)\n\u0009\u0009\u0009do r[i] :: path[p + i]\n\u0009\u0009end for\n\u0009\u0009ret r\n\u0009end if\nend func\n\n+func fileName(path: []char): []char\n\u0009assert path <>& null\n\u0009var p: int :: ^path - 1\n\u0009while(p >= 0 & path[p] <> \'/\' & path[p] <> \'\\\\\')\n\u0009\u0009do p :- 1\n\u0009end while\n\u0009if(p < 0)\n\u0009\u0009ret path\n\u0009end if\n\u0009do p :+ 1\n\u0009var r: []char :: #[^path - p]char\n\u0009for i(0, ^path - p - 1)\n\u0009\u0009do r[i] :: path[p + i]\n\u0009end for\n\u0009ret r\nend func\n\n+func [d0000.knd, _fullPath] fullPath(path: []char): []char\nend func\n\n+func delExt(path: []char): []char\n\u0009assert path <>& null\n\u0009var p: int :: ^path - 1\n\u0009while(p >= 0 & path[p] <> \'/\' & path[p] <> \'\\\\\' & path[p] <> \'.\')\n\u0009\u0009do p :- 1\n\u0009end while\n\u0009if(p < 0 | path[p] <> \'.\')\n\u0009\u0009ret path\n\u0009end if\n\u0009var r: []char :: #[p]char\n\u0009for i(0, p - 1)\n\u0009\u0009do r[i] :: path[i] = \'\\\\\' ?(\'/\', path[i])\n\u0009end for\n\u0009ret r\nend func\n\n+func [d0000.knd, _sysDir] sysDir(kind: @SysDir): []char\nend func\n\n+func [d0000.knd, _exeDir] exeDir(): []char\nend func\n\n+func [d0000.knd, _fileSize] fileSize(path: []char): int\nend func\n\n+func [d0000.knd, _setCurDir] setCurDir(path: []char)\nend func\n\n+func [d0000.knd, _getCurDir] getCurDir(): []char\nend func\n";
else if(p==="res/sys/kuin.kn")
return "+const envCui: bit64 :: 0b64\n+const envWnd: bit64 :: 1b64\n+const envWeb: bit64 :: 2b64\n+const envCpp: bit64 :: 3b64\n\n+class Class()\n\u0009func ctor()\n\u0009end func\n\n\u0009func _dtor()\n\u0009end func\n\n\u0009+func cmp(t: @Class): int\n\u0009\u0009throw 0xE9170004\n\u0009end func\n\n\u0009func _copy(): @Class\n\u0009end func\n\n\u0009func _toBin(): []bit8\n\u0009end func\n\n\u0009func _fromBin(bin: []bit8, idx: &int): @Class\n\u0009end func\n\n\u0009+func toStr(): []char\n\u0009\u0009ret \"\"\n\u0009end func\nend class\n\nfunc _init()\nend func\n\nfunc _fin()\nend func\n\nfunc _err(excpt: int)\nend func\n\nfunc _initVars()\nend func\n\nfunc _finVars()\nend func\n\nfunc [__any, __raw, toStr] _toStr(me_: int, type: []int): []char\nend func\n\nfunc [d0000.knd] _toStrFmtInt(me_: int, fmt: []char): []char\nend func\n\nfunc [d0000.knd] _toStrFmtFloat(me_: float, fmt: []char): []char\nend func\n\nfunc _absInt(me_: int): int\n\u0009ret me_ >= 0 ?(me_, -me_)\nend func\n\nfunc _absFloat(me_: float): float\n\u0009ret me_ >= 0.0 ?(me_, -me_)\nend func\n\nfunc _signInt(me_: int): int\n\u0009ret me_ > 0 ?(1, me_ < 0 ?(-1, 0))\nend func\n\nfunc _signFloat(me_: float): float\n\u0009ret me_ > 0.0 ?(1.0, me_ < 0.0 ?(-1.0, 0.0))\nend func\n\nfunc _clampInt(me_: int, min: int, max: int): int\n\u0009ret me_ > max ?(max, me_ < min ?(min, me_))\nend func\n\nfunc _clampFloat(me_: float, min: float, max: float): float\n\u0009ret me_ > max ?(max, me_ < min ?(min, me_))\nend func\n\nfunc _clampMinInt(me_: int, min: int): int\n\u0009ret me_ < min ?(min, me_)\nend func\n\nfunc _clampMinFloat(me_: float, min: float): float\n\u0009ret me_ < min ?(min, me_)\nend func\n\nfunc _clampMaxInt(me_: int, max: int): int\n\u0009ret me_ > max ?(max, me_)\nend func\n\nfunc _clampMaxFloat(me_: float, max: float): float\n\u0009ret me_ > max ?(max, me_)\nend func\n\nfunc _offset(me_: char, n: int): char\n\u0009ret (me_ $ bit64 + n $ bit64) $ char\nend func\n\nfunc [__any, __tme, __rme, __raw, or] _or(me_: int, type: []int, n: int): int\nend func\n\nfunc [__any, __tme, __rme, __raw, and] _and(me_: int, type: []int, n: int): int\nend func\n\nfunc [__any, __tme, __rme] _xor(me_: int, type: []int, n: int): int\nend func\n\nfunc [__any, __rme] _not(me_: int, type: []int): int\nend func\n\nfunc [__any, __rme] _shl(me_: int, type: []int, n: int): int\nend func\n\nfunc [__any, __rme] _shr(me_: int, type: []int, n: int): int\nend func\n\nfunc [__any, __rme] _sar(me_: int, type: []int, n: int): int\nend func\n\nfunc [__any, __rme] _endian(me_: int, type: []int): int\nend func\n\nfunc [__any, __rme, __raw, sub] _sub(me_: int, type: []int, start: int, len: int): int\nend func\n\nfunc [__any] _reverse(me_: int, type: []int)\nend func\n\nfunc [__any] _shuffle(me_: int, type: []int)\nend func\n\nfunc [__any] _sortArray(me_: int, type: []int)\nend func\n\nfunc [__any] _sortDescArray(me_: int, type: []int)\nend func\n\nfunc [__any] _sortList(me_: int, type: []int)\nend func\n\nfunc [__any] _sortDescList(me_: int, type: []int)\nend func\n\nfunc [__any, __tch, __raw, findArray] _findArray(me_: int, type: []int, item: int, start: int): int\nend func\n\nfunc [__any, __tch] _findList(me_: int, type: []int, item: int): bool\nend func\n\nfunc [__any, __tch] _findLastArray(me_: int, type: []int, item: int, start: int): int\nend func\n\nfunc [__any, __tch] _findLastList(me_: int, type: []int, item: int): bool\nend func\n\nfunc [__any, __tch, __raw, findBin] _findBin(me_: int, type: []int, item: int): int\nend func\n\nfunc [__any, __tch, __raw, fill] _fill(me_: int, type: []int, value: int)\nend func\n\nfunc [__any, __rch] _min(me_: int, type: []int): int\nend func\n\nfunc [__any, __rch] _max(me_: int, type: []int): int\nend func\n\nfunc [__any, __rme] _repeat(me_: int, type: []int, len: int): int\nend func\n\nfunc [__raw, toInt] _toInt(me_: []char, success: &bool): int\nend func\n\nfunc [__raw, toFloat] _toFloat(me_: []char, success: &bool): float\nend func\n\nfunc [__raw, toBit64] _toBit64(me_: []char, success: &bool): bit64\nend func\n\nfunc _lower(me_: []char): []char\n\u0009assert me_ <>& null\n\u0009for i(0, ^me_ - 1)\n\u0009\u0009if(\'A\' <= me_[i] & me_[i] <= \'Z\')\n\u0009\u0009\u0009do me_[i] :: (me_[i] $ bit64 - 0x41b64 + 0x61b64) $ char\n\u0009\u0009end if\n\u0009end for\nend func\n\nfunc _upper(me_: []char): []char\n\u0009assert me_ <>& null\n\u0009for i(0, ^me_ - 1)\n\u0009\u0009if(\'a\' <= me_[i] & me_[i] <= \'z\')\n\u0009\u0009\u0009do me_[i] :: (me_[i] $ bit64 - 0x61b64 + 0x41b64) $ char\n\u0009\u0009end if\n\u0009end for\nend func\n\nfunc _trim(me_: []char): []char\n\u0009assert me_ <>& null\n\u0009var f: int :: -1\n\u0009for i(0, ^me_ - 1)\n\u0009\u0009var c: bit64 :: me_[i] $ bit64\n\u0009\u0009if(!(0x09b64 <= c & c <= 0x0Db64 | c = 0x20b64 | c = 0xA0b64))\n\u0009\u0009\u0009do f :: i\n\u0009\u0009\u0009break i\n\u0009\u0009end if\n\u0009end for\n\u0009if(f = -1)\n\u0009\u0009ret me_\n\u0009end if\n\u0009var l: int :: -1\n\u0009for i(^me_ - 1, 0, -1)\n\u0009\u0009var c: bit64 :: me_[i] $ bit64\n\u0009\u0009if(!(0x09b64 <= c & c <= 0x0Db64 | c = 0x20b64 | c = 0xA0b64))\n\u0009\u0009\u0009do l :: i\n\u0009\u0009\u0009break i\n\u0009\u0009end if\n\u0009end for\n\u0009var r: []char :: #[l - f + 1]char\n\u0009for i(0, l - f)\n\u0009\u0009do r[i] :: me_[f + i]\n\u0009end for\n\u0009ret r\nend func\n\nfunc _trimLeft(me_: []char): []char\n\u0009assert me_ <>& null\n\u0009var f: int :: -1\n\u0009for i(0, ^me_ - 1)\n\u0009\u0009var c: bit64 :: me_[i] $ bit64\n\u0009\u0009if(!(0x09b64 <= c & c <= 0x0Db64 | c = 0x20b64 | c = 0xA0b64))\n\u0009\u0009\u0009do f :: i\n\u0009\u0009\u0009break i\n\u0009\u0009end if\n\u0009end for\n\u0009if(f = -1)\n\u0009\u0009ret me_\n\u0009end if\n\u0009var r: []char :: #[^me_ - f]char\n\u0009for i(0, ^me_ - f - 1)\n\u0009\u0009do r[i] :: me_[f + i]\n\u0009end for\n\u0009ret r\nend func\n\nfunc _trimRight(me_: []char): []char\n\u0009var l: int :: -1\n\u0009for i(^me_ - 1, 0, -1)\n\u0009\u0009var c: bit64 :: me_[i] $ bit64\n\u0009\u0009if(!(0x09b64 <= c & c <= 0x0Db64 | c = 0x20b64 | c = 0xA0b64))\n\u0009\u0009\u0009do l :: i\n\u0009\u0009\u0009break i\n\u0009\u0009end if\n\u0009end for\n\u0009if(l = -1)\n\u0009\u0009ret me_\n\u0009end if\n\u0009var r: []char :: #[l + 1]char\n\u0009for i(0, l)\n\u0009\u0009do r[i] :: me_[i]\n\u0009end for\n\u0009ret r\nend func\n\nfunc [d0000.knd] _split(me_: []char, delimiter: []char): [][]char\nend func\n\nfunc _join(me_: [][]char, delimiter: []char): []char\n\u0009var t: int :: ^delimiter * (^me_ - 1)\n\u0009for i(0, ^me_ - 1)\n\u0009\u0009do t :+ ^me_[i]\n\u0009end for\n\u0009var r: []char :: #[t]char\n\u0009var p: int :: 0\n\u0009for i(0, ^me_ - 1)\n\u0009\u0009if(i <> 0)\n\u0009\u0009\u0009for j(0, ^delimiter - 1)\n\u0009\u0009\u0009\u0009do r[p] :: delimiter[j]\n\u0009\u0009\u0009\u0009do p :+ 1\n\u0009\u0009\u0009end for\n\u0009\u0009end if\n\u0009\u0009var s: []char :: me_[i]\n\u0009\u0009for j(0, ^s - 1)\n\u0009\u0009\u0009do r[p] :: s[j]\n\u0009\u0009\u0009do p :+ 1\n\u0009\u0009end for\n\u0009end for\n\u0009ret r\nend func\n\nfunc [d0000.knd] _replace(me_: []char, old: []char, new: []char): []char\nend func\n\nfunc [d0000.knd] _findStr(me_: []char, pattern: []char, start: int): int\nend func\n\nfunc [d0000.knd] _findStrLast(me_: []char, pattern: []char, start: int): int\nend func\n\nfunc [d0000.knd] _findStrEx(me_: []char, pattern: []char, start: int, fromLast: bool, ignoreCase: bool, wholeWord: bool): int\nend func\n\nfunc [__any, __tch, __raw, addList] _addList(me_: int, type: []int, item: int)\nend func\n\nfunc [__any, __tch, __raw, addStack] _addStack(me_: int, type: []int, item: int)\nend func\n\nfunc [__any, __tch, __raw, addQueue] _addQueue(me_: int, type: []int, item: int)\nend func\n\nfunc [__any, __tkv, __raw, addDict] _addDict(me_: int, type: []int, key: int, item: int)\nend func\n\nfunc [__any, __rch, __raw, getList] _getList(me_: int, type: []int): int\nend func\n\nfunc [__any, __rch, __raw, getStack] _getStack(me_: int, type: []int): int\nend func\n\nfunc [__any, __rch, __raw, getQueue] _getQueue(me_: int, type: []int): int\nend func\n\nfunc [__any, __tch, __rch, __raw, getDict] _getDict(me_: int, type: []int, key: int, existed: &bool): int\nend func\n\nfunc [__any, __rch] _getOffset(me_: int, type: []int, offset: int): int\nend func\n\nfunc [__any, __raw, head] _head(me_: int, type: []int)\nend func\n\nfunc [__any, __raw, moveOffset] _moveOffset(me_: int, type: []int, offset: int)\nend func\n\nfunc [__any, __raw, tail] _tail(me_: int, type: []int)\nend func\n\nfunc [__any, __raw, next] _next(me_: int, type: []int)\nend func\n\nfunc [__any] _prev(me_: int, type: []int)\nend func\n\nfunc [__any, __raw, term] _term(me_: int, type: []int): bool\nend func\n\nfunc [__any] _termOffset(me_: int, type: []int, offset: int): bool\nend func\n\nfunc [__any, __raw, del] _del(me_: int, type: []int)\nend func\n\nfunc [__any] _delNext(me_: int, type: []int)\nend func\n\nfunc [__any, __tch, __raw, ins] _ins(me_: int, type: []int, item: int)\nend func\n\nfunc [__any, __rac] _toArray(me_: int, type: []int): int\nend func\n\nfunc [__any, __rak] _toArrayKey(me_: int, type: []int): int\nend func\n\nfunc [__any, __rav] _toArrayValue(me_: int, type: []int): int\nend func\n\nfunc [__any, __rch, __raw, peekQueue] _peekQueue(me_: int, type: []int): int\nend func\n\nfunc [__any, __rch, __raw, peekStack] _peekStack(me_: int, type: []int): int\nend func\n\nfunc [__any, __tch] _exist(me_: int, type: []int, key: int): bool\nend func\n\nfunc [__any, __kvf, __raw, forEach] _forEach(me_: int, type: []int, callback: int, data: @Class): bool\nend func\n\nfunc [__any, __tch] _delDict(me_: int, type: []int, key: int)\nend func\n\nfunc [__any, __raw, idx] _idx(me_: int, type: []int): int\nend func\n";
else if(p==="res/sys/lib.kn")
return "+const pi: float :: 3.14159265358979323846\n+const e: float :: 2.71828182845904523536\n+const intMin: int :: -9223372036854775807 - 1\n+const intMax: int :: 9223372036854775807\n\n+func [__raw, cmdLine] cmdLine(): [][]char\nend func\n\n+func [_exit_code] exitCode(code: int)\n\u0009if(dbg)\n\u0009\u0009if(code < 0 | 0xFFFFFFFF < code)\n\u0009\u0009\u0009throw excpt@dbgArgOutDomain\n\u0009\u0009end if\n\u0009end if\nend func\n\n+class Rnd()\n\u0009*func [d0000.knd, _rndDtor, __frc] _dtor()\n\u0009end func\n\n\u0009+func [d0000.knd, _rndRnd] rnd(min: int, max: int): int\n\u0009end func\n\n\u0009+func [d0000.knd, _rndRndFloat] rndFloat(min: float, max: float): float\n\u0009end func\n\n\u0009+func [d0000.knd, _rndRndBit64] rndBit64(): bit64\n\u0009end func\n\n\u0009var rndState: int\nend class\n\n+func [d0000.knd, _makeRnd, __mki] makeRnd(me2: @Rnd, seed: int): @Rnd\nend func\n\n+func [__raw, rnd] rnd(min: int, max: int): int\nend func\n\n+func [__raw, rndFloat] rndFloat(min: float, max: float): float\nend func\n\n+func [d0000.knd, _rndBit64] rndBit64(): bit64\nend func\n\n+func [d0000.knd, _rndUuid] rndUuid(): []char\nend func\n\n+func [d0000.knd, _cos] cos(x: float): float\nend func\n\n+func [d0000.knd, _sin] sin(x: float): float\nend func\n\n+func [d0000.knd, _tan] tan(x: float): float\nend func\n\n+func [d0000.knd, _acos] acos(x: float): float\nend func\n\n+func [d0000.knd, _asin] asin(x: float): float\nend func\n\n+func [d0000.knd, _atan] atan(x: float): float\nend func\n\n+func [d0000.knd, _cosh] cosh(x: float): float\nend func\n\n+func [d0000.knd, _sinh] sinh(x: float): float\nend func\n\n+func [d0000.knd, _tanh] tanh(x: float): float\nend func\n\n+func [d0000.knd, _acosh] acosh(x: float): float\nend func\n\n+func [d0000.knd, _asinh] asinh(x: float): float\nend func\n\n+func [d0000.knd, _atanh] atanh(x: float): float\nend func\n\n+func [d0000.knd, _sqrt] sqrt(x: float): float\nend func\n\n+func [d0000.knd, _exp] exp(x: float): float\nend func\n\n+func [d0000.knd, _ln] ln(x: float): float\nend func\n\n+func [d0000.knd, _log] log(base: float, x: float): float\nend func\n\n+func [d0000.knd, _floor] floor(x: float): float\nend func\n\n+func [d0000.knd, _ceil] ceil(x: float): float\nend func\n\n+func [d0000.knd, _round] round(x: float, precision: int): float\nend func\n\n+func [d0000.knd, _rot] rot(x: &float, y: &float, centerX: float, centerY: float, angle: float)\nend func\n\n+func [d0000.knd, _invRot] invRot(x: float, y: float, centerX: float, centerY: float): float\nend func\n\n+func [d0000.knd, _dist] dist(x: float, y: float, centerX: float, centerY: float): float\nend func\n\n+func [d0000.knd, _chase] chase(x: &float, target: float, vel: float): bool\nend func\n\n+func [d0000.knd, _same] same(n1: float, n2: float): bool\nend func\n\n+func [d0000.knd, _toRad] toRad(degree: float): float\nend func\n\n+func [d0000.knd, _toDegree] toDegree(rad: float): float\nend func\n\n+func cmp(s1: []char, s2: []char): int\n\u0009var p: int :: 0\n\u0009while(p < ^s1 & p < ^s2)\n\u0009\u0009if(s1[p] <> s2[p])\n\u0009\u0009\u0009ret s1[p] > s2[p] ?(1, s1[p] < s2[p] ?(-1, 0))\n\u0009\u0009end if\n\u0009\u0009do p :+ 1\n\u0009end while\n\u0009ret ^s1 > ^s2 ?(1, ^s1 < ^s2 ?(-1, 0))\nend func\n\n+func [d0000.knd, _cmpEx] cmpEx(s1: []char, s2: []char, len: int, ignoreCase: bool): int\nend func\n\n+func min(n1: int, n2: int): int\n\u0009ret n1 <= n2 ?(n1, n2)\nend func\n\n+func minFloat(n1: float, n2: float): float\n\u0009ret n1 <= n2 ?(n1, n2)\nend func\n\n+func max(n1: int, n2: int): int\n\u0009ret n1 >= n2 ?(n1, n2)\nend func\n\n+func maxFloat(n1: float, n2: float): float\n\u0009ret n1 >= n2 ?(n1, n2)\nend func\n\n+func [d0000.knd, _levenshtein] levenshtein(s1: []char, s2: []char): int\nend func\n\n+func [d0000.knd, _lerp] lerp(first: float, last: float, rate: float): float\nend func\n\n+func [d0000.knd, _qerp] qerp(first: float, last: float, easeIn: bool, rate: float): float\nend func\n\n+func [d0000.knd, _cerp] cerp(first: float, last: float, rate: float): float\nend func\n\n+func [d0000.knd, _hermite] hermite(pos: []float, rate: float): float\nend func\n\n+class BmSearch()\n\u0009*func [d0000.knd, _bmSearchDtor, __frc] _dtor()\n\u0009end func\n\n\u0009+func [d0000.knd, _bmSearchFind] find(text: []char, start: int): int\n\u0009end func\n\n\u0009var pattern: int\n\u0009var dists: int\n\u0009var len: int\nend class\n\n+func [d0000.knd, _makeBmSearch, __mki] makeBmSearch(me2: @BmSearch, pattern: []char): @BmSearch\nend func\n\n+func [d0000.knd, _hash] hash(data: []bit8): []bit8\nend func\n\n+func [d0000.knd, _encrypt] encrypt(data: []bit8, key: []bit8): []bit8\nend func\n\n+func [d0000.knd, _decrypt] decrypt(data: []bit8, key: []bit8): []bit8\nend func\n\n+func [__raw, sysTime] sysTime(): int\nend func\n\n+func [d0000.knd, _now] now(): int\nend func\n\n+func [d0000.knd, _intToDate] intToDate(time: int, year: &int, month: &int, day: &int, hour: &int, minute: &int, second: &int): int\nend func\n\n+func [d0000.knd, _dateToInt] dateToInt(year: int, month: int, day: int, hour: int, minute: int, second: int): int\nend func\n\n+func [d0000.knd, _intToLocalDate] intToLocalDate(time: int, year: &int, month: &int, day: &int, hour: &int, minute: &int, second: &int): int\nend func\n\n+func [d0000.knd, _localDateToInt] localDateToInt(year: int, month: int, day: int, hour: int, minute: int, second: int): int\nend func\n\n+func [d0000.knd] sleep(ms: int)\nend func\n\n+func [d0000.knd, _countUp] countUp(min: int, max: int): []int\nend func\n\n+func [__raw, addr] addr(class_: kuin@Class): bit64\nend func\n\n+class Int()\n\u0009+*func cmp(t: @Int): int\n\u0009\u0009ret (me.value - t.value).sign()\n\u0009end func\n\n\u0009+*func toStr(): []char\n\u0009\u0009ret me.value.toStr()\n\u0009end func\n\n\u0009+var value: int\nend class\n\n+class Float()\n\u0009+*func cmp(t: @Float): int\n\u0009\u0009ret (me.value - t.value).sign() $ int\n\u0009end func\n\n\u0009+*func toStr(): []char\n\u0009\u0009ret me.value.toStr()\n\u0009end func\n\n\u0009+var value: float\nend class\n\n+class Bool()\n\u0009+*func cmp(t: @Bool): int\n\u0009\u0009ret (me.value $ int - t.value $ int).sign()\n\u0009end func\n\n\u0009+*func toStr(): []char\n\u0009\u0009ret me.value.toStr()\n\u0009end func\n\n\u0009+var value: bool\nend class\n\n+class Char()\n\u0009+*func cmp(t: @Char): int\n\u0009\u0009ret (me.value $ int - t.value $ int).sign()\n\u0009end func\n\n\u0009+*func toStr(): []char\n\u0009\u0009ret me.value.toStr()\n\u0009end func\n\n\u0009+var value: char\nend class\n\n+class Str()\n\u0009+*func cmp(t: @Str): int\n\u0009\u0009ret @cmp(me.value, t.value)\n\u0009end func\n\n\u0009+*func toStr(): []char\n\u0009\u0009ret me.value\n\u0009end func\n\n\u0009+var value: []char\nend class\n";
else if(p==="res/sys/preset00_cui.knp")
return "func main()\n\u0009do cui@print(\"Hello, world!\")\nend func\n";
else if(p==="res/sys/preset00_wnd.knp")
return "func main()\n\u0009var wndMain: wnd@Wnd :: wnd@makeWnd(null, %normal, 1024, 768, \"\")\n\u0009var editLog: wnd@EditMulti :: wnd@makeEditMulti(wndMain, 12, 12, 1000, 744, %scale, %scale)\n\u0009do editLog.readonly(true)\n\u0009do editLog.setText(\"Hello, world!\")\n\n\u0009while(wnd@act())\n\u0009end while\nend func\n";
else if(p==="res/sys/preset01_cui.knp")
return "func main()\n\u0009do cui@print(\"q\")\nend func\n";
else if(p==="res/sys/preset01_wnd.knp")
return "func main()\n\u0009var wndMain: wnd@Wnd :: wnd@makeWnd(null, %normal, 1024, 768, \"\")\n\u0009var editLog: wnd@EditMulti :: wnd@makeEditMulti(wndMain, 12, 12, 1000, 744, %scale, %scale)\n\u0009do editLog.readonly(true)\n\u0009do editLog.setText(\"q\")\n\n\u0009while(wnd@act())\n\u0009end while\nend func\n";
else if(p==="res/sys/preset02_cui.knp")
return "func main()\n\u0009for i(1, 100)\n\u0009\u0009if(i % 15 = 0)\n\u0009\u0009\u0009do cui@print(\"FizzBuzz\\n\")\n\u0009\u0009elif(i % 3 = 0)\n\u0009\u0009\u0009do cui@print(\"Fizz\\n\")\n\u0009\u0009elif(i % 5 = 0)\n\u0009\u0009\u0009do cui@print(\"Buzz\\n\")\n\u0009\u0009else\n\u0009\u0009\u0009do cui@print(i.toStr() ~ \"\\n\")\n\u0009\u0009end if\n\u0009end for\nend func\n";
else if(p==="res/sys/preset02_wnd.knp")
return "func main()\n\u0009var wndMain: wnd@Wnd :: wnd@makeWnd(null, %normal, 1024, 768, \"\")\n\u0009var editLog: wnd@EditMulti :: wnd@makeEditMulti(wndMain, 12, 12, 1000, 744, %scale, %scale)\n\u0009do editLog.readonly(true)\n\u0009do editLog.setText(\"\")\n\u0009for i(1, 100)\n\u0009\u0009if(i % 15 = 0)\n\u0009\u0009\u0009do editLog.setText(editLog.getText() ~ \"FizzBuzz\\n\")\n\u0009\u0009elif(i % 3 = 0)\n\u0009\u0009\u0009do editLog.setText(editLog.getText() ~ \"Fizz\\n\")\n\u0009\u0009elif(i % 5 = 0)\n\u0009\u0009\u0009do editLog.setText(editLog.getText() ~ \"Buzz\\n\")\n\u0009\u0009else\n\u0009\u0009\u0009do editLog.setText(editLog.getText() ~ (i.toStr() ~ \"\\n\"))\n\u0009\u0009end if\n\u0009end for\n\n\u0009while(wnd@act())\n\u0009end while\nend func\n";
else if(p==="res/sys/preset03_cui.knp")
return "func main()\n\u0009for i(99, 2, -1)\n\u0009\u0009do cui@print(i.toStr() ~ \" bottles of beer on the wall, \" ~ i.toStr() ~ \" bottles of beer.\\n\")\n\u0009\u0009do cui@print(\"Take one down, pass it around, \" ~ (i - 1).toStr() ~ \" bottles of beer on the wall.\\n\")\n\u0009end for\n\u0009do cui@print(\"2 bottles of beer on the wall, 2 bottles of beer.\\n\")\n\u0009do cui@print(\"Take one down, pass it around, 1 bottle of beer on the wall.\\n\")\n\u0009do cui@print(\"1 bottle of beer on the wall, 1 bottle of beer.\\n\")\n\u0009do cui@print(\"Take one down, pass it around, no more bottles of beer on the wall.\\n\")\n\u0009do cui@print(\"No more bottles of beer on the wall, no more bottles of beer.\\n\")\n\u0009do cui@print(\"Go to the store and buy some more, 99 bottles of beer on the wall.\\n\")\nend func\n";
else if(p==="res/sys/preset03_wnd.knp")
return "func main()\n\u0009var wndMain: wnd@Wnd :: wnd@makeWnd(null, %normal, 1024, 768, \"\")\n\u0009var editLog: wnd@EditMulti :: wnd@makeEditMulti(wndMain, 12, 12, 1000, 744, %scale, %scale)\n\u0009do editLog.readonly(true)\n\u0009do editLog.setText(\"\")\n\u0009for i(99, 2, -1)\n\u0009\u0009do editLog.setText(editLog.getText() ~ (i.toStr() ~ \" bottles of beer on the wall, \" ~ i.toStr() ~ \" bottles of beer.\\n\"))\n\u0009\u0009do editLog.setText(editLog.getText() ~ (\"Take one down, pass it around, \" ~ (i - 1).toStr() ~ \" bottles of beer on the wall.\\n\"))\n\u0009end for\n\u0009do editLog.setText(editLog.getText() ~ \"2 bottles of beer on the wall, 2 bottles of beer.\\n\")\n\u0009do editLog.setText(editLog.getText() ~ \"Take one down, pass it around, 1 bottle of beer on the wall.\\n\")\n\u0009do editLog.setText(editLog.getText() ~ \"1 bottle of beer on the wall, 1 bottle of beer.\\n\")\n\u0009do editLog.setText(editLog.getText() ~ \"Take one down, pass it around, no more bottles of beer on the wall.\\n\")\n\u0009do editLog.setText(editLog.getText() ~ \"No more bottles of beer on the wall, no more bottles of beer.\\n\")\n\u0009do editLog.setText(editLog.getText() ~ \"Go to the store and buy some more, 99 bottles of beer on the wall.\\n\")\n\n\u0009while(wnd@act())\n\u0009end while\nend func\n";
else if(p==="res/sys/wnd.kn")
return "func [d0001.knd, _init] _init()\nend func\n\nfunc [d0001.knd] _fin()\nend func\n\n+func [d0001.knd, _act] act(): bool\nend func\n\n+enum WndStyle\n\u0009normal\n\u0009fix\n\u0009aspect\n\u0009popup\n\u0009dialog\n\u0009layered :: 0x10000\n\u0009noMinimize :: 0x20000\nend enum\n\n+enum Anchor\n\u0009fix\n\u0009move\n\u0009scale\nend enum\n\n+class WndBase()\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseGetPos] getPos(x: &int, y: &int, width: &int, height: &int)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseGetPosScreen] getPosScreen(x: &int, y: &int, width: &int, height: &int)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseFocus] focus()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseFocused] focused(): bool\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseSetEnabled] setEnabled(isEnabled: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseGetEnabled] getEnabled(): bool\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseSetPos] setPos(x: int, y: int, width: int, height: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseSetRedraw] setRedraw(isEnabled: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseSetVisible] setVisible(isVisible: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseGetVisible] getVisible(): bool\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseClientToScreen] clientToScreen(screenX: &int, screenY: &int, clientX: int, clientY: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseScreenToClient] screenToClient(clientX: &int, clientY: &int, screenX: int, screenY: int)\n\u0009end func\n\n\u0009+func addChild(child: kuin@Class)\n\u0009\u0009do me.children.add(child)\n\u0009end func\n\n\u0009+func find(name: []char): @WndBase\n\u0009\u0009if(dbg)\n\u0009\u0009\u0009if(name =& null)\n\u0009\u0009\u0009\u0009throw 0xE9170006\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009ret findRecursion(me, name)\n\n\u0009\u0009func findRecursion(wnd: @WndBase, name: []char): @WndBase\n\u0009\u0009\u0009if(wnd.name <>& null & wnd.name = name)\n\u0009\u0009\u0009\u0009ret wnd\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do wnd.children.head()\n\u0009\u0009\u0009while(!wnd.children.term())\n\u0009\u0009\u0009\u0009var child: kuin@Class :: wnd.children.get()\n\u0009\u0009\u0009\u0009if(child =$ @WndBase)\n\u0009\u0009\u0009\u0009\u0009var result: @WndBase :: findRecursion(child $ @WndBase, name)\n\u0009\u0009\u0009\u0009\u0009if(result <>& null)\n\u0009\u0009\u0009\u0009\u0009\u0009ret result\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do wnd.children.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009ret null\n\u0009\u0009end func\n\u0009end func\n\n\u0009+var name: []char\n\u0009var kind: int\n\u0009var handle: int\n\u0009var defaultWndProc: int\n\u0009var ctrlFlag: int\n\u0009var defaultRect: int\n\u0009var redrawEnabled: int\n\u0009+var children: list<kuin@Class>\nend class\n\n+class Wnd(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetText] getText(): []char\n\u0009end func\n\n\u0009+func [d0001.knd, _wndClose] close()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndExit] exit()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndMinMax] minMax(minWidth: int, minHeight: int, maxWidth: int, maxHeight: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetMenu] setMenu(menu: @Menu)\n\u0009\u0009if(menu <>& null)\n\u0009\u0009\u0009do me.addChild(menu)\n\u0009\u0009end if\n\u0009end func\n\n\u0009+func [d0001.knd, _wndActivate] activate()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndActivated] activated(): bool\n\u0009end func\n\n\u0009+func [d0001.knd, _wndFocusedWnd] focusedWnd(): bool\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetAlpha] setAlpha(alpha: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetAlpha] getAlpha(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _wndAcceptDraggedFiles] acceptDraggedFiles(isAccepted: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndUpdateMenu] updateMenu()\n\u0009end func\n\n\u0009+func modal()\n\u0009\u0009do me.setModalLock()\n\u0009\u0009while(@act() & me.modalLock)\n\u0009\u0009end while\n\u0009end func\n\n\u0009func [d0001.knd, _wndSetModalLock] setModalLock()\n\u0009end func\n\n\u0009var minMaxRect: int\n\u0009+var onClose: func<(@WndBase): bool>\n\u0009+var onActivate: func<(@WndBase, bool, bool)>\n\u0009+var onPushMenu: func<(@WndBase, int)>\n\u0009+var onDropFiles: func<(@WndBase, [][]char)>\n\u0009+var onResize: func<(@WndBase)>\n\u0009var modalLock: bool\nend class\n\n+enum ShiftCtrl\n\u0009none\n\u0009shift :: 0x01\n\u0009ctrl :: 0x02\nend enum\n\n+class Draw(@WndBase)\n\u0009*func [d0001.knd, _drawDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _drawPaint] paint()\n\u0009end func\n\n\u0009+func [d0001.knd, _drawShowCaret] showCaret(height: int, font: draw@Font)\n\u0009end func\n\n\u0009+func [d0001.knd, _drawHideCaret] hideCaret()\n\u0009end func\n\n\u0009+func [d0001.knd, _drawMoveCaret] moveCaret(x: int, y: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _drawMouseCapture] mouseCapture(enabled: bool)\n\u0009end func\n\n\u0009var equalMagnification: int\n\u0009var drawBuf: int\n\u0009+var onPaint: func<(@WndBase, int, int)>\n\u0009+var onMouseDownL: func<(@WndBase, int, int)>\n\u0009+var onMouseDownR: func<(@WndBase, int, int)>\n\u0009+var onMouseDownM: func<(@WndBase, int, int)>\n\u0009+var onMouseDoubleClick: func<(@WndBase, int, int)>\n\u0009+var onMouseUpL: func<(@WndBase, int, int)>\n\u0009+var onMouseUpR: func<(@WndBase, int, int)>\n\u0009+var onMouseUpM: func<(@WndBase, int, int)>\n\u0009+var onMouseMove: func<(@WndBase, int, int)>\n\u0009+var onMouseEnter: func<(@WndBase, int, int)>\n\u0009+var onMouseLeave: func<(@WndBase)>\n\u0009+var onMouseWheelX: func<(@WndBase, int)>\n\u0009+var onMouseWheelY: func<(@WndBase, int)>\n\u0009+var onFocus: func<(@WndBase, bool)>\n\u0009+var onKeyDown: func<(@WndBase, @Key, @ShiftCtrl)>\n\u0009+var onKeyUp: func<(@WndBase, @Key, @ShiftCtrl)>\n\u0009+var onKeyChar: func<(@WndBase, char)>\n\u0009+var onScrollX: func<(@WndBase, int)>\n\u0009+var onScrollY: func<(@WndBase, int)>\n\u0009+var onSetMouseImg: func<(@WndBase): @MouseImg>\nend class\n\n+class DrawEditable(@Draw)\n\u0009*func [d0001.knd, _drawDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Btn(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetText] getText(): []char\n\u0009end func\n\n\u0009+var onPush: func<(@WndBase)>\nend class\n\n+class Chk(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetText] getText(): []char\n\u0009end func\n\n\u0009+func [d0001.knd, _btnSetChk] setChk(value: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _btnGetChk] getChk(): bool\n\u0009end func\n\n\u0009+var onPush: func<(@WndBase)>\nend class\n\n+class Radio(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetText] getText(): []char\n\u0009end func\n\n\u0009+func [d0001.knd, _btnSetChk] setChk(value: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _btnGetChk] getChk(): bool\n\u0009end func\n\n\u0009+var onPush: func<(@WndBase)>\nend class\n\n+class EditBase(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [__raw,  wnd_editBaseGetText] getText(): []char\n\u0009end func\n\n\u0009+func [d0001.knd, _editReadonly] readonly(enabled: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _editSetSel] setSel(start: int, len: int)\n\u0009end func\n\n\u0009+var onChange: func<(@WndBase)>\n\u0009+var onFocus: func<(@WndBase, bool)>\nend class\n\n+class Edit(@EditBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _editRightAligned] rightAligned(enabled: bool)\n\u0009end func\nend class\n\n+class EditMulti(@EditBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _editMultiAddText] addText(text: []char)\n\u0009end func\nend class\n\n+class List(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _listClear] clear()\n\u0009end func\n\n\u0009+func [d0001.knd, _listAdd] add(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _listIns] ins(idx: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _listDel] del(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listLen] len(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _listSetSel] setSel(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listGetSel] getSel(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _listSetText] setText(idx: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _listGetText] getText(idx: int): []char\n\u0009end func\n\n\u0009+var onSel: func<(@WndBase)>\n\u0009+var onMouseDoubleClick: func<(@WndBase)>\nend class\n\n+class Combo(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _comboClear] clear()\n\u0009end func\n\n\u0009+func [d0001.knd, _comboAdd] add(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _comboIns] ins(idx: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _comboDel] del(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _comboLen] len(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _comboSetSel] setSel(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _comboGetSel] getSel(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _comboSetText] setText(idx: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _comboGetText] getText(idx: int): []char\n\u0009end func\nend class\n\n+class Label(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetText] getText(): []char\n\u0009end func\nend class\n\n+class Group(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetText] getText(): []char\n\u0009end func\nend class\n\n+class Calendar(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Progress(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Rebar(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Status(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Toolbar(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Trackbar(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class LabelLink(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+enum ListViewStyle\n\u0009large\n\u0009report\n\u0009small\n\u0009list_\n\u0009chk\n\u0009hideHeader :: 0x4000\nend enum\n\n+class ListView(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewClear] clear()\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewAdd] add(text: []char, img: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewIns] ins(idx: int, text: []char, img: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewDel] del(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewLen] len(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewAddColumn] addColumn(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewInsColumn] insColumn(column: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewDelColumn] delColumn(column: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewLenColumn] lenColumn(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewClearAll] clearAll()\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewSetText] setText(idx: int, column: int, text: []char, img: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewGetText] getText(img: &int, idx: int, column: int): []char\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewAdjustWidth] adjustWidth()\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewSetSel] setSel(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewGetSel] getSel(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewSetSelMulti] setSelMulti(idx: int, value: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewGetSelMulti] getSelMulti(idx: int): bool\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewStyle] style(listViewStyle: @ListViewStyle)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewDraggable] draggable(enabled: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewSetChk] setChk(idx: int, value: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewGetChk] getChk(idx: int): bool\n\u0009end func\n\n\u0009+var onSel: func<(@WndBase)>\n\u0009+var onMouseDoubleClick: func<(@WndBase)>\n\u0009+var onMouseClick: func<(@WndBase)>\n\u0009+var onMoveNode: func<(@WndBase)>\n\u0009var draggable_: int\n\u0009var draggingImage: int\nend class\n\n+class Pager(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Tab(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _tabAdd] add(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _tabLen] len(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _tabSetSel] setSel(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _tabGetSel] getSel(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _tabGetPosInner] getPosInner(x: &int, y: &int, width: &int, height: &int)\n\u0009end func\n\n\u0009+var onSel: func<(@WndBase)>\nend class\n\n+class Tree(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _treeClear] clear()\n\u0009end func\n\n\u0009+func [d0001.knd, _treeExpand] expand(expand_: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _treeRoot, _make_instance] root(me2: @TreeNode): @TreeNode\n\u0009end func\n\n\u0009+func [d0001.knd, _treeDraggable] draggable(enabled: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _treeAllowDraggingToRoot] allowDraggingToRoot(enabled: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _treeSetSel] setSel(node: @TreeNode)\n\u0009end func\n\n\u0009+func [d0001.knd, _treeGetSel, _make_instance] getSel(me2: @TreeNode): @TreeNode\n\u0009end func\n\n\u0009var draggable_: int\n\u0009var draggingItem: int\n\u0009+var onSel: func<(@WndBase)>\n\u0009+var onMoveNode: func<(@WndBase)>\nend class\n\n+class TreeNode()\n\u0009+*func cmp(t: @TreeNode): int\n\u0009\u0009ret me.item - t.item\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeAddChild, _make_instance] addChild(me2: @TreeNode, name: []char): @TreeNode\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeInsChild, _make_instance] insChild(me2: @TreeNode, node: @TreeNode, name: []char): @TreeNode\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeDelChild] delChild(node: @TreeNode)\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeFirstChild, _make_instance] firstChild(me2: @TreeNode): @TreeNode\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeGetName] getName(): []char\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeNext, _make_instance] next(me2: @TreeNode): @TreeNode\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodePrev, _make_instance] prev(me2: @TreeNode): @TreeNode\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeParent, _make_instance] parent(me2: @TreeNode): @TreeNode\n\u0009end func\n\n\u0009var wndHandle: int\n\u0009+var item: int\nend class\n\nclass SplitBase(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class SplitX(@SplitBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class SplitY(@SplitBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\nclass ScrollBase(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _scrollSetState] setState(min: int, max: int, page: int, pos: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _scrollSetScrollPos] setScrollPos(pos: int)\n\u0009end func\nend class\n\n+class ScrollX(@ScrollBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class ScrollY(@ScrollBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+enum MsgBoxIcon\n\u0009none\n\u0009err :: 0x10\n\u0009question :: 0x20\n\u0009warn :: 0x30\n\u0009info :: 0x40\nend enum\n\n+enum MsgBoxBtn\n\u0009ok\n\u0009okCancel\n\u0009abortRetryIgnore\n\u0009yesNoCancel\n\u0009yesNo\n\u0009retryCancel\n\u0009cancelAgainContinue\nend enum\n\n+enum MsgBoxResult\n\u0009ok :: 1\n\u0009cancel\n\u0009abort\n\u0009retry\n\u0009ignore\n\u0009yes\n\u0009no\n\u0009again :: 10\n\u0009continue\nend enum\n\n+func [d0001.knd, _setOnKeyPress] setOnKeyPress(onKeyPressFunc: func<(@Key, @ShiftCtrl): bool>)\nend func\n\n+func [d0001.knd, _getOnKeyPress] getOnKeyPress(): func<(@Key, @ShiftCtrl): bool>\nend func\n\n+func [d0001.knd, _msgBox] msgBox(parent: @Wnd, text: []char, title: []char, icon: @MsgBoxIcon, btn: @MsgBoxBtn): @MsgBoxResult\nend func\n\n+func [d0001.knd, _openFileDialog] openFileDialog(parent: @Wnd, filter: [][]char, defaultFilter: int): []char\nend func\n\n+func [d0001.knd, _saveFileDialog] saveFileDialog(parent: @Wnd, filter: [][]char, defaultFilter: int, defaultExt: []char): []char\nend func\n\n+func [d0001.knd, _fileDialogDir] fileDialogDir(defaultDir: []char)\nend func\n\n+func [d0001.knd, _colorDialog] colorDialog(parent: @Wnd, defaultColor: int): int\nend func\n\n+func [d0001.knd, _setClipboardStr] setClipboardStr(str: []char)\nend func\n\n+func [d0001.knd, _getClipboardStr] getClipboardStr(): []char\nend func\n\n+func [d0001.knd, _getCaretPos] getCaretPos(x: &int, y: &int)\nend func\n\n+func [d0001.knd, _screenSize] screenSize(width: &int, height: &int)\nend func\n\n+func [d0001.knd, _makeWnd, _make_instance] makeWnd(me2: @Wnd, parent: @Wnd, style: @WndStyle, width: int, height: int, text: []char): @Wnd\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeDraw, _make_instance] makeDraw(me2: @Draw, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, equalMagnification: bool): @Draw\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeDrawReduced, _make_instance] makeDrawReduced(me2: @Draw, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, equalMagnification: bool, split: int): @Draw\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeDrawEditable, _make_instance] makeDrawEditable(me2: @DrawEditable, parent: @WndBase, x: int, y: int, width: int, height: int): @DrawEditable\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeBtn, _make_instance] makeBtn(me2: @Btn, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, text: []char): @Btn\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeChk, _make_instance] makeChk(me2: @Chk, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, text: []char): @Chk\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeRadio, _make_instance] makeRadio(me2: @Radio, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, text: []char): @Radio\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeEdit, _make_instance] makeEdit(me2: @Edit, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Edit\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [__mki, __raw, wnd_makeEditMulti] makeEditMulti(me2: @EditMulti, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @EditMulti\nend func\n\n+func [d0001.knd, _makeList, _make_instance] makeList(me2: @List, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @List\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeCombo, _make_instance] makeCombo(me2: @Combo, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Combo\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeLabel, _make_instance] makeLabel(me2: @Label, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, text: []char): @Label\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeGroup, _make_instance] makeGroup(me2: @Group, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, text: []char): @Group\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeCalendar, _make_instance] makeCalendar(me2: @Calendar, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Calendar\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeProgress, _make_instance] makeProgress(me2: @Progress, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Progress\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeRebar, _make_instance] makeRebar(me2: @Rebar, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Rebar\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeStatus, _make_instance] makeStatus(me2: @Status, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Status\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeToolbar, _make_instance] makeToolbar(me2: @Toolbar, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Toolbar\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeTrackbar, _make_instance] makeTrackbar(me2: @Trackbar, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Trackbar\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeLabelLink, _make_instance] makeLabelLink(me2: @LabelLink, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @LabelLink\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeListView, _make_instance] makeListView(me2: @ListView, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, multiSel: bool, smallImgs: [][]char, largeImgs: [][]char): @ListView\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makePager, _make_instance] makePager(me2: @Pager, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Pager\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeTab, _make_instance] makeTab(me2: @Tab, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Tab\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeTree, _make_instance] makeTree(me2: @Tree, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Tree\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeSplitX, _make_instance] makeSplitX(me2: @SplitX, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @SplitX\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeSplitY, _make_instance] makeSplitY(me2: @SplitY, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @SplitY\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeScrollX, _make_instance] makeScrollX(me2: @ScrollX, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @ScrollX\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeScrollY, _make_instance] makeScrollY(me2: @ScrollY, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @ScrollY\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+class MenuBase()\n\u0009*func [d0001.knd, _menuDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _menuAdd] add(id: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _menuAddLine] addLine()\n\u0009end func\n\n\u0009+func [d0001.knd, _menuAddPopup] addPopup(text: []char, popup: @Popup)\n\u0009\u0009do me.children.add(popup)\n\u0009end func\n\n\u0009+func [d0001.knd, _menuIns] ins(targetId: int, id: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _menuInsPopup] insPopup(target: @Popup, text: []char, popup: @Popup)\n\u0009\u0009do me.children.add(popup)\n\u0009end func\n\n\u0009+func [d0001.knd, _menuDel] del(id: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _menuDelPopup] delPopup(popup: @Popup)\n\u0009end func\n\n\u0009var handle: int\n\u0009var children: list<kuin@Class>\nend class\n\n+class Menu(@MenuBase)\n\u0009*func [d0001.knd, _menuDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Popup(@MenuBase)\n\u0009*func [d0001.knd, _menuDtor, _force] _dtor()\n\u0009end func\nend class\n\n+func [d0001.knd, _makeMenu, _make_instance] makeMenu(me2: @Menu): @Menu\nend func\n\n+func [d0001.knd, _makePopup, _make_instance] makePopup(me2: @Popup): @Popup\nend func\n\n+class TabOrder()\n\u0009*func [_force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _tabOrderChk] chk(key: @Key, shiftCtrl: @ShiftCtrl): bool\n\u0009end func\n\n\u0009var ctrls: []@WndBase\nend class\n\n+func [d0001.knd, _makeTabOrder, _make_instance] makeTabOrder(me2: @TabOrder, ctrls: []@WndBase): @TabOrder\nend func\n\n+func [d0001.knd, _key] key(key_: @Key): bool\nend func\n\n+enum Key\n\u0009mouseL :: 0x01\n\u0009mouseR\n\u0009mouseM :: 0x04\n\u0009bs :: 0x08\n\u0009tab\n\u0009enter :: 0x0D\n\u0009shift :: 0x10\n\u0009ctrl\n\u0009alt\n\u0009pause\n\u0009esc :: 0x1B\n\u0009space :: 0x20\n\u0009pageUp\n\u0009pageDown\n\u0009end_\n\u0009home\n\u0009left\n\u0009up\n\u0009right\n\u0009down\n\u0009ins :: 0x2D\n\u0009del\n\u0009_0 :: 0x30\n\u0009_1\n\u0009_2\n\u0009_3\n\u0009_4\n\u0009_5\n\u0009_6\n\u0009_7\n\u0009_8\n\u0009_9\n\u0009a :: 0x41\n\u0009b\n\u0009c\n\u0009d\n\u0009e\n\u0009f\n\u0009g\n\u0009h\n\u0009i\n\u0009j\n\u0009k\n\u0009l\n\u0009m\n\u0009n\n\u0009o\n\u0009p\n\u0009q\n\u0009r\n\u0009s\n\u0009t\n\u0009u\n\u0009v\n\u0009w\n\u0009x\n\u0009y\n\u0009z\n\u0009f1 :: 0x70\n\u0009f2\n\u0009f3\n\u0009f4\n\u0009f5\n\u0009f6\n\u0009f7\n\u0009f8\n\u0009f9\n\u0009f10\n\u0009f11\n\u0009f12\n\u0009plus :: 0xBB\n\u0009comma\n\u0009minus\n\u0009period\nend enum\n\n+enum MouseImg\n\u0009arrow :: 32512\n\u0009ibeam\n\u0009wait\n\u0009cross\n\u0009upArrow\n\u0009resizeLTRB :: 32642\n\u0009resizeRTLB\n\u0009resizeH\n\u0009resizeV\n\u0009move\n\u0009no :: 32648\n\u0009link\n\u0009arrowWait\n\u0009arrowHelp\nend enum\n";
else if(p==="res/web/output.kn")
return "const classTableItemSize: int :: 2\n\nvar funcs: queue<\\ast@AstFunc>\nvar classes: queue<\\ast@AstClass>\n\nvar uniqueId: []char\nvar codes: list<[]char>\nvar tmpVars: list<@TmpVar>\nvar globalVars: list<\\ast@AstArg>\nvar localVars: list<\\ast@AstArg>\n\n+class WebInfo(\\ast@HasType)\n\u0009+var id: []char\n\u0009+var breakSkipLabel: []char\n\u0009+var alreadyWritten: bool\nend class\n\nclass TmpVar()\n\u0009+var identifier: []char\n\u0009+var type: \\ast@AstType\nend class\n\n+func output(entry: \\ast@AstFunc, resFiles: list<[]char>): bool\n\u0009do @funcs :: #queue<\\ast@AstFunc>\n\u0009do @funcs.add(entry)\n\u0009do @classes :: #queue<\\ast@AstClass>\n\u0009\n\u0009do @uniqueId :: \"a\"\n\u0009do @codes :: #list<[]char>\n\u0009do @tmpVars :: #list<@TmpVar>\n\u0009do @globalVars :: #list<\\ast@AstArg>\n\u0009do @localVars :: #list<\\ast@AstArg>\n\u0009\n\u0009while(^@funcs > 0 | ^@classes > 0)\n\u0009\u0009while(^@funcs > 0)\n\u0009\u0009\u0009var func_: \\ast@AstFunc :: @funcs.get()\n\u0009\u0009\u0009do @buildFunc(func_)\n\u0009\u0009end while\n\u0009\u0009while(^@classes > 0)\n\u0009\u0009\u0009var class_: \\ast@AstClass :: @classes.get()\n\u0009\u0009\u0009do @buildClass(class_)\n\u0009\u0009end while\n\u0009end while\n\u0009\n\u0009do @write(resFiles)\n\u0009\n\u0009ret true\nend func\n\nfunc buildFunc(ast: \\ast@AstFunc)\n\u0009var info: @WebInfo :: @getInfo(ast)\n\u0009if(info.alreadyWritten)\n\u0009\u0009ret\n\u0009end if\n\u0009do info.alreadyWritten :: true\n\u0009\n\u0009var arg: []char :: \"\"\n\u0009block\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstArg :: items.get()\n\u0009\u0009\u0009var info2: @WebInfo :: @getInfo(item)\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do arg :~ \",\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do arg :~ \"\\{info2.id}\"\n\u0009\u0009\u0009if(item.name <>& null)\n\u0009\u0009\u0009\u0009do arg :~ \" /*\\{item.name}*/\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009\n\u0009if(ast.name <>& null)\n\u0009\u0009do @codes.add(\"// \\{ast.name}\\n\")\n\u0009end if\n\u0009do @codes.add(\"function \\{info.id}(\\{arg}){\\n\")\n\u0009\n\u0009if(ast.funcOption.and(%raw) = %raw)\n\u0009\u0009if(^ast.funcAttr = 1)\n\u0009\u0009\u0009do ast.funcAttr.head()\n\u0009\u0009\u0009var hasMembers: bool :: false\n\u0009\u0009\u0009if(^ast.args > 0)\n\u0009\u0009\u0009\u0009do ast.args.head()\n\u0009\u0009\u0009\u0009var arg2: \\ast@AstArg :: ast.args.get()\n\u0009\u0009\u0009\u0009if(arg2.type.refItem <>& null & arg2.type.refItem.typeId = %class_)\n\u0009\u0009\u0009\u0009\u0009var members: list<\\ast@AstClassItem> :: (arg2.type.refItem $ \\ast@AstClass).items\n\u0009\u0009\u0009\u0009\u0009do \\web\\raw_funcs@write(@codes, ast.funcAttr.get(), ast.args, members)\n\u0009\u0009\u0009\u0009\u0009do hasMembers :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!hasMembers)\n\u0009\u0009\u0009\u0009do \\web\\raw_funcs@write(@codes, ast.funcAttr.get(), ast.args, null)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009end if\n\u0009else\n\u0009\u0009do @codes.tail()\n\u0009\u0009var localVarPos: int :: @codes.idx()\n\u0009\u0009\n\u0009\u0009do @buildStats(ast.stats)\n\u0009\u0009\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\n\u0009\u0009do @codes.head()\n\u0009\u0009do @codes.moveOffset(localVarPos)\n\u0009\u0009do @codes.next()\n\u0009\u0009do @localVars.head()\n\u0009\u0009while(!@localVars.term())\n\u0009\u0009\u0009var localVar: \\ast@AstArg :: @localVars.get()\n\u0009\u0009\u0009var info2: @WebInfo :: @getInfo(localVar)\n\u0009\u0009\u0009if(localVar.name =& null)\n\u0009\u0009\u0009\u0009do @codes.ins(\"let \\{info2.id}=\\{@getDefaultValue(localVar.type)};\\n\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.ins(\"let \\{info2.id}=\\{@getDefaultValue(localVar.type)}; // \\{localVar.name}\\n\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @localVars.del()\n\u0009\u0009end while\n\u0009\u0009do @tmpVars.head()\n\u0009\u0009while(!@tmpVars.term())\n\u0009\u0009\u0009var tmpVar: @TmpVar :: @tmpVars.get()\n\u0009\u0009\u0009do @codes.ins(\"let \\{tmpVar.identifier}=\\{@getDefaultValue(tmpVar.type)};\\n\")\n\u0009\u0009\u0009do @tmpVars.del()\n\u0009\u0009end while\n\u0009end if\nend func\n\nfunc buildClass(ast: \\ast@AstClass)\n\u0009var parentId: []char :: null\n\u0009if(ast.refItem <>& null)\n\u0009\u0009do parentId :: @refClass(ast.refItem $ \\ast@AstClass)\n\u0009end if\n\u0009if(parentId =& null)\n\u0009\u0009do parentId :: \"Object\"\n\u0009end if\n\u0009var info: @WebInfo :: @getInfo(ast)\n\u0009if(ast.name <>& null)\n\u0009\u0009do @codes.add(\"// \\{ast.name}\\n\")\n\u0009end if\n\u0009block\n\u0009\u0009var ctor: \\ast@AstFunc :: findFunc(ast, \"ctor\")\n\u0009\u0009do @codes.add(\"function \\{info.id}(){\\n\")\n\u0009\u0009do @codes.add(\"\\{parentId}.call(this);\\n\")\n\u0009\u0009if(ctor <>& null)\n\u0009\u0009\u0009var ctorInfo: @WebInfo :: @getInfo(ctor)\n\u0009\u0009\u0009do @codes.add(\"\\{ctorInfo.id}(this);\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009end block\n\u0009do @codes.add(\"\\{info.id}.prototype = Object.create(\\{parentId}.prototype);\\n\")\n\u0009block\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item.def.typeId = %func_)\n\u0009\u0009\u0009\u0009do @funcs.add(item.def $ \\ast@AstFunc)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009; TODO: Destructor.\n\u0009\n\u0009func findFunc(ast: \\ast@AstClass, name: []char): \\ast@AstFunc\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item.def.typeId = %func_ & item.def.name = name)\n\u0009\u0009\u0009\u0009ret item.def $ \\ast@AstFunc\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009ret null\n\u0009end func\nend func\n\nfunc buildStats(stats: list<\\ast@AstStat>)\n\u0009do stats.head()\n\u0009while(!stats.term())\n\u0009\u0009var stat: \\ast@AstStat :: stats.get()\n\u0009\u0009switch(stat.typeId)\n\u0009\u0009case %statIf\n\u0009\u0009\u0009do @buildIf(stat $ \\ast@AstStatIf)\n\u0009\u0009case %statSwitch\n\u0009\u0009\u0009do @buildSwitch(stat $ \\ast@AstStatSwitch)\n\u0009\u0009case %statWhile\n\u0009\u0009\u0009do @buildWhile(stat $ \\ast@AstStatWhile)\n\u0009\u0009case %statFor\n\u0009\u0009\u0009do @buildFor(stat $ \\ast@AstStatFor)\n\u0009\u0009case %statTry\n\u0009\u0009\u0009do @buildTry(stat $ \\ast@AstStatTry)\n\u0009\u0009case %statThrow\n\u0009\u0009\u0009do @buildThrow(stat $ \\ast@AstStatThrow)\n\u0009\u0009case %statBlock\n\u0009\u0009\u0009do @buildBlock(stat $ \\ast@AstStatBlock)\n\u0009\u0009case %statRet\n\u0009\u0009\u0009do @buildRet(stat $ \\ast@AstStatRet)\n\u0009\u0009case %statDo\n\u0009\u0009\u0009do @buildDo(stat $ \\ast@AstStatDo)\n\u0009\u0009case %statBreak\n\u0009\u0009\u0009do @buildBreak(stat $ \\ast@AstStat)\n\u0009\u0009case %statSkip\n\u0009\u0009\u0009do @buildSkip(stat $ \\ast@AstStat)\n\u0009\u0009case %statAssert\n\u0009\u0009\u0009do @buildAssert(stat $ \\ast@AstStatAssert)\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009do stats.next()\n\u0009end while\nend func\n\nfunc buildIf(ast: \\ast@AstStatIf)\n\u0009var infoMe: @WebInfo :: @getInfo(ast)\n\u0009if(ast.cond =& null)\n\u0009\u0009; Optimized code.\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:{\\n\")\n\u0009\u0009end if\n\u0009\u0009do @buildBlock(ast.statBlock)\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009end if\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009end if\n\u0009do @codes.add(\"if(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\"){\\n\")\n\u0009do @buildBlock(ast.statBlock)\n\u0009do @codes.add(\"}\\n\")\n\u0009block\n\u0009\u0009var items: list<\\ast@AstStatElIf> :: ast.elIfs\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatElIf :: items.get()\n\u0009\u0009\u0009do @codes.add(\"else if(\")\n\u0009\u0009\u0009do @buildExpr(item.cond)\n\u0009\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009\u0009do @buildBlock(item.statBlock)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009if(ast.elseStatBlock <>& null)\n\u0009\u0009do @codes.add(\"else{\\n\")\n\u0009\u0009do @buildBlock(ast.elseStatBlock)\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009end if\nend func\n\nfunc buildSwitch(ast: \\ast@AstStatSwitch)\n\u0009var infoMe: @WebInfo :: @getInfo(ast)\n\u0009var info: @WebInfo :: @getInfo(ast.blockVar)\n\u0009if(!info.alreadyWritten)\n\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009do @localVars.add(ast.blockVar)\n\u0009end if\n\u0009var useSwitch: bool :: false\n\u0009if chk(\\ast@isInt(ast.cond.type) | \\ast@isChar(ast.cond.type) | \\ast@isEnum(ast.cond.type) | ast.cond.type.typeId = %typeBit)\n\u0009\u0009do useSwitch :: true\n\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009if(exprs.expr0.typeId.and(%exprValue) <> %exprValue | exprs.expr1 <>& null)\n\u0009\u0009\u0009\u0009\u0009do useSwitch :: false\n\u0009\u0009\u0009\u0009\u0009break chk\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end if\n\u0009if(useSwitch)\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"switch(\")\n\u0009\u0009do @buildExpr(ast.cond)\n\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009block\n\u0009\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009\u0009assert exprs.expr1 =& null\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"case \")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\":\\n\")\n\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @buildBlock(item.statBlock)\n\u0009\u0009\u0009\u0009do @codes.add(\"break;\\n\")\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009if(ast.defaultStatBlock <>& null)\n\u0009\u0009\u0009do @codes.add(\"default:\\n\")\n\u0009\u0009\u0009do @buildBlock(ast.defaultStatBlock)\n\u0009\u0009\u0009do @codes.add(\"break;\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009else\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:{\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"\\{info.id}=\")\n\u0009\u0009do @buildExpr(ast.cond)\n\u0009\u0009do @codes.add(\";\\n\")\n\u0009\u0009block\n\u0009\u0009\u0009var first: bool :: true\n\u0009\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"if(\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"else if(\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009var first2: bool :: true\n\u0009\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009\u0009if(first2)\n\u0009\u0009\u0009\u0009\u0009\u0009do first2 :: false\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"||\")\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(exprs.expr1 =& null)\n\u0009\u0009\u0009\u0009\u0009\u0009if(\\ast@isStr(ast.cond.type))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"\\{info.id}.S===(\")\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009\u0009\u0009\u0009\u0009elif(\\ast@isRef(ast.cond.type))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"cmp_(\\{info.id},(\")\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"))==0\")\n\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"\\{info.id}===(\")\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\")<=\\{info.id}&&\\{info.id}<=(\")\n\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr1)\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009\u0009\u0009do @buildBlock(item.statBlock)\n\u0009\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009if(ast.defaultStatBlock <>& null)\n\u0009\u0009\u0009do @codes.add(\"else{\")\n\u0009\u0009\u0009do @buildBlock(ast.defaultStatBlock)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009end if\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009end if\n\u0009end if\nend func\n\nfunc buildWhile(ast: \\ast@AstStatWhile)\n\u0009var infoMe: @WebInfo :: @getInfo(ast)\n\u0009if(ast.cond =& null)\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"for(;;){\\n\")\n\u0009\u0009do @buildStats(ast.stats)\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009ret\n\u0009end if\n\u0009if(ast.skip_)\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"do{\\n\")\n\u0009\u0009do @buildStats(ast.stats)\n\u0009\u0009do @codes.add(\"}while(\")\n\u0009\u0009do @buildExpr(ast.cond)\n\u0009\u0009do @codes.add(\");\\n\")\n\u0009\u0009ret\n\u0009end if\n\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009end if\n\u0009do @codes.add(\"while(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\"){\\n\")\n\u0009do @buildStats(ast.stats)\n\u0009do @codes.add(\"}\\n\")\nend func\n\nfunc buildFor(ast: \\ast@AstStatFor)\n\u0009var infoMe: @WebInfo :: @getInfo(ast)\n\u0009var info: @WebInfo :: @getInfo(ast.blockVar)\n\u0009if(!info.alreadyWritten)\n\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009do @localVars.add(ast.blockVar)\n\u0009end if\n\u0009var endId: []char :: @addTmpVar(ast.cond.type)\n\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009end if\n\u0009do @codes.add(\"for(\\{info.id}=(\")\n\u0009do @buildExpr(ast.start)\n\u0009do @codes.add(\"),\\{endId}=(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\");\\{info.id}\")\n\u0009assert ast.step.typeId = %exprValuePrim & \\ast@isInt(ast.cond.type)\n\u0009var step: int :: (ast.step $ \\ast@AstExprValuePrim).value $ int\n\u0009if(step > 0)\n\u0009\u0009do @codes.add(\"<=\")\n\u0009else\n\u0009\u0009do @codes.add(\">=\")\n\u0009end if\n\u0009do @codes.add(\"\\{endId};\\{info.id}\")\n\u0009if(step > 0)\n\u0009\u0009do @codes.add(\"+=(\")\n\u0009else\n\u0009\u0009do @codes.add(\"-=(\")\n\u0009end if\n\u0009do @buildExpr(ast.step)\n\u0009do @codes.add(\")){\\n\")\n\u0009do @buildStats(ast.stats)\n\u0009do @codes.add(\"}\\n\")\nend func\n\nfunc buildTry(ast: \\ast@AstStatTry)\n\u0009var infoMe: @WebInfo :: @getInfo(ast)\n\u0009var info: @WebInfo :: @getInfo(ast.blockVar)\n\u0009if(!info.alreadyWritten)\n\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009do @localVars.add(ast.blockVar)\n\u0009end if\n\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009end if\n\u0009do @codes.add(\"try{\\n\")\n\u0009do @buildBlock(ast.statBlock)\n\u0009do @codes.add(\"}catch(\\{info.id}){\\n\")\n\u0009block\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstStatCatch> :: ast.catches\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatCatch :: items.get()\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009do @codes.add(\"if(\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"else if(\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009var first2: bool :: true\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009if(first2)\n\u0009\u0009\u0009\u0009\u0009do first2 :: false\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"||\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(exprs.expr1 =& null)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"\\{info.id}===(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")<=\\{info.id}&&\\{info.id}<=(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr1)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009\u0009do @buildBlock(item.statBlock)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009if(first)\n\u0009\u0009\u0009do @codes.add(\"{\\n\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"else{\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"throw \\{info.id};\\n}\\n\")\n\u0009end block\n\u0009do @codes.add(\"}\\n\")\n\u0009if(ast.finallyStatBlock <>& null)\n\u0009\u0009do @codes.add(\"finally{\\n\")\n\u0009\u0009do @buildBlock(ast.finallyStatBlock)\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009end if\nend func\n\nfunc buildThrow(ast: \\ast@AstStatThrow)\n\u0009do @codes.add(\"throw \")\n\u0009do @buildExpr(ast.code)\n\u0009do @codes.add(\";\\n\")\nend func\n\nfunc buildBlock(ast: \\ast@AstStatBlock)\n\u0009var infoMe: @WebInfo :: @getInfo(ast)\n\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:{\\n\")\n\u0009end if\n\u0009do @buildStats(ast.stats)\n\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009end if\nend func\n\nfunc buildRet(ast: \\ast@AstStatRet)\n\u0009if(ast.value =& null)\n\u0009\u0009do @codes.add(\"return;\\n\")\n\u0009else\n\u0009\u0009do @codes.add(\"return \")\n\u0009\u0009do @buildExpr(ast.value)\n\u0009\u0009do @codes.add(\";\\n\")\n\u0009end if\nend func\n\nfunc buildDo(ast: \\ast@AstStatDo)\n\u0009do @buildExpr(ast.expr)\n\u0009do @codes.add(\";\\n\")\nend func\n\nfunc buildBreak(ast: \\ast@AstStat)\n\u0009assert ast.refItem.typeId.and(%statBreakable) = %statBreakable\n\u0009var info: @WebInfo :: @getInfo(ast.refItem)\n\u0009do @codes.add(\"break \\{info.breakSkipLabel};\\n\")\nend func\n\nfunc buildSkip(ast: \\ast@AstStat)\n\u0009assert ast.refItem.typeId.and(%statSkipable) = %statSkipable\n\u0009var info: @WebInfo :: @getInfo(ast.refItem)\n\u0009do @codes.add(\"continue \\{info.breakSkipLabel};\\n\")\nend func\n\nfunc buildAssert(ast: \\ast@AstStatAssert)\n\u0009do @codes.add(\"if(!(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\")){throw \\{excpt@dbgAssertFailed $ bit32};}\\n\")\nend func\n\nfunc buildExpr(ast: \\ast@AstExpr)\n\u0009switch(ast.typeId)\n\u0009case %expr1\n\u0009\u0009do @buildExpr1(ast $ \\ast@AstExpr1)\n\u0009case %expr2\n\u0009\u0009do @buildExpr2(ast $ \\ast@AstExpr2)\n\u0009case %expr3\n\u0009\u0009do @buildExpr3(ast $ \\ast@AstExpr3)\n\u0009case %exprNew\n\u0009\u0009do @buildExprNew(ast $ \\ast@AstExprNew)\n\u0009case %exprNewArray\n\u0009\u0009do @buildExprNewArray(ast $ \\ast@AstExprNewArray)\n\u0009case %exprAs\n\u0009\u0009do @buildExprAs(ast $ \\ast@AstExprAs)\n\u0009case %exprToBin\n\u0009\u0009do @buildExprToBin(ast $ \\ast@AstExprToBin)\n\u0009case %exprFromBin\n\u0009\u0009do @buildExprFromBin(ast $ \\ast@AstExprFromBin)\n\u0009case %exprCall\n\u0009\u0009do @buildExprCall(ast $ \\ast@AstExprCall)\n\u0009case %exprArray\n\u0009\u0009do @buildExprArray(ast $ \\ast@AstExprArray)\n\u0009case %exprDot\n\u0009\u0009do @buildExprDot(ast $ \\ast@AstExprDot)\n\u0009case %exprValue\n\u0009\u0009do @buildExprValue(ast $ \\ast@AstExprValue)\n\u0009case %exprValuePrim\n\u0009\u0009do @buildExprValuePrim(ast $ \\ast@AstExprValuePrim)\n\u0009case %exprValueStr\n\u0009\u0009do @buildExprValueStr(ast $ \\ast@AstExprValueStr)\n\u0009case %exprValueFloat\n\u0009\u0009do @buildExprValueFloat(ast $ \\ast@AstExprValueFloat)\n\u0009case %exprValueArray\n\u0009\u0009do @buildExprValueArray(ast $ \\ast@AstExprValueArray)\n\u0009case %exprRef\n\u0009\u0009do @buildExprRef(ast $ \\ast@AstExpr)\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExpr1(ast: \\ast@AstExpr1)\n\u0009assert ast.varKind <> %unknown\n\u0009switch(ast.kind)\n\u0009case %plus\n\u0009\u0009do @buildExpr(ast.child)\n\u0009case %minus\n\u0009\u0009do @codes.add(\"-(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %not\n\u0009\u0009do @codes.add(\"!(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %copy\n\u0009\u0009var typeId: []char :: @makeTypeId(ast.child.type)\n\u0009\u0009do @codes.add(\"C_(\\{typeId},(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\"))\")\n\u0009case %len\n\u0009\u0009var type: \\ast@AstType :: ast.child.type\n\u0009\u0009if(type.typeId = %typeGen)\n\u0009\u0009\u0009switch((type $ \\ast@AstTypeGen).kind)\n\u0009\u0009\u0009case %list_\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009do @codes.add(\").L\")\n\u0009\u0009\u0009case %stack_\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009do @codes.add(\").length\")\n\u0009\u0009\u0009case %queue_\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009do @codes.add(\").length\")\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009elif(type.typeId = %typeDict)\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009do @codes.add(\").size\")\n\u0009\u0009else\n\u0009\u0009\u0009assert type.typeId = %typeArray\n\u0009\u0009\u0009if(\\ast@isChar((type $ \\ast@AstTypeArray).itemType))\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009do @codes.add(\").S.length\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009do @codes.add(\").length\")\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExpr2(ast: \\ast@AstExpr2)\n\u0009assert ast.varKind <> %unknown\n\u0009var type: \\ast@AstType :: ast.children0.type\n\u0009switch(ast.kind)\n\u0009case %assign\n\u0009\u0009if(ast.children0.typeId = %exprArray & \\ast@isChar((ast.children0 $ \\ast@AstExprArray).type))\n\u0009\u0009\u0009var ast2: \\ast@AstExprArray :: ast.children0 $ \\ast@AstExprArray\n\u0009\u0009\u0009var tmpIdx: []char :: @addTmpVar(ast2.idx.type)\n\u0009\u0009\u0009var tmpChar: []char :: @addTmpVar(ast2.type)\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast2.var_)\n\u0009\u0009\u0009do @codes.add(\").S=(\\{tmpIdx}=(\")\n\u0009\u0009\u0009do @buildExpr(ast2.idx)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast2.var_)\n\u0009\u0009\u0009do @codes.add(\").S.slice(0,\\{tmpIdx})+String.fromCharCode(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")+(\")\n\u0009\u0009\u0009do @buildExpr(ast2.var_)\n\u0009\u0009\u0009do @codes.add(\").S.slice(\\{tmpIdx}+1))\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")=(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %or\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")||(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %and\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")&&(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %lt\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S<(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009elif(\\ast@isRef(type))\n\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))<0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")<(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %gt\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S>(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009elif(\\ast@isRef(type))\n\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))>0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")>(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %le\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S<=(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009elif(\\ast@isRef(type))\n\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))<=0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")<=(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %ge\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S>=(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009elif(\\ast@isRef(type))\n\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))>=0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")>=(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %eq\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S===(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009elif(\\ast@isRef(type))\n\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))==0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")===(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %nEq\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S!==(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009elif(\\ast@isRef(type))\n\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))!=0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")!==(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %eqRef\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")===(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %nEqRef\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")!==(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %cat\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"{S:(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S+(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S}\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").concat(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %add\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")+(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %sub\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")-(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %mul\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")*(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %div\n\u0009\u0009if(!\\ast@isFloat(type))\n\u0009\u0009\u0009do @codes.add(\"~~(\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")/(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009if(!\\ast@isFloat(type))\n\u0009\u0009\u0009do @codes.add(\"))\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %mod\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")%(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %pow\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")**(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %swap\n\u0009\u0009var tmpVar: []char :: @addTmpVar(type)\n\u0009\u0009do @codes.add(\"\\{tmpVar}=(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")=(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")=(\\{tmpVar})\")\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExpr3(ast: \\ast@AstExpr3)\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"(\")\n\u0009do @buildExpr(ast.children0)\n\u0009do @codes.add(\")?(\")\n\u0009do @buildExpr(ast.children1)\n\u0009do @codes.add(\"):(\")\n\u0009do @buildExpr(ast.children2)\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprNew(ast: \\ast@AstExprNew)\n\u0009assert ast.varKind <> %unknown\n\u0009if(\\ast@isClass(ast.itemType))\n\u0009\u0009var class_: \\ast@AstClass :: ast.itemType.refItem $ \\ast@AstClass\n\u0009\u0009var id: []char :: @refClass(class_)\n\u0009\u0009do @codes.add(\"new \\{id}()\")\n\u0009else\n\u0009\u0009if(ast.itemType.typeId = %typeGen)\n\u0009\u0009\u0009var gen: \\ast@AstTypeGen :: ast.itemType $ \\ast@AstTypeGen\n\u0009\u0009\u0009switch(gen.kind)\n\u0009\u0009\u0009case %list_\n\u0009\u0009\u0009\u0009do @codes.add(\"{L:0,H:null,T:null,P:null}\")\n\u0009\u0009\u0009case %stack_\n\u0009\u0009\u0009\u0009do @codes.add(\"[]\")\n\u0009\u0009\u0009case %queue_\n\u0009\u0009\u0009\u0009do @codes.add(\"[]\")\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009else\n\u0009\u0009\u0009assert ast.itemType.typeId = %typeDict\n\u0009\u0009\u0009do @codes.add(\"new Map()\")\n\u0009\u0009end if\n\u0009end if\nend func\n\nfunc buildExprNewArray(ast: \\ast@AstExprNewArray)\n\u0009assert ast.varKind <> %unknown\n\u0009block\n\u0009\u0009var items: list<\\ast@AstExpr> :: ast.idces\n\u0009\u0009do items.head()\n\u0009\u0009if(\\ast@isChar(ast.itemType))\n\u0009\u0009\u0009if(^items = 1)\n\u0009\u0009\u0009\u0009do @codes.add(\"{S:\\\"\\\\0\\\".repeat(\")\n\u0009\u0009\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009\u0009\u0009do @codes.add(\")}\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"(function A_(n){if(n.length===1)return{S:\\\"\\\\0\\\".repeat(\\{@getDefaultValue(ast.itemType)})}else{let a=new Array(n[0]),m=n.shift(),i;for(i=0;i<n[0];i++)a[i]=A_(m);return a}})([\")\n\u0009\u0009\u0009\u0009var first: bool :: true\n\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\",(\")\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @codes.add(\"])\")\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009if(^items = 1)\n\u0009\u0009\u0009\u0009do @codes.add(\"new Array(\")\n\u0009\u0009\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009\u0009\u0009do @codes.add(\").fill(\\{@getDefaultValue(ast.itemType)})\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"(function A_(n){if(n.length===1)return new Array(n[0]).fill(\\{@getDefaultValue(ast.itemType)})else{let a=new Array(n[0]),m=n.shift(),i;for(i=0;i<n[0];i++)a[i]=A_(m);return a}})([\")\n\u0009\u0009\u0009\u0009var first: bool :: true\n\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\",(\")\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @codes.add(\"])\")\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009end block\nend func\n\nfunc buildExprAs(ast: \\ast@AstExprAs)\n\u0009assert ast.varKind <> %unknown\n\u0009switch(ast.kind)\n\u0009case %as\n\u0009\u0009var t1: \\ast@AstType :: ast.child.type\n\u0009\u0009var t2: \\ast@AstType :: ast.childType\n\u0009\u0009if(\\ast@isClass(t1))\n\u0009\u0009\u0009assert \\ast@isClass(t2)\n\u0009\u0009\u0009do @refClass(t2.refItem $ \\ast@AstClass)\n\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009else\n\u0009\u0009\u0009if(t1.typeId = %typeBit | \\ast@isInt(t1) | \\ast@isChar(t1) | \\ast@isEnum(t1))\n\u0009\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2) | \\ast@isChar(t2) | \\ast@isEnum(t2) | \\ast@isFloat(t2))\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert \\ast@isBool(t2)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")!=0\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009elif(\\ast@isFloat(t1))\n\u0009\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2))\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"~~(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert \\ast@isFloat(t2)\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009assert \\ast@isBool(t1)\n\u0009\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2))\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")?1:0\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert \\ast@isBool(t2)\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009case %is\n\u0009\u0009do @refClass(ast.childType.refItem $ \\ast@AstClass)\n\u0009\u0009var info: @WebInfo :: @getInfo(ast.childType.refItem)\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")instanceof \\{info.id}\")\n\u0009case %nIs\n\u0009\u0009do @refClass(ast.childType.refItem $ \\ast@AstClass)\n\u0009\u0009var info: @WebInfo :: @getInfo(ast.childType.refItem)\n\u0009\u0009do @codes.add(\"!((\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")instanceof \\{info.id})\")\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExprToBin(ast: \\ast@AstExprToBin)\n\u0009; TODO:\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"toBin_(\")\n\u0009do @buildExpr(ast.child)\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprFromBin(ast: \\ast@AstExprFromBin)\n\u0009; TODO:\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"fromBin_((\")\n\u0009do @buildExpr(ast.child)\n\u0009do @codes.add(\"),(\")\n\u0009do @buildExpr(ast.offset)\n\u0009do @codes.add(\"))\")\nend func\n\nfunc buildExprCall(ast: \\ast@AstExprCall)\n\u0009assert ast.varKind <> %unknown\n\u0009var funcType: \\ast@AstTypeFunc :: ast.func_.type $ \\ast@AstTypeFunc\n\u0009var meTypeId: []char :: null\n\u0009if(funcType <>& null & funcType.funcOption.and(%any) = %any)\n\u0009\u0009var items: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009do meTypeId :: @makeTypeId(items.get().arg.type)\n\u0009end if\n\u0009var refNum: int :: 0\n\u0009block\n\u0009\u0009var items: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009if(items.get().refVar)\n\u0009\u0009\u0009\u0009do refNum :+ 1\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009var resultVar: []char :: null\n\u0009var refVar: [][]char :: null\n\u0009if(refNum > 0)\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009if(ast.type <>& null)\n\u0009\u0009\u0009do resultVar :: @addTmpVar(ast.type)\n\u0009\u0009\u0009do @codes.add(\"\\{resultVar}=\")\n\u0009\u0009end if\n\u0009\u0009do refVar :: #[refNum][]char\n\u0009end if\n\u0009do @codes.add(\"(\")\n\u0009do @buildExpr(ast.func_)\n\u0009do @codes.add(\")(\")\n\u0009block\n\u0009\u0009var idx: int :: 0\n\u0009\u0009var refCnt: int :: 0\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstExprCallArg :: items.get()\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\",(\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(meTypeId <>& null & idx = 1)\n\u0009\u0009\u0009\u0009do @codes.add(meTypeId)\n\u0009\u0009\u0009elif(item.refVar)\n\u0009\u0009\u0009\u0009do refVar[refCnt] :: @addTmpVar(item.arg.type)\n\u0009\u0009\u0009\u0009do @codes.add(\"\\{refVar[refCnt]}={$:(\")\n\u0009\u0009\u0009\u0009do @buildExpr(item.arg)\n\u0009\u0009\u0009\u0009do @codes.add(\")},\\{refVar[refCnt]}\")\n\u0009\u0009\u0009\u0009do refCnt :+ 1\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @buildExpr(item.arg)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do @codes.add(\")\")\n\u0009if(refNum > 0)\n\u0009\u0009block\n\u0009\u0009\u0009var idx: int :: 0\n\u0009\u0009\u0009var refCnt: int :: 0\n\u0009\u0009\u0009var items: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstExprCallArg :: items.get()\n\u0009\u0009\u0009\u0009if(meTypeId <>& null & idx = 1)\n\u0009\u0009\u0009\u0009\u0009; Do nothing.\n\u0009\u0009\u0009\u0009elif(item.refVar)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\",(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(item.arg)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")=\\{refVar[refCnt]}.$\")\n\u0009\u0009\u0009\u0009\u0009do refCnt :+ 1\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009if(ast.type <>& null)\n\u0009\u0009\u0009do @codes.add(\",\\{resultVar}\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\")\")\n\u0009end if\n\u0009\n\u0009block\n\u0009\u0009var type: \\ast@AstType :: ast.type\n\u0009\u0009if(type <>& null)\n\u0009\u0009\u0009if(\\ast@isClass(type))\n\u0009\u0009\u0009\u0009do @refClass(type.refItem $ \\ast@AstClass)\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009end block\nend func\n\nfunc buildExprArray(ast: \\ast@AstExprArray)\n\u0009assert ast.varKind <> %unknown\n\u0009if(\\ast@isChar(ast.type))\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.var_)\n\u0009\u0009do @codes.add(\").S.charCodeAt(\")\n\u0009\u0009do @buildExpr(ast.idx)\n\u0009\u0009do @codes.add(\")\")\n\u0009else\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.var_)\n\u0009\u0009do @codes.add(\")[\")\n\u0009\u0009do @buildExpr(ast.idx)\n\u0009\u0009do @codes.add(\"]\")\n\u0009end if\nend func\n\nfunc buildExprDot(ast: \\ast@AstExprDot)\n\u0009assert ast.varKind <> %unknown\n\u0009if(\\ast@isClass(ast.var_.type))\n\u0009\u0009var classItem: \\ast@AstClassItem :: ast.classItem\n\u0009\u0009assert classItem <>& null\n\u0009\u0009do @refClass(ast.var_.type.refItem $ \\ast@AstClass)\n\u0009\u0009var info: @WebInfo\n\u0009\u0009if(classItem.def.typeId = %var_)\n\u0009\u0009\u0009do info :: @getInfo((classItem.def $ \\ast@AstVar).arg)\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.var_)\n\u0009\u0009\u0009do @codes.add(\").\\{info.id}\")\n\u0009\u0009else\n\u0009\u0009\u0009assert classItem.def.typeId = %func_\n\u0009\u0009\u0009do info :: @getInfo(classItem.def)\n\u0009\u0009\u0009; \'ast.var_\' is calculated elsewhere.\n\u0009\u0009\u0009do @codes.add(\"\\{info.id}\")\n\u0009\u0009end if\n\u0009else\n\u0009\u0009assert ast.refItem.typeId = %exprRef\n\u0009\u0009do @buildExprRef(ast.refItem $ \\ast@AstExpr)\n\u0009end if\nend func\n\nfunc buildExprValue(ast: \\ast@AstExprValue)\n\u0009assert ast.type.typeId = %typeNull\n\u0009do @codes.add(\"null\")\nend func\n\nfunc buildExprValuePrim(ast: \\ast@AstExprValuePrim)\n\u0009var type: \\ast@AstType :: ast.type\n\u0009if(\\ast@isInt(type) | \\ast@isEnum(type))\n\u0009\u0009do @codes.add((ast.value $ int).toStr())\n\u0009elif(\\ast@isChar(type))\n\u0009\u0009do @codes.add((ast.value $ bit16).toStr())\n\u0009elif(\\ast@isBool(type))\n\u0009\u0009do @codes.add(ast.value = 0b64 ?(\"false\", \"true\"))\n\u0009elif(type.typeId = %typeBit)\n\u0009\u0009switch((type $ \\ast@AstTypeBit).size)\n\u0009\u0009case 1\n\u0009\u0009\u0009do @codes.add((ast.value $ bit8).toStr())\n\u0009\u0009case 2\n\u0009\u0009\u0009do @codes.add((ast.value $ bit16).toStr())\n\u0009\u0009case 4\n\u0009\u0009\u0009do @codes.add((ast.value $ bit32).toStr())\n\u0009\u0009case 8\n\u0009\u0009\u0009do @codes.add((ast.value $ bit64).toStr())\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009else\n\u0009\u0009assert false\n\u0009end if\nend func\n\nfunc buildExprValueStr(ast: \\ast@AstExprValueStr)\n\u0009var value: []char :: ast.value\n\u0009var s: []char :: \"{S:\\\"\"\n\u0009for i(0, ^value - 1)\n\u0009\u0009do s :~ @escapeChar(value[i])\n\u0009end for\n\u0009do s :~ \"\\\"}\"\n\u0009do @codes.add(s)\nend func\n\nfunc buildExprValueFloat(ast: \\ast@AstExprValueFloat)\n\u0009var value: []char :: ast.value.toStr()\n\u0009if(value = \"inf\")\n\u0009\u0009do @codes.add(\"Infinity\")\n\u0009else\n\u0009\u0009do @codes.add(value)\n\u0009end if\nend func\n\nfunc buildExprValueArray(ast: \\ast@AstExprValueArray)\n\u0009; Note that constant string values are handled by \'ExprValueStr\'.\n\u0009do @codes.add(\"[\")\n\u0009var first: bool :: true\n\u0009var items: list<\\ast@AstExpr> :: ast.values\n\u0009do items.head()\n\u0009while(!items.term())\n\u0009\u0009if(first)\n\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\",(\")\n\u0009\u0009end if\n\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009do @codes.add(\")\")\n\u0009\u0009do items.next()\n\u0009end while\n\u0009do @codes.add(\"]\")\nend func\n\nfunc buildExprRef(ast: \\ast@AstExpr)\n\u0009var ast2: \\ast@Ast :: ast.refItem\n\u0009var info: @WebInfo :: @getInfo(ast2)\n\u0009if(ast2.typeId = %func_)\n\u0009\u0009do @funcs.add(ast2 $ \\ast@AstFunc)\n\u0009\u0009do @codes.add(info.id)\n\u0009else\n\u0009\u0009assert ast2.typeId = %arg\n\u0009\u0009var arg: \\ast@AstArg :: ast2 $ \\ast@AstArg\n\u0009\u0009switch(arg.kind)\n\u0009\u0009case %global\n\u0009\u0009\u0009if(!info.alreadyWritten)\n\u0009\u0009\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009\u0009\u0009do @globalVars.add(arg)\n\u0009\u0009\u0009end if\n\u0009\u0009case %localArg\n\u0009\u0009\u0009; Do nothing.\n\u0009\u0009case %localVar\n\u0009\u0009\u0009if(!info.alreadyWritten)\n\u0009\u0009\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009\u0009\u0009do @localVars.add(arg)\n\u0009\u0009\u0009end if\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009if(arg.refVar)\n\u0009\u0009\u0009do @codes.add(\"\\{info.id}.$\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(info.id)\n\u0009\u0009end if\n\u0009end if\nend func\n\nfunc write(resFiles: list<[]char>)\n\u0009var writer: file@Writer\n\u0009do writer :: file@makeWriter(\\option@outputFile ~ \".js\", false)\n\u0009var static: bool :: \\option@extra.get(\"static\", &)\n\u0009if(static)\n\u0009\u0009do writer.writeStr(\"\\\"use strict\\\";function \\{file@fileName(\\option@outputFile)}(O_){\\n\")\n\u0009else\n\u0009\u0009do writer.writeStr(\"\\\"use strict\\\";!function(f){let d=document;function h(){d.removeEventListener(\\\"DOMContentLoaded\\\",h);removeEventListener(\\\"load\\\",h);f()}\\\"complete\\\"===d.readyState||\\\"loading\\\"!==d.readyState&&!d.documentElement.doScroll?setTimeout(f):(d.addEventListener(\\\"DOMContentLoaded\\\",h),addEventListener(\\\"load\\\",h))}(function(){\\n\")\n\u0009\u0009do writer.writeStr(\"let O_;\\n\")\n\u0009end if\n\u0009\n\u0009do @globalVars.head()\n\u0009while(!@globalVars.term())\n\u0009\u0009var globalVar: \\ast@AstArg :: @globalVars.get()\n\u0009\u0009var info: @WebInfo :: @getInfo(globalVar)\n\u0009\u0009do writer.writeStr(\"let \\{info.id}=\\{@getDefaultValue(globalVar.type)};\\n\")\n\u0009\u0009do @globalVars.next()\n\u0009end while\n\u0009do @codes.head()\n\u0009while(!@codes.term())\n\u0009\u0009do writer.writeStr(@codes.get())\n\u0009\u0009do @codes.next()\n\u0009end while\n\u0009\n\u0009do writer.writeStr(\"function C_(t,v){\\n\")\n\u0009do writer.writeStr(\"switch(t[0]){\\n\")\n\u0009do writer.writeStr(\"case \\{%int_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009do writer.writeStr(\"case \\{%float_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009do writer.writeStr(\"case \\{%char_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009do writer.writeStr(\"case \\{%bool_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009do writer.writeStr(\"case \\{%bit8_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009do writer.writeStr(\"case \\{%bit16_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009do writer.writeStr(\"case \\{%bit32_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009do writer.writeStr(\"case \\{%bit64_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009do writer.writeStr(\"case \\{%func_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009do writer.writeStr(\"case \\{%enum_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009do writer.writeStr(\"return v;\\n\")\n\u0009do writer.writeStr(\"case \\{%array $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009do writer.writeStr(\"if(t[1]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009do writer.writeStr(\"return v===null?null:{S:v.S};\\n\")\n\u0009do writer.writeStr(\"else{\\n\")\n\u0009do writer.writeStr(\"let a=new Array(v.length);\\n\")\n\u0009do writer.writeStr(\"for(let i=0;i<v.length;i++)a[i]=C_(t.slice(1),v[i]);\\n\")\n\u0009do writer.writeStr(\"return a;\\n\")\n\u0009do writer.writeStr(\"}\\n\")\n\u0009do writer.writeStr(\"case \\{%list_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009; TODO:\n\u0009do writer.writeStr(\"case \\{%stack_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009; TODO:\n\u0009do writer.writeStr(\"case \\{%queue_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009; TODO:\n\u0009do writer.writeStr(\"case \\{%dict_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009; TODO:\n\u0009do writer.writeStr(\"case \\{%class_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009; TODO:\n\u0009do writer.writeStr(\"}\\n\")\n\u0009do writer.writeStr(\"}\\n\")\n\u0009\n\u0009do writer.writeStr(\"function F_(p){\\n\")\n\u0009block\n\u0009\u0009var first: bool :: true\n\u0009\u0009do resFiles.head()\n\u0009\u0009while(!resFiles.term())\n\u0009\u0009\u0009var resFile: []char :: resFiles.get()\n\u0009\u0009\u0009var reader: file@Reader :: file@makeReader(resFile)\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009do writer.writeStr(\"if(p===\\\"\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do writer.writeStr(\"else if(p===\\\"\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009for i(^\\option@inputDir, ^resFile - 1)\n\u0009\u0009\u0009\u0009do writer.writeStr(@escapeChar(resFile[i]))\n\u0009\u0009\u0009end for\n\u0009\u0009\u0009do writer.writeStr(\"\\\")\\n\")\n\u0009\u0009\u0009do writer.writeStr(\"return \\\"\")\n\u0009\u0009\u0009while(!reader.term())\n\u0009\u0009\u0009\u0009var line: []char :: reader.readLine()\n\u0009\u0009\u0009\u0009for i(0, ^line - 1)\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(@escapeChar(line[i]))\n\u0009\u0009\u0009\u0009end for\n\u0009\u0009\u0009\u0009do writer.writeStr(\"\\\\n\")\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do writer.writeStr(\"\\\";\\n\")\n\u0009\u0009\u0009do reader.fin()\n\u0009\u0009\u0009do resFiles.next()\n\u0009\u0009end while\n\u0009\u0009if(^resFiles > 0)\n\u0009\u0009\u0009do writer.writeStr(\"else return null;\\n\")\n\u0009\u0009else\n\u0009\u0009\u0009do writer.writeStr(\"return null;\\n\")\n\u0009\u0009end if\n\u0009end block\n\u0009do writer.writeStr(\"}\\n\")\n\u0009do writer.writeStr(\"a();\\n\")\n\u0009if(static)\n\u0009\u0009do writer.writeStr(\"}\\n\")\n\u0009else\n\u0009\u0009do writer.writeStr(\"})\\n\")\n\u0009end if\n\u0009do writer.fin()\n\u0009\n\u0009var fileName: []char :: file@fileName(\\option@outputFile)\n\u0009do writer :: file@makeWriter(\\option@outputFile ~ \".html\", false)\n\u0009do writer.writeStr(\"<!DOCTYPE html>\\n\")\n\u0009do writer.writeStr(\"<html>\\n\")\n\u0009do writer.writeStr(\"\\t<head>\\n\")\n\u0009do writer.writeStr(\"\\t\\t<meta charset=\\\"utf-8\\\" />\\n\")\n\u0009do writer.writeStr(\"\\t\\t<script src=\\\"\\{fileName}.js\\\" type=\\\"text/javascript\\\"></script>\\n\")\n\u0009do writer.writeStr(\"\\t\\t<title>\\{fileName}</title>\\n\")\n\u0009do writer.writeStr(\"\\t</head>\\n\")\n\u0009do writer.writeStr(\"\\t<body>\\n\")\n\u0009do writer.writeStr(\"\\t</body>\\n\")\n\u0009do writer.writeStr(\"</html>\\n\")\n\u0009do writer.fin()\nend func\n\nfunc getId(): []char\n\u0009var curId: []char :: @uniqueId\n\u0009var newId: []char :: ##@uniqueId\n\u0009while loop2(true)\n\u0009\u0009var idx: int :: ^newId - 1\n\u0009\u0009while loop(true)\n\u0009\u0009\u0009switch(newId[idx])\n\u0009\u0009\u0009case \'z\'\n\u0009\u0009\u0009\u0009do newId[idx] :: idx = 0 ?(\'A\', \'0\')\n\u0009\u0009\u0009case \'9\'\n\u0009\u0009\u0009\u0009do newId[idx] :: \'A\'\n\u0009\u0009\u0009case \'Z\'\n\u0009\u0009\u0009\u0009if(idx = 0)\n\u0009\u0009\u0009\u0009\u0009do newId :: #[^newId + 1]char\n\u0009\u0009\u0009\u0009\u0009do newId.fill(\'a\')\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do newId[idx] :: \'a\'\n\u0009\u0009\u0009\u0009\u0009do idx :- 1\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do newId[idx] :: newId[idx].offset(1)\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009break loop\n\u0009\u0009end while\n\u0009\u0009switch(^newId)\n\u0009\u0009case 2\n\u0009\u0009\u0009switch(newId)\n\u0009\u0009\u0009case \"do\", \"if\", \"in\"\n\u0009\u0009\u0009\u0009skip loop2\n\u0009\u0009\u0009end switch\n\u0009\u0009case 3\n\u0009\u0009\u0009switch(newId)\n\u0009\u0009\u0009case \"for\", \"let\", \"new\", \"try\", \"var\", \"Map\", \"NaN\", \"Set\"\n\u0009\u0009\u0009\u0009skip loop2\n\u0009\u0009\u0009end switch\n\u0009\u0009case 4\n\u0009\u0009\u0009switch(newId)\n\u0009\u0009\u0009case \"case\", \"else\", \"enum\", \"eval\", \"name\", \"null\", \"this\", \"true\", \"void\", \"with\", \"Date\", \"Intl\", \"JSON\", \"Math\"\n\u0009\u0009\u0009\u0009skip loop2\n\u0009\u0009\u0009end switch\n\u0009\u0009end switch\n\u0009\u0009break loop2\n\u0009end while\n\u0009do @uniqueId :: newId\n\u0009ret curId\nend func\n\n+func getInfo(ast: \\ast@Ast): @WebInfo\n\u0009if(ast.extra =& null | ast.extra.typeId <> %info)\n\u0009\u0009var info: @WebInfo :: #@WebInfo\n\u0009\u0009do info.typeId :: %info\n\u0009\u0009do info.id :: @getId()\n\u0009\u0009if(ast.typeId.and(%statBreakable) = %statBreakable & ast.name <>& null & ast.name <> \"$\")\n\u0009\u0009\u0009do info.breakSkipLabel :: @getId()\n\u0009\u0009else\n\u0009\u0009\u0009do info.breakSkipLabel :: null\n\u0009\u0009end if\n\u0009\u0009do info.alreadyWritten :: false\n\u0009\u0009do ast.extra :: info\n\u0009end if\n\u0009ret ast.extra $ @WebInfo\nend func\n\nfunc addTmpVar(type: \\ast@AstType): []char\n\u0009var tmpVar: @TmpVar :: #@TmpVar\n\u0009do tmpVar.identifier :: @getId()\n\u0009do tmpVar.type :: type\n\u0009do @tmpVars.add(tmpVar)\n\u0009ret tmpVar.identifier\nend func\n\nfunc refClass(ast: \\ast@AstClass): []char\n\u0009var info: @WebInfo :: @getInfo(ast)\n\u0009if(info.alreadyWritten)\n\u0009\u0009ret info.id\n\u0009end if\n\u0009do info.alreadyWritten :: true\n\u0009if(ast.refItem <>& null)\n\u0009\u0009do @refClass(ast.refItem $ \\ast@AstClass)\n\u0009end if\n\u0009do @classes.add(ast)\n\u0009ret info.id\nend func\n\nfunc getDefaultValue(type: \\ast@AstType): []char\n\u0009if(\\ast@isNullable(type))\n\u0009\u0009ret \"null\"\n\u0009end if\n\u0009switch(type.typeId)\n\u0009case %typeUser\n\u0009\u0009assert \\ast@isEnum(type)\n\u0009\u0009ret \"0\"\n\u0009case %typeBit\n\u0009\u0009ret \"0\"\n\u0009case %typePrim\n\u0009\u0009switch((type $ \\ast@AstTypePrim).kind)\n\u0009\u0009case %int_, %char_\n\u0009\u0009\u0009ret \"0\"\n\u0009\u0009case %float_\n\u0009\u0009\u0009ret \"0\"\n\u0009\u0009case %bool_\n\u0009\u0009\u0009ret \"false\"\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc makeTypeId(type: \\ast@AstType): []char\n\u0009var result: []char :: \"[\"\n\u0009var first: bool :: true\n\u0009var items: list<int> :: \\convert@getTypeId(type)\n\u0009do items.head()\n\u0009while(!items.term())\n\u0009\u0009if(first)\n\u0009\u0009\u0009do first :: false\n\u0009\u0009else\n\u0009\u0009\u0009do result :~ \",\"\n\u0009\u0009end if\n\u0009\u0009do result :~ items.get().toStr()\n\u0009\u0009do items.next()\n\u0009end while\n\u0009do result :~ \"]\"\n\u0009ret result\nend func\n\nfunc escapeChar(c: char): []char\n\u0009switch(c)\n\u0009case \'\"\'\n\u0009\u0009ret \"\\\\\\\"\"\n\u0009case \'\\\'\'\n\u0009\u0009ret \"\\\\\'\"\n\u0009case \'\\\\\'\n\u0009\u0009ret \"\\\\\\\\\"\n\u0009case \' \' to \'~\'\n\u0009\u0009ret c.toStr()\n\u0009default\n\u0009\u0009ret \"\\\\u\\{(c $ bit16).toStr().sub(2, -1)}\"\n\u0009end switch\nend func\n";
else if(p==="res/web/raw_funcs.kn")
return "+func write(codes: list<[]char>, attr: []char, args: list<\\ast@AstArg>, members: list<\\ast@AstClassItem>)\n\u0009switch(attr)\n\u0009case \"addr\"\n\u0009\u0009; TODO:\n\u0009case \"addDict\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var key: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{meType.id}[1]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[2]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.set(\\{key.id}.S, \\{item.id});\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.set(\\{key.id}, \\{item.id});\\n\")\n\u0009case \"addList\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let n_={P:null,N:null,I:\\{item.id}};\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}.H===null){\\{me_.id}.H=n_;\\{me_.id}.T=n_}else{n_.P=\\{me_.id}.T;\\{me_.id}.T.N=n_;\\{me_.id}.T=n_}\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.L++;\\n\")\n\u0009case \"addQueue\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}.push(\\{item.id});\\n\")\n\u0009case \"addStack\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}.push(\\{item.id});\\n\")\n\u0009case \"and\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}&\\{n.id};\\n\")\n\u0009case \"cmdLine\"\n\u0009\u0009do codes.add(\"let r_=(O_&&O_.cmdLine)?O_.cmdLine:location.search.slice(1).split(\\\"&\\\");\\n\")\n\u0009\u0009do codes.add(\"if(r_.length===1&&r_[0]===\\\"\\\")return[];\\n\")\n\u0009\u0009do codes.add(\"for(let i_=0;i_<r_.length;i_++)\\n\")\n\u0009\u0009do codes.add(\"r_[i_]={S:r_[i_]};\\n\")\n\u0009\u0009do codes.add(\"return r_;\\n\")\n\u0009case \"del\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let p_=\\{me_.id}.P;\\n\")\n\u0009\u0009do codes.add(\"if(p_.P===null)\\{me_.id}.H=p_.N;else p_.P.N=p_.N;\\n\")\n\u0009\u0009do codes.add(\"if(p_.N===null)\\{me_.id}.T=p_.P;else p_.N.P=p_.P;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.P=p_.N;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.L--;\\n\")\n\u0009case \"fill\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var value: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{meType.id}[0]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[1]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.S=String.fromCharCode(\\{value.id}).repeat(\\{me_.id}.S.length);\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.fill(\\{value.id});\\n\")\n\u0009case \"findArray\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var start: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{meType.id}[0]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[1]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.S.indexOf(String.fromCharCode(\\{item.id}),\\{start.id}===-1?0:\\{start.id});\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.indexOf(\\{item.id},\\{start.id}===-1?0:\\{start.id});\\n\")\n\u0009case \"findBin\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let a_=0,b_=\\{me_.id}.length-1,c_,m_,f_;\\n\")\n\u0009\u0009do codes.add(\"switch(\\{meType.id}[0]){\\n\")\n\u0009\u0009do codes.add(\"case \\{%int_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%float_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%char_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit8_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit16_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit32_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit64_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%enum_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"f_=function(a,b){return a>b?1:a<b?-1:0};\\n\")\n\u0009\u0009do codes.add(\"break;\\n\")\n\u0009\u0009do codes.add(\"case \\{%array $ \\convert@runtimeTypeId $ int}:\\n\") {TODO:}\n\u0009\u0009do codes.add(\"f_=function(a,b){return a.S>b.S?1:a.S<b.S?-1:0};\\n\")\n\u0009\u0009do codes.add(\"break;\\n\")\n\u0009\u0009do codes.add(\"default:\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"break;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"while (a_<=b_){\\n\")\n\u0009\u0009do codes.add(\"c_=~~((a_+b_)/2);\\n\")\n\u0009\u0009do codes.add(\"m_=f_(\\{item.id},\\{me_.id}[c_]);\\n\")\n\u0009\u0009do codes.add(\"if(m_<0)b_=c_-1;\\n\")\n\u0009\u0009do codes.add(\"else if(m_>0)a_=c_+1;\\n\")\n\u0009\u0009do codes.add(\"else return c_;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return -1;\\n\")\n\u0009case \"forEach\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var callback: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var data: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let D_={F:\\{callback.id},D:\\{data.id},C:true};\\n\")\n\u0009\u0009do codes.add(\"if(\\{meType.id}[1]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[2]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.forEach(function(V_,K_){if(this.C)this.C=this.F({S:K_},V_,this.D)},D_);\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.forEach(function(V_,K_){if(this.C)this.C=this.F(K_,V_,this.D)},D_);\\n\")\n\u0009\u0009do codes.add(\"return D_.C;\\n\")\n\u0009case \"getDict\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var key: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var existed: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let r_;\\n\")\n\u0009\u0009do codes.add(\"if(\\{meType.id}[1]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[2]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"r_=\\{me_.id}.get(\\{key.id}.S);\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"r_=\\{me_.id}.get(\\{key.id});\\n\")\n\u0009\u0009do codes.add(\"if(!(\\{existed.id}.$=r_!==undefined)){\\n\")\n\u0009\u0009do codes.add(\"switch(\\{meType.id}){\\n\")\n\u0009\u0009do codes.add(\"case \\{%int_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%float_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%char_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit8_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit16_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit32_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit64_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%enum_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"case \\{%bool_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return false;\\n\")\n\u0009\u0009do codes.add(\"default:\\n\")\n\u0009\u0009do codes.add(\"return null;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return r_;\\n\")\n\u0009case \"getList\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}.P.I;\\n\")\n\u0009case \"getQueue\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}.shift();\\n\")\n\u0009case \"getStack\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}.pop();\\n\")\n\u0009case \"head\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}.P=\\{me_.id}.H;\\n\")\n\u0009case \"idx\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let p_=\\{me_.id}.H,i_=0;\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}.P===null)return -1;\\n\")\n\u0009\u0009do codes.add(\"while(p_!==null){\\n\")\n\u0009\u0009do codes.add(\"if(p_===\\{me_.id}.P)return i_\\n\")\n\u0009\u0009do codes.add(\"i_++;\\n\")\n\u0009\u0009do codes.add(\"p_=p_.N;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return -1;\\n\")\n\u0009case \"ins\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let p_=\\{me_.id}.P;\\n\")\n\u0009\u0009do codes.add(\"let n_={P:p_.P,N:p_,I:\\{item.id}}\\n\")\n\u0009\u0009do codes.add(\"if(p_.P===null)\\{me_.id}.H=n_;else p_.P.N=n_;\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}.T===null)\\{me_.id}.T=n_;\\n\")\n\u0009\u0009do codes.add(\"p_.P=n_;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.L++;\\n\")\n\u0009case \"moveOffset\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var offset: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{offset.id}>=0){\\n\")\n\u0009\u0009do codes.add(\"for(let i_=0;i_<\\{offset.id};i_++){\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}.P===null)break;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.P=\\{me_.id}.P.N;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"for(let i_=0;i_>\\{offset.id};i_--){\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}.P===null)break;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.P=\\{me_.id}.P.P;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"next\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}.P=\\{me_.id}.P.N;\\n\")\n\u0009case \"or\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}|\\{n.id};\\n\")\n\u0009case \"peekQueue\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}[0];\\n\")\n\u0009case \"peekStack\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}[\\{me_.id}.length-1];\\n\")\n\u0009case \"rnd\"\n\u0009\u0009do args.head()\n\u0009\u0009var min: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var max: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return ~~(Math.random()*(\\{max.id}-\\{min.id}+1))+\\{min.id};\\n\")\n\u0009case \"rndFloat\"\n\u0009\u0009do args.head()\n\u0009\u0009var min: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var max: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.random()*(\\{max.id}-\\{min.id})+\\{min.id};\\n\")\n\u0009case \"sub\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var start: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var len: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{meType.id}[0]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[1]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"return {S:\\{len.id}===-1?\\{me_.id}.S.slice(\\{start.id}):\\{me_.id}.S.slice(\\{start.id},\\{start.id}+\\{len.id})};\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"return \\{len.id}===-1?\\{me_.id}.slice(\\{start.id}):\\{me_.id}.slice(\\{start.id},\\{start.id}+\\{len.id});\\n\")\n\u0009case \"sysTime\"\n\u0009\u0009do codes.add(\"return new Date().getTime();\\n\")\n\u0009case \"tail\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}.P=\\{me_.id}.T;\\n\")\n\u0009case \"term\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}.P===null;\\n\")\n\u0009case \"toBit64\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var success: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{me_.id}.S.length>=2&&\\{me_.id}.S[0]===\\\"0\\\"&&\\{me_.id}.S[1]===\\\"x\\\"){\\n\")\n\u0009\u0009do codes.add(\"let s_=\\{me_.id}.S.slice(2),r_=Number(\\{me_.id}.S);\\n\")\n\u0009\u0009do codes.add(\"\\{success.id}.$=!isNaN(r_);\\n\")\n\u0009\u0009do codes.add(\"return parseInt(s_,16);\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"let r_=Number(\\{me_.id}.S);\\n\")\n\u0009\u0009do codes.add(\"\\{success.id}.$=!isNaN(r_);\\n\")\n\u0009\u0009do codes.add(\"return parseInt(\\{me_.id}.S,10);\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"toFloat\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var success: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let r_=Number(\\{me_.id}.S);\\n\")\n\u0009\u0009do codes.add(\"\\{success.id}.$=!isNaN(r_);\\n\")\n\u0009\u0009do codes.add(\"return r_;\\n\")\n\u0009case \"toInt\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var success: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{me_.id}.S.length>=2&&\\{me_.id}.S[0]===\\\"0\\\"&&\\{me_.id}.S[1]===\\\"x\\\"){\\n\")\n\u0009\u0009do codes.add(\"let s_=\\{me_.id}.S.slice(2),r_=Number(\\{me_.id}.S);\\n\")\n\u0009\u0009do codes.add(\"\\{success.id}.$=!isNaN(r_);\\n\")\n\u0009\u0009do codes.add(\"return parseInt(s_,16);\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"let r_=Number(\\{me_.id}.S);\\n\")\n\u0009\u0009do codes.add(\"\\{success.id}.$=!isNaN(r_);\\n\")\n\u0009\u0009do codes.add(\"return parseInt(\\{me_.id}.S,10);\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"toStr\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var type: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"switch(\\{type.id}[0]){\\n\")\n\u0009\u0009do codes.add(\"case \\{%int_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%float_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%enum_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return{S:\\{me_.id}.toString(10)};\\n\")\n\u0009\u0009do codes.add(\"case \\{%char_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return{S:String.fromCharCode(\\{me_.id})};\\n\")\n\u0009\u0009do codes.add(\"case \\{%bool_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return{S:\\{me_.id}?\\\"true\\\":\\\"false\\\"};\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit8_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return{S:\\\"0x\\\"+(\\\"00\\\"+\\{me_.id}.toString(16)).slice(-2).toUpperCase()};\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit16_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return{S:\\\"0x\\\"+(\\\"0000\\\"+\\{me_.id}.toString(16)).slice(-4).toUpperCase()};\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit32_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return{S:\\\"0x\\\"+(\\\"00000000\\\"+\\{me_.id}.toString(16)).slice(-8).toUpperCase()};\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit64_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return{S:\\\"0x\\\"+(\\\"0000000000000000\\\"+\\{me_.id}.toString(16)).slice(-16).toUpperCase()};\\n\")\n\u0009\u0009do codes.add(\"case \\{%array $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"if(\\{type.id}[1]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id};\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"cui_print\"\n\u0009\u0009do args.head()\n\u0009\u0009var str: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(O_&&O_.print){O_.print(\\{str.id}.S);return;}\\n\")\n\u0009\u0009do codes.add(\"console.log(\\{str.id}.S);\\n\")\n\u0009case \"file_copyFile\"\n\u0009\u0009; TODO:\n\u0009case \"file_exist\"\n\u0009\u0009do args.head()\n\u0009\u0009var path: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"return false;\\n\")\n\u0009case \"file_forEach\"\n\u0009\u0009do args.head()\n\u0009\u0009var path: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var recursion: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var callback: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var data: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"return false;\\n\")\n\u0009case \"file_makeReader\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var path: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"let f_=null,p_=\\{path.id}.S;\\n\")\n\u0009\u0009do codes.add(\"if(O_&&O_.readFile)f_=O_.readFile(p_);\\n\")\n\u0009\u0009do codes.add(\"if(f_===null){\\n\")\n\u0009\u0009do codes.add(\"if(p_.length>=4&&p_[0]===\\\"r\\\"&&p_[1]===\\\"e\\\"&&p_[2]===\\\"s\\\"&&p_[3]===\\\"/\\\")\\n\")\n\u0009\u0009do codes.add(\"f_=F_(p_);\\n\")\n\u0009\u0009do codes.add(\"else{\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"if(f_===null)return null;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}={F:f_,I:0};\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id};\\n\")\n\u0009case \"file_makeWriter\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var path: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var append: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}={F:\\\"\\\",I:0,P:\\{path.id}.S};\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id};\\n\")\n\u0009case \"file_readerFin\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.F=null;\\n\")\n\u0009case \"file_readerGetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.\\{handle.id}.I;\\n\")\n\u0009case \"file_readerReadLetter\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.\\{handle.id}.F.charCodeAt(\\{me_.id}.\\{handle.id}.I++);\\n\")\n\u0009case \"file_readerSetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var origin: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var pos: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.I=\\{pos.id};\\n\")\n\u0009case \"file_readerTerm\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.\\{handle.id}.I>=\\{me_.id}.\\{handle.id}.F.length;\\n\")\n\u0009case \"file_writerFin\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"var d_=\\{me_.id}.\\{handle.id}.F.replace(\\\"\\\\n\\\", \\\"\\\\u000D\\\\n\\\");\\n\")\n\u0009\u0009do codes.add(\"if(O_&&O_.writeFile){O_.writeFile(\\{me_.id}.\\{handle.id}.P,d_);return;}\\n\")\n\u0009\u0009do codes.add(\"let b_=new Blob([d_],{type:\\\"text/plain\\\"});\\n\")\n\u0009\u0009do codes.add(\"let l_=document.createElement(\\\"a\\\");\\n\")\n\u0009\u0009do codes.add(\"l_.download=\\{me_.id}.\\{handle.id}.P;\\n\")\n\u0009\u0009do codes.add(\"l_.href=(URL||webkitURL).createObjectURL(b_);\\n\")\n\u0009\u0009do codes.add(\"l_.setAttribute(\\\"style\\\",\\\"display:none\\\");\\n\")\n\u0009\u0009do codes.add(\"document.body.appendChild(l_);\\n\")\n\u0009\u0009do codes.add(\"l_.click();\\n\")\n\u0009\u0009do codes.add(\"document.body.removeChild(l_);\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.F=null;\\n\")\n\u0009case \"file_writerGetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.\\{handle.id}.I;\\n\")\n\u0009case \"file_writerSetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var origin: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var pos: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.I=\\{pos.id};\\n\")\n\u0009case \"file_writerWrite\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009; TODO:\n\u0009case \"file_writerWriteChar\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}.\\{handle.id}.I<\\{me_.id}.\\{handle.id}.F.length)\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.F=\\{me_.id}.\\{handle.id}.F.slice(0,\\{me_.id}.\\{handle.id}.I)+String.fromCharCode(\\{n.id})+\\{me_.id}.\\{handle.id}.F.slice(\\{me_.id}.\\{handle.id}.I+1);\\n\")\n\u0009\u0009do codes.add(\"else{\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.F+=String.fromCharCode(\\{n.id});\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.I++;\\n\")\n\u0009case \"wnd_editBaseGetText\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.\\{handle.id}.H.value;\\n\")\n\u0009case \"wnd_makeEditMulti\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var parent: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var y: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var width: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var height: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var anchorX: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var anchorY: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"let h_=document.createElement(\\\"textarea\\\");\\n\")\n\u0009\u0009do codes.add(\"h_.setAttribute(\\\"cols\\\",\\\"\\{width.id}\\\");\\n\")\n\u0009\u0009do codes.add(\"h_.setAttribute(\\\"rows\\\",\\\"\\{height.id}\\\");\\n\")\n\u0009\u0009do codes.add(\"document.body.appendChild(c_);\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}={C:c_};\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id};\\n\")\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\n\u0009\n\u0009func search(members: list<\\ast@AstClassItem>, name: []char): \\web\\output@WebInfo\n\u0009\u0009do members.head()\n\u0009\u0009while(!members.term())\n\u0009\u0009\u0009var def: \\ast@Ast :: members.get().def\n\u0009\u0009\u0009if(def.typeId = %var_ & (def $ \\ast@AstVar).arg.name <>& null & (def $ \\ast@AstVar).arg.name = name)\n\u0009\u0009\u0009\u0009ret \\web\\output@getInfo((def $ \\ast@AstVar).arg)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do members.next()\n\u0009\u0009end while\n\u0009\u0009assert false\n\u0009\u0009ret null\n\u0009end func\nend func\n";
else return null;
}
a();
}
