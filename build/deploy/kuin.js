"use strict";function kuin(O_){
let m=0;
let s=false;
let x=false;
let y=null;
let F=false;
let I=null;
let J=null;
let K=null;
let L=null;
let M=null;
let N=null;
let O=null;
let P=null;
let Q=null;
let R=null;
let S=null;
let T=null;
let U=null;
let V=null;
let W=null;
let X=null;
let Y=null;
let Z=null;
let aa=null;
let ab=null;
let ac=null;
let ad=null;
let ae=null;
let af=null;
let ag=null;
let ah=null;
let ai=null;
let aj=null;
let ak=null;
let al=null;
let am=null;
let an=null;
let ao=null;
let ap=null;
let aY=false;
let b5=false;
let bL=0;
let bW=0;
let c2=0;
let eR=0;
let pF=0;
let pG=0;
let pH=0;
let pI=0;
let pJ=false;
let pK=0;
// $
function a(){
let c; // $
try{
(e)();
(f)();
(g)();
}catch(c){
if((0)<=c&&c<=(4294967295)){
(i)((c));
}
else{
throw c;
}
}
finally{
(k)();
(l)();
}
}
// _init
function e(){
}
// _initVars
function f(){
(m)=(0);
}
// main
function g(){
if(!((o)())){
(q)((1));
return;
}
if(s){
(u)(({S:({S:({S:"Kuin Programming Language v."}).S+((v)((2019),([0]))).S}).S+({S:({S:({S:"."}).S+((v)((10),([0]))).S}).S+({S:({S:({S:"."}).S+((v)((17),([0]))).S}).S+({S:"\u000A"}).S}).S}).S}));
(u)(({S:"(C)Kuina-chan\u000A"}));
(q)((0));
return;
}
if((x)||((y)===(null))){
(u)(({S:"Usage: kuincl [-i input.kn] [-o output.kn] [-s \'sys\' directory] [-c icon.ico] [-e environment] [-a appcode] [-r] [-h] [-v] [-q]\u000A"}));
(q)((0));
return;
}
if((B)()){
(D)((196609),(null),(null));
(q)((0));
return;
}
if(!(F)){
(D)((196610),(null),(null));
}
(q)((1));
}
// _err
function i(H /*excpt*/){
}
// _finVars
function k(){
(I)=(null);
(J)=(null);
(K)=(null);
(L)=(null);
(M)=(null);
(N)=(null);
(O)=(null);
(P)=(null);
(Q)=(null);
(R)=(null);
(S)=(null);
(T)=(null);
(U)=(null);
(y)=(null);
(V)=(null);
(W)=(null);
(X)=(null);
(Y)=(null);
(Z)=(null);
(aa)=(null);
(ab)=(null);
(ac)=(null);
(ad)=(null);
(ae)=(null);
(af)=(null);
(ag)=(null);
(ah)=(null);
(ai)=(null);
(aj)=(null);
(ak)=(null);
(al)=(null);
(am)=(null);
(an)=(null);
(ao)=(null);
(ap)=(null);
}
// _fin
function l(){
}
// acquireOption
function o(){
let aq; // cmdLines
let as; // envStr
let at; // appCodeStr
let aw;
let ay; // cmdLine
let a3;
let b8; // extra
let bO;
let bZ; // success
let ax;
let a6;
let a8;
let a9;
let aD;
let aE;
let aF;
let aJ;
let aK;
let aL;
let aP;
let aQ;
let aR;
let aV;
let aX;
let bc;
let bd;
let be;
let bi;
let bj;
let bn;
let bo;
let bs;
let bt;
let bx;
let by;
let bz;
let b3;
let b4;
let bA;
let bB;
let bC;
let ca;
let cc;
(aq)=((ar)());
(as)=(null);
(at)=(null);
(Y)=(new Map());
av:
for(aw=(0),ax=(((aq).length)-(1));aw<=ax;aw+=(1)){
(ay)=((aq)[aw]);
if((((ay).S.length)===(2))&&(((ay).S.charCodeAt(0))===(0x002D))){
a3=(ay).S.charCodeAt(1);
a2:
switch(a3){
case 0x0069:
if(!((a6=(a7)((a8={$:(y)},a8),(aq),(a9={$:(aw)},a9),(a3)),(y)=a8.$,(aw)=a9.$,a6))){
return false;
}
break;
case 0x006F:
if(!((aD=(a7)((aE={$:(V)},aE),(aq),(aF={$:(aw)},aF),(a3)),(V)=aE.$,(aw)=aF.$,aD))){
return false;
}
break;
case 0x0073:
if(!((aJ=(a7)((aK={$:(W)},aK),(aq),(aL={$:(aw)},aL),(a3)),(W)=aK.$,(aw)=aL.$,aJ))){
return false;
}
break;
case 0x0063:
if(!((aP=(a7)((aQ={$:(X)},aQ),(aq),(aR={$:(aw)},aR),(a3)),(X)=aQ.$,(aw)=aR.$,aP))){
return false;
}
break;
case 0x0072:
if(!((aV=(aW)((aX={$:(aY)},aX),(a3)),(aY)=aX.$,aV))){
return false;
}
break;
case 0x0065:
if(!((bc=(a7)((bd={$:(as)},bd),(aq),(be={$:(aw)},be),(a3)),(as)=bd.$,(aw)=be.$,bc))){
return false;
}
break;
case 0x0068:
if(!((bi=(aW)((bj={$:(x)},bj),(a3)),(x)=bj.$,bi))){
return false;
}
break;
case 0x0076:
if(!((bn=(aW)((bo={$:(s)},bo),(a3)),(s)=bo.$,bn))){
return false;
}
break;
case 0x0071:
if(!((bs=(aW)((bt={$:(F)},bt),(a3)),(F)=bt.$,bs))){
return false;
}
break;
case 0x0061:
if(!((bx=(a7)((by={$:(at)},by),(aq),(bz={$:(aw)},bz),(a3)),(at)=by.$,(aw)=bz.$,bx))){
return false;
}
break;
case 0x0064:
if(!((b3=(aW)((b4={$:(b5)},b4),(a3)),(b5)=b4.$,b3))){
return false;
}
break;
case 0x0078:
(b8)=(null);
if(!((bA=(a7)((bB={$:(b8)},bB),(aq),(bC={$:(aw)},bC),(a3)),(b8)=bB.$,(aw)=bC.$,bA))){
return false;
}
(bE)((Y),([133,129,2,3]),(b8),(true));
break;
default:
(D)((2),(null),([({S:({S:({S:"-"}).S+((v)((a3),([2]))).S}).S+({S:""}).S})]));
return false;
break;
}
}
else{
(D)((2),(null),([({S:({S:({S:""}).S+((v)((ay),([129,2]))).S}).S+({S:""}).S})]));
return false;
}
}
if((y)===(null)){
return true;
}
if((as)===(null)){
(bL)=(0);
}
else{
bO=as;
if(bO.S===({S:"cui"}).S){
(bL)=(0);
}
else if(bO.S===({S:"wnd"}).S){
(bL)=(1);
}
else if(bO.S===({S:"web"}).S){
(bL)=(2);
}
else if(bO.S===({S:"cpp"}).S){
(bL)=(3);
}
else{(D)((1),(null),([({S:"-e"})]));
}
}
if((at)===(null)){
(bW)=((bX)((1),(4294967295)));
}
else{
(bZ)=(false);
(bW)=((ca=(cb)((at),(cc={$:(bZ)},cc)),(bZ)=cc.$,ca));
if(!(bZ)){
(D)((1),(null),([({S:"-a"})]));
return false;
}
}
if((V)===(null)){
(V)=({S:((ch)((y))).S+({S:"out"}).S});
}
else{
(V)=((cj)((V)));
}
if((W)===(null)){
(W)=({S:"sys/"});
}
if((X)===(null)){
(X)=({S:(W).S+({S:"default.ico"}).S});
}
(Z)=((ch)((y)));
(aa)=((cj)(((co)((y)))));
(ab)=((ch)((V)));
if(((cq)((y))).S!==({S:"kn"}).S){
(D)((3),(null),([(aa)]));
}
return true;
}
// exitCode
function q(cs /*code*/){
if(((cs)<(0))||((4294967295)<(cs))){
throw 3910598662;
}
}
// print
function u(cx /*str*/){
if(cx===null)cx={S:"(null)"};
if(O_&&O_.print){O_.print(cx.S);return;}
console.log(cx.S);
}
// _toStr
function v(cy /*me_*/,cz /*type*/){
let n_;
switch(cz[0]){
case 0:
case 1:
case 9:
return{S:cy.toString(10)};
case 2:
return{S:String.fromCharCode(cy)};
case 3:
return{S:cy?"true":"false"};
case 4:
n_=cy>=0?~~cy&0xFF:0xFF-(~cy&0xFF);
return{S:"0x"+("00"+n_.toString(16)).slice(-2).toUpperCase()};
case 5:
n_=cy>=0?~~cy&0xFFFF:0xFFFF-(~cy&0xFFFF);
return{S:"0x"+("0000"+n_.toString(16)).slice(-4).toUpperCase()};
case 6:
n_=cy>>>0;
return{S:"0x"+("00000000"+n_.toString(16)).slice(-8).toUpperCase()};
case 7:
n_=cy>>>0;
return{S:"0x"+((cy>=0?"0000000000000000":"FFFFFFFFFFFFFFFF")+n_.toString(16)).slice(-16).toUpperCase()};
case 129:
if(cz[1]===2)
return cy;
}
}
// build
function B(){
let c0; // asts
let c1; // entry
let c3; // beginTime
let cD; // resDir
let cE; // resFiles
let cN;
(c0)=(null);
(c1)=(null);
(c2)=(0);
(c3)=((c4)());
(D)((196611),(null),([((v)(((((c4)())-(c3))/(1000)),([1])))]));
(c0)=((c5)());
(D)((196612),(null),([((v)(((((c4)())-(c3))/(1000)),([1])))]));
(c1)=((c6)((c0)));
(D)((196613),(null),([((v)(((((c4)())-(c3))/(1000)),([1])))]));
if((c2)>(0)){
return false;
}
(cD)=({S:(Z).S+({S:"res/"}).S});
(cE)=(new cF());
((cE).cG)=({L:0,H:null,T:null,P:null});
if((cI)((cD))){
(cK)((cD),(true),(cL),(cE));
}
cN=bL;
switch(cN){
case 3:
if(!((cQ)((c1),((cE).cG)))){
return false;
}
break;
case 2:
if(!((cU)((c1),((cE).cG)))){
return false;
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(D)((196614),(null),([((v)(((((c4)())-(c3))/(1000)),([1])))]));
return true;
}
// err
function D(cX /*id*/,cY /*pos*/,cZ /*args*/){
let dc; // msg
if(((cX)<(196608))&&((c2)>=(100))){
return;
}
(dc)=((dd)((cX),(cZ)));
(u)(({S:((v)((cX),([6]))).S+({S:": "}).S}));
if((cY)!==(null)){
(u)(({S:({S:({S:"["}).S+((v)(((cY).dh),([129,2]))).S}).S+({S:({S:({S:": "}).S+((v)(((cY).di),([0]))).S}).S+({S:({S:({S:", "}).S+((v)(((cY).dj),([0]))).S}).S+({S:"]"}).S}).S}).S}));
}
(u)(({S:(dc).S+({S:"\u000A"}).S}));
if((cX)<(196608)){
(c2)=((c2)+(1));
}
}
// cmdLine
function ar(){
let r_=(O_&&O_.cmdLine)?O_.cmdLine:location.search.slice(1).split("&");
if(r_.length===1&&r_[0]==="")return[];
for(let i_=0;i_<r_.length;i_++)
r_[i_]={S:r_[i_]};
return r_;
}
// getArg1
function a7(dn /*out*/,dp /*cmdLines*/,dq /*idx*/,dr /*option*/){
if(((dn.$)!==(null))||(((dq.$)+(1))>=((dp).length))){
(D)((1),(null),([({S:({S:({S:"-"}).S+((v)((dr),([2]))).S}).S+({S:""}).S})]));
return false;
}
(dn.$)=((dp)[(dq.$)+(1)]);
(dq.$)=((dq.$)+(1));
return true;
}
// getArg0
function aW(dv /*out*/,dw /*option*/){
if((dv.$)!==(false)){
(D)((1),(null),([({S:({S:({S:"-"}).S+((v)((dw),([2]))).S}).S+({S:""}).S})]));
return false;
}
(dv.$)=(true);
return true;
}
// _addDict
function bE(dz /*me_*/,d0 /*type*/,d1 /*key*/,d2 /*item*/){
if(d0[1]===129&&d0[2]===2)
dz.set(d1.S, d2);
else
dz.set(d1, d2);
}
// rnd
function bX(d3 /*min*/,d4 /*max*/){
return ~~(Math.random()*(d4-d3+1))+d3;
}
// _toInt
function cb(d5 /*me_*/,d6 /*success*/){
if(d5.S.length>=2&&d5.S[0]==="0"&&d5.S[1]==="x"){
let s_=d5.S.slice(2),r_=Number(d5.S);
d6.$=!isNaN(r_);
return parseInt(s_,16);
}else{
let r_=Number(d5.S);
d6.$=!isNaN(r_);
return parseInt(d5.S,10);
}
}
// dir
function ch(d7 /*path*/){
let d8; // p
let dE; // r
let dH;
let dI;
let dJ;
let dK;
if(!((d7)!==(null))){throw 0xE9170000;}
(d8)=(((d7).S.length)-(1));
while((((d8)>=(0))&&(((d7).S.charCodeAt(d8))!==(0x002F)))&&(((d7).S.charCodeAt(d8))!==(0x005C))){
(d8)=((d8)-(1));
}
if((d8)<(0)){
return {S:"./"};
}
else{
(dE)=({S:"\0".repeat((d8)+(1))});
dG:
for(dH=(0),dI=(d8);dH<=dI;dH+=(1)){
(dE).S=(dJ=(dH),(dE).S.slice(0,dJ)+String.fromCharCode((((d7).S.charCodeAt(dH))===(0x005C))?(0x002F):((d7).S.charCodeAt(dH)))+(dE).S.slice(dJ+1));
}
return dE;
}
}
// delExt
function cj(dL /*path*/){
let dM; // p
let dR; // r
let dU;
let dV;
let dW;
let dX;
if(!((dL)!==(null))){throw 0xE9170000;}
(dM)=(((dL).S.length)-(1));
while(((((dM)>=(0))&&(((dL).S.charCodeAt(dM))!==(0x002F)))&&(((dL).S.charCodeAt(dM))!==(0x005C)))&&(((dL).S.charCodeAt(dM))!==(0x002E))){
(dM)=((dM)-(1));
}
if(((dM)<(0))||(((dL).S.charCodeAt(dM))!==(0x002E))){
return dL;
}
(dR)=({S:"\0".repeat(dM)});
dT:
for(dU=(0),dV=((dM)-(1));dU<=dV;dU+=(1)){
(dR).S=(dW=(dU),(dR).S.slice(0,dW)+String.fromCharCode((((dL).S.charCodeAt(dU))===(0x005C))?(0x002F):((dL).S.charCodeAt(dU)))+(dR).S.slice(dW+1));
}
return dR;
}
// fileName
function co(dY /*path*/){
let dZ; // p
let ef; // r
let ei;
let ej;
let ek;
let el;
if(!((dY)!==(null))){throw 0xE9170000;}
(dZ)=(((dY).S.length)-(1));
while((((dZ)>=(0))&&(((dY).S.charCodeAt(dZ))!==(0x002F)))&&(((dY).S.charCodeAt(dZ))!==(0x005C))){
(dZ)=((dZ)-(1));
}
if((dZ)<(0)){
return dY;
}
(dZ)=((dZ)+(1));
(ef)=({S:"\0".repeat(((dY).S.length)-(dZ))});
eh:
for(ei=(0),ej=((((dY).S.length)-(dZ))-(1));ei<=ej;ei+=(1)){
(ef).S=(ek=(ei),(ef).S.slice(0,ek)+String.fromCharCode((dY).S.charCodeAt((dZ)+(ei)))+(ef).S.slice(ek+1));
}
return ef;
}
// ext
function cq(em /*path*/){
let en; // p
let eu; // r
let ex;
let ey;
let ez;
let e0;
if(!((em)!==(null))){throw 0xE9170000;}
(en)=(((em).S.length)-(1));
while(((((en)>=(0))&&(((em).S.charCodeAt(en))!==(0x002F)))&&(((em).S.charCodeAt(en))!==(0x005C)))&&(((em).S.charCodeAt(en))!==(0x002E))){
(en)=((en)-(1));
}
if(((em).S.charCodeAt(en))!==(0x002E)){
return {S:""};
}
else{
(en)=((en)+(1));
(eu)=({S:"\0".repeat(((em).S.length)-(en))});
ew:
for(ex=(0),ey=((((em).S.length)-(en))-(1));ex<=ey;ex+=(1)){
(eu).S=(ez=(ex),(eu).S.slice(0,ez)+String.fromCharCode((em).S.charCodeAt((en)+(ex)))+(eu).S.slice(ez+1));
}
return eu;
}
}
// sysTime
function c4(){
return new Date().getTime();
}
// parse
function c5(){
let e1; // endFlag
(ad)=(new Map());
(bE)((ad),([133,129,2,134]),({S:({S:"\\"}).S+(aa).S}),(null));
(bE)((ad),([133,129,2,134]),({S:"kuin"}),(null));
(e1)=(new e2());
((e1).e3)=(false);
while(!((e1).e3)){
((e1).e3)=(true);
(ae)=(new Map());
(e5)((ad),([133,129,2,134]),(e6),(e1));
(ad)=(ae);
}
return ad;
}
// analyze
function c6(e7 /*asts*/){
let e8; // mainFunc
(I)=(e7);
(e8)=((e9)());
if((e8)===(null)){
return null;
}
(e5)((e7),([133,129,2,134]),(eC),(null));
return (eD)((e8));
}
// exist
function cI(eE /*path*/){
let f_=false,p_=eE.S;
if(O_&&O_.readFile)f_=O_.readFile(p_)!==null;
if(f_===false){
if(p_.length>=4&&p_[0]==="r"&&p_[1]==="e"&&p_[2]==="s"&&p_[3]==="/")
f_=F_(p_,false);
else{
}
}
return f_;
}
// forEach
function cK(eF /*path*/,eG /*recursion*/,eH /*callback*/,eI /*data*/){
let f_,p_=eF.S;
if(p_.length>=4&&p_[0]==="r"&&p_[1]==="e"&&p_[2]==="s"&&p_[3]==="/")
f_=FF_();
for(let i_=0;i_<f_.length;i_++){
if(f_[i_].slice(0,p_.length)===p_&&(eG||f_[i_].slice(p_.length).indexOf("/")===-1)){
if(!eH({S:f_[i_]},f_[i_][f_[i_].length-1]==='/',eI))return false}
}
return true;
}
// searchResFiles
function cL(eJ /*path*/,eK /*isDir*/,eL /*data*/){
let eM; // data2
(eM)=(eL);
(eN)(((eM).cG),([130,129,2]),(eJ));
return true;
}
// output
function cQ(eO /*entry*/,eP /*resFiles*/){
let eU; // func_
let eY; // class_
(K)=([]);
(eQ)((K),([132,134]),(eO));
(L)=([]);
(M)=({S:"a"});
(N)=({L:0,H:null,T:null,P:null});
(O)=({L:0,H:null,T:null,P:null});
(P)=({L:0,H:null,T:null,P:null});
(Q)=({L:0,H:null,T:null,P:null});
(R)=({L:0,H:null,T:null,P:null});
(S)=({L:0,H:null,T:null,P:null});
(T)=({L:0,H:null,T:null,P:null});
(eR)=(0);
(U)=({L:0,H:null,T:null,P:null});
while((((K).length)>(0))||(((L).length)>(0))){
while(((K).length)>(0)){
(eU)=((eV)((K),([132,134])));
(eW)((eU));
}
while(((L).length)>(0)){
(eY)=((eV)((L),([132,134])));
(fa)((eY));
}
}
(fb)((eP));
return true;
}
// output
function cU(fc /*entry*/,fd /*resFiles*/){
let fg; // func_
let fj; // class_
(aj)=([]);
(eQ)((aj),([132,134]),(fc));
(ak)=([]);
(al)=({S:"a"});
(am)=({L:0,H:null,T:null,P:null});
(an)=({L:0,H:null,T:null,P:null});
(ao)=({L:0,H:null,T:null,P:null});
(ap)=({L:0,H:null,T:null,P:null});
while((((aj).length)>(0))||(((ak).length)>(0))){
while(((aj).length)>(0)){
(fg)=((eV)((aj),([132,134])));
(fh)((fg));
}
while(((ak).length)>(0)){
(fj)=((eV)((ak),([132,134])));
(fk)((fj));
}
}
(fl)((fd));
return true;
}
// get
function dd(fm /*id*/,fn /*args*/){
let fp;
let fs;
let fx;
let f2;
let f7;
let fC;
let fH;
let fM;
let fR;
let fW;
let gb;
let gg;
let gl;
let gq;
let gv;
let g0;
let g5;
let gA;
let gF;
let gK;
let gP;
let gU;
let gZ;
let he;
let hj;
let ho;
let ht;
let hy;
let h3;
let h8;
let hD;
let hI;
let hN;
let hS;
let hX;
let ic;
let ii;
let io;
let it;
let iy;
let i3;
let i8;
let iD;
let iI;
let iN;
let iS;
let iX;
let jc;
let jh;
let jm;
let jr;
let jw;
let j1;
let j6;
let jB;
let jG;
let jL;
let jQ;
let jV;
let ka;
let kf;
let kk;
let kp;
let ku;
let kz;
let k4;
let k9;
let kE;
let kJ;
let kO;
let kT;
let kY;
let ld;
let li;
let ln;
let ls;
let lx;
let l2;
let l7;
let lC;
let lH;
let lM;
let lR;
let lW;
let mb;
let mg;
let ml;
let mq;
let mv;
let m0;
let m5;
let mA;
let mF;
let mK;
let mP;
let mU;
let mZ;
let ne;
let nj;
let no;
let nt;
let ny;
let n3;
let n8;
let nD;
let nI;
let nN;
let nS;
let nX;
let oc;
let oh;
let om;
let or;
let ow;
let o1;
let o6;
let oB;
let oG;
let oL;
let oQ;
let oV;
let pa;
let pf;
let pk;
let pp;
fp=fm;
switch(fp){
case 1:
fs=m;
switch(fs){
case 0:
return {S:({S:({S:"\u30AA\u30D7\u30B7\u30E7\u30F3\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u4F7F\u308F\u308C\u65B9\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The option \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' was used incorrectly."}).S};
break;
}
break;
case 2:
fx=m;
switch(fx){
case 0:
return {S:({S:({S:"\u4E0D\u660E\u306A\u30AA\u30D7\u30B7\u30E7\u30F3\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u6307\u5B9A\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"Unexpected option: \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 3:
f2=m;
switch(f2){
case 0:
return {S:({S:({S:"\u5165\u529B\u30D5\u30A1\u30A4\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u62E1\u5F35\u5B50\u306F\u300C.kn\u300D\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The extension of the input file \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' must be \'.kn\'."}).S};
break;
}
break;
case 4:
f7=m;
switch(f7){
case 0:
return {S:({S:({S:"\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u540D\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306B\u4F7F\u3048\u306A\u3044\u6587\u5B57\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The source file name \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' contains characters that cannot be used."}).S};
break;
}
break;
case 5:
fC=m;
switch(fC){
case 0:
return {S:({S:({S:"\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u958B\u3051\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"Cannot open source file \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 6:
fH=m;
switch(fH){
case 0:
return {S:({S:({S:"\u30B7\u30B9\u30C6\u30E0\u30D5\u30A1\u30A4\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u958B\u3051\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The system file \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' could not be opened."}).S};
break;
}
break;
case 7:
fM=m;
switch(fM){
case 0:
return {S:({S:({S:"\u30B7\u30B9\u30C6\u30E0\u30D5\u30A1\u30A4\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u58CA\u308C\u3066\u3044\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The system file \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' is broken."}).S};
break;
}
break;
case 65537:
fR=m;
switch(fR){
case 0:
return {S:({S:({S:"\u540C\u3058\u30B9\u30B3\u30FC\u30D7\u5185\u306B\u65E2\u306B\u540C\u3058\u8B58\u5225\u5B50\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u5B58\u5728\u3057\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The same identifier \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' already exists in the same scope."}).S};
break;
}
break;
case 65538:
fW=m;
switch(fW){
case 0:
return {S:({S:({S:"\u4E0A\u4F4D\u306E\u30B9\u30B3\u30FC\u30D7\u5185\u306B\u65E2\u306B\u540C\u3058\u8B58\u5225\u5B50\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u5B58\u5728\u3057\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The same identifier \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' already exists in the upper scope."}).S};
break;
}
break;
case 65539:
gb=m;
switch(gb){
case 0:
return {S:"\u30B3\u30E1\u30F3\u30C8\u306E\u300C{\u300D\u306B\u5BFE\u5FDC\u3059\u308B\u300C}\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"There is no \'}\' corresponding to \'{\' for comment."};
break;
}
break;
case 65540:
gg=m;
switch(gg){
case 0:
return {S:"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3084\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u4E2D\u306B\u30BF\u30D6\u6587\u5B57\u306F\u8A18\u8FF0\u3067\u304D\u307E\u305B\u3093\u3002 \u30A8\u30B9\u30B1\u30FC\u30D7\u30B7\u30FC\u30B1\u30F3\u30B9\u300C\\t\u300D\u3092\u4EE3\u7528\u3057\u3066\u304F\u3060\u3055\u3044\u3002"};
break;
default:
return {S:"Tab characters cannot be written in character literals and string literals. Use the escape sequence \'\\t\' instead."};
break;
}
break;
case 65541:
gl=m;
switch(gl){
case 0:
return {S:"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3084\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u4E2D\u3067\u306F\u6539\u884C\u3067\u304D\u307E\u305B\u3093\u3002 \u30A8\u30B9\u30B1\u30FC\u30D7\u30B7\u30FC\u30B1\u30F3\u30B9\u300C\\n\u300D\u3092\u4EE3\u7528\u3057\u3066\u304F\u3060\u3055\u3044\u3002"};
break;
default:
return {S:"Line breaks are not allowed in character literals and string literals. Use the escape sequence \'\\n\' instead."};
break;
}
break;
case 65542:
gq=m;
switch(gq){
case 0:
return {S:({S:({S:"\u8B58\u5225\u5B50\u306B\u306F\u4F7F\u3048\u306A\u3044\u6587\u5B57\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The character \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' that cannot be used in identifiers was written."}).S};
break;
}
break;
case 65543:
gv=m;
switch(gv){
case 0:
return {S:"\u8B58\u5225\u5B50\u306B\u6B63\u3057\u304F\u306A\u3044\u5F62\u5F0F\u3067\u300C@\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"Incorrect \'@\' was written in an identifier."};
break;
}
break;
case 65544:
g0=m;
switch(g0){
case 0:
return {S:({S:({S:"\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u540D\u306E\u6307\u5B9A\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306B\u5927\u6587\u5B57\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"A source file name description \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' contains uppercase letters."}).S};
break;
}
break;
case 65545:
g5=m;
switch(g5){
case 0:
return {S:"\u8B58\u5225\u5B50\u306B\u6B63\u3057\u304F\u306A\u3044\u5F62\u5F0F\u3067\u300C\\\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"Incorrect \'\\\' was written in an identifier."};
break;
}
break;
case 65546:
gA=m;
switch(gA){
case 0:
return {S:({S:({S:"\u8B58\u5225\u5B50\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 128\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The identifier \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"...\' is too long. Must be 128 characters or less."}).S};
break;
}
break;
case 65547:
gF=m;
switch(gF){
case 0:
return {S:({S:({S:"\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u30D6\u30ED\u30C3\u30AF\u3082\u3057\u304F\u306F\u6587\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"An incorrect block or sentence \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' was written."}).S};
break;
}
break;
case 65548:
gK=m;
switch(gK){
case 0:
return {S:({S:({S:"\u95A2\u6570\u5C5E\u6027\u306B\u306F\u4F7F\u3048\u306A\u3044\u6587\u5B57\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The character \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' that cannot be used in function attributes was written."}).S};
break;
}
break;
case 65549:
gP=m;
switch(gP){
case 0:
return {S:({S:({S:"\u95A2\u6570\u5C5E\u6027\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 128\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The function attribute \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"...\' is too long. Must be 128 characters or less."}).S};
break;
}
break;
case 65550:
gU=m;
switch(gU){
case 0:
return {S:({S:({S:"\u6587\u5B57\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u308B\u3079\u304D\u7B87\u6240\u306B\u3001\u4E0D\u6B63\u306A\u6587\u5B57\u300C"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S}).S};
break;
default:
return {S:({S:({S:"An invalid character \'"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\' was written in a place where the character \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' should be written."}).S}).S};
break;
}
break;
case 65551:
gZ=m;
switch(gZ){
case 0:
return {S:({S:({S:"\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u306B\u5BFE\u5FDC\u3059\u308B\u300Cend "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002"}).S}).S};
break;
default:
return {S:({S:({S:"There is no \'end "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\' corresponding to \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\'."}).S}).S};
break;
}
break;
case 65552:
he=m;
switch(he){
case 0:
return {S:({S:({S:"\u95A2\u6570\u4EE5\u5916\u306E\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"Overridden non-function member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 65553:
hj=m;
switch(hj){
case 0:
return {S:({S:({S:"\u95A2\u6570\u304A\u3088\u3073\u5909\u6570\u4EE5\u5916\u306E\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u3092\u516C\u958B\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' other than functions and variables has been released."}).S};
break;
}
break;
case 65554:
ho=m;
switch(ho){
case 0:
return {S:({S:({S:"\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u304C\u300Cend "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u3067\u306F\u306A\u304F\u4E0D\u6B63\u306A\u300Cend "}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:"\u300D\u3067\u9589\u3058\u3089\u308C\u307E\u3057\u305F\u3002"}).S}).S}).S};
break;
default:
return {S:({S:({S:"\'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\' was closed with invalid \'end "}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\' instead of \'end "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\'."}).S}).S}).S};
break;
}
break;
case 65555:
ht=m;
switch(ht){
case 0:
return {S:({S:({S:"\u6B63\u3057\u304F\u306A\u3044\u5F62\u5F0F\u306E\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"Incorrectly formatted member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' was written."}).S};
break;
}
break;
case 65556:
hy=m;
switch(hy){
case 0:
return {S:"\u5F15\u6570\u4EE5\u5916\u306E\u5909\u6570\u306B\u4E0D\u6B63\u306A\u300C&\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"An invalid \'&\' was written in other than an argument."};
break;
}
break;
case 65557:
h3=m;
switch(h3){
case 0:
return {S:"\u5F15\u6570\u306B\u521D\u671F\u5316\u5B50\u300C::\u300D\u3092\u8A18\u8FF0\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The initializer \'::\' cannot be written in arguments."};
break;
}
break;
case 65558:
h8=m;
switch(h8){
case 0:
return {S:"\u30E1\u30F3\u30D0\u306B\u521D\u671F\u5316\u5B50\u300C::\u300D\u3092\u8A18\u8FF0\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The initializer \'::\' cannot be written in members."};
break;
}
break;
case 65559:
hD=m;
switch(hD){
case 0:
return {S:"const\u6587\u306B\u306F\u521D\u671F\u5316\u5B50\u300C::\u300D\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The initializer \'::\' must be written in const statements."};
break;
}
break;
case 65560:
hI=m;
switch(hI){
case 0:
return {S:"\u30D6\u30ED\u30C3\u30AF\u306B\u5BFE\u5FDC\u3059\u308B\u300Cend\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"There is no \'end\' corresponding to a block."};
break;
}
break;
case 65561:
hN=m;
switch(hN){
case 0:
return {S:({S:({S:"\u300Cend "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306F\u4E0D\u6B63\u306A\u5F62\u5F0F\u3067\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"\'end "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' is incorrectly formatted."}).S};
break;
}
break;
case 65562:
hS=m;
switch(hS){
case 0:
return {S:({S:({S:"\u30D6\u30ED\u30C3\u30AF\u3068\u5BFE\u5FDC\u3057\u306A\u3044\u4E0D\u6B63\u306A\u300Cend "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u3067\u9589\u3058\u3089\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"Closed with invalid \'end "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' that does not correspond to the block."}).S};
break;
}
break;
case 65563:
hX=m;
switch(hX){
case 0:
return {S:"\u300Cif\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Celse\u300D\u7BC0\u306E\u5F8C\u306B\u4E0D\u6B63\u306A\u300Celif\u300D\u7BC0\u3084\u300Celse\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"In an \'if\' block, an invalid \'elif\' or \'else\' clauses is written after an \'else\' clause."};
break;
}
break;
case 65564:
ic=m;
switch(ic){
case 0:
return {S:"\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Cdefault\u300D\u7BC0\u306E\u5F8C\u306B\u4E0D\u6B63\u306A\u300Ccase\u300D\u7BC0\u3084\u300Cdefault\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"In a \'switch\' block, an invalid \'case\' or \'default\' clauses is written after a \'default\' clause."};
break;
}
break;
case 65565:
ii=m;
switch(ii){
case 0:
return {S:"\u300Ctry\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Cfinally\u300D\u7BC0\u306E\u5F8C\u306B\u4E0D\u6B63\u306A\u300Ccatch\u300D\u7BC0\u3084\u300Cfinally\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"In a \'try\' block, an invalid \'catch\' or \'finally\' clauses is written after a \'finally\' clause."};
break;
}
break;
case 65566:
io=m;
switch(io){
case 0:
return {S:({S:({S:"\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u30D6\u30ED\u30C3\u30AF\u4EE5\u5916\u3067\u4E0D\u6B63\u306A\u300C"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:"\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S}).S};
break;
default:
return {S:({S:({S:"A invalid \'"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\' clause was written outside \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' blocks."}).S}).S};
break;
}
break;
case 65567:
it=m;
switch(it){
case 0:
return {S:"\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Ccase\u300D\u300Cdefault\u300D\u300Cend switch\u300D\u306E\u3044\u305A\u308C\u304B\u304C\u8A18\u8FF0\u3055\u308C\u308B\u3079\u304D\u7B87\u6240\u306B\u305D\u308C\u4EE5\u5916\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"In a \'switch\' block, clauses other than \'case\', \'default\' and \'end switch\' were written."};
break;
}
break;
case 65568:
iy=m;
switch(iy){
case 0:
return {S:({S:({S:"\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u308B\u3079\u304D\u7B87\u6240\u306B\u4E0D\u6B63\u306A\u300C"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S}).S};
break;
default:
return {S:({S:({S:"An invalid \'"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\' was written where \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' should be written."}).S}).S};
break;
}
break;
case 65569:
i3=m;
switch(i3){
case 0:
return {S:({S:({S:"\u300C\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u6F14\u7B97\u5B50\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"An incorrect operator \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' was written."}).S};
break;
}
break;
case 65570:
i8=m;
switch(i8){
case 0:
return {S:({S:({S:"\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 1024\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The string literal \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' is too long. Must be 1024 characters or less."}).S};
break;
}
break;
case 65571:
iD=m;
switch(iD){
case 0:
return {S:({S:({S:"\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u30A8\u30B9\u30B1\u30FC\u30D7\u30B7\u30FC\u30B1\u30F3\u30B9\u300C\\"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"A invalid escape sequence \'\\"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' was written."}).S};
break;
}
break;
case 65572:
iI=m;
switch(iI){
case 0:
return {S:"\u6587\u5B57\u30B3\u30FC\u30C9\u8868\u8A18\u306F\u300C\\u\u300D\u306B\u7D9A\u3044\u3066\u3001\u6570\u5B57\u307E\u305F\u306F\u5927\u6587\u5B57\u30A2\u30EB\u30D5\u30A1\u30D9\u30C3\u30C8\u30674\u6841\u306E16\u9032\u6570\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"Character code representations must be \'\\u\' followed by a 4-digit hexadecimal number in numbers or capital letters."};
break;
}
break;
case 65573:
iN=m;
switch(iN){
case 0:
return {S:"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3082\u3057\u304F\u306F\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u304C\u9589\u3058\u3089\u308C\u3066\u3044\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"A character literal or string literal is not closed."};
break;
}
break;
case 65574:
iS=m;
switch(iS){
case 0:
return {S:({S:({S:"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 1\u6587\u5B57\u5206\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The character literal \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"...\' is too long. A character literal must contain one character."}).S};
break;
}
break;
case 65575:
iX=m;
switch(iX){
case 0:
return {S:"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u304C\u7A7A\u3067\u3059\u3002 1\u6587\u5B57\u5206\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"There is an empty character literal. A character literal must contain one character."};
break;
}
break;
case 65576:
jc=m;
switch(jc){
case 0:
return {S:"\u62EC\u5F27\u300C(\u300D\u306B\u5BFE\u5FDC\u3059\u308B\u300C)\u300D\u304C\u3001\u3042\u308B\u3079\u304D\u5834\u6240\u306B\u5B58\u5728\u3057\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The \')\' corresponding to the parenthesis \'(\' does not exist where it should be."};
break;
}
break;
case 65577:
jh=m;
switch(jh){
case 0:
return {S:({S:({S:"\u6570\u5024\u30EA\u30C6\u30E9\u30EB\u306B\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"An invalid \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' was written in a numeric literal."}).S};
break;
}
break;
case 65578:
jm=m;
switch(jm){
case 0:
return {S:({S:({S:"\u6570\u5024\u30EA\u30C6\u30E9\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 1024\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The numeric literal \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' is too long. Must be 1024 characters or less."}).S};
break;
}
break;
case 65579:
jr=m;
switch(jr){
case 0:
return {S:"16\u9032\u6570\u30EA\u30C6\u30E9\u30EB\u306F\u300C0x\u300D\u304B\u3089\u59CB\u3081\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"Hexadecimal literals must start with \'0x\'."};
break;
}
break;
case 65580:
jw=m;
switch(jw){
case 0:
return {S:"\u6307\u6570\u8868\u8A18\u30EA\u30C6\u30E9\u30EB\u306F\u300Ce+\u300D\u3082\u3057\u304F\u306F\u300Ce-\u300D\u304B\u3089\u59CB\u3081\u3066\u6307\u6570\u90E8\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"Exponential notation literals must start with \'e+\' or \'e-\' and write the exponent part."};
break;
}
break;
case 65581:
j1=m;
switch(j1){
case 0:
return {S:({S:({S:"\u6D6E\u52D5\u5C0F\u6570\u70B9\u30EA\u30C6\u30E9\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u89E3\u91C8\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002 \u5024\u304C\u5927\u304D\u3059\u304E\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The floating point literal \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' could not be interpreted. The value may be too large."}).S};
break;
}
break;
case 65582:
j6=m;
switch(j6){
case 0:
return {S:({S:({S:"\u30D3\u30C3\u30C8\u578B\u30EA\u30C6\u30E9\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u63A5\u5C3E\u8F9E\u306F\u300Cb8\u300D\u300Cb16\u300D\u300Cb32\u300D\u300Cb64\u300D\u306E\u3044\u305A\u308C\u304B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The suffix of bit type literal \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' must be either \'b8\', \'b16\', \'b32\' or \'b64\'."}).S};
break;
}
break;
case 65583:
jB=m;
switch(jB){
case 0:
return {S:({S:({S:"\u6574\u6570\u30EA\u30C6\u30E9\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u30AA\u30FC\u30D0\u30FC\u30D5\u30ED\u30FC\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The integer literal \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' has overflowed."}).S};
break;
}
break;
case 131073:
jG=m;
switch(jG){
case 0:
return {S:"\u300Cmain\u300D\u95A2\u6570\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002 \u30B3\u30F3\u30D1\u30A4\u30EB\u3059\u308B\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u306B\u300Cfunc main()\u300D\u3092\u5B9A\u7FA9\u3057\u3066\u304F\u3060\u3055\u3044\u3002"};
break;
default:
return {S:"\'main\' function does not exist. Define \'func main()\' in the source files to be compiled."};
break;
}
break;
case 131074:
jL=m;
switch(jL){
case 0:
return {S:"\u300Cmain\u300D\u95A2\u6570\u306E\u5B9A\u7FA9\u306F\u300Cfunc main()\u300D\u3068\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The definition of the \'main\' function must be \'func main()\'."};
break;
}
break;
case 131075:
jQ=m;
switch(jQ){
case 0:
return {S:({S:({S:"\u30E1\u30F3\u30D0\u3082\u3057\u304F\u306F\u5909\u6570\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306B\u3001\u300Cme\u300D\u3092\u4ECB\u3055\u305A\u76F4\u63A5\u30A2\u30AF\u30BB\u30B9\u3057\u305F\u304B\u3001\u95A2\u6570\u3092\u8D85\u3048\u3066\u30A2\u30AF\u30BB\u30B9\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The member or variable \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' was accessed directly without \'me\', or accessed beyond the function."}).S};
break;
}
break;
case 131076:
jV=m;
switch(jV){
case 0:
return {S:({S:({S:"\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"@\u300D\u306B\u3064\u3044\u3066\u3001\u81EA\u8EAB\u306E\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u306E\u30B0\u30ED\u30FC\u30D0\u30EB\u8981\u7D20\u3092\u53C2\u7167\u3059\u308B\u3068\u304D\u306F\u3001\u300C@\u300D\u306E\u524D\u306E\u30BD\u30FC\u30B9\u540D\u3092\u7701\u7565\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"For \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"@\', when referring to global elements in its own source file, the source name before the \'@\' must be omitted."}).S};
break;
}
break;
case 131077:
ka=m;
switch(ka){
case 0:
return {S:({S:({S:"\u4ED6\u306E\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u306E\u516C\u958B\u3055\u308C\u3066\u3044\u306A\u3044\u8981\u7D20\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u3092\u53C2\u7167\u3057\u307E\u3057\u305F\u3002\u8981\u7D20\u306E\u5148\u982D\u306B\u300C+\u300D\u304C\u4ED8\u3044\u3066\u3044\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"A non-public element \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' in another souce file was referenced. The element must start with a \'+\'."}).S};
break;
}
break;
case 131078:
kf=m;
switch(kf){
case 0:
return {S:({S:({S:"\u8B58\u5225\u5B50\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u5B9A\u7FA9\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002\u540D\u524D\u3092\u9593\u9055\u3048\u3066\u3044\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The definition of identifier \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' was not be found. The name may have been written incorrectly."}).S};
break;
}
break;
case 131079:
kk=m;
switch(kk){
case 0:
return {S:({S:({S:"\u300Calias "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u5B9A\u7FA9\u304C\u5FAA\u74B0\u3057\u3066\u3044\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The definition of \'alias "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' is circulating."}).S};
break;
}
break;
case 131080:
kp=m;
switch(kp){
case 0:
return {S:({S:({S:"\u300Cclass "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u7D99\u627F\u304C\u5FAA\u74B0\u3057\u3066\u3044\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The inheritance of \'class "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' is circulating."}).S};
break;
}
break;
case 131081:
ku=m;
switch(ku){
case 0:
return {S:({S:({S:"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B\u89AA\u30AF\u30E9\u30B9\u306E\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' of the parent class to override cannot be found."}).S};
break;
}
break;
case 131082:
kz=m;
switch(kz){
case 0:
return {S:({S:({S:"\u30E1\u30F3\u30D0\u540D\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u89AA\u30AF\u30E9\u30B9\u306E\u3082\u306E\u3068\u91CD\u8907\u3057\u3066\u3044\u307E\u3059\u3002 \u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B\u5834\u5408\u306F\u300C*\u300D\u3092\u4ED8\u3051\u3066\u304F\u3060\u3055\u3044\u3002"}).S};
break;
default:
return {S:({S:({S:"The member name \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' is duplicated with that of the parent class. Add \'*\' when overriding."}).S};
break;
}
break;
case 131083:
k4=m;
switch(k4){
case 0:
return {S:({S:({S:"\u95A2\u6570\u4EE5\u5916\u306E\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"Overridden non-function member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 131084:
k9=m;
switch(k9){
case 0:
return {S:({S:({S:"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u305F\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u3068\u30A2\u30AF\u30BB\u30B9\u4FEE\u98FE\u5B50\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The access modifier does not match that of the overridden member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 131085:
kE=m;
switch(kE){
case 0:
return {S:({S:({S:"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u305F\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u3068\u578B\u3082\u3057\u304F\u306F\u5F15\u6570\u540D\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The types or argument names do not match that of the overridden member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 131086:
kJ=m;
switch(kJ){
case 0:
return {S:({S:({S:"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u304C\u8A31\u53EF\u3055\u308C\u3066\u3044\u306A\u3044\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' that is not allowed to be overridden was overridden."}).S};
break;
}
break;
case 131087:
kO=m;
switch(kO){
case 0:
return {S:({S:({S:"\u5217\u6319\u578B\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u306E\u8981\u7D20\u300C%"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:"\u300D\u306E\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u300Cint\u300D\u578B\u306E\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S}).S};
break;
default:
return {S:({S:({S:"The value of the element \'%"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\' of enumeration type \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' must be an \'int\' value that can be made a constant at compile time."}).S}).S};
break;
}
break;
case 131088:
kT=m;
switch(kT){
case 0:
return {S:({S:({S:"\u5217\u6319\u578B\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u306E\u8981\u7D20\u300C%"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:"\u300D\u306E\u5024\u304C\u300Cint\u300D\u578B\u306E\u6709\u52B9\u7BC4\u56F2\u3092\u8D85\u3048\u307E\u3057\u305F\u3002"}).S}).S};
break;
default:
return {S:({S:({S:"The value of the element \'%"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\' of enumeration type \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' exceeds the valid range of \'int\' type."}).S}).S};
break;
}
break;
case 131089:
kY=m;
switch(kY){
case 0:
return {S:({S:({S:"\u5217\u6319\u578B\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u306E\u8981\u7D20\u300C%"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u306E\u5024\u300C"}).S+((v)(((fn)[2]),([129,2]))).S}).S+({S:"\u300D\u304C\u5225\u306E\u8981\u7D20\u306E\u5024\u3068\u91CD\u8907\u3057\u3066\u3044\u307E\u3059\u3002"}).S}).S}).S};
break;
default:
return {S:({S:({S:"The value \'"}).S+((v)(((fn)[2]),([129,2]))).S}).S+({S:({S:({S:"\' of the element \'%"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\' of enumeration type \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' is duplicated with the value of another element."}).S}).S}).S};
break;
}
break;
case 131090:
ld=m;
switch(ld){
case 0:
return {S:({S:({S:"\u5217\u6319\u578B\u5185\u306B\u5B58\u5728\u3057\u306A\u3044\u8981\u7D20\u540D\u300C%"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The element name \'%"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' that does not exist in the enumeration type was written."}).S};
break;
}
break;
case 131091:
li=m;
switch(li){
case 0:
return {S:({S:({S:"\u30B0\u30ED\u30FC\u30D0\u30EB\u5909\u6570\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The value of global variable \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' must be a constant at compile time."}).S};
break;
}
break;
case 131092:
ln=m;
switch(ln){
case 0:
return {S:({S:({S:"\u300Cconst\u300D\u6587\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The value of \'const\' statement \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' must be a constant at compile time."}).S};
break;
}
break;
case 131093:
ls=m;
switch(ls){
case 0:
return {S:({S:({S:"\u5909\u6570\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u578B\u3068\u5024\u306E\u578B\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The type of the variable \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' does not match the value type."}).S};
break;
}
break;
case 131094:
lx=m;
switch(lx){
case 0:
return {S:"\u300Cif\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The conditional expression of the \'if\' block must be \'bool\' type."};
break;
}
break;
case 131095:
l2=m;
switch(l2){
case 0:
return {S:"\u300Celif\u300D\u7BC0\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The conditional expression of the \'elif\' clause must be \'bool\' type."};
break;
}
break;
case 131096:
l7=m;
switch(l7){
case 0:
return {S:"\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306F\u6BD4\u8F03\u53EF\u80FD\u306A\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The conditional expression of the \'switch\' block must be a comparable type."};
break;
}
break;
case 131097:
lC=m;
switch(lC){
case 0:
return {S:"\u300Ccase\u300D\u7BC0\u306E\u578B\u304C\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306E\u578B\u3068\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The type of the \'case\' clause does not match the type of the conditional expression in the \'switch\' block."};
break;
}
break;
case 131098:
lH=m;
switch(lH){
case 0:
return {S:"\u300Cwhile\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The conditional expression of the \'while\' block must be \'bool\' type."};
break;
}
break;
case 131099:
lM=m;
switch(lM){
case 0:
return {S:"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u521D\u671F\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The begin value of the \'for\' block must be \'int\' type."};
break;
}
break;
case 131100:
lR=m;
switch(lR){
case 0:
return {S:"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u7D42\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The end value of the \'for\' block must be \'int\' type."};
break;
}
break;
case 131101:
lW=m;
switch(lW){
case 0:
return {S:"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u5897\u6E1B\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The increase / decrease value of the \'for\' block must be \'int\' type."};
break;
}
break;
case 131102:
mb=m;
switch(mb){
case 0:
return {S:"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u5897\u6E1B\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The increase / decrease value of the \'for\' block must be a constant at compile time."};
break;
}
break;
case 131103:
mg=m;
switch(mg){
case 0:
return {S:"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u5897\u6E1B\u5024\u306F\u300C0\u300D\u4EE5\u5916\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The increase / decrease value of the \'for\' block must be other than \'0\'."};
break;
}
break;
case 131104:
ml=m;
switch(ml){
case 0:
return {S:"\u300Ccatch\u300D\u7BC0\u306E\u6761\u4EF6\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u300Cint\u300D\u578B\u306E\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The condition value in the \'catch\' clause must be an \'int\' value that can be a constant at compile time."};
break;
}
break;
case 131105:
mq=m;
switch(mq){
case 0:
return {S:"\u300Cthrow\u300D\u6587\u306E\u4F8B\u5916\u30B3\u30FC\u30C9\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The exception code for the \'throw\' statement must be \'int\'."};
break;
}
break;
case 131106:
mv=m;
switch(mv){
case 0:
return {S:"\u623B\u308A\u5024\u3092\u8FD4\u3059\u95A2\u6570\u3067\u306F\u300Cret\u300D\u6587\u306F\u5024\u3092\u8FD4\u3055\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"For functions that return a value, \'ret\' statements must return a value."};
break;
}
break;
case 131107:
m0=m;
switch(m0){
case 0:
return {S:"\u300Cret\u300D\u6587\u306E\u5024\u306E\u578B\u304C\u95A2\u6570\u306E\u623B\u308A\u5024\u306E\u578B\u3068\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The type of the \'ret\' statement does not match the return type of the function."};
break;
}
break;
case 131108:
m5=m;
switch(m5){
case 0:
return {S:"\u300Cdo\u300D\u6587\u3067\u6700\u5F8C\u306B\u884C\u3046\u6F14\u7B97\u306F\u300C::\u300D\u6F14\u7B97\u5B50\u3084\u95A2\u6570\u547C\u3073\u51FA\u3057\u306A\u3069\u306E\u526F\u4F5C\u7528\u306E\u3042\u308B\u6F14\u7B97\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The last operation in \'do\' statements must be with side effects such as \'::\' operator or function calls."};
break;
}
break;
case 131109:
mA=m;
switch(mA){
case 0:
return {S:({S:({S:"\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u6587\u306B\u306F\u30D6\u30ED\u30C3\u30AF\u540D\u3092\u6307\u5B9A\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"\'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' statements must be given block names."}).S};
break;
}
break;
case 131110:
mF=m;
switch(mF){
case 0:
return {S:"\u300Cassert\u300D\u6587\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The conditional expression of the \'assert\' statement must be \'bool\' type."};
break;
}
break;
case 131111:
mK=m;
switch(mK){
case 0:
return {S:"\u578B\u3092\u8A18\u8FF0\u3059\u3079\u304D\u3068\u3053\u308D\u306B\u578B\u4EE5\u5916\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"A non-type was written where a type should be written."};
break;
}
break;
case 131112:
mP=m;
switch(mP){
case 0:
return {S:"\u5024\u304C\u8A2D\u5B9A\u3055\u308C\u308B\u3079\u304D\u5834\u6240\u306B\u5024\u304C\u6E21\u3055\u308C\u307E\u305B\u3093\u3067\u3057\u305F\u3002"};
break;
default:
return {S:"No value was passed where some value should be set."};
break;
}
break;
case 131113:
mU=m;
switch(mU){
case 0:
return {S:"\u6F14\u7B97\u5B50\u306E\u578B\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"Incorrect type for operator."};
break;
}
break;
case 131114:
mZ=m;
switch(mZ){
case 0:
return {S:"\u4EE3\u5165\u6F14\u7B97\u5B50\u306E\u5DE6\u8FBA\u5024\u304C\u4EE3\u5165\u53EF\u80FD\u306A\u5909\u6570\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The left value of the assignment operator is not an assignable variable."};
break;
}
break;
case 131115:
ne=m;
switch(ne){
case 0:
return {S:"\u300Cnull\u300D\u306F\u5024\u6BD4\u8F03\u304C\u3067\u304D\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"\'null\' cannot be compared by value."};
break;
}
break;
case 131116:
nj=m;
switch(nj){
case 0:
return {S:({S:({S:"\u300Cenum\u300D\u306E\u8981\u7D20\u540D\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304B\u3089\u578B\u304C\u63A8\u6E2C\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The type could not be inferred from the element name \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' of \'enum\'."}).S};
break;
}
break;
case 131117:
no=m;
switch(no){
case 0:
return {S:"\u300Cnull\u300D\u306F\u300C~\u300D\u6F14\u7B97\u5B50\u3067\u9023\u7D50\u3067\u304D\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"\'null\' cannot be concatenated with the \'~\' operator."};
break;
}
break;
case 131118:
nt=m;
switch(nt){
case 0:
return {S:"0\u3067\u9664\u7B97\u3057\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"Divided by 0."};
break;
}
break;
case 131119:
ny=m;
switch(ny){
case 0:
return {S:"\u300C:$\u300D\u6F14\u7B97\u5B50\u306E\u5DE6\u8FBA\u5024\u3082\u3057\u304F\u306F\u53F3\u8FBA\u5024\u304C\u4EE3\u5165\u53EF\u80FD\u306A\u5909\u6570\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The left or right value of the \':$\' operator is not an assignable variable."};
break;
}
break;
case 131120:
n3=m;
switch(n3){
case 0:
return {S:"\u300C?(,)\u300D\u6F14\u7B97\u5B50\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The conditional expression for the \'?(,)\' operator must be \'bool\'."};
break;
}
break;
case 131121:
n8=m;
switch(n8){
case 0:
return {S:"\u300C?(,)\u300D\u6F14\u7B97\u5B50\u306E\u62EC\u5F27\u5185\u306E2\u3064\u306E\u5024\u306F\u540C\u3058\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The two values in the parenthesis for the \'?(,)\' operator must be the same type."};
break;
}
break;
case 131122:
nD=m;
switch(nD){
case 0:
return {S:"\u300C#\u300D\u6F14\u7B97\u5B50\u306F\u30AF\u30E9\u30B9\u3084\u300Clist\u300D\u300Cdict\u300D\u306A\u3069\u306E\u53C2\u7167\u578B\u306B\u3057\u304B\u4F7F\u3048\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The \'#\' operator can only be used for reference types such as classes, \'list\' and \'dict\'."};
break;
}
break;
case 131123:
nI=m;
switch(nI){
case 0:
return {S:"\u300C#\u300D\u6F14\u7B97\u5B50\u306B\u8A18\u8FF0\u3059\u308B\u914D\u5217\u306E\u8981\u7D20\u6570\u306E\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The number of array elements written in the \'#\' operator must be \'int\'."};
break;
}
break;
case 131124:
nN=m;
switch(nN){
case 0:
return {S:"\u95A2\u6570\u3067\u306A\u3044\u3082\u306E\u3092\u95A2\u6570\u547C\u3073\u51FA\u3057\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"A non-function was called as if it were a function."};
break;
}
break;
case 131125:
nS=m;
switch(nS){
case 0:
return {S:({S:({S:""}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u500B\u306E\u5F15\u6570\u3092\u53D7\u3051\u53D6\u308B\u95A2\u6570\u547C\u3073\u51FA\u3057\u306B"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\u500B\u306E\u5F15\u6570\u304C\u6307\u5B9A\u3055\u308C\u307E\u3057\u305F\u3002 \u95A2\u6570\u306E\u578B\u306F\u300C"}).S+((v)(((fn)[2]),([129,2]))).S}).S+({S:"\u300D\u3067\u3059\u3002"}).S}).S}).S};
break;
default:
return {S:({S:({S:""}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:" arguments were written in the function call that received "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:" arguments. The function type is \'"}).S+((v)(((fn)[2]),([129,2]))).S}).S+({S:"\'"}).S}).S}).S};
break;
}
break;
case 131126:
nX=m;
switch(nX){
case 0:
return {S:({S:({S:"\u95A2\u6570\u547C\u3073\u51FA\u3057\u306E"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u756A\u76EE\u306E\u53C2\u7167\u6E21\u3057\u306E\u5F15\u6570\u306B\u3001\u53C2\u7167\u3092\u53D6\u308C\u306A\u3044\u5024\u304C\u6E21\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"A value that cannot be referenced was passed to the "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"th/st/nd/rd argument, which is a reference argument, of the function call."}).S};
break;
}
break;
case 131127:
oc=m;
switch(oc){
case 0:
return {S:({S:({S:"\u95A2\u6570\u547C\u3073\u51FA\u3057\u306E\u5F15\u6570\u306E\u578B\u304C\u7570\u306A\u308A\u307E\u3059\u3002 "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u756A\u76EE\u306E\u5F15\u6570\u3067\u300C"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u3092\u6307\u5B9A\u3059\u3079\u304D\u3068\u3053\u308D\u306B\u300C"}).S+((v)(((fn)[2]),([129,2]))).S}).S+({S:"\u300D\u304C\u6E21\u3055\u308C\u307E\u3057\u305F\u3002"}).S}).S}).S};
break;
default:
return {S:({S:({S:"The type of arguments of the function call is different. \'"}).S+((v)(((fn)[2]),([129,2]))).S}).S+({S:({S:({S:"\' has been passed where \'"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\' should be written in the "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"th/st/nd/rd argument."}).S}).S}).S};
break;
}
break;
case 131128:
oh=m;
switch(oh){
case 0:
return {S:"\u914D\u5217\u3067\u306A\u3044\u3082\u306E\u306B\u914D\u5217\u30A2\u30AF\u30BB\u30B9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"A non-array was accessed as an array."};
break;
}
break;
case 131129:
om=m;
switch(om){
case 0:
return {S:"\u914D\u5217\u306E\u6DFB\u5B57\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"Array indices must be \'int\'."};
break;
}
break;
case 131130:
or=m;
switch(or){
case 0:
return {S:({S:({S:"\u53C2\u7167\u5148\u306E\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The referenced member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' does not exist."}).S};
break;
}
break;
case 131131:
ow=m;
switch(ow){
case 0:
return {S:({S:({S:"\u516C\u958B\u3055\u308C\u3066\u3044\u306A\u3044\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u3092\u53C2\u7167\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"An unpublished member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' was referenced."}).S};
break;
}
break;
case 131132:
o1=m;
switch(o1){
case 0:
return {S:"\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306E\u8981\u7D20\u306E\u578B\u304C\u4E00\u81F4\u3057\u3066\u3044\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The element types of the array initializer \'[]\' do not match."};
break;
}
break;
case 131133:
o6=m;
switch(o6){
case 0:
return {S:"\u5024\u578B\u306E\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306B\u300Cnull\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"\'null\' was written in the value type array initializer \'[]\'."};
break;
}
break;
case 131134:
oB=m;
switch(oB){
case 0:
return {S:"\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306E\u3059\u3079\u3066\u306E\u8981\u7D20\u304C\u300Cenum\u300D\u306E\u8981\u7D20\u540D\u306E\u305F\u3081\u3001\u578B\u304C\u6C7A\u5B9A\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002 \u3044\u305A\u308C\u304B\u306E\u8981\u7D20\u540D\u3092\u30AD\u30E3\u30B9\u30C8\u3057\u3066\u578B\u3092\u793A\u3057\u3066\u304F\u3060\u3055\u3044\u3002"};
break;
default:
return {S:"The type could not be determined because all elements of the array initializer \'[]\' are element names of \'enum\'. Cast one of the element names to indicate the type."};
break;
}
break;
case 131135:
oG=m;
switch(oG){
case 0:
return {S:"\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306E\u3059\u3079\u3066\u306E\u8981\u7D20\u304C\u300Cnull\u300D\u306E\u305F\u3081\u3001\u578B\u304C\u6C7A\u5B9A\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002 \u3044\u305A\u308C\u304B\u306E\u300Cnull\u300D\u3092\u30AD\u30E3\u30B9\u30C8\u3057\u3066\u578B\u3092\u793A\u3057\u3066\u304F\u3060\u3055\u3044\u3002"};
break;
default:
return {S:"The type could not be determined because all elements of the array initializer \'[]\' are \'null\'. Cast one of \'null\' to indicate the type."};
break;
}
break;
case 131136:
oL=m;
switch(oL){
case 0:
return {S:({S:({S:"\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u306A\u3044\u8981\u7D20\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306B\u30A2\u30AF\u30BB\u30B9\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"Accessed inaccessible element \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 196609:
oQ=m;
switch(oQ){
case 0:
return {S:"\u6210\u529F\u3002"};
break;
default:
return {S:"Success."};
break;
}
break;
case 196610:
oV=m;
switch(oV){
case 0:
return {S:"\u5931\u6557\u3002"};
break;
default:
return {S:"Failure."};
break;
}
break;
case 196611:
pa=m;
switch(pa){
case 0:
return {S:({S:({S:"\u30B3\u30F3\u30D1\u30A4\u30EB\u958B\u59CB: "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u79D2\u3002"}).S};
break;
default:
return {S:({S:({S:"Compilation started: "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"s."}).S};
break;
}
break;
case 196612:
pf=m;
switch(pf){
case 0:
return {S:({S:({S:"\u5B57\u53E5\u69CB\u6587\u89E3\u6790\u5B8C\u4E86: "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u79D2\u3002"}).S};
break;
default:
return {S:({S:({S:"Parsing is complete: "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"s."}).S};
break;
}
break;
case 196613:
pk=m;
switch(pk){
case 0:
return {S:({S:({S:"\u610F\u5473\u89E3\u6790\u5B8C\u4E86: "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u79D2\u3002"}).S};
break;
default:
return {S:({S:({S:"Semantic analysis is complete: "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"s."}).S};
break;
}
break;
case 196614:
pp=m;
switch(pp){
case 0:
return {S:({S:({S:"\u751F\u6210\u51E6\u7406\u5B8C\u4E86: "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u79D2\u3002"}).S};
break;
default:
return {S:({S:({S:"Generation process is complete: "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"s."}).S};
break;
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// _forEach
function e5(pt /*me_*/,pu /*type*/,pv /*callback*/,pw /*data*/){
let D_={F:pv,D:pw,C:true};
if(pu[1]===129&&pu[2]===2)
pt.forEach(function(V_,K_){if(this.C)this.C=this.F({S:K_},V_,this.D)},D_);
else
pt.forEach(function(V_,K_){if(this.C)this.C=this.F(K_,V_,this.D)},D_);
return D_.C;
}
// parseSrc
function e6(px /*key*/,py /*value*/,pz /*data*/){
let p5; // truePath
let pL; // ast
if((py)!==(null)){
(bE)((ae),([133,129,2,134]),(px),(py));
return true;
}
if(!((p3)((px)))){
(D)((4),(null),([(px)]));
return true;
}
((pz).e3)=(false);
(p5)=(null);
if(((px).S.charCodeAt(0))===(0x005C)){
(p5)=({S:({S:(Z).S+((p8)(((p9)((px),([129,2]),(1),(-1))))).S}).S+({S:".kn"}).S});
}
else{
(p5)=({S:({S:(W).S+((p8)((px))).S}).S+({S:".kn"}).S});
}
(af)=((pB)((new pC()),(p5)));
if((af)===(null)){
(D)((5),(null),([(p5)]));
return true;
}
(ag)=(px);
(pF)=(1);
(pG)=(0);
(pH)=(0x0000);
(pI)=(0x0000);
(pJ)=(false);
(ah)=([]);
(pK)=(0);
(ai)=(null);
(pL)=((pM)());
(pO)((af));
(bE)((ae),([133,129,2,134]),(px),(pL));
return true;
}
// searchMain
function e9(){
let pP; // ast
let pT;
let pW; // mainFunc
let qa;
let qe; // mainFunc2
let pQ;
let pS;
let pX;
let pZ;
(pP)=((pQ=(pR)((I),([133,129,2,134]),({S:({S:"\\"}).S+(aa).S}),(pS={$:(pT)},pS)),(pT)=pS.$,pQ));
if((pP)===(null)){
(D)((131073),(null),(null));
return null;
}
(pW)=((pX=(pR)(((pP).pY),([133,129,2,134]),({S:"main"}),(pZ={$:(qa)},pZ)),(qa)=pZ.$,pX));
if(((pW)===(null))||(((pW).qc)!==(256))){
(D)((131073),(null),(null));
return null;
}
(qe)=(pW);
if(((((((qe).qg).L)!==(0))||(((qe).qh)!==(null)))||(((qe).qi)!==(0)))||((((qe).qj).L)!==(0))){
(D)((131074),((qe).ql),(null));
}
return qe;
}
// resolveIdentifier
function eC(qm /*key*/,qn /*value*/,qo /*data*/){
let qp; // scopeRefedItems
let qu; // item
let qx; // ast
let q1; // otherFile
let q2; // ptrAt
let q4; // ptrName
let q5; // foundAst
let q8; // ptrSrc
let qE; // ast2
let qH;
let qM;
let qO; // scope
let qQ; // overFunc
let rc; // ast2
let rf;
let ri; // err
let rn; // kind
let qF;
let qG;
let qK;
let qL;
let rd;
let re;
if(!((qn)instanceof pN)){throw 0xE9170000;}
(qp)=((qn).qq);
(qr)((qp),([130,134]));
while(!((qt)((qp),([130,134])))){
(qu)=((qv)((qp),([130,134])));
(qx)=((qu).qy);
if(!(((qx).qz)===(null))){throw 0xE9170000;}
if(!(((qx).q0)!==(null))){throw 0xE9170000;}
(q1)=(false);
(q2)=((q3)(((qx).q0),([129,2]),(0x0040),(-1)));
(q4)=(((q2)===(-1))?((qx).q0):((p9)(((qx).q0),([129,2]),((q2)+(1)),(-1))));
(q5)=(null);
if((q2)!==(-1)){
(q8)=(null);
if((q2)===(0)){
(q8)=(qm);
}
else{
(q8)=((p9)(((qx).q0),([129,2]),(0),(q2)));
if((q8).S===(qm).S){
(D)((131076),((qx).ql),([(q8)]));
}
(q1)=(true);
}
(qE)=((qF=(pR)((I),([133,129,2,134]),(q8),(qG={$:(qH)},qG)),(qH)=qG.$,qF));
if((qE)!==(null)){
(q5)=((qK=(pR)(((qE).pY),([133,129,2,134]),(q4),(qL={$:(qM)},qL)),(qM)=qL.$,qK));
}
}
else{
(qO)=((qu).qP);
(qQ)=(false);
qS:
while(true){
if(((qO).qU)===(null)){
break qS;
}
if((((qO).qX)!==(null))&&(((qO).qX).S===(q4).S)){
if((((qO).qc)===(256))&&(((qO).q0)!==(null))){
(D)((131075),((qx).ql),([(q4)]));
}
else{
(q5)=(qO);
break qS;
}
}
(rc)=((rd=(pR)(((qO).pY),([133,129,2,134]),(q4),(re={$:(rf)},re)),(rf)=re.$,rd));
if((rc)!==(null)){
(ri)=(false);
if(qQ){
if(((rc).qc)===(7)){
(rn)=((rc).rp);
if((((rn)===(5))||((rn)===(3)))||((rn)===(2))){
(ri)=(true);
}
}
if((!(ri))&&(((rt)(((rc).qc),([9]),(66048)))===(66048))){
(ri)=(true);
}
}
if(((!(ri))&&(((rc).qc)===(256)))&&(((rc).q0)!==(null))){
(ri)=(true);
}
if(ri){
(D)((131075),((qx).ql),([(q4)]));
}
else{
(q5)=(rc);
break qS;
}
}
if(((qO).qc)===(256)){
(qQ)=(true);
}
(qO)=((qO).qU);
}
}
if((q5)!==(null)){
if((q1)&&(!((q5).r5))){
(D)((131077),((qx).ql),([((qx).q0)]));
}
((qx).qz)=(q5);
}
else{
(D)((131078),((qx).ql),([((qx).q0)]));
((qx).qz)=(null);
}
(r8)((qp),([130,134]));
}
return true;
}
// rebuild
function eD(r9 /*mainFunc*/){
let rA; // entry
let rE; // root
let rH;
let rF;
let rG;
(rA)=(null);
(rA)=((rC)((r9)));
(rD)((rA));
(rE)=((rF=(pR)((I),([133,129,2,134]),({S:({S:"\\"}).S+(aa).S}),(rG={$:(rH)},rG)),(rH)=rG.$,rF));
if(!((rE)instanceof pN)){throw 0xE9170000;}
(eN)(((rE).rI),([130,134]),(rA));
(e5)((I),([133,129,2,134]),(rJ),(null));
return rA;
}
// _addList
function eN(rK /*me_*/,rL /*type*/,rM /*item*/){
let n_={P:null,N:null,I:rM};
if(rK.H===null){rK.H=n_;rK.T=n_}else{n_.P=rK.T;rK.T.N=n_;rK.T=n_}
rK.L++;
}
// _addQueue
function eQ(rN /*me_*/,rO /*type*/,rP /*item*/){
rN.push(rP);
}
// _getQueue
function eV(rQ /*me_*/,rR /*type*/){
return rQ.shift();
}
// buildFunc
function eW(rS /*ast*/){
let rT; // info
let rZ; // template
let so; // retType
let sx; // arg
let sz; // idx
let s0; // items
let s2; // item
let s6; // info2
let te; // hasMembers
let th; // arg2
let tl; // members
let ts; // localVarPos
let ty; // localVar
let tz; // info2
let t6; // tmpVar
(rT)=((rU)((rS)));
if((rT).rX){
return;
}
((rT).rX)=(true);
(rZ)=({S:""});
if(((rt)(((rS).qi),([9]),(1)))===(1)){
if(((rt)(((rS).qi),([9]),(32)))===(32)){
(rZ)=({S:"template<typename T_, typename K_, typename V_> "});
}
else if(((rt)(((rS).qi),([9]),(8)))===(8)){
if(((rt)(((rS).qi),([9]),(16)))===(16)){
(rZ)=({S:"template<typename T_, typename C_, typename R_> "});
}
else{
(rZ)=({S:"template<typename T_, typename C_> "});
}
}
else if(((rt)(((rS).qi),([9]),(16)))===(16)){
(rZ)=({S:"template<typename T_, typename R_> "});
}
else if(((rt)(((rS).qi),([9]),(256)))===(256)){
(rZ)=({S:"template<typename T_, typename K_, typename V_> "});
}
else if(((rt)(((rS).qi),([9]),(64)))===(64)){
(rZ)=({S:"template<typename T_, typename C_> "});
}
else if(((rt)(((rS).qi),([9]),(512)))===(512)){
(rZ)=({S:"template<typename T_, typename K_> "});
}
else if(((rt)(((rS).qi),([9]),(1024)))===(1024)){
(rZ)=({S:"template<typename T_, typename V_> "});
}
else{
(rZ)=({S:"template<typename T_> "});
}
}
(so)=(null);
if(((rt)(((rS).qi),([9]),(16)))===(16)){
(so)=({S:"R_"});
}
else if(((rt)(((rS).qi),([9]),(4)))===(4)){
(so)=({S:"T_"});
}
else if(((rt)(((rS).qi),([9]),(64)))===(64)){
(so)=({S:"Array_<C_>*"});
}
else if(((rt)(((rS).qi),([9]),(512)))===(512)){
(so)=({S:"Array_<K_>*"});
}
else if(((rt)(((rS).qi),([9]),(1024)))===(1024)){
(so)=({S:"Array_<V_>*"});
}
else{
(so)=((sw)(((rS).qh)));
}
(sx)=({S:""});
(sz)=(0);
(s0)=((rS).qg);
(qr)((s0),([130,134]));
while(!((qt)((s0),([130,134])))){
(s2)=((qv)((s0),([130,134])));
if((sz)!==(0)){
(sx)=({S:(sx).S+({S:", "}).S});
}
(s6)=((rU)((s2)));
if((((rt)(((rS).qi),([9]),(1)))===(1))&&((sz)===(0))){
if(!((s9)(((s2).sA)))){throw 0xE9170000;}
(sx)=({S:(sx).S+({S:"T_"}).S});
}
else if((((rt)(((rS).qi),([9]),(32)))===(32))&&((sz)===(2))){
if(!((s9)(((s2).sA)))){throw 0xE9170000;}
(sx)=({S:(sx).S+({S:"K_"}).S});
}
else if((((rt)(((rS).qi),([9]),(32)))===(32))&&((sz)===(3))){
if(!((s9)(((s2).sA)))){throw 0xE9170000;}
(sx)=({S:(sx).S+({S:"V_"}).S});
}
else if((((rt)(((rS).qi),([9]),(8)))===(8))&&((sz)===(2))){
if(!((s9)(((s2).sA)))){throw 0xE9170000;}
(sx)=({S:(sx).S+({S:"C_"}).S});
}
else if((((rt)(((rS).qi),([9]),(2)))===(2))&&((sz)===(2))){
if(!((s9)(((s2).sA)))){throw 0xE9170000;}
(sx)=({S:(sx).S+({S:"T_"}).S});
}
else if((((rt)(((rS).qi),([9]),(256)))===(256))&&((sz)===(2))){
if(!((s9)(((s2).sA)))){throw 0xE9170000;}
(sx)=({S:(sx).S+({S:"const void*"}).S});
}
else{
(sx)=({S:(sx).S+({S:({S:({S:""}).S+((v)(((sw)(((s2).sA))),([129,2]))).S}).S+({S:""}).S}).S});
}
if((s2).sP){
(sx)=({S:(sx).S+({S:"*"}).S});
}
(sx)=({S:(sx).S+({S:({S:({S:" "}).S+((v)(((s6).sT),([129,2]))).S}).S+({S:""}).S}).S});
if(((s2).qX)!==(null)){
(sx)=({S:(sx).S+({S:({S:({S:" /*"}).S+((v)(((s2).qX),([129,2]))).S}).S+({S:"*/"}).S}).S});
}
(r8)((s0),([130,134]));
(sz)=((sz)+(1));
}
if(((rS).qX)!==(null)){
(eN)((P),([130,129,2]),({S:({S:({S:"// "}).S+((v)(((rS).qX),([129,2]))).S}).S+({S:"\u000A"}).S}));
}
(eN)((O),([130,129,2]),({S:({S:({S:""}).S+((v)((rZ),([129,2]))).S}).S+({S:({S:({S:"static "}).S+((v)((so),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((rT).sT),([129,2]))).S}).S+({S:({S:({S:"("}).S+((v)((sx),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}).S}));
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)((rZ),([129,2]))).S}).S+({S:({S:({S:"static "}).S+((v)((so),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((rT).sT),([129,2]))).S}).S+({S:({S:({S:"("}).S+((v)((sx),([129,2]))).S}).S+({S:"){\u000A"}).S}).S}).S}).S}));
if(((rt)(((rS).qi),([9]),(4096)))===(4096)){
if((((rS).qj).L)===(1)){
(qr)(((rS).qj),([130,129,2]));
(te)=(false);
if((((rS).qg).L)>(0)){
(qr)(((rS).qg),([130,134]));
(th)=((qv)(((rS).qg),([130,134])));
if(((((th).sA).qz)!==(null))&&(((((th).sA).qz).qc)===(5))){
(tl)=((((th).sA).qz).tm);
(tn)((P),((qv)(((rS).qj),([130,129,2]))),((rS).qg),(tl));
(te)=(true);
}
}
if(!(te)){
(tn)((P),((qv)(((rS).qj),([130,129,2]))),((rS).qg),(null));
}
(eN)((P),([130,129,2]),({S:"}\u000A"}));
}
}
else{
(tr)((P),([130,129,2]));
(ts)=((tt)((P),([130,129,2])));
(tu)(((rS).tv),(null),(null));
(eN)((P),([130,129,2]),({S:"}\u000A"}));
(qr)((P),([130,129,2]));
(tw)((P),([130,129,2]),(ts));
(r8)((P),([130,129,2]));
(qr)((T),([130,134]));
while(!((qt)((T),([130,134])))){
(ty)=((qv)((T),([130,134])));
(tz)=((rU)((ty)));
if(((ty).qX)===(null)){
(t2)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((sw)(((ty).sA))),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((tz).sT),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else{
(t2)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((sw)(((ty).sA))),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((tz).sT),([129,2]))).S}).S+({S:({S:({S:"; // "}).S+((v)(((ty).qX),([129,2]))).S}).S+({S:"\u000A"}).S}).S}).S}));
}
(t4)((T),([130,134]));
}
(qr)((R),([130,134]));
while(!((qt)((R),([130,134])))){
(t6)=((qv)((R),([130,134])));
(t2)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((sw)(((t6).t8))),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((t6).t9),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
(t4)((R),([130,134]));
}
}
}
// buildClass
function fa(tA /*ast*/){
let tB; // parentId
let tH; // info
let tK; // parentOffset
let tO; // parentInfo
let tS; // items
let tU; // item
let tZ; // var_
let ub; // info2
let ue; // ctor
let ui; // ctorInfo
let uk; // cmp
let un; // cmpInfo
let uo; // copy
let uq; // copyInfo
let us; // items
let uu; // item
let ux; // var_
let uy; // info2
(tB)=(null);
if(((tA).qz)!==(null)){
(tB)=((tE)(((tA).qz)));
}
if((tB)===(null)){
(tB)=({S:"Class_"});
}
(tH)=((rU)((tA)));
if(!(((tH).tJ)!==(-1))){throw 0xE9170000;}
(tK)=(0);
if(((tA).qz)===(null)){
(tK)=(0);
}
else{
(tO)=((rU)(((tA).qz)));
if(!(((tO).tJ)!==(-1))){throw 0xE9170000;}
(tK)=((tO).tJ);
}
(eN)((U),([130,129,2]),({S:({S:({S:"classTable_["}).S+((v)((((tH).tJ)*(2)),([0]))).S}).S+({S:({S:({S:"] = "}).S+((v)(((tK)*(2)),([0]))).S}).S+({S:";\u000A"}).S}).S}));
if(((tA).qX)!==(null)){
(eN)((N),([130,129,2]),({S:({S:({S:"// "}).S+((v)(((tA).qX),([129,2]))).S}).S+({S:"\u000A"}).S}));
}
(eN)((N),([130,129,2]),({S:({S:({S:"class "}).S+((v)(((tH).sT),([129,2]))).S}).S+({S:({S:({S:" : public "}).S+((v)((tB),([129,2]))).S}).S+({S:"{\u000Apublic:\u000A"}).S}).S}));
(eN)((N),([130,129,2]),({S:({S:({S:""}).S+((v)(((tH).sT),([129,2]))).S}).S+({S:"();\u000A"}).S}));
(eN)((Q),([130,129,2]),({S:({S:({S:""}).S+((v)(((tH).sT),([129,2]))).S}).S+({S:({S:({S:"::"}).S+((v)(((tH).sT),([129,2]))).S}).S+({S:({S:({S:"(): "}).S+((v)((tB),([129,2]))).S}).S+({S:"()"}).S}).S}).S}));
(tS)=((tA).tm);
(qr)((tS),([130,134]));
while(!((qt)((tS),([130,134])))){
(tU)=((qv)((tS),([130,134])));
if((((tU).tX).qc)===(2)){
(tZ)=((tU).tX);
(ub)=((rU)(((tZ).uc)));
(eN)((Q),([130,129,2]),({S:({S:({S:", "}).S+((v)(((ub).sT),([129,2]))).S}).S+({S:"()"}).S}));
}
(r8)((tS),([130,134]));
}
(eN)((Q),([130,129,2]),({S:"{\u000A"}));
(eN)((Q),([130,129,2]),({S:({S:({S:"Y = "}).S+((v)((((tH).tJ)*(2)),([0]))).S}).S+({S:";\u000A"}).S}));
(ue)=((uf)((tA),({S:"ctor"})));
if((ue)!==(null)){
(ui)=((rU)((ue)));
(eN)((Q),([130,129,2]),({S:({S:({S:""}).S+((v)(((ui).sT),([129,2]))).S}).S+({S:"(this);\u000A"}).S}));
}
(eN)((Q),([130,129,2]),({S:"}\u000A"}));
(uk)=((uf)((tA),({S:"cmp"})));
if((uk)!==(null)){
(un)=((rU)((uk)));
(eN)((N),([130,129,2]),({S:"virtual int64_t cmp_(Class_* t) override;\u000A"}));
(eN)((Q),([130,129,2]),({S:({S:({S:"int64_t "}).S+((v)(((tH).sT),([129,2]))).S}).S+({S:"::cmp_(Class_* t){\u000A"}).S}));
(eN)((Q),([130,129,2]),({S:({S:({S:""}).S+((v)(((tH).sT),([129,2]))).S}).S+({S:({S:({S:"* u = reinterpret_cast<"}).S+((v)(((tH).sT),([129,2]))).S}).S+({S:"*>(t);\u000A"}).S}).S}));
(eN)((Q),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((un).sT),([129,2]))).S}).S+({S:"(this, u);\u000A"}).S}));
(eN)((Q),([130,129,2]),({S:"}\u000A"}));
}
(uo)=((uf)((tA),({S:"_copy"})));
if(!((uo)!==(null))){throw 0xE9170000;}
(uq)=((rU)((uo)));
(eN)((N),([130,129,2]),({S:"virtual Class_* copy_(Class_* t) override;\u000A"}));
(eN)((Q),([130,129,2]),({S:({S:({S:"Class_* "}).S+((v)(((tH).sT),([129,2]))).S}).S+({S:"::copy_(Class_* t){\u000A"}).S}));
(eN)((Q),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((uq).sT),([129,2]))).S}).S+({S:"(this);\u000A"}).S}));
(eN)((Q),([130,129,2]),({S:"}\u000A"}));
(us)=((tA).tm);
(qr)((us),([130,134]));
while(!((qt)((us),([130,134])))){
(uu)=((qv)((us),([130,134])));
if((((uu).tX).qc)===(2)){
(ux)=((uu).tX);
(uy)=((rU)(((ux).uc)));
if((((ux).uc).qX)===(null)){
(eN)((N),([130,129,2]),({S:({S:({S:""}).S+((v)(((sw)((((ux).uc).sA))),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((uy).sT),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else{
(eN)((N),([130,129,2]),({S:({S:({S:""}).S+((v)(((sw)((((ux).uc).sA))),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((uy).sT),([129,2]))).S}).S+({S:({S:({S:"; // "}).S+((v)((((ux).uc).qX),([129,2]))).S}).S+({S:"\u000A"}).S}).S}).S}));
}
}
(r8)((us),([130,134]));
}
(eN)((N),([130,129,2]),({S:"};\u000A"}));
}
// write
function fb(u2 /*resFiles*/){
let u6;
let u8; // writer
let uB; // reader
let uE; // s
let uL; // writer
let u4;
let u5;
if((u4=(pR)((Y),([133,129,2,3]),({S:"merge"}),(u5={$:(u6)},u5)),(u6)=u5.$,u4)){
(u8)=((u9)((new uA()),({S:(V).S+({S:".cpp"}).S}),(false)));
(uB)=((pB)((new pC()),({S:(W).S+({S:"common.h"}).S})));
while(!((uD)((uB)))){
(uE)=((uF)((uB)));
(uG)((u8),({S:(uE).S+({S:"\u000A"}).S}));
}
(pO)((uB));
(uH)((u8),(u2));
(uI)((u8));
}
else{
(uK)(({S:(ab).S+({S:"common.h"}).S}),({S:(W).S+({S:"common.h"}).S}));
(uL)=((u9)((new uA()),({S:(V).S+({S:".cpp"}).S}),(false)));
(uG)((uL),({S:"#include \"common.h\"\u000A"}));
(uH)((uL),(u2));
(uI)((uL));
}
}
// buildFunc
function fh(uM /*ast*/){
let uN; // info
let uT; // arg
let uV; // first
let uW; // items
let uY; // item
let uZ; // info2
let vp; // hasMembers
let vs; // arg2
let vv; // members
let v0; // localVarPos
let v3; // localVar
let v4; // info2
let v9; // tmpVar
(uN)=((uO)((uM)));
if((uN).uR){
return;
}
((uN).uR)=(true);
(uT)=({S:""});
(uV)=(true);
(uW)=((uM).qg);
(qr)((uW),([130,134]));
while(!((qt)((uW),([130,134])))){
(uY)=((qv)((uW),([130,134])));
(uZ)=((uO)((uY)));
if(uV){
(uV)=(false);
}
else{
(uT)=({S:(uT).S+({S:","}).S});
}
(uT)=({S:(uT).S+({S:({S:({S:""}).S+((v)(((uZ).vf),([129,2]))).S}).S+({S:""}).S}).S});
if(((uY).qX)!==(null)){
(uT)=({S:(uT).S+({S:({S:({S:" /*"}).S+((v)(((uY).qX),([129,2]))).S}).S+({S:"*/"}).S}).S});
}
(r8)((uW),([130,134]));
}
if(((uM).qX)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:"// "}).S+((v)(((uM).qX),([129,2]))).S}).S+({S:"\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:({S:({S:"function "}).S+((v)(((uN).vf),([129,2]))).S}).S+({S:({S:({S:"("}).S+((v)((uT),([129,2]))).S}).S+({S:"){\u000A"}).S}).S}));
if(((rt)(((uM).qi),([9]),(4096)))===(4096)){
if((((uM).qj).L)===(1)){
(qr)(((uM).qj),([130,129,2]));
(vp)=(false);
if((((uM).qg).L)>(0)){
(qr)(((uM).qg),([130,134]));
(vs)=((qv)(((uM).qg),([130,134])));
if(((((vs).sA).qz)!==(null))&&(((((vs).sA).qz).qc)===(5))){
(vv)=((((vs).sA).qz).tm);
(vw)((am),((qv)(((uM).qj),([130,129,2]))),((uM).qg),(vv));
(vp)=(true);
}
}
if(!(vp)){
(vw)((am),((qv)(((uM).qj),([130,129,2]))),((uM).qg),(null));
}
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
}
else{
(tr)((am),([130,129,2]));
(v0)=((tt)((am),([130,129,2])));
(v1)(((uM).tv));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
(qr)((am),([130,129,2]));
(tw)((am),([130,129,2]),(v0));
(r8)((am),([130,129,2]));
(qr)((ap),([130,134]));
while(!((qt)((ap),([130,134])))){
(v3)=((qv)((ap),([130,134])));
(v4)=((uO)((v3)));
if(((v3).qX)===(null)){
(t2)((am),([130,129,2]),({S:({S:({S:"let "}).S+((v)(((v4).vf),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
else{
(t2)((am),([130,129,2]),({S:({S:({S:"let "}).S+((v)(((v4).vf),([129,2]))).S}).S+({S:({S:({S:"; // "}).S+((v)(((v3).qX),([129,2]))).S}).S+({S:"\u000A"}).S}).S}));
}
(t4)((ap),([130,134]));
}
(qr)((an),([130,134]));
while(!((qt)((an),([130,134])))){
(v9)=((qv)((an),([130,134])));
(t2)((am),([130,129,2]),({S:({S:({S:"let "}).S+((v)(((v9).vB),([129,2]))).S}).S+({S:";\u000A"}).S}));
(t4)((an),([130,134]));
}
}
}
// buildClass
function fk(vC /*ast*/){
let vD; // parentId
let vJ; // info
let vN; // ctor
let vR; // ctorInfo
let vT; // items
let vV; // item
(vD)=(null);
if(((vC).qz)!==(null)){
(vD)=((vG)(((vC).qz)));
}
if((vD)===(null)){
(vD)=({S:"Object"});
}
(vJ)=((uO)((vC)));
if(((vC).qX)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:"// "}).S+((v)(((vC).qX),([129,2]))).S}).S+({S:"\u000A"}).S}));
}
(vN)=((vO)((vC),({S:"ctor"})));
(eN)((am),([130,129,2]),({S:({S:({S:"function "}).S+((v)(((vJ).vf),([129,2]))).S}).S+({S:"(){\u000A"}).S}));
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)((vD),([129,2]))).S}).S+({S:".call(this);\u000A"}).S}));
if((vN)!==(null)){
(vR)=((uO)((vN)));
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((vR).vf),([129,2]))).S}).S+({S:"(this);\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:"}\u000A"}));
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((vJ).vf),([129,2]))).S}).S+({S:({S:({S:".prototype = Object.create("}).S+((v)((vD),([129,2]))).S}).S+({S:".prototype);\u000A"}).S}).S}));
(vT)=((vC).tm);
(qr)((vT),([130,134]));
while(!((qt)((vT),([130,134])))){
(vV)=((qv)((vT),([130,134])));
if((((vV).tX).qc)===(256)){
(eQ)((aj),([132,134]),((vV).tX));
}
(r8)((vT),([130,134]));
}
}
// write
function fl(vY /*resFiles*/){
let vZ; // writer
let wd;
let wf; // fileName
let wi; // fileName
let wb;
let wc;
(vZ)=(null);
if((wb=(pR)((Y),([133,129,2,3]),({S:"merge"}),(wc={$:(wd)},wc)),(wd)=wc.$,wb)){
(wf)=((co)((V)));
(vZ)=((u9)((new uA()),({S:(V).S+({S:".html"}).S}),(false)));
(uG)((vZ),({S:"<!DOCTYPE html>\u000A"}));
(uG)((vZ),({S:"<html>\u000A"}));
(uG)((vZ),({S:"\u0009<head>\u000A"}));
(uG)((vZ),({S:"\u0009\u0009<meta charset=\"utf-8\" />\u000A"}));
(uG)((vZ),({S:({S:({S:"\u0009\u0009<title>"}).S+((v)((wf),([129,2]))).S}).S+({S:"</title>\u000A"}).S}));
(uG)((vZ),({S:"\u0009\u0009<script type=\"text/javascript\">\u000A"}));
(wg)((vZ),(vY));
(uG)((vZ),({S:"\u0009\u0009</script>\u000A"}));
(uG)((vZ),({S:"\u0009</head>\u000A"}));
(uG)((vZ),({S:"\u0009<body>\u000A"}));
(uG)((vZ),({S:"\u0009</body>\u000A"}));
(uG)((vZ),({S:"</html>\u000A"}));
(uI)((vZ));
}
else{
(vZ)=((u9)((new uA()),({S:(V).S+({S:".js"}).S}),(false)));
(wg)((vZ),(vY));
(uI)((vZ));
(wi)=((co)((V)));
(vZ)=((u9)((new uA()),({S:(V).S+({S:".html"}).S}),(false)));
(uG)((vZ),({S:"<!DOCTYPE html>\u000A"}));
(uG)((vZ),({S:"<html>\u000A"}));
(uG)((vZ),({S:"\u0009<head>\u000A"}));
(uG)((vZ),({S:"\u0009\u0009<meta charset=\"utf-8\" />\u000A"}));
(uG)((vZ),({S:({S:({S:"\u0009\u0009<script src=\""}).S+((v)((wi),([129,2]))).S}).S+({S:".js\" type=\"text/javascript\"></script>\u000A"}).S}));
(uG)((vZ),({S:({S:({S:"\u0009\u0009<title>"}).S+((v)((wi),([129,2]))).S}).S+({S:"</title>\u000A"}).S}));
(uG)((vZ),({S:"\u0009</head>\u000A"}));
(uG)((vZ),({S:"\u0009<body>\u000A"}));
(uG)((vZ),({S:"\u0009</body>\u000A"}));
(uG)((vZ),({S:"</html>\u000A"}));
(uI)((vZ));
}
}
// isCorrectSrcName
function p3(wj /*name*/){
let wk; // idx
(wk)=(0);
if(((wk)<((wj).S.length))&&(((wj).S.charCodeAt(wk))===(0x005C))){
(wk)=((wk)+(1));
}
while(true){
if(((wk)>=((wj).S.length))||(!((((0x0061)<=((wj).S.charCodeAt(wk)))&&(((wj).S.charCodeAt(wk))<=(0x007A)))||(((wj).S.charCodeAt(wk))===(0x005F))))){
return false;
}
ws:
while(true){
(wk)=((wk)+(1));
if((wk)>=((wj).S.length)){
return true;
}
if(((((0x0061)<=((wj).S.charCodeAt(wk)))&&(((wj).S.charCodeAt(wk))<=(0x007A)))||(((wj).S.charCodeAt(wk))===(0x005F)))||(((0x0030)<=((wj).S.charCodeAt(wk)))&&(((wj).S.charCodeAt(wk))<=(0x0039)))){
continue ws;
}
if(((wj).S.charCodeAt(wk))===(0x005C)){
(wk)=((wk)+(1));
break ws;
}
return false;
}
}
}
// replacePath
function p8(w1 /*path*/){
let w2; // r
let w5;
let w6;
let w7;
let w8;
(w2)=({S:"\0".repeat((w1).S.length)});
w4:
for(w5=(0),w6=(((w1).S.length)-(1));w5<=w6;w5+=(1)){
(w2).S=(w7=(w5),(w2).S.slice(0,w7)+String.fromCharCode((((w1).S.charCodeAt(w5))===(0x005C))?(0x002F):((w1).S.charCodeAt(w5)))+(w2).S.slice(w7+1));
}
return w2;
}
// _sub
function p9(w9 /*me_*/,wA /*type*/,wB /*start*/,wC /*len*/){
if(wA[0]===129&&wA[1]===2)
return {S:wC===-1?w9.S.slice(wB):w9.S.slice(wB,wB+wC)};
else
return wC===-1?w9.slice(wB):w9.slice(wB,wB+wC);
}
// makeReader
function pB(wD /*me2*/,wE /*path*/){
let f_=null,p_=wE.S;
if(O_&&O_.readFile)f_=O_.readFile(p_);
if(f_===null){
if(p_.length>=4&&p_[0]==="r"&&p_[1]==="e"&&p_[2]==="s"&&p_[3]==="/")
f_=F_(p_,true);
else{
}
}
if(f_===null)return null;
wD.wF={F:f_,I:0};
return wD;
}
// parseRoot
function pM(){
let wG; // ast
let wN; // c
let wS; // item
let wT; // itemPublic
let wY; // row
let wZ; // col
let xa; // id
let xd;
(wG)=(new pN());
(wH)((wG),(1),((wI)((ag),(1),(1))),(null),(false));
((wG).qq)=({L:0,H:null,T:null,P:null});
((wG).rI)=({L:0,H:null,T:null,P:null});
(ai)=((wG).qq);
((wG).pY)=(new Map());
(wJ)((ah),([131,134]),(wG));
(pH)=(0x000A);
(pH)=((wK)());
wM:
while(true){
(wN)=((wK)());
if((wN)===(0x0000)){
break wM;
}
if((wN)===(0x000A)){
continue wM;
}
(wS)=(null);
(wT)=(false);
if((wN)===(0x002B)){
(wT)=(true);
}
else{
(pH)=(wN);
}
(wY)=(pF);
(wZ)=(pG);
(xa)=((xb)((true),(false)));
xd=xa;
if(xd.S===({S:"func"}).S){
(wS)=((xf)((null),(false)));
}
else if(xd.S===({S:"var"}).S){
(wS)=((xh)((1),(null)));
}
else if(xd.S===({S:"const"}).S){
(wS)=((xj)());
}
else if(xd.S===({S:"alias"}).S){
(wS)=((xm)());
}
else if(xd.S===({S:"include"}).S){
}
else if(xd.S===({S:"class"}).S){
(wS)=((xq)());
}
else if(xd.S===({S:"enum"}).S){
(wS)=((xs)());
}
else{(D)((65547),((wI)((ag),(wY),(wZ))),([(xa)]));
(xv)(((xw)()));
continue wM;
}
if(((wS).qc)===(2)){
(((wS).uc).r5)=(wT);
}
else if(((wS).qc)===(3)){
(((wS).x0).r5)=(wT);
}
else{
((wS).r5)=(wT);
}
(eN)(((wG).rI),([130,134]),(wS));
}
(x2)((ah),([131,134]));
return wG;
}
// _getDict
function pR(x3 /*me_*/,x4 /*type*/,x5 /*key*/,x6 /*existed*/){
let r_;
if(x4[1]===129&&x4[2]===2)
r_=x3.get(x5.S);
else
r_=x3.get(x5);
if(!(x6.$=r_!==undefined)){
switch(x4){
case 0:
case 1:
case 2:
case 4:
case 5:
case 6:
case 7:
case 9:
return 0;
case 3:
return false;
default:
return null;
}
}
return r_;
}
// _head
function qr(x7 /*me_*/,x8 /*type*/){
x7.P=x7.H;
}
// _term
function qt(x9 /*me_*/,xA /*type*/){
return x9.P===null;
}
// _getList
function qv(xB /*me_*/,xC /*type*/){
return xB.P.I;
}
// _findArray
function q3(xD /*me_*/,xE /*type*/,xF /*item*/,xG /*start*/){
if(xE[0]===129&&xE[1]===2)
return xD.S.indexOf(String.fromCharCode(xF),xG===-1?0:xG);
else
return xD.indexOf(xF,xG===-1?0:xG);
}
// _and
function rt(xH /*me_*/,xI /*type*/,xJ /*n*/){
return xH&xJ;
}
// _next
function r8(xK /*me_*/,xL /*type*/){
xK.P=xK.P.N;
}
// makeEntryPoint
function rC(xM /*mainFunc*/){
let xN; // pos
let xO; // entry
let xR; // try_
let xW; // var_
let xY; // type
let ye; // block_
let yk; // block_
let yn; // funcs
let yr; // do_
let yu; // call
let y0; // ref
let y4; // catch_
let y8; // block_
let yB; // exprs
let yE; // expr
let yK; // type
let yO; // expr
let yQ; // type
let yT; // do_
let yV; // call
let yX; // ref_
let yZ; // excpt
let ze; // ref_
let zh; // funcs
let zk; // do_
let zm; // call
let zo; // ref
(xN)=((wI)(({S:"kuin"}),(1),(1)));
(xO)=(new c7());
(xP)((xO),(256),(xN));
((xO).qX)=({S:"$"});
((xO).qi)=(0);
((xO).qj)=({L:0,H:null,T:null,P:null});
((xO).qg)=({L:0,H:null,T:null,P:null});
((xO).qh)=(null);
((xO).tv)=({L:0,H:null,T:null,P:null});
(xR)=(new xS());
(xP)((xR),(66051),(xN));
(xW)=(new ro());
(xP)((xW),(7),(xN));
((xW).qX)=({S:"$"});
((xW).rp)=(3);
((xW).sP)=(false);
(xY)=(new xZ());
(xP)((xY),(1026),(xN));
((xY).ya)=(0);
((xW).sA)=(xY);
((xW).yb)=(null);
((xR).yc)=(xW);
(ye)=(new yf());
(xP)((ye),(66052),(xN));
((ye).qX)=({S:"$"});
((ye).yc)=(null);
((ye).yg)=({L:0,H:null,T:null,P:null});
((xR).yh)=(ye);
((xR).yi)=({L:0,H:null,T:null,P:null});
(yk)=(new yf());
(xP)((yk),(66052),(xN));
((yk).qX)=({S:"$"});
((yk).yc)=(null);
((yk).yg)=({L:0,H:null,T:null,P:null});
((xR).yl)=(yk);
(yn)=({L:0,H:null,T:null,P:null});
(eN)((yn),([130,134]),((yo)(({S:"kuin"}),({S:"_init"}),(false))));
(eN)((yn),([130,134]),((yo)(({S:"kuin"}),({S:"_initVars"}),(false))));
(eN)((yn),([130,134]),(xM));
(qr)((yn),([130,134]));
while(!((qt)((yn),([130,134])))){
(yr)=(new ys());
(xP)((yr),(528),(xN));
(yu)=(new yv());
(yx)((yu),(2057),(xN));
((yu).yy)=({L:0,H:null,T:null,P:null});
(y0)=(new yw());
(yx)((y0),(2062),(xN));
((y0).qz)=((qv)((yn),([130,134])));
((yu).y1)=(y0);
((yr).y2)=(yu);
(eN)((((xR).yh).yg),([130,134]),(yr));
(r8)((yn),([130,134]));
}
(y4)=(new y5());
(xP)((y4),(524),(xN));
((y4).y6)=({L:0,H:null,T:null,P:null});
(y8)=(new yf());
(xP)((y8),(66052),(xN));
((y8).qX)=({S:"$"});
((y8).yc)=(null);
((y8).yg)=({L:0,H:null,T:null,P:null});
((y4).y9)=(y8);
(yB)=(new yC());
(yE)=(new yF());
(yx)((yE),(67585),(xN));
((yE).yH)=(1);
((yE).yI)=(0x0000000000000000);
(yK)=(new xZ());
(xP)((yK),(1026),(xN));
((yK).ya)=(0);
((yE).yL)=(yK);
((yB).yM)=(yE);
(yO)=(new yF());
(yx)((yO),(67585),(xN));
((yO).yH)=(1);
((yO).yI)=(0x00000000FFFFFFFF);
(yQ)=(new xZ());
(xP)((yQ),(1026),(xN));
((yQ).ya)=(0);
((yO).yL)=(yQ);
((yB).yR)=(yO);
(eN)(((y4).y6),([130,134]),(yB));
(yT)=(new ys());
(xP)((yT),(528),(xN));
(yV)=(new yv());
(yx)((yV),(2057),(xN));
((yV).yy)=({L:0,H:null,T:null,P:null});
(yX)=(new yw());
(yx)((yX),(2062),(xN));
((yX).qz)=((yo)(({S:"kuin"}),({S:"_err"}),(false)));
((yV).y1)=(yX);
(yZ)=(new za());
((yZ).zb)=(false);
((yZ).zc)=(false);
(ze)=(new yw());
(yx)((ze),(2062),(xN));
((ze).qz)=((xR).yc);
((yZ).zf)=(ze);
(eN)(((yV).yy),([130,134]),(yZ));
((yT).y2)=(yV);
(eN)((((y4).y9).yg),([130,134]),(yT));
(eN)(((xR).yi),([130,134]),(y4));
(zh)=({L:0,H:null,T:null,P:null});
(eN)((zh),([130,134]),((yo)(({S:"kuin"}),({S:"_finVars"}),(false))));
(eN)((zh),([130,134]),((yo)(({S:"kuin"}),({S:"_fin"}),(false))));
(qr)((zh),([130,134]));
while(!((qt)((zh),([130,134])))){
(zk)=(new ys());
(xP)((zk),(528),(xN));
(zm)=(new yv());
(yx)((zm),(2057),(xN));
((zm).yy)=({L:0,H:null,T:null,P:null});
(zo)=(new yw());
(yx)((zo),(2062),(xN));
((zo).qz)=((qv)((zh),([130,134])));
((zm).y1)=(zo);
((zk).y2)=(zm);
(eN)((((xR).yl).yg),([130,134]),(zk));
(r8)((zh),([130,134]));
}
(eN)(((xO).tv),([130,134]),(xR));
return xO;
}
// rebuildFunc
function rD(zp /*ast*/){
let zt; // items
if(((zp).zr)!==(null)){
return;
}
((zp).zr)=(zp);
(zt)=((zp).qg);
(qr)((zt),([130,134]));
while(!((qt)((zt),([130,134])))){
(zv)(((qv)((zt),([130,134]))));
(r8)((zt),([130,134]));
}
if(((zp).qh)!==(null)){
((zp).qh)=((zy)(((zp).qh),(null)));
}
((zp).tv)=((zz)(((zp).tv),((zp).qh),(zp)));
}
// rebuildRoot
function rJ(z0 /*key*/,z1 /*value*/,z2 /*data*/){
let z3; // ast
let z6; // initVarsFunc
let z7; // finVarsFunc
let z8; // items
let zA; // item
let zE; // var_
let zI; // do_
let zK; // assign
let zO; // ref
let zV; // do_
let zX; // assign
let zZ; // ref
(z3)=(z1);
if(((z3).zr)!==(null)){
return true;
}
((z3).zr)=(z3);
(z6)=((yo)(({S:"kuin"}),({S:"_initVars"}),(false)));
(z7)=((yo)(({S:"kuin"}),({S:"_finVars"}),(false)));
(z8)=((z3).rI);
(qr)((z8),([130,134]));
while(!((qt)((z8),([130,134])))){
(zA)=((qv)((z8),([130,134])));
if(((zA).qc)===(256)){
(rD)((zA));
}
else if(((zA).qc)===(2)){
(zE)=(zA);
if(!((((zE).uc).rp)===(1))){throw 0xE9170000;}
if((((zE).uc).yb)!==(null)){
(((zE).uc).yb)=((zH)((((zE).uc).yb),(false)));
(zI)=(new ys());
(xP)((zI),(528),((z3).ql));
(zK)=(new zL());
(yx)((zK),(2050),((z3).ql));
((zK).zM)=(0);
(zO)=(new yw());
(yx)((zO),(2062),((z3).ql));
((zO).yL)=(((zE).uc).sA);
((zO).qz)=((zE).uc);
((zK).zP)=(zO);
((zK).zQ)=(((zE).uc).yb);
((zI).y2)=(zK);
(eN)(((z6).tv),([130,134]),((zR)((zI),(null),(null))));
}
if(((((zE).uc).sA)!==(null))&&((zT)((((zE).uc).sA)))){
(zV)=(new ys());
(xP)((zV),(528),((z3).ql));
(zX)=(new zL());
(yx)((zX),(2050),((z3).ql));
((zX).zM)=(0);
(zZ)=(new yw());
(yx)((zZ),(2062),((z3).ql));
((zZ).yL)=(((zE).uc).sA);
((zZ).qz)=((zE).uc);
((zX).zP)=(zZ);
((zX).zQ)=((Aa)(((z3).ql)));
((zV).y2)=(zX);
(eN)(((z7).tv),([130,134]),((zR)((zV),(null),(null))));
}
}
else{
if(!((((((zA).qc)===(3))||(((zA).qc)===(4)))||(((zA).qc)===(5)))||(((zA).qc)===(6)))){throw 0xE9170000;}
}
(r8)((z8),([130,134]));
}
return true;
}
// getInfo
function rU(Ac /*ast*/){
let Af; // info
if((((Ac).zr)===(null))||((((Ac).zr).qc)!==(268435456))){
(Af)=(new rV());
((Af).qc)=(268435456);
((Af).sT)=((Ag)());
if(((((rt)(((Ac).qc),([9]),(66048)))===(66048))&&(((Ac).qX)!==(null)))&&(((Ac).qX).S!==({S:"$"}).S)){
((Af).Aj)=((Ag)());
if(((rt)(((Ac).qc),([9]),(16843264)))===(16843264)){
((Af).Am)=((Ag)());
}
else{
((Af).Am)=(null);
}
}
else{
((Af).Aj)=(null);
((Af).Am)=(null);
}
((Af).tJ)=(-1);
((Af).rX)=(false);
((Af).Ap)=(false);
((Af).Aq)=(false);
((Ac).zr)=(Af);
}
return (Ac).zr;
}
// getType
function sw(Ar /*type*/){
let Av;
let A4; // func_
let A6; // id
let A9; // arg
let AA; // first
let AB; // items
let AE; // item
let AR; // gen
let AU;
let Bc; // dict_
let Bh; // prim
let Bj;
let Bq; // ref
let Bt; // info
if((Ar)===(null)){
return {S:"void"};
}
Av=(Ar).qc;
switch(Av){
case 66561:
return {S:({S:({S:"Array_<"}).S+((v)(((sw)(((Ar).Az))),([129,2]))).S}).S+({S:">*"}).S};
break;
case 1025:
return {S:({S:({S:"uint"}).S+((v)((((Ar).A2)*(8)),([0]))).S}).S+({S:"_t"}).S};
break;
case 66562:
(A4)=(Ar);
(A6)=((Ag)());
(eN)((O),([130,129,2]),({S:({S:({S:"typedef "}).S+((v)(((sw)(((A4).A7))),([129,2]))).S}).S+({S:({S:({S:"(*"}).S+((v)((A6),([129,2]))).S}).S+({S:")("}).S}).S}));
(A9)=({S:""});
(AA)=(true);
(AB)=((A4).AC);
(qr)((AB),([130,134]));
while(!((qt)((AB),([130,134])))){
(AE)=((qv)((AB),([130,134])));
if(AA){
(AA)=(false);
}
else{
(A9)=({S:(A9).S+({S:", "}).S});
}
(A9)=({S:(A9).S+({S:({S:({S:""}).S+((v)(((sw)(((AE).AL))),([129,2]))).S}).S+({S:""}).S}).S});
if((AE).AN){
(A9)=({S:(A9).S+({S:"*"}).S});
}
(r8)((AB),([130,134]));
}
(eN)((O),([130,129,2]),({S:({S:({S:""}).S+((v)((A9),([129,2]))).S}).S+({S:");\u000A"}).S}));
return A6;
break;
case 66563:
(AR)=(Ar);
AU=(AR).AV;
switch(AU){
case 0:
return {S:({S:({S:"List_<"}).S+((v)(((sw)(((AR).AX))),([129,2]))).S}).S+({S:">*"}).S};
break;
case 1:
return {S:({S:({S:"Stack_<"}).S+((v)(((sw)(((AR).AX))),([129,2]))).S}).S+({S:">*"}).S};
break;
case 2:
return {S:({S:({S:"Queue_<"}).S+((v)(((sw)(((AR).AX))),([129,2]))).S}).S+({S:">*"}).S};
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
break;
case 66564:
(Bc)=(Ar);
return {S:({S:({S:"Dict_<"}).S+((v)(((sw)(((Bc).Be))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sw)(((Bc).Bf))),([129,2]))).S}).S+({S:">*"}).S}).S};
break;
case 1026:
(Bh)=(Ar);
Bj=(Bh).ya;
switch(Bj){
case 0:
return {S:"int64_t"};
break;
case 1:
return {S:"double"};
break;
case 2:
return {S:"char16_t"};
break;
case 3:
return {S:"bool"};
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
break;
case 66565:
(Bq)=((Ar).qz);
if(((Bq).qc)===(5)){
(tE)((Bq));
(Bt)=((rU)((Bq)));
return {S:((Bt).sT).S+({S:"*"}).S};
}
else{
if(!(((Bq).qc)===(6))){throw 0xE9170000;}
return {S:"int64_t"};
}
break;
case 1027:
if(!(false)){throw 0xE9170000;}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// isInt
function s9(Bx /*type*/){
return (((Bx).qc)===(1026))&&(((Bx).ya)===(0));
}
// write
function tn(By /*codes*/,Bz /*attr*/,B0 /*args*/,B1 /*members*/){
let B3;
let B5; // x
let B7; // x
let B9; // class_
let BB; // me_
let BC; // key
let BD; // item
let BF; // me_
let BG; // item
let BI; // me_
let BJ; // item
let BL; // me_
let BM; // item
let BO; // me_
let BP; // n
let BR; // x
let BT; // x
let BV; // x
let BX; // x
let BZ; // x
let Cc; // x
let Ce; // x
let Cg; // me_
let Ci; // x
let Cj; // y
let Ck; // centerX
let Cl; // centerY
let Cn; // x
let Cp; // me_
let Cq; // value
let Cs; // me_
let Ct; // item
let Cu; // start
let Cw; // me_
let Cx; // item
let Cz; // me_
let C0; // item
let C1; // start
let C3; // x
let C5; // me_
let C6; // callback
let C7; // data
let C9; // me_
let CA; // key
let CB; // existed
let CD; // me_
let CF; // me_
let CH; // me_
let CJ; // me_
let CL; // me_
let CN; // me_
let CO; // item
let CQ; // x
let CR; // y
let CS; // centerX
let CT; // centerY
let CV; // x
let CX; // me_
let CY; // offset
let Da; // me_
let Dc; // me_
let De; // me_
let Df; // n
let Dh; // me_
let Dj; // me_
let Dl; // me_
let Dn; // min
let Do; // max
let Dq; // min
let Dr; // max
let Dt; // me_
let Du; // n
let Dw; // me_
let Dx; // n
let Dz; // me_
let D0; // n
let D2; // x
let D4; // x
let D6; // x
let D8; // me_
let D9; // start
let DA; // len
let DD; // me_
let DF; // x
let DH; // x
let DJ; // me_
let DL; // me_
let DN; // me_
let DO; // success
let DQ; // me_
let DR; // success
let DT; // me_
let DU; // success
let DW; // me_
let DY; // me_
let DZ; // n
let Eb; // str
let Ed; // dst
let Ee; // src
let Eg; // path
let Ei; // path
let Ej; // recursion
let Ek; // callback
let El; // data
let En; // me_
let Eo; // path
let Ep; // handle
let Es; // me_
let Et; // path
let Eu; // append
let Ev; // handle
let Ex; // me_
let Ey; // handle
let E0; // me_
let E1; // handle
let E3; // me_
let E4; // handle
let E6; // me_
let E7; // origin
let E8; // pos
let E9; // handle
let EB; // me_
let EC; // handle
let EE; // me_
let EF; // handle
let EH; // me_
let EI; // handle
let EK; // me_
let EL; // origin
let EM; // pos
let EN; // handle
let EP; // me_
let EQ; // n
let ER; // handle
let ET; // me_
let EU; // n
let EV; // handle
B3=Bz;
if(B3.S===({S:"acos"}).S){
(qr)((B0),([130,134]));
(B5)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return std::acos("}).S+((v)(((B5).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"acosh"}).S){
(qr)((B0),([130,134]));
(B7)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return std::acosh("}).S+((v)(((B7).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"addr"}).S){
(qr)((B0),([130,134]));
(B9)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return reinterpret_cast<uint64_t>("}).S+((v)(((B9).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"addDict"}).S){
(qr)((B0),([130,134]));
(BB)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(BC)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(BD)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:""}).S+((v)(((BB).sT),([129,2]))).S}).S+({S:({S:({S:"->Add("}).S+((v)(((BC).sT),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((BD).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
}
else if(B3.S===({S:"addList"}).S){
(qr)((B0),([130,134]));
(BF)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(BG)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:""}).S+((v)(((BF).sT),([129,2]))).S}).S+({S:({S:({S:"->B.push_back("}).S+((v)(((BG).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(B3.S===({S:"addQueue"}).S){
(qr)((B0),([130,134]));
(BI)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(BJ)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:""}).S+((v)(((BI).sT),([129,2]))).S}).S+({S:({S:({S:"->B.push("}).S+((v)(((BJ).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(B3.S===({S:"addStack"}).S){
(qr)((B0),([130,134]));
(BL)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(BM)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:""}).S+((v)(((BL).sT),([129,2]))).S}).S+({S:({S:({S:"->B.push("}).S+((v)(((BM).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(B3.S===({S:"and"}).S){
(qr)((B0),([130,134]));
(BO)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(BP)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((BO).sT),([129,2]))).S}).S+({S:({S:({S:" & "}).S+((v)(((BP).sT),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(B3.S===({S:"asin"}).S){
(qr)((B0),([130,134]));
(BR)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return std::asin("}).S+((v)(((BR).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"asinh"}).S){
(qr)((B0),([130,134]));
(BT)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return std::asinh("}).S+((v)(((BT).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"atan"}).S){
(qr)((B0),([130,134]));
(BV)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return std::atan("}).S+((v)(((BV).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"atanh"}).S){
(qr)((B0),([130,134]));
(BX)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return std::atanh("}).S+((v)(((BX).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"ceil"}).S){
(qr)((B0),([130,134]));
(BZ)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return std::ceil("}).S+((v)(((BZ).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"cmdLine"}).S){
(eN)((By),([130,129,2]),({S:"Array_<Array_<char16_t>*>* a_ = new Array_<Array_<char16_t>*>();\u000A"}));
(eN)((By),([130,129,2]),({S:"a_->L = argc_;\u000A"}));
(eN)((By),([130,129,2]),({S:"a_->B = new Array_<char16_t>*[static_cast<size_t>(argc_)];\u000A"}));
(eN)((By),([130,129,2]),({S:"for (int64_t i_ = 0; i_ < argc_; i_++){\u000A"}));
(eN)((By),([130,129,2]),({S:"std::string s_ = argv_[i_];\u000A"}));
(eN)((By),([130,129,2]),({S:"const std::u16string t_ = utf8ToUtf16_(s_);\u000A"}));
(eN)((By),([130,129,2]),({S:"a_->B[i_] = new Array_<char16_t>();\u000A"}));
(eN)((By),([130,129,2]),({S:"a_->B[i_]->L = static_cast<int64_t>(t_.size());\u000A"}));
(eN)((By),([130,129,2]),({S:"a_->B[i_]->B = new char16_t[t_.size() + 1];\u000A"}));
(eN)((By),([130,129,2]),({S:"std::memcpy(a_->B[i_]->B, t_.c_str(), sizeof(char16_t) * (t_.size() + 1));\u000A"}));
(eN)((By),([130,129,2]),({S:"}\u000A"}));
(eN)((By),([130,129,2]),({S:"return a_;\u000A"}));
}
else if(B3.S===({S:"cos"}).S){
(qr)((B0),([130,134]));
(Cc)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return std::cos("}).S+((v)(((Cc).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"cosh"}).S){
(qr)((B0),([130,134]));
(Ce)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return std::cosh("}).S+((v)(((Ce).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"del"}).S){
(qr)((B0),([130,134]));
(Cg)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"auto& i_ = "}).S+((v)(((Cg).sT),([129,2]))).S}).S+({S:"->I++;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:""}).S+((v)(((Cg).sT),([129,2]))).S}).S+({S:"->B.erase(i_);\u000A"}).S}));
}
else if(B3.S===({S:"dist"}).S){
(qr)((B0),([130,134]));
(Ci)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(Cj)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(Ck)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(Cl)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return std::hypot("}).S+((v)(((Ci).sT),([129,2]))).S}).S+({S:({S:({S:" - "}).S+((v)(((Ck).sT),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((Cj).sT),([129,2]))).S}).S+({S:({S:({S:" - "}).S+((v)(((Cl).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}).S}));
}
else if(B3.S===({S:"exp"}).S){
(qr)((B0),([130,134]));
(Cn)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return std::exp("}).S+((v)(((Cn).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"fill"}).S){
(qr)((B0),([130,134]));
(Cp)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(Cq)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"for(int64_t i_ = 0; i_ < "}).S+((v)(((Cp).sT),([129,2]))).S}).S+({S:({S:({S:"->L; i_++) "}).S+((v)(((Cp).sT),([129,2]))).S}).S+({S:({S:({S:"->B[i_] = "}).S+((v)(((Cq).sT),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
}
else if(B3.S===({S:"findArray"}).S){
(qr)((B0),([130,134]));
(Cs)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(Ct)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(Cu)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Cu).sT),([129,2]))).S}).S+({S:({S:({S:" == -1) "}).S+((v)(((Cu).sT),([129,2]))).S}).S+({S:" = 0;\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Cu).sT),([129,2]))).S}).S+({S:" < 0) return -1;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:"for(int64_t i_ = "}).S+((v)(((Cu).sT),([129,2]))).S}).S+({S:({S:({S:"; i_ < "}).S+((v)(((Cs).sT),([129,2]))).S}).S+({S:"->L; i_++){\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Cs).sT),([129,2]))).S}).S+({S:({S:({S:"->B[i_] == "}).S+((v)(((Ct).sT),([129,2]))).S}).S+({S:") return i_;\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:"}\u000A"}));
(eN)((By),([130,129,2]),({S:"return -1;\u000A"}));
}
else if(B3.S===({S:"findBin"}).S){
(qr)((B0),([130,134]));
(Cw)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(Cx)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"int64_t a_ = 0, b_ = "}).S+((v)(((Cw).sT),([129,2]))).S}).S+({S:"->L - 1;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"while (a_ <= b_) {\u000A"}));
(eN)((By),([130,129,2]),({S:"int64_t c_ = (a_ + b_) / 2;\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"int64_t m_ = cmp_("}).S+((v)(((Cx).sT),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((Cw).sT),([129,2]))).S}).S+({S:"->B[c_]);\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:"if(m_ < 0) b_ = c_ - 1;\u000A"}));
(eN)((By),([130,129,2]),({S:"else if(m_ > 0) a_ = c_ + 1;\u000A"}));
(eN)((By),([130,129,2]),({S:"else return c_;\u000A"}));
(eN)((By),([130,129,2]),({S:"}\u000A"}));
(eN)((By),([130,129,2]),({S:"return -1;\u000A"}));
}
else if(B3.S===({S:"findLastArray"}).S){
(qr)((B0),([130,134]));
(Cz)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(C0)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(C1)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((C1).sT),([129,2]))).S}).S+({S:({S:({S:" == -1) "}).S+((v)(((C1).sT),([129,2]))).S}).S+({S:({S:({S:" = "}).S+((v)(((Cz).sT),([129,2]))).S}).S+({S:"->L - 1;\u000A"}).S}).S}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((C1).sT),([129,2]))).S}).S+({S:({S:({S:" >= "}).S+((v)(((Cz).sT),([129,2]))).S}).S+({S:"->L) return -1;\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:"for(int64_t i_ = "}).S+((v)(((C1).sT),([129,2]))).S}).S+({S:"; i_ >= 0; i_--){\u000A"}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Cz).sT),([129,2]))).S}).S+({S:({S:({S:"->B[i_] == "}).S+((v)(((C0).sT),([129,2]))).S}).S+({S:") return i_;\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:"}\u000A"}));
(eN)((By),([130,129,2]),({S:"return -1;\u000A"}));
}
else if(B3.S===({S:"floor"}).S){
(qr)((B0),([130,134]));
(C3)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return std::floor("}).S+((v)(((C3).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"forEach"}).S){
(qr)((B0),([130,134]));
(C5)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(C6)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(C7)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return dictForEach_("}).S+((v)(((C5).sT),([129,2]))).S}).S+({S:({S:({S:"->B, static_cast<bool(*)(K_, V_, Class_*)>("}).S+((v)(((C6).sT),([129,2]))).S}).S+({S:({S:({S:"), "}).S+((v)(((C7).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
}
else if(B3.S===({S:"getDict"}).S){
(qr)((B0),([130,134]));
(C9)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(CA)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(CB)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return dictSearch_("}).S+((v)(((C9).sT),([129,2]))).S}).S+({S:({S:({S:"->B, "}).S+((v)(((CA).sT),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((CB).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
}
else if(B3.S===({S:"getList"}).S){
(qr)((B0),([130,134]));
(CD)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return *"}).S+((v)(((CD).sT),([129,2]))).S}).S+({S:"->I;\u000A"}).S}));
}
else if(B3.S===({S:"getQueue"}).S){
(qr)((B0),([130,134]));
(CF)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"R_ r_ = "}).S+((v)(((CF).sT),([129,2]))).S}).S+({S:"->B.front();\u000A"}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:""}).S+((v)(((CF).sT),([129,2]))).S}).S+({S:"->B.pop();\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"return r_;\u000A"}));
}
else if(B3.S===({S:"getStack"}).S){
(qr)((B0),([130,134]));
(CH)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"R_ r_ = "}).S+((v)(((CH).sT),([129,2]))).S}).S+({S:"->B.top();\u000A"}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:""}).S+((v)(((CH).sT),([129,2]))).S}).S+({S:"->B.pop();\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"return r_;\u000A"}));
}
else if(B3.S===({S:"head"}).S){
(qr)((B0),([130,134]));
(CJ)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:""}).S+((v)(((CJ).sT),([129,2]))).S}).S+({S:({S:({S:"->I = "}).S+((v)(((CJ).sT),([129,2]))).S}).S+({S:"->B.begin();\u000A"}).S}).S}));
}
else if(B3.S===({S:"idx"}).S){
(qr)((B0),([130,134]));
(CL)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:"int64_t i_ = 0;\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"for(auto& t_ = "}).S+((v)(((CL).sT),([129,2]))).S}).S+({S:({S:({S:"->B.begin(); t_ != "}).S+((v)(((CL).sT),([129,2]))).S}).S+({S:"->B.end(); ++t_){\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:"if(t_ == "}).S+((v)(((CL).sT),([129,2]))).S}).S+({S:"->I) return i_;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"i_++;\u000A"}));
(eN)((By),([130,129,2]),({S:"}\u000A"}));
(eN)((By),([130,129,2]),({S:"return -1;\u000A"}));
}
else if(B3.S===({S:"ins"}).S){
(qr)((B0),([130,134]));
(CN)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(CO)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:""}).S+((v)(((CN).sT),([129,2]))).S}).S+({S:({S:({S:"->B.insert("}).S+((v)(((CN).sT),([129,2]))).S}).S+({S:({S:({S:"->I, "}).S+((v)(((CO).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
}
else if(B3.S===({S:"invRot"}).S){
(qr)((B0),([130,134]));
(CQ)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(CR)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(CS)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(CT)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"double r_ = std::atan2("}).S+((v)(((CR).sT),([129,2]))).S}).S+({S:({S:({S:" - "}).S+((v)(((CT).sT),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((CQ).sT),([129,2]))).S}).S+({S:({S:({S:" - "}).S+((v)(((CS).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}).S}));
(eN)((By),([130,129,2]),({S:"return r_ < 0.0 ? r_ + 2.0 * 3.14159265358979323846 : r_;\u000A"}));
}
else if(B3.S===({S:"ln"}).S){
(qr)((B0),([130,134]));
(CV)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return std::log("}).S+((v)(((CV).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"moveOffset"}).S){
(qr)((B0),([130,134]));
(CX)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(CY)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((CY).sT),([129,2]))).S}).S+({S:" >= 0){\u000A"}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:"for(int64_t i_ = 0; i_ < "}).S+((v)(((CY).sT),([129,2]))).S}).S+({S:"; i_++){\u000A"}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((CX).sT),([129,2]))).S}).S+({S:({S:({S:"->I == "}).S+((v)(((CX).sT),([129,2]))).S}).S+({S:"->B.end()) break;\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:"++"}).S+((v)(((CX).sT),([129,2]))).S}).S+({S:"->I;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"}\u000A"}));
(eN)((By),([130,129,2]),({S:"}else{\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"for(int64_t i_ = 0; i_ > "}).S+((v)(((CY).sT),([129,2]))).S}).S+({S:"; i_--){\u000A"}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((CX).sT),([129,2]))).S}).S+({S:({S:({S:"->I == "}).S+((v)(((CX).sT),([129,2]))).S}).S+({S:"->B.end()) break;\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:"--"}).S+((v)(((CX).sT),([129,2]))).S}).S+({S:"->I;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"}\u000A"}));
(eN)((By),([130,129,2]),({S:"}\u000A"}));
}
else if(B3.S===({S:"next"}).S){
(qr)((B0),([130,134]));
(Da)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"++"}).S+((v)(((Da).sT),([129,2]))).S}).S+({S:"->I;\u000A"}).S}));
}
else if(B3.S===({S:"not"}).S){
(qr)((B0),([130,134]));
(Dc)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return ~"}).S+((v)(((Dc).sT),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
else if(B3.S===({S:"or"}).S){
(qr)((B0),([130,134]));
(De)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(Df)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((De).sT),([129,2]))).S}).S+({S:({S:({S:" | "}).S+((v)(((Df).sT),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(B3.S===({S:"peekQueue"}).S){
(qr)((B0),([130,134]));
(Dh)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Dh).sT),([129,2]))).S}).S+({S:"->B.front();\u000A"}).S}));
}
else if(B3.S===({S:"peekStack"}).S){
(qr)((B0),([130,134]));
(Dj)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Dj).sT),([129,2]))).S}).S+({S:"->B.top();\u000A"}).S}));
}
else if(B3.S===({S:"prev"}).S){
(qr)((B0),([130,134]));
(Dl)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Dl).sT),([129,2]))).S}).S+({S:({S:({S:"->I == "}).S+((v)(((Dl).sT),([129,2]))).S}).S+({S:"->B.begin())\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:""}).S+((v)(((Dl).sT),([129,2]))).S}).S+({S:({S:({S:"->I = "}).S+((v)(((Dl).sT),([129,2]))).S}).S+({S:"->B.end();\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:"else\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"--"}).S+((v)(((Dl).sT),([129,2]))).S}).S+({S:"->I;\u000A"}).S}));
}
else if(B3.S===({S:"rnd"}).S){
(qr)((B0),([130,134]));
(Dn)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(Do)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return rnd_("}).S+((v)(((Dn).sT),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((Do).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(B3.S===({S:"rndFloat"}).S){
(qr)((B0),([130,134]));
(Dq)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(Dr)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return rndFloat_("}).S+((v)(((Dq).sT),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((Dr).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(B3.S===({S:"sar"}).S){
(qr)((B0),([130,134]));
(Dt)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(Du)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Dt).sT),([129,2]))).S}).S+({S:({S:({S:" >> "}).S+((v)(((Du).sT),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(B3.S===({S:"shl"}).S){
(qr)((B0),([130,134]));
(Dw)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(Dx)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Dw).sT),([129,2]))).S}).S+({S:({S:({S:" << "}).S+((v)(((Dx).sT),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(B3.S===({S:"shr"}).S){
(qr)((B0),([130,134]));
(Dz)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(D0)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Dz).sT),([129,2]))).S}).S+({S:({S:({S:" >> "}).S+((v)(((D0).sT),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(B3.S===({S:"sin"}).S){
(qr)((B0),([130,134]));
(D2)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return std::sin("}).S+((v)(((D2).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"sinh"}).S){
(qr)((B0),([130,134]));
(D4)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return std::sinh("}).S+((v)(((D4).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"sqrt"}).S){
(qr)((B0),([130,134]));
(D6)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return std::sqrt("}).S+((v)(((D6).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"sub"}).S){
(qr)((B0),([130,134]));
(D8)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(D9)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(DA)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return sub_("}).S+((v)(((D8).sT),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((D9).sT),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((DA).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
}
else if(B3.S===({S:"sysTime"}).S){
(eN)((By),([130,129,2]),({S:"return static_cast<int64_t>(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());\u000A"}));
}
else if(B3.S===({S:"tail"}).S){
(qr)((B0),([130,134]));
(DD)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:""}).S+((v)(((DD).sT),([129,2]))).S}).S+({S:({S:({S:"->I = "}).S+((v)(((DD).sT),([129,2]))).S}).S+({S:"->B.end();\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:"--"}).S+((v)(((DD).sT),([129,2]))).S}).S+({S:"->I;\u000A"}).S}));
}
else if(B3.S===({S:"tan"}).S){
(qr)((B0),([130,134]));
(DF)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return std::tan("}).S+((v)(((DF).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"tanh"}).S){
(qr)((B0),([130,134]));
(DH)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return std::tanh("}).S+((v)(((DH).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"term"}).S){
(qr)((B0),([130,134]));
(DJ)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((DJ).sT),([129,2]))).S}).S+({S:({S:({S:"->I == "}).S+((v)(((DJ).sT),([129,2]))).S}).S+({S:"->B.end();\u000A"}).S}).S}));
}
else if(B3.S===({S:"toArray"}).S){
(qr)((B0),([130,134]));
(DL)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return toArray_<C_>("}).S+((v)(((DL).sT),([129,2]))).S}).S+({S:");"}).S}));
}
else if(B3.S===({S:"toBit64"}).S){
(qr)((B0),([130,134]));
(DN)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(DO)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"std::u16string s_ = "}).S+((v)(((DN).sT),([129,2]))).S}).S+({S:"->B;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"const std::string& t_ = utf16ToUtf8_(s_);\u000A"}));
(eN)((By),([130,129,2]),({S:"try{\u000A"}));
(eN)((By),([130,129,2]),({S:"size_t s_;\u000A"}));
(eN)((By),([130,129,2]),({S:"uint64_t v_ = t_.size() > 2 && t_[0] == \'0\' && t_[1] == \'x\' ? std::stoull(t_, &s_, 16) : std::stoull(t_, &s_);\u000A"}));
(eN)((By),([130,129,2]),({S:"if(s_ == t_.size()){\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((DO).sT),([129,2]))).S}).S+({S:" = true;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"return v_;\u000A"}));
(eN)((By),([130,129,2]),({S:"}else{\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((DO).sT),([129,2]))).S}).S+({S:" = false;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"return 0;\u000A"}));
(eN)((By),([130,129,2]),({S:"}\u000A"}));
(eN)((By),([130,129,2]),({S:"}catch(...){\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((DO).sT),([129,2]))).S}).S+({S:" = false;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"return 0;\u000A"}));
(eN)((By),([130,129,2]),({S:"}\u000A"}));
}
else if(B3.S===({S:"toFloat"}).S){
(qr)((B0),([130,134]));
(DQ)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(DR)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"std::u16string s_ = "}).S+((v)(((DQ).sT),([129,2]))).S}).S+({S:"->B;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"const std::string& t_ = utf16ToUtf8_(s_);\u000A"}));
(eN)((By),([130,129,2]),({S:"try{\u000A"}));
(eN)((By),([130,129,2]),({S:"size_t s_;\u000A"}));
(eN)((By),([130,129,2]),({S:"double v_ = std::stod(t_, &s_);\u000A"}));
(eN)((By),([130,129,2]),({S:"if(s_ == t_.size()){\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((DR).sT),([129,2]))).S}).S+({S:" = true;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"return v_;\u000A"}));
(eN)((By),([130,129,2]),({S:"}else{\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((DR).sT),([129,2]))).S}).S+({S:" = false;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"return 0;\u000A"}));
(eN)((By),([130,129,2]),({S:"}\u000A"}));
(eN)((By),([130,129,2]),({S:"}catch(...){\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((DR).sT),([129,2]))).S}).S+({S:" = false;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"return 0;\u000A"}));
(eN)((By),([130,129,2]),({S:"}\u000A"}));
}
else if(B3.S===({S:"toInt"}).S){
(qr)((B0),([130,134]));
(DT)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(DU)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"std::u16string s_ = "}).S+((v)(((DT).sT),([129,2]))).S}).S+({S:"->B;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"const std::string& t_ = utf16ToUtf8_(s_);\u000A"}));
(eN)((By),([130,129,2]),({S:"try{\u000A"}));
(eN)((By),([130,129,2]),({S:"size_t s_;\u000A"}));
(eN)((By),([130,129,2]),({S:"int64_t v_ = t_.size() > 2 && t_[0] == \'0\' && t_[1] == \'x\' ? std::stoll(t_, &s_, 16) : std::stoull(t_, &s_);\u000A"}));
(eN)((By),([130,129,2]),({S:"if(s_ == t_.size()){\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((DU).sT),([129,2]))).S}).S+({S:" = true;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"return v_;\u000A"}));
(eN)((By),([130,129,2]),({S:"}else{\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((DU).sT),([129,2]))).S}).S+({S:" = false;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"return 0;\u000A"}));
(eN)((By),([130,129,2]),({S:"}\u000A"}));
(eN)((By),([130,129,2]),({S:"}catch(...){\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((DU).sT),([129,2]))).S}).S+({S:" = false;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"return 0;\u000A"}));
(eN)((By),([130,129,2]),({S:"}\u000A"}));
}
else if(B3.S===({S:"toStr"}).S){
(qr)((B0),([130,134]));
(DW)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return toStr_("}).S+((v)(((DW).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"xor"}).S){
(qr)((B0),([130,134]));
(DY)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(r8)((B0),([130,134]));
(DZ)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((DY).sT),([129,2]))).S}).S+({S:({S:({S:" ^ "}).S+((v)(((DZ).sT),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(B3.S===({S:"cui_print"}).S){
(qr)((B0),([130,134]));
(Eb)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Eb).sT),([129,2]))).S}).S+({S:" == nullptr){\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"std::cout << \"(null)\";\u000A"}));
(eN)((By),([130,129,2]),({S:"return;\u000A"}));
(eN)((By),([130,129,2]),({S:"}\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"std::u16string s_ = "}).S+((v)(((Eb).sT),([129,2]))).S}).S+({S:"->B;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"const std::string& t_ = utf16ToUtf8_(s_);\u000A"}));
(eN)((By),([130,129,2]),({S:"std::cout << t_ << std::flush;\u000A"}));
}
else if(B3.S===({S:"file_copyFile"}).S){
(qr)((B0),([130,134]));
(Ed)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(Ee)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:({S:({S:"return copyFile_("}).S+((v)(((Ed).sT),([129,2]))).S}).S+({S:({S:({S:"->B, "}).S+((v)(((Ee).sT),([129,2]))).S}).S+({S:"->B);\u000A"}).S}).S}));
}
else if(B3.S===({S:"file_exist"}).S){
(qr)((B0),([130,134]));
(Eg)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:"return false;\u000A"}));
}
else if(B3.S===({S:"file_forEach"}).S){
(qr)((B0),([130,134]));
(Ei)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(Ej)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(Ek)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(El)=((rU)(((qv)((B0),([130,134])))));
(eN)((By),([130,129,2]),({S:"return false;\u000A"}));
}
else if(B3.S===({S:"file_makeReader"}).S){
(qr)((B0),([130,134]));
(En)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(Eo)=((rU)(((qv)((B0),([130,134])))));
(Ep)=((Eq)((B1),({S:"handle"})));
(eN)((By),([130,129,2]),({S:({S:({S:""}).S+((v)(((En).sT),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((Ep).sT),([129,2]))).S}).S+({S:" = reinterpret_cast<int64_t>(new reader_());\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:"std::u16string s_ = "}).S+((v)(((Eo).sT),([129,2]))).S}).S+({S:"->B;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"const std::string& t_ = utf16ToUtf8_(s_);\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"reader_* r_ = reinterpret_cast<reader_*>("}).S+((v)(((En).sT),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((Ep).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:"r_->F = new std::ifstream(t_.c_str(), std::ios::in | std::ios::binary);\u000A"}));
(eN)((By),([130,129,2]),({S:"if(!*r_->F) return nullptr;\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((En).sT),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
else if(B3.S===({S:"file_makeWriter"}).S){
(qr)((B0),([130,134]));
(Es)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(Et)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(Eu)=((rU)(((qv)((B0),([130,134])))));
(Ev)=((Eq)((B1),({S:"handle"})));
(eN)((By),([130,129,2]),({S:({S:({S:""}).S+((v)(((Es).sT),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((Ev).sT),([129,2]))).S}).S+({S:" = reinterpret_cast<int64_t>(new writer_());\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:"std::u16string s_ = "}).S+((v)(((Et).sT),([129,2]))).S}).S+({S:"->B;\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"const std::string& t_ = utf16ToUtf8_(s_);\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"writer_* r_ = reinterpret_cast<writer_*>("}).S+((v)(((Es).sT),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((Ev).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:"r_->F = new std::ofstream(t_.c_str(), std::ios::out | std::ios::binary | ("}).S+((v)(((Eu).sT),([129,2]))).S}).S+({S:" ? std::ios::app : std::ios::trunc));\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"if(!*r_->F) return nullptr;\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Es).sT),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
else if(B3.S===({S:"file_readerFin"}).S){
(qr)((B0),([130,134]));
(Ex)=((rU)(((qv)((B0),([130,134])))));
(Ey)=((Eq)((B1),({S:"handle"})));
(eN)((By),([130,129,2]),({S:({S:({S:"reader_* r_ = reinterpret_cast<reader_*>("}).S+((v)(((Ex).sT),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((Ey).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:"r_->F->close();\u000A"}));
}
else if(B3.S===({S:"file_readerGetPos"}).S){
(qr)((B0),([130,134]));
(E0)=((rU)(((qv)((B0),([130,134])))));
(E1)=((Eq)((B1),({S:"handle"})));
(eN)((By),([130,129,2]),({S:({S:({S:"reader_* r_ = reinterpret_cast<reader_*>("}).S+((v)(((E0).sT),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((E1).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:"return static_cast<int64_t>(r_->F->tellg());\u000A"}));
}
else if(B3.S===({S:"file_readerReadLetter"}).S){
(qr)((B0),([130,134]));
(E3)=((rU)(((qv)((B0),([130,134])))));
(E4)=((Eq)((B1),({S:"handle"})));
(eN)((By),([130,129,2]),({S:({S:({S:"reader_* r_ = reinterpret_cast<reader_*>("}).S+((v)(((E3).sT),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((E4).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:"return readUtf8_(r_->F);\u000A"}));
}
else if(B3.S===({S:"file_readerSetPos"}).S){
(qr)((B0),([130,134]));
(E6)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(E7)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(E8)=((rU)(((qv)((B0),([130,134])))));
(E9)=((Eq)((B1),({S:"handle"})));
(eN)((By),([130,129,2]),({S:({S:({S:"reader_* r_ = reinterpret_cast<reader_*>("}).S+((v)(((E6).sT),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((E9).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:"std::ios_base::seekdir o_ = std::ios_base::beg;\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"switch("}).S+((v)(((E7).sT),([129,2]))).S}).S+({S:"){\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"case 0: o_ = std::ios_base::beg; break;\u000A"}));
(eN)((By),([130,129,2]),({S:"case 1: o_ = std::ios_base::cur; break;\u000A"}));
(eN)((By),([130,129,2]),({S:"case 2: o_ = std::ios_base::end; break;\u000A"}));
(eN)((By),([130,129,2]),({S:"}\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"r_->F->seekg("}).S+((v)(((E8).sT),([129,2]))).S}).S+({S:", o_);\u000A"}).S}));
}
else if(B3.S===({S:"file_readerTerm"}).S){
(qr)((B0),([130,134]));
(EB)=((rU)(((qv)((B0),([130,134])))));
(EC)=((Eq)((B1),({S:"handle"})));
(eN)((By),([130,129,2]),({S:({S:({S:"reader_* r_ = reinterpret_cast<reader_*>("}).S+((v)(((EB).sT),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((EC).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:"char c_;\u000A"}));
(eN)((By),([130,129,2]),({S:"if(r_->F->get(c_)) {\u000A"}));
(eN)((By),([130,129,2]),({S:"r_->F->seekg(-1, std::ios_base::cur);\u000A"}));
(eN)((By),([130,129,2]),({S:"return false;\u000A"}));
(eN)((By),([130,129,2]),({S:"}\u000A"}));
(eN)((By),([130,129,2]),({S:"return true;\u000A"}));
}
else if(B3.S===({S:"file_writerFin"}).S){
(qr)((B0),([130,134]));
(EE)=((rU)(((qv)((B0),([130,134])))));
(EF)=((Eq)((B1),({S:"handle"})));
(eN)((By),([130,129,2]),({S:({S:({S:"writer_* r_ = reinterpret_cast<writer_*>("}).S+((v)(((EE).sT),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((EF).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:"r_->F->close();\u000A"}));
}
else if(B3.S===({S:"file_writerGetPos"}).S){
(qr)((B0),([130,134]));
(EH)=((rU)(((qv)((B0),([130,134])))));
(EI)=((Eq)((B1),({S:"handle"})));
(eN)((By),([130,129,2]),({S:({S:({S:"writer_* r_ = reinterpret_cast<writer_*>("}).S+((v)(((EH).sT),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((EI).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:"return static_cast<int64_t>(r_->F->tellp());\u000A"}));
}
else if(B3.S===({S:"file_writerSetPos"}).S){
(qr)((B0),([130,134]));
(EK)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(EL)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(EM)=((rU)(((qv)((B0),([130,134])))));
(EN)=((Eq)((B1),({S:"handle"})));
(eN)((By),([130,129,2]),({S:({S:({S:"writer_* r_ = reinterpret_cast<writer_*>("}).S+((v)(((EK).sT),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((EN).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:"std::ios_base::seekdir o_ = std::ios_base::beg;\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"switch("}).S+((v)(((EL).sT),([129,2]))).S}).S+({S:"){\u000A"}).S}));
(eN)((By),([130,129,2]),({S:"case 0: o_ = std::ios_base::beg; break;\u000A"}));
(eN)((By),([130,129,2]),({S:"case 1: o_ = std::ios_base::cur; break;\u000A"}));
(eN)((By),([130,129,2]),({S:"case 2: o_ = std::ios_base::end; break;\u000A"}));
(eN)((By),([130,129,2]),({S:"}\u000A"}));
(eN)((By),([130,129,2]),({S:({S:({S:"r_->F->seekp("}).S+((v)(((EM).sT),([129,2]))).S}).S+({S:", o_);\u000A"}).S}));
}
else if(B3.S===({S:"file_writerWrite"}).S){
(qr)((B0),([130,134]));
(EP)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(EQ)=((rU)(((qv)((B0),([130,134])))));
(ER)=((Eq)((B1),({S:"handle"})));
(eN)((By),([130,129,2]),({S:({S:({S:"writer_* r_ = reinterpret_cast<writer_*>("}).S+((v)(((EP).sT),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((ER).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:"r_->F->write(reinterpret_cast<char*>("}).S+((v)(((EQ).sT),([129,2]))).S}).S+({S:({S:({S:"->B), "}).S+((v)(((EQ).sT),([129,2]))).S}).S+({S:"->L);\u000A"}).S}).S}));
}
else if(B3.S===({S:"file_writerWriteChar"}).S){
(qr)((B0),([130,134]));
(ET)=((rU)(((qv)((B0),([130,134])))));
(r8)((B0),([130,134]));
(EU)=((rU)(((qv)((B0),([130,134])))));
(EV)=((Eq)((B1),({S:"handle"})));
(eN)((By),([130,129,2]),({S:({S:({S:"writer_* r_ = reinterpret_cast<writer_*>("}).S+((v)(((ET).sT),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((EV).sT),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((By),([130,129,2]),({S:({S:({S:"writeUtf8_(r_->F, "}).S+((v)(((EU).sT),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B3.S===({S:"wnd_editBaseGetText"}).S){
}
else if(B3.S===({S:"wnd_makeEditMulti"}).S){
}
else{if(!(false)){throw 0xE9170000;}
}
}
// _tail
function tr(EZ /*me_*/,Fa /*type*/){
EZ.P=EZ.T;
}
// _idx
function tt(Fb /*me_*/,Fc /*type*/){
let p_=Fb.H,i_=0;
if(Fb.P===null)return -1;
while(p_!==null){
if(p_===Fb.P)return i_
i_++;
p_=p_.N;
}
return -1;
}
// buildStats
function tu(Fd /*stats*/,Fe /*breakStat*/,Ff /*skipStat*/){
let Fh; // stat
let Fj;
(qr)((Fd),([130,134]));
while(!((qt)((Fd),([130,134])))){
(Fh)=((qv)((Fd),([130,134])));
Fj=(Fh).qc;
switch(Fj){
case 66049:
(Fl)((Fh),(Fe),(Ff));
break;
case 66050:
(Fo)((Fh),(Fe),(Ff));
break;
case 16843265:
(Fr)((Fh),(Fe),(Ff));
break;
case 16843266:
(Fv)((Fh),(Fe),(Ff));
break;
case 66051:
(Fy)((Fh),(Fe),(Ff));
break;
case 526:
(F0)((Fh));
break;
case 66052:
(F3)((Fh),(Fe),(Ff));
break;
case 527:
(F5)((Fh));
break;
case 528:
(F8)((Fh));
break;
case 529:
(FA)((Fh),(Fe));
break;
case 530:
(FC)((Fh),(Ff));
break;
case 531:
(FE)((Fh));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(r8)((Fd),([130,134]));
}
}
// _moveOffset
function tw(FH /*me_*/,FI /*type*/,FJ /*offset*/){
if(FJ>=0){
for(let i_=0;i_<FJ;i_++){
if(FH.P===null)break;
FH.P=FH.P.N;
}
}else{
for(let i_=0;i_>FJ;i_--){
if(FH.P===null)break;
FH.P=FH.P.P;
}
}
}
// _ins
function t2(FK /*me_*/,FL /*type*/,FM /*item*/){
let p_=FK.P;
let n_={P:p_.P,N:p_,I:FM}
if(p_.P===null)FK.H=n_;else p_.P.N=n_;
if(FK.T===null)FK.T=n_;
p_.P=n_;
FK.L++;
}
// _del
function t4(FN /*me_*/,FO /*type*/){
let p_=FN.P;
if(p_.P===null)FN.H=p_.N;else p_.P.N=p_.N;
if(p_.N===null)FN.T=p_.P;else p_.N.P=p_.P;
FN.P=p_.N;
FN.L--;
}
// refClass
function tE(FP /*ast*/){
let FQ; // info
let FZ; // items
let Gb; // item
let Ge; // func_
let Gh; // items2
let Gj; // arg
let Gl; // var_
(FQ)=((rU)((FP)));
if((FQ).rX){
return (FQ).sT;
}
((FQ).rX)=(true);
if(((FP).qz)!==(null)){
(tE)(((FP).qz));
}
if(((FQ).tJ)===(-1)){
((FQ).tJ)=(eR);
(eR)=((eR)+(1));
}
(FZ)=((FP).tm);
(qr)((FZ),([130,134]));
while(!((qt)((FZ),([130,134])))){
(Gb)=((qv)((FZ),([130,134])));
if((((Gb).tX).qc)===(256)){
(Ge)=((Gb).tX);
if(((Ge).qh)!==(null)){
(sw)(((Ge).qh));
}
(Gh)=((Ge).qg);
(qr)((Gh),([130,134]));
while(!((qt)((Gh),([130,134])))){
(Gj)=((qv)((Gh),([130,134])));
(sw)(((Gj).sA));
(r8)((Gh),([130,134]));
}
(eQ)((K),([132,134]),(Ge));
}
else if((((Gb).tX).qc)===(2)){
(Gl)=((Gb).tX);
(sw)((((Gl).uc).sA));
}
(r8)((FZ),([130,134]));
}
(eQ)((L),([132,134]),(FP));
return (FQ).sT;
}
// findFunc
function uf(Gm /*ast*/,Gn /*name*/){
let Go; // items
let Gq; // item
(Go)=((Gm).tm);
(qr)((Go),([130,134]));
while(!((qt)((Go),([130,134])))){
(Gq)=((qv)((Go),([130,134])));
if(((((Gq).tX).qc)===(256))&&((((Gq).tX).qX).S===(Gn).S)){
return (Gq).tX;
}
(r8)((Go),([130,134]));
}
return null;
}
// makeWriter
function u9(Gt /*me2*/,Gu /*path*/,Gv /*append*/){
Gt.Gw={F:"",I:0,P:Gu.S};
return Gt;
}
// writeCpp
function uH(Gx /*writer*/,Gy /*resFiles*/){
let G4; // globalVar
let G5; // info
let GA; // item
(uG)((Gx),({S:"namespace {\u000A"}));
(qr)((N),([130,129,2]));
while(!((qt)((N),([130,129,2])))){
(uG)((Gx),((qv)((N),([130,129,2]))));
(r8)((N),([130,129,2]));
}
(qr)((O),([130,129,2]));
while(!((qt)((O),([130,129,2])))){
(uG)((Gx),((qv)((O),([130,129,2]))));
(r8)((O),([130,129,2]));
}
if((eR)!==(0)){
(uG)((Gx),({S:({S:({S:"static int64_t classTable_["}).S+((v)(((eR)*(2)),([0]))).S}).S+({S:"];\u000A"}).S}));
}
(uG)((Gx),({S:"static int64_t argc_;\u000A"}));
(uG)((Gx),({S:"static char** argv_;\u000A"}));
(qr)((S),([130,134]));
while(!((qt)((S),([130,134])))){
(G4)=((qv)((S),([130,134])));
(G5)=((rU)((G4)));
(uG)((Gx),({S:({S:({S:"static "}).S+((v)(((sw)(((G4).sA))),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((G5).sT),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
(r8)((S),([130,134]));
}
(qr)((Q),([130,129,2]));
while(!((qt)((Q),([130,129,2])))){
(uG)((Gx),((qv)((Q),([130,129,2]))));
(r8)((Q),([130,129,2]));
}
(qr)((P),([130,129,2]));
while(!((qt)((P),([130,129,2])))){
(uG)((Gx),((qv)((P),([130,129,2]))));
(r8)((P),([130,129,2]));
}
(uG)((Gx),({S:"}\u000A"}));
(uG)((Gx),({S:"int main(int c_, char** v_){\u000A"}));
(uG)((Gx),({S:"argc_ = static_cast<int64_t>(c_) - 1;\u000A"}));
(uG)((Gx),({S:"argv_ = v_ + 1;\u000A"}));
(qr)((U),([130,129,2]));
while(!((qt)((U),([130,129,2])))){
(GA)=((qv)((U),([130,129,2])));
(uG)((Gx),(GA));
(r8)((U),([130,129,2]));
}
(uG)((Gx),({S:"init_();\u000A"}));
(uG)((Gx),({S:"a();\u000A"}));
(uG)((Gx),({S:"return 0;\u000A"}));
(uG)((Gx),({S:"}\u000A"}));
}
// copyFile
function uK(GB /*dst*/,GC /*src*/){
return false;
}
// getInfo
function uO(GD /*ast*/){
let GG; // info
if((((GD).zr)===(null))||((((GD).zr).qc)!==(268435456))){
(GG)=(new uP());
((GG).qc)=(268435456);
((GG).vf)=((GH)());
if(((((rt)(((GD).qc),([9]),(66048)))===(66048))&&(((GD).qX)!==(null)))&&(((GD).qX).S!==({S:"$"}).S)){
((GG).GK)=((GH)());
}
else{
((GG).GK)=(null);
}
((GG).uR)=(false);
((GD).zr)=(GG);
}
return (GD).zr;
}
// write
function vw(GM /*codes*/,GN /*attr*/,GO /*args*/,GP /*members*/){
let GR;
let GT; // x
let GV; // x
let GY; // me_
let GZ; // meType
let Ha; // key
let Hb; // item
let Hd; // me_
let He; // item
let Hg; // me_
let Hh; // item
let Hj; // me_
let Hk; // item
let Hm; // me_
let Hn; // n
let Hp; // x
let Hr; // x
let Ht; // x
let Hv; // x
let Hx; // x
let H0; // x
let H2; // x
let H4; // me_
let H6; // x
let H7; // y
let H8; // centerX
let H9; // centerY
let HB; // x
let HD; // me_
let HE; // meType
let HF; // value
let HH; // me_
let HI; // meType
let HJ; // item
let HK; // start
let HM; // me_
let HN; // meType
let HO; // item
let HQ; // me_
let HR; // meType
let HS; // item
let HT; // start
let HV; // x
let HX; // me_
let HY; // meType
let HZ; // callback
let Ia; // data
let Ic; // me_
let Id; // meType
let Ie; // key
let If; // existed
let Ih; // me_
let Ij; // me_
let Il; // me_
let In; // me_
let Ip; // me_
let Ir; // me_
let Is; // item
let Iu; // x
let Iv; // y
let Iw; // centerX
let Ix; // centerY
let Iz; // x
let I1; // me_
let I2; // offset
let I4; // me_
let I6; // me_
let I8; // me_
let I9; // n
let IB; // me_
let ID; // me_
let IF; // me_
let IH; // min
let II; // max
let IK; // min
let IL; // max
let IN; // me_
let IO; // n
let IQ; // me_
let IR; // n
let IT; // me_
let IU; // n
let IW; // x
let IY; // x
let Ja; // x
let Jc; // me_
let Jd; // meType
let Je; // start
let Jf; // len
let Ji; // me_
let Jk; // x
let Jm; // x
let Jo; // me_
let Jq; // me_
let Js; // me_
let Jt; // success
let Jv; // me_
let Jw; // success
let Jy; // me_
let Jz; // success
let J1; // me_
let J2; // type
let J4; // me_
let J5; // n
let J7; // str
let JA; // path
let JC; // path
let JD; // recursion
let JE; // callback
let JF; // data
let JH; // me_
let JI; // path
let JJ; // handle
let JM; // me_
let JN; // path
let JO; // append
let JP; // handle
let JR; // me_
let JS; // handle
let JU; // me_
let JV; // handle
let JX; // me_
let JY; // handle
let Ka; // me_
let Kb; // origin
let Kc; // pos
let Kd; // handle
let Kf; // me_
let Kg; // handle
let Ki; // me_
let Kj; // handle
let Kl; // me_
let Km; // handle
let Ko; // me_
let Kp; // origin
let Kq; // pos
let Kr; // handle
let Kt; // me_
let Ku; // n
let Kv; // handle
let Kx; // me_
let Ky; // n
let Kz; // handle
let K1; // me_
let K2; // handle
let K4; // me_
let K5; // parent
let K6; // x
let K7; // y
let K8; // width
let K9; // height
let KA; // anchorX
let KB; // anchorY
let KC; // handle
GR=GN;
if(GR.S===({S:"acos"}).S){
(qr)((GO),([130,134]));
(GT)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return Math.acos("}).S+((v)(((GT).vf),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(GR.S===({S:"acosh"}).S){
(qr)((GO),([130,134]));
(GV)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return Math.log("}).S+((v)(((GV).vf),([129,2]))).S}).S+({S:({S:({S:"+Math.sqrt("}).S+((v)(((GV).vf),([129,2]))).S}).S+({S:({S:({S:"*"}).S+((v)(((GV).vf),([129,2]))).S}).S+({S:"-1));\u000A"}).S}).S}).S}));
}
else if(GR.S===({S:"addr"}).S){
}
else if(GR.S===({S:"addDict"}).S){
(qr)((GO),([130,134]));
(GY)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(GZ)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Ha)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Hb)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((GZ).vf),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((GZ).vf),([129,2]))).S}).S+({S:({S:({S:"[2]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((GY).vf),([129,2]))).S}).S+({S:({S:({S:".set("}).S+((v)(((Ha).vf),([129,2]))).S}).S+({S:({S:({S:".S, "}).S+((v)(((Hb).vf),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:"else\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((GY).vf),([129,2]))).S}).S+({S:({S:({S:".set("}).S+((v)(((Ha).vf),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((Hb).vf),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
}
else if(GR.S===({S:"addList"}).S){
(qr)((GO),([130,134]));
(Hd)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(r8)((GO),([130,134]));
(He)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"let n_={P:null,N:null,I:"}).S+((v)(((He).vf),([129,2]))).S}).S+({S:"};\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Hd).vf),([129,2]))).S}).S+({S:({S:({S:".H===null){"}).S+((v)(((Hd).vf),([129,2]))).S}).S+({S:({S:({S:".H=n_;"}).S+((v)(((Hd).vf),([129,2]))).S}).S+({S:({S:({S:".T=n_}else{n_.P="}).S+((v)(((Hd).vf),([129,2]))).S}).S+({S:({S:({S:".T;"}).S+((v)(((Hd).vf),([129,2]))).S}).S+({S:({S:({S:".T.N=n_;"}).S+((v)(((Hd).vf),([129,2]))).S}).S+({S:".T=n_}\u000A"}).S}).S}).S}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((Hd).vf),([129,2]))).S}).S+({S:".L++;\u000A"}).S}));
}
else if(GR.S===({S:"addQueue"}).S){
(qr)((GO),([130,134]));
(Hg)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(r8)((GO),([130,134]));
(Hh)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((Hg).vf),([129,2]))).S}).S+({S:({S:({S:".push("}).S+((v)(((Hh).vf),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(GR.S===({S:"addStack"}).S){
(qr)((GO),([130,134]));
(Hj)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(r8)((GO),([130,134]));
(Hk)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((Hj).vf),([129,2]))).S}).S+({S:({S:({S:".push("}).S+((v)(((Hk).vf),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(GR.S===({S:"and"}).S){
(qr)((GO),([130,134]));
(Hm)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(r8)((GO),([130,134]));
(Hn)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Hm).vf),([129,2]))).S}).S+({S:({S:({S:"&"}).S+((v)(((Hn).vf),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(GR.S===({S:"asin"}).S){
(qr)((GO),([130,134]));
(Hp)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return Math.asin("}).S+((v)(((Hp).vf),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(GR.S===({S:"asinh"}).S){
(qr)((GO),([130,134]));
(Hr)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return Math.log("}).S+((v)(((Hr).vf),([129,2]))).S}).S+({S:({S:({S:"+Math.sqrt("}).S+((v)(((Hr).vf),([129,2]))).S}).S+({S:({S:({S:"*"}).S+((v)(((Hr).vf),([129,2]))).S}).S+({S:"+1));\u000A"}).S}).S}).S}));
}
else if(GR.S===({S:"atan"}).S){
(qr)((GO),([130,134]));
(Ht)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return Math.atan("}).S+((v)(((Ht).vf),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(GR.S===({S:"atanh"}).S){
(qr)((GO),([130,134]));
(Hv)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return 0.5*Math.log((1+"}).S+((v)(((Hv).vf),([129,2]))).S}).S+({S:({S:({S:")/(1-"}).S+((v)(((Hv).vf),([129,2]))).S}).S+({S:"));\u000A"}).S}).S}));
}
else if(GR.S===({S:"ceil"}).S){
(qr)((GO),([130,134]));
(Hx)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return Math.ceil("}).S+((v)(((Hx).vf),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(GR.S===({S:"cmdLine"}).S){
(eN)((GM),([130,129,2]),({S:"let r_=(O_&&O_.cmdLine)?O_.cmdLine:location.search.slice(1).split(\"&\");\u000A"}));
(eN)((GM),([130,129,2]),({S:"if(r_.length===1&&r_[0]===\"\")return[];\u000A"}));
(eN)((GM),([130,129,2]),({S:"for(let i_=0;i_<r_.length;i_++)\u000A"}));
(eN)((GM),([130,129,2]),({S:"r_[i_]={S:r_[i_]};\u000A"}));
(eN)((GM),([130,129,2]),({S:"return r_;\u000A"}));
}
else if(GR.S===({S:"cos"}).S){
(qr)((GO),([130,134]));
(H0)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return Math.cos("}).S+((v)(((H0).vf),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(GR.S===({S:"cosh"}).S){
(qr)((GO),([130,134]));
(H2)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return Math.cosh("}).S+((v)(((H2).vf),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(GR.S===({S:"del"}).S){
(qr)((GO),([130,134]));
(H4)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"let p_="}).S+((v)(((H4).vf),([129,2]))).S}).S+({S:".P;\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"if(p_.P===null)"}).S+((v)(((H4).vf),([129,2]))).S}).S+({S:".H=p_.N;else p_.P.N=p_.N;\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"if(p_.N===null)"}).S+((v)(((H4).vf),([129,2]))).S}).S+({S:".T=p_.P;else p_.N.P=p_.P;\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((H4).vf),([129,2]))).S}).S+({S:".P=p_.N;\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((H4).vf),([129,2]))).S}).S+({S:".L--;\u000A"}).S}));
}
else if(GR.S===({S:"dist"}).S){
(qr)((GO),([130,134]));
(H6)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(H7)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(H8)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(H9)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"var x_="}).S+((v)(((H6).vf),([129,2]))).S}).S+({S:({S:({S:"-"}).S+((v)(((H8).vf),([129,2]))).S}).S+({S:({S:({S:",y_="}).S+((v)(((H7).vf),([129,2]))).S}).S+({S:({S:({S:"-"}).S+((v)(((H9).vf),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:"return Math.sqrt(x_*x_+y_*y_);\u000A"}));
}
else if(GR.S===({S:"exp"}).S){
(qr)((GO),([130,134]));
(HB)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return Math.exp("}).S+((v)(((HB).vf),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(GR.S===({S:"fill"}).S){
(qr)((GO),([130,134]));
(HD)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(HE)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(HF)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((HE).vf),([129,2]))).S}).S+({S:({S:({S:"[0]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((HE).vf),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((HD).vf),([129,2]))).S}).S+({S:({S:({S:".S=String.fromCharCode("}).S+((v)(((HF).vf),([129,2]))).S}).S+({S:({S:({S:").repeat("}).S+((v)(((HD).vf),([129,2]))).S}).S+({S:".S.length);\u000A"}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:"else\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((HD).vf),([129,2]))).S}).S+({S:({S:({S:".fill("}).S+((v)(((HF).vf),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(GR.S===({S:"findArray"}).S){
(qr)((GO),([130,134]));
(HH)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(HI)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(HJ)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(HK)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((HI).vf),([129,2]))).S}).S+({S:({S:({S:"[0]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((HI).vf),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((HH).vf),([129,2]))).S}).S+({S:({S:({S:".S.indexOf(String.fromCharCode("}).S+((v)(((HJ).vf),([129,2]))).S}).S+({S:({S:({S:"),"}).S+((v)(((HK).vf),([129,2]))).S}).S+({S:({S:({S:"===-1?0:"}).S+((v)(((HK).vf),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:"else\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((HH).vf),([129,2]))).S}).S+({S:({S:({S:".indexOf("}).S+((v)(((HJ).vf),([129,2]))).S}).S+({S:({S:({S:","}).S+((v)(((HK).vf),([129,2]))).S}).S+({S:({S:({S:"===-1?0:"}).S+((v)(((HK).vf),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}).S}));
}
else if(GR.S===({S:"findBin"}).S){
(qr)((GO),([130,134]));
(HM)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(HN)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(HO)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"let a_=0,b_="}).S+((v)(((HM).vf),([129,2]))).S}).S+({S:".length-1,c_,m_,f_;\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"switch("}).S+((v)(((HN).vf),([129,2]))).S}).S+({S:"[0]){\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((0),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((1),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((2),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((4),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((5),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((6),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((7),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((9),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"f_=function(a,b){return a>b?1:a<b?-1:0};\u000A"}));
(eN)((GM),([130,129,2]),({S:"break;\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((129),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"f_=function(a,b){return a.S>b.S?1:a.S<b.S?-1:0};\u000A"}));
(eN)((GM),([130,129,2]),({S:"break;\u000A"}));
(eN)((GM),([130,129,2]),({S:"default:\u000A"}));
(eN)((GM),([130,129,2]),({S:"break;\u000A"}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
(eN)((GM),([130,129,2]),({S:"while (a_<=b_){\u000A"}));
(eN)((GM),([130,129,2]),({S:"c_=~~((a_+b_)/2);\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"m_=f_("}).S+((v)(((HO).vf),([129,2]))).S}).S+({S:({S:({S:","}).S+((v)(((HM).vf),([129,2]))).S}).S+({S:"[c_]);\u000A"}).S}).S}));
(eN)((GM),([130,129,2]),({S:"if(m_<0)b_=c_-1;\u000A"}));
(eN)((GM),([130,129,2]),({S:"else if(m_>0)a_=c_+1;\u000A"}));
(eN)((GM),([130,129,2]),({S:"else return c_;\u000A"}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
(eN)((GM),([130,129,2]),({S:"return -1;\u000A"}));
}
else if(GR.S===({S:"findLastArray"}).S){
(qr)((GO),([130,134]));
(HQ)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(HR)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(HS)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(HT)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((HR).vf),([129,2]))).S}).S+({S:({S:({S:"[0]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((HR).vf),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((HQ).vf),([129,2]))).S}).S+({S:({S:({S:".S.lastIndexOf(String.fromCharCode("}).S+((v)(((HS).vf),([129,2]))).S}).S+({S:({S:({S:"),"}).S+((v)(((HT).vf),([129,2]))).S}).S+({S:({S:({S:"===-1?"}).S+((v)(((HQ).vf),([129,2]))).S}).S+({S:({S:({S:".S.length-1:"}).S+((v)(((HT).vf),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:"else\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((HQ).vf),([129,2]))).S}).S+({S:({S:({S:".lastIndexOf("}).S+((v)(((HS).vf),([129,2]))).S}).S+({S:({S:({S:","}).S+((v)(((HT).vf),([129,2]))).S}).S+({S:({S:({S:"===-1?"}).S+((v)(((HQ).vf),([129,2]))).S}).S+({S:({S:({S:".S.length-1:"}).S+((v)(((HT).vf),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}).S}).S}));
}
else if(GR.S===({S:"floor"}).S){
(qr)((GO),([130,134]));
(HV)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return Math.floor("}).S+((v)(((HV).vf),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(GR.S===({S:"forEach"}).S){
(qr)((GO),([130,134]));
(HX)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(HY)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(HZ)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Ia)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"let D_={F:"}).S+((v)(((HZ).vf),([129,2]))).S}).S+({S:({S:({S:",D:"}).S+((v)(((Ia).vf),([129,2]))).S}).S+({S:",C:true};\u000A"}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((HY).vf),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((HY).vf),([129,2]))).S}).S+({S:({S:({S:"[2]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((HX).vf),([129,2]))).S}).S+({S:".forEach(function(V_,K_){if(this.C)this.C=this.F({S:K_},V_,this.D)},D_);\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"else\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((HX).vf),([129,2]))).S}).S+({S:".forEach(function(V_,K_){if(this.C)this.C=this.F(K_,V_,this.D)},D_);\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"return D_.C;\u000A"}));
}
else if(GR.S===({S:"getDict"}).S){
(qr)((GO),([130,134]));
(Ic)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Id)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Ie)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(If)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:"let r_;\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Id).vf),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((Id).vf),([129,2]))).S}).S+({S:({S:({S:"[2]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"r_="}).S+((v)(((Ic).vf),([129,2]))).S}).S+({S:({S:({S:".get("}).S+((v)(((Ie).vf),([129,2]))).S}).S+({S:".S);\u000A"}).S}).S}));
(eN)((GM),([130,129,2]),({S:"else\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"r_="}).S+((v)(((Ic).vf),([129,2]))).S}).S+({S:({S:({S:".get("}).S+((v)(((Ie).vf),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"if(!("}).S+((v)(((If).vf),([129,2]))).S}).S+({S:".$=r_!==undefined)){\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"switch("}).S+((v)(((Id).vf),([129,2]))).S}).S+({S:"){\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((0),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((1),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((2),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((4),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((5),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((6),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((7),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((9),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"return 0;\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((3),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"return false;\u000A"}));
(eN)((GM),([130,129,2]),({S:"default:\u000A"}));
(eN)((GM),([130,129,2]),({S:"return null;\u000A"}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
(eN)((GM),([130,129,2]),({S:"return r_;\u000A"}));
}
else if(GR.S===({S:"getList"}).S){
(qr)((GO),([130,134]));
(Ih)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Ih).vf),([129,2]))).S}).S+({S:".P.I;\u000A"}).S}));
}
else if(GR.S===({S:"getQueue"}).S){
(qr)((GO),([130,134]));
(Ij)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Ij).vf),([129,2]))).S}).S+({S:".shift();\u000A"}).S}));
}
else if(GR.S===({S:"getStack"}).S){
(qr)((GO),([130,134]));
(Il)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Il).vf),([129,2]))).S}).S+({S:".pop();\u000A"}).S}));
}
else if(GR.S===({S:"head"}).S){
(qr)((GO),([130,134]));
(In)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((In).vf),([129,2]))).S}).S+({S:({S:({S:".P="}).S+((v)(((In).vf),([129,2]))).S}).S+({S:".H;\u000A"}).S}).S}));
}
else if(GR.S===({S:"idx"}).S){
(qr)((GO),([130,134]));
(Ip)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"let p_="}).S+((v)(((Ip).vf),([129,2]))).S}).S+({S:".H,i_=0;\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Ip).vf),([129,2]))).S}).S+({S:".P===null)return -1;\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"while(p_!==null){\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"if(p_==="}).S+((v)(((Ip).vf),([129,2]))).S}).S+({S:".P)return i_\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"i_++;\u000A"}));
(eN)((GM),([130,129,2]),({S:"p_=p_.N;\u000A"}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
(eN)((GM),([130,129,2]),({S:"return -1;\u000A"}));
}
else if(GR.S===({S:"ins"}).S){
(qr)((GO),([130,134]));
(Ir)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(r8)((GO),([130,134]));
(Is)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"let p_="}).S+((v)(((Ir).vf),([129,2]))).S}).S+({S:".P;\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"let n_={P:p_.P,N:p_,I:"}).S+((v)(((Is).vf),([129,2]))).S}).S+({S:"}\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"if(p_.P===null)"}).S+((v)(((Ir).vf),([129,2]))).S}).S+({S:".H=n_;else p_.P.N=n_;\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Ir).vf),([129,2]))).S}).S+({S:({S:({S:".T===null)"}).S+((v)(((Ir).vf),([129,2]))).S}).S+({S:".T=n_;\u000A"}).S}).S}));
(eN)((GM),([130,129,2]),({S:"p_.P=n_;\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((Ir).vf),([129,2]))).S}).S+({S:".L++;\u000A"}).S}));
}
else if(GR.S===({S:"invRot"}).S){
(qr)((GO),([130,134]));
(Iu)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Iv)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Iw)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Ix)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"var r_=Math.atan2("}).S+((v)(((Iv).vf),([129,2]))).S}).S+({S:({S:({S:"-"}).S+((v)(((Ix).vf),([129,2]))).S}).S+({S:({S:({S:","}).S+((v)(((Iu).vf),([129,2]))).S}).S+({S:({S:({S:"-"}).S+((v)(((Iw).vf),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:"return r_<0.0?r_+2.0*Math.PI:r_;\u000A"}));
}
else if(GR.S===({S:"ln"}).S){
(qr)((GO),([130,134]));
(Iz)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return Math.log("}).S+((v)(((Iz).vf),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(GR.S===({S:"moveOffset"}).S){
(qr)((GO),([130,134]));
(I1)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(r8)((GO),([130,134]));
(I2)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((I2).vf),([129,2]))).S}).S+({S:">=0){\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"for(let i_=0;i_<"}).S+((v)(((I2).vf),([129,2]))).S}).S+({S:";i_++){\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((I1).vf),([129,2]))).S}).S+({S:".P===null)break;\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((I1).vf),([129,2]))).S}).S+({S:({S:({S:".P="}).S+((v)(((I1).vf),([129,2]))).S}).S+({S:".P.N;\u000A"}).S}).S}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
(eN)((GM),([130,129,2]),({S:"}else{\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"for(let i_=0;i_>"}).S+((v)(((I2).vf),([129,2]))).S}).S+({S:";i_--){\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((I1).vf),([129,2]))).S}).S+({S:".P===null)break;\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((I1).vf),([129,2]))).S}).S+({S:({S:({S:".P="}).S+((v)(((I1).vf),([129,2]))).S}).S+({S:".P.P;\u000A"}).S}).S}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
}
else if(GR.S===({S:"next"}).S){
(qr)((GO),([130,134]));
(I4)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((I4).vf),([129,2]))).S}).S+({S:({S:({S:".P="}).S+((v)(((I4).vf),([129,2]))).S}).S+({S:".P.N;\u000A"}).S}).S}));
}
else if(GR.S===({S:"not"}).S){
(qr)((GO),([130,134]));
(I6)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return ~"}).S+((v)(((I6).vf),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
else if(GR.S===({S:"or"}).S){
(qr)((GO),([130,134]));
(I8)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(r8)((GO),([130,134]));
(I9)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((I8).vf),([129,2]))).S}).S+({S:({S:({S:"|"}).S+((v)(((I9).vf),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(GR.S===({S:"peekQueue"}).S){
(qr)((GO),([130,134]));
(IB)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((IB).vf),([129,2]))).S}).S+({S:"[0];\u000A"}).S}));
}
else if(GR.S===({S:"peekStack"}).S){
(qr)((GO),([130,134]));
(ID)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((ID).vf),([129,2]))).S}).S+({S:({S:({S:"["}).S+((v)(((ID).vf),([129,2]))).S}).S+({S:".length-1];\u000A"}).S}).S}));
}
else if(GR.S===({S:"prev"}).S){
(qr)((GO),([130,134]));
(IF)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((IF).vf),([129,2]))).S}).S+({S:({S:({S:".P="}).S+((v)(((IF).vf),([129,2]))).S}).S+({S:".P.P;\u000A"}).S}).S}));
}
else if(GR.S===({S:"rnd"}).S){
(qr)((GO),([130,134]));
(IH)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(II)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return ~~(Math.random()*("}).S+((v)(((II).vf),([129,2]))).S}).S+({S:({S:({S:"-"}).S+((v)(((IH).vf),([129,2]))).S}).S+({S:({S:({S:"+1))+"}).S+((v)(((IH).vf),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
}
else if(GR.S===({S:"rndFloat"}).S){
(qr)((GO),([130,134]));
(IK)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(IL)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return Math.random()*("}).S+((v)(((IL).vf),([129,2]))).S}).S+({S:({S:({S:"-"}).S+((v)(((IK).vf),([129,2]))).S}).S+({S:({S:({S:")+"}).S+((v)(((IK).vf),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
}
else if(GR.S===({S:"sar"}).S){
(qr)((GO),([130,134]));
(IN)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(r8)((GO),([130,134]));
(IO)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((IN).vf),([129,2]))).S}).S+({S:({S:({S:">>"}).S+((v)(((IO).vf),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(GR.S===({S:"shl"}).S){
(qr)((GO),([130,134]));
(IQ)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(r8)((GO),([130,134]));
(IR)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((IQ).vf),([129,2]))).S}).S+({S:({S:({S:"<<"}).S+((v)(((IR).vf),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(GR.S===({S:"shr"}).S){
(qr)((GO),([130,134]));
(IT)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(r8)((GO),([130,134]));
(IU)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((IT).vf),([129,2]))).S}).S+({S:({S:({S:">>>"}).S+((v)(((IU).vf),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(GR.S===({S:"sin"}).S){
(qr)((GO),([130,134]));
(IW)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return Math.sin("}).S+((v)(((IW).vf),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(GR.S===({S:"sinh"}).S){
(qr)((GO),([130,134]));
(IY)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return Math.sinh("}).S+((v)(((IY).vf),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(GR.S===({S:"sqrt"}).S){
(qr)((GO),([130,134]));
(Ja)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return Math.sqrt("}).S+((v)(((Ja).vf),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(GR.S===({S:"sub"}).S){
(qr)((GO),([130,134]));
(Jc)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Jd)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Je)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Jf)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Jd).vf),([129,2]))).S}).S+({S:({S:({S:"[0]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((Jd).vf),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"return {S:"}).S+((v)(((Jf).vf),([129,2]))).S}).S+({S:({S:({S:"===-1?"}).S+((v)(((Jc).vf),([129,2]))).S}).S+({S:({S:({S:".S.slice("}).S+((v)(((Je).vf),([129,2]))).S}).S+({S:({S:({S:"):"}).S+((v)(((Jc).vf),([129,2]))).S}).S+({S:({S:({S:".S.slice("}).S+((v)(((Je).vf),([129,2]))).S}).S+({S:({S:({S:","}).S+((v)(((Je).vf),([129,2]))).S}).S+({S:({S:({S:"+"}).S+((v)(((Jf).vf),([129,2]))).S}).S+({S:")};\u000A"}).S}).S}).S}).S}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:"else\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Jf).vf),([129,2]))).S}).S+({S:({S:({S:"===-1?"}).S+((v)(((Jc).vf),([129,2]))).S}).S+({S:({S:({S:".slice("}).S+((v)(((Je).vf),([129,2]))).S}).S+({S:({S:({S:"):"}).S+((v)(((Jc).vf),([129,2]))).S}).S+({S:({S:({S:".slice("}).S+((v)(((Je).vf),([129,2]))).S}).S+({S:({S:({S:","}).S+((v)(((Je).vf),([129,2]))).S}).S+({S:({S:({S:"+"}).S+((v)(((Jf).vf),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}).S}).S}).S}).S}));
}
else if(GR.S===({S:"sysTime"}).S){
(eN)((GM),([130,129,2]),({S:"return new Date().getTime();\u000A"}));
}
else if(GR.S===({S:"tail"}).S){
(qr)((GO),([130,134]));
(Ji)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((Ji).vf),([129,2]))).S}).S+({S:({S:({S:".P="}).S+((v)(((Ji).vf),([129,2]))).S}).S+({S:".T;\u000A"}).S}).S}));
}
else if(GR.S===({S:"tan"}).S){
(qr)((GO),([130,134]));
(Jk)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return Math.tan("}).S+((v)(((Jk).vf),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(GR.S===({S:"tanh"}).S){
(qr)((GO),([130,134]));
(Jm)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return Math.tanh("}).S+((v)(((Jm).vf),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(GR.S===({S:"term"}).S){
(qr)((GO),([130,134]));
(Jo)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Jo).vf),([129,2]))).S}).S+({S:".P===null;\u000A"}).S}));
}
else if(GR.S===({S:"toArray"}).S){
(qr)((GO),([130,134]));
(Jq)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"let a_=new Array("}).S+((v)(((Jq).vf),([129,2]))).S}).S+({S:({S:({S:".L),e_="}).S+((v)(((Jq).vf),([129,2]))).S}).S+({S:".H;\u000A"}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"for(let i_=0;i_<"}).S+((v)(((Jq).vf),([129,2]))).S}).S+({S:".L;i_++){\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"a_[i_]=e_.I;\u000A"}));
(eN)((GM),([130,129,2]),({S:"e_=e_.N;\u000A"}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
(eN)((GM),([130,129,2]),({S:"return a_;\u000A"}));
}
else if(GR.S===({S:"toBit64"}).S){
(qr)((GO),([130,134]));
(Js)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Jt)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Js).vf),([129,2]))).S}).S+({S:({S:({S:".S.length>=2&&"}).S+((v)(((Js).vf),([129,2]))).S}).S+({S:({S:({S:".S[0]===\"0\"&&"}).S+((v)(((Js).vf),([129,2]))).S}).S+({S:".S[1]===\"x\"){\u000A"}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"let s_="}).S+((v)(((Js).vf),([129,2]))).S}).S+({S:({S:({S:".S.slice(2),r_=Number("}).S+((v)(((Js).vf),([129,2]))).S}).S+({S:".S);\u000A"}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((Jt).vf),([129,2]))).S}).S+({S:".$=!isNaN(r_);\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"return parseInt(s_,16);\u000A"}));
(eN)((GM),([130,129,2]),({S:"}else{\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"let r_=Number("}).S+((v)(((Js).vf),([129,2]))).S}).S+({S:".S);\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((Jt).vf),([129,2]))).S}).S+({S:".$=!isNaN(r_);\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"return parseInt("}).S+((v)(((Js).vf),([129,2]))).S}).S+({S:".S,10);\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
}
else if(GR.S===({S:"toFloat"}).S){
(qr)((GO),([130,134]));
(Jv)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Jw)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"let r_=Number("}).S+((v)(((Jv).vf),([129,2]))).S}).S+({S:".S);\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((Jw).vf),([129,2]))).S}).S+({S:".$=!isNaN(r_);\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"return r_;\u000A"}));
}
else if(GR.S===({S:"toInt"}).S){
(qr)((GO),([130,134]));
(Jy)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Jz)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Jy).vf),([129,2]))).S}).S+({S:({S:({S:".S.length>=2&&"}).S+((v)(((Jy).vf),([129,2]))).S}).S+({S:({S:({S:".S[0]===\"0\"&&"}).S+((v)(((Jy).vf),([129,2]))).S}).S+({S:".S[1]===\"x\"){\u000A"}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"let s_="}).S+((v)(((Jy).vf),([129,2]))).S}).S+({S:({S:({S:".S.slice(2),r_=Number("}).S+((v)(((Jy).vf),([129,2]))).S}).S+({S:".S);\u000A"}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((Jz).vf),([129,2]))).S}).S+({S:".$=!isNaN(r_);\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"return parseInt(s_,16);\u000A"}));
(eN)((GM),([130,129,2]),({S:"}else{\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"let r_=Number("}).S+((v)(((Jy).vf),([129,2]))).S}).S+({S:".S);\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((Jz).vf),([129,2]))).S}).S+({S:".$=!isNaN(r_);\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"return parseInt("}).S+((v)(((Jy).vf),([129,2]))).S}).S+({S:".S,10);\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
}
else if(GR.S===({S:"toStr"}).S){
(qr)((GO),([130,134]));
(J1)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(J2)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:"let n_;\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"switch("}).S+((v)(((J2).vf),([129,2]))).S}).S+({S:"[0]){\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((0),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((1),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((9),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"return{S:"}).S+((v)(((J1).vf),([129,2]))).S}).S+({S:".toString(10)};\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((2),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"return{S:String.fromCharCode("}).S+((v)(((J1).vf),([129,2]))).S}).S+({S:")};\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((3),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"return{S:"}).S+((v)(((J1).vf),([129,2]))).S}).S+({S:"?\"true\":\"false\"};\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((4),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"n_="}).S+((v)(((J1).vf),([129,2]))).S}).S+({S:({S:({S:">=0?~~"}).S+((v)(((J1).vf),([129,2]))).S}).S+({S:({S:({S:"&0xFF:0xFF-(~"}).S+((v)(((J1).vf),([129,2]))).S}).S+({S:"&0xFF);\u000A"}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:"return{S:\"0x\"+(\"00\"+n_.toString(16)).slice(-2).toUpperCase()};\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((5),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"n_="}).S+((v)(((J1).vf),([129,2]))).S}).S+({S:({S:({S:">=0?~~"}).S+((v)(((J1).vf),([129,2]))).S}).S+({S:({S:({S:"&0xFFFF:0xFFFF-(~"}).S+((v)(((J1).vf),([129,2]))).S}).S+({S:"&0xFFFF);\u000A"}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:"return{S:\"0x\"+(\"0000\"+n_.toString(16)).slice(-4).toUpperCase()};\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((6),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"n_="}).S+((v)(((J1).vf),([129,2]))).S}).S+({S:">>>0;\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"return{S:\"0x\"+(\"00000000\"+n_.toString(16)).slice(-8).toUpperCase()};\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((7),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"n_="}).S+((v)(((J1).vf),([129,2]))).S}).S+({S:">>>0;\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"return{S:\"0x\"+(("}).S+((v)(((J1).vf),([129,2]))).S}).S+({S:">=0?\"0000000000000000\":\"FFFFFFFFFFFFFFFF\")+n_.toString(16)).slice(-16).toUpperCase()};\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"case "}).S+((v)((129),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((J2).vf),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((J1).vf),([129,2]))).S}).S+({S:";\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
}
else if(GR.S===({S:"xor"}).S){
(qr)((GO),([130,134]));
(J4)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(r8)((GO),([130,134]));
(J5)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((J4).vf),([129,2]))).S}).S+({S:({S:({S:"^"}).S+((v)(((J5).vf),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(GR.S===({S:"cui_print"}).S){
(qr)((GO),([130,134]));
(J7)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((J7).vf),([129,2]))).S}).S+({S:({S:({S:"===null)"}).S+((v)(((J7).vf),([129,2]))).S}).S+({S:"={S:\"(null)\"};\u000A"}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"if(O_&&O_.print){O_.print("}).S+((v)(((J7).vf),([129,2]))).S}).S+({S:".S);return;}\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"console.log("}).S+((v)(((J7).vf),([129,2]))).S}).S+({S:".S);\u000A"}).S}));
}
else if(GR.S===({S:"file_copyFile"}).S){
(eN)((GM),([130,129,2]),({S:"return false;\u000A"}));
}
else if(GR.S===({S:"file_exist"}).S){
(qr)((GO),([130,134]));
(JA)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"let f_=false,p_="}).S+((v)(((JA).vf),([129,2]))).S}).S+({S:".S;\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"if(O_&&O_.readFile)f_=O_.readFile(p_)!==null;\u000A"}));
(eN)((GM),([130,129,2]),({S:"if(f_===false){\u000A"}));
(eN)((GM),([130,129,2]),({S:"if(p_.length>=4&&p_[0]===\"r\"&&p_[1]===\"e\"&&p_[2]===\"s\"&&p_[3]===\"/\")\u000A"}));
(eN)((GM),([130,129,2]),({S:"f_=F_(p_,false);\u000A"}));
(eN)((GM),([130,129,2]),({S:"else{\u000A"}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
(eN)((GM),([130,129,2]),({S:"return f_;\u000A"}));
}
else if(GR.S===({S:"file_forEach"}).S){
(qr)((GO),([130,134]));
(JC)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(JD)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(JE)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(JF)=((uO)(((qv)((GO),([130,134])))));
(eN)((GM),([130,129,2]),({S:({S:({S:"let f_,p_="}).S+((v)(((JC).vf),([129,2]))).S}).S+({S:".S;\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"if(p_.length>=4&&p_[0]===\"r\"&&p_[1]===\"e\"&&p_[2]===\"s\"&&p_[3]===\"/\")\u000A"}));
(eN)((GM),([130,129,2]),({S:"f_=FF_();\u000A"}));
(eN)((GM),([130,129,2]),({S:"for(let i_=0;i_<f_.length;i_++){\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"if(f_[i_].slice(0,p_.length)===p_&&("}).S+((v)(((JD).vf),([129,2]))).S}).S+({S:"||f_[i_].slice(p_.length).indexOf(\"/\")===-1)){\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"if(!"}).S+((v)(((JE).vf),([129,2]))).S}).S+({S:({S:({S:"({S:f_[i_]},f_[i_][f_[i_].length-1]===\'/\',"}).S+((v)(((JF).vf),([129,2]))).S}).S+({S:"))return false"}).S}).S}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
(eN)((GM),([130,129,2]),({S:"return true;\u000A"}));
}
else if(GR.S===({S:"file_makeReader"}).S){
(qr)((GO),([130,134]));
(JH)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(JI)=((uO)(((qv)((GO),([130,134])))));
(JJ)=((JK)((GP),({S:"handle"})));
(eN)((GM),([130,129,2]),({S:({S:({S:"let f_=null,p_="}).S+((v)(((JI).vf),([129,2]))).S}).S+({S:".S;\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"if(O_&&O_.readFile)f_=O_.readFile(p_);\u000A"}));
(eN)((GM),([130,129,2]),({S:"if(f_===null){\u000A"}));
(eN)((GM),([130,129,2]),({S:"if(p_.length>=4&&p_[0]===\"r\"&&p_[1]===\"e\"&&p_[2]===\"s\"&&p_[3]===\"/\")\u000A"}));
(eN)((GM),([130,129,2]),({S:"f_=F_(p_,true);\u000A"}));
(eN)((GM),([130,129,2]),({S:"else{\u000A"}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
(eN)((GM),([130,129,2]),({S:"if(f_===null)return null;\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((JH).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((JJ).vf),([129,2]))).S}).S+({S:"={F:f_,I:0};\u000A"}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((JH).vf),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
else if(GR.S===({S:"file_makeWriter"}).S){
(qr)((GO),([130,134]));
(JM)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(JN)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(JO)=((uO)(((qv)((GO),([130,134])))));
(JP)=((JK)((GP),({S:"handle"})));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((JM).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((JP).vf),([129,2]))).S}).S+({S:({S:({S:"={F:\"\",I:0,P:"}).S+((v)(((JN).vf),([129,2]))).S}).S+({S:".S};\u000A"}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((JM).vf),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
else if(GR.S===({S:"file_readerFin"}).S){
(qr)((GO),([130,134]));
(JR)=((uO)(((qv)((GO),([130,134])))));
(JS)=((JK)((GP),({S:"handle"})));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((JR).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((JS).vf),([129,2]))).S}).S+({S:".F=null;\u000A"}).S}).S}));
}
else if(GR.S===({S:"file_readerGetPos"}).S){
(qr)((GO),([130,134]));
(JU)=((uO)(((qv)((GO),([130,134])))));
(JV)=((JK)((GP),({S:"handle"})));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((JU).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((JV).vf),([129,2]))).S}).S+({S:".I;\u000A"}).S}).S}));
}
else if(GR.S===({S:"file_readerReadLetter"}).S){
(qr)((GO),([130,134]));
(JX)=((uO)(((qv)((GO),([130,134])))));
(JY)=((JK)((GP),({S:"handle"})));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((JX).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((JY).vf),([129,2]))).S}).S+({S:({S:({S:".F.charCodeAt("}).S+((v)(((JX).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((JY).vf),([129,2]))).S}).S+({S:".I++);\u000A"}).S}).S}).S}).S}));
}
else if(GR.S===({S:"file_readerSetPos"}).S){
(qr)((GO),([130,134]));
(Ka)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Kb)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Kc)=((uO)(((qv)((GO),([130,134])))));
(Kd)=((JK)((GP),({S:"handle"})));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((Ka).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Kd).vf),([129,2]))).S}).S+({S:({S:({S:".I="}).S+((v)(((Kc).vf),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
}
else if(GR.S===({S:"file_readerTerm"}).S){
(qr)((GO),([130,134]));
(Kf)=((uO)(((qv)((GO),([130,134])))));
(Kg)=((JK)((GP),({S:"handle"})));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Kf).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Kg).vf),([129,2]))).S}).S+({S:({S:({S:".I>="}).S+((v)(((Kf).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Kg).vf),([129,2]))).S}).S+({S:".F.length;\u000A"}).S}).S}).S}).S}));
}
else if(GR.S===({S:"file_writerFin"}).S){
(qr)((GO),([130,134]));
(Ki)=((uO)(((qv)((GO),([130,134])))));
(Kj)=((JK)((GP),({S:"handle"})));
(eN)((GM),([130,129,2]),({S:({S:({S:"var d_="}).S+((v)(((Ki).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Kj).vf),([129,2]))).S}).S+({S:".F.replace(\"\\n\", \"\\u000D\\n\");\u000A"}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"if(O_&&O_.writeFile){O_.writeFile("}).S+((v)(((Ki).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Kj).vf),([129,2]))).S}).S+({S:".P,d_);return;}\u000A"}).S}).S}));
(eN)((GM),([130,129,2]),({S:"let b_=new Blob([d_]);\u000A"}));
(eN)((GM),([130,129,2]),({S:"let l_=document.createElement(\"a\");\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"l_.download="}).S+((v)(((Ki).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Kj).vf),([129,2]))).S}).S+({S:".P;\u000A"}).S}).S}));
(eN)((GM),([130,129,2]),({S:"l_.href=(URL||webkitURL).createObjectURL(b_);\u000A"}));
(eN)((GM),([130,129,2]),({S:"l_.setAttribute(\"style\",\"display:none\");\u000A"}));
(eN)((GM),([130,129,2]),({S:"document.body.appendChild(l_);\u000A"}));
(eN)((GM),([130,129,2]),({S:"l_.click();\u000A"}));
(eN)((GM),([130,129,2]),({S:"document.body.removeChild(l_);\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((Ki).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Kj).vf),([129,2]))).S}).S+({S:".F=null;\u000A"}).S}).S}));
}
else if(GR.S===({S:"file_writerGetPos"}).S){
(qr)((GO),([130,134]));
(Kl)=((uO)(((qv)((GO),([130,134])))));
(Km)=((JK)((GP),({S:"handle"})));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Kl).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Km).vf),([129,2]))).S}).S+({S:".I;\u000A"}).S}).S}));
}
else if(GR.S===({S:"file_writerSetPos"}).S){
(qr)((GO),([130,134]));
(Ko)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Kp)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Kq)=((uO)(((qv)((GO),([130,134])))));
(Kr)=((JK)((GP),({S:"handle"})));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((Ko).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Kr).vf),([129,2]))).S}).S+({S:({S:({S:".I="}).S+((v)(((Kq).vf),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
}
else if(GR.S===({S:"file_writerWrite"}).S){
(qr)((GO),([130,134]));
(Kt)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Ku)=((uO)(((qv)((GO),([130,134])))));
(Kv)=((JK)((GP),({S:"handle"})));
}
else if(GR.S===({S:"file_writerWriteChar"}).S){
(qr)((GO),([130,134]));
(Kx)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(Ky)=((uO)(((qv)((GO),([130,134])))));
(Kz)=((JK)((GP),({S:"handle"})));
(eN)((GM),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Kx).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Kz).vf),([129,2]))).S}).S+({S:({S:({S:".I<"}).S+((v)(((Kx).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Kz).vf),([129,2]))).S}).S+({S:".F.length)\u000A"}).S}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((Kx).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Kz).vf),([129,2]))).S}).S+({S:({S:({S:".F="}).S+((v)(((Kx).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Kz).vf),([129,2]))).S}).S+({S:({S:({S:".F.slice(0,"}).S+((v)(((Kx).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Kz).vf),([129,2]))).S}).S+({S:({S:({S:".I)+String.fromCharCode("}).S+((v)(((Ky).vf),([129,2]))).S}).S+({S:({S:({S:")+"}).S+((v)(((Kx).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Kz).vf),([129,2]))).S}).S+({S:({S:({S:".F.slice("}).S+((v)(((Kx).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Kz).vf),([129,2]))).S}).S+({S:".I+1);\u000A"}).S}).S}).S}).S}).S}).S}).S}).S}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:"else{\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((Kx).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Kz).vf),([129,2]))).S}).S+({S:({S:({S:".F+=String.fromCharCode("}).S+((v)(((Ky).vf),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
(eN)((GM),([130,129,2]),({S:"}\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((Kx).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Kz).vf),([129,2]))).S}).S+({S:".I++;\u000A"}).S}).S}));
}
else if(GR.S===({S:"wnd_editBaseGetText"}).S){
(qr)((GO),([130,134]));
(K1)=((uO)(((qv)((GO),([130,134])))));
(K2)=((JK)((GP),({S:"handle"})));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((K1).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((K2).vf),([129,2]))).S}).S+({S:".H.value;\u000A"}).S}).S}));
}
else if(GR.S===({S:"wnd_makeEditMulti"}).S){
(qr)((GO),([130,134]));
(K4)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(K5)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(K6)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(K7)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(K8)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(K9)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(KA)=((uO)(((qv)((GO),([130,134])))));
(r8)((GO),([130,134]));
(KB)=((uO)(((qv)((GO),([130,134])))));
(KC)=((JK)((GP),({S:"handle"})));
(eN)((GM),([130,129,2]),({S:"let h_=document.createElement(\"textarea\");\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:"h_.setAttribute(\"cols\",\""}).S+((v)(((K8).vf),([129,2]))).S}).S+({S:"\");\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"h_.setAttribute(\"rows\",\""}).S+((v)(((K9).vf),([129,2]))).S}).S+({S:"\");\u000A"}).S}));
(eN)((GM),([130,129,2]),({S:"document.body.appendChild(c_);\u000A"}));
(eN)((GM),([130,129,2]),({S:({S:({S:""}).S+((v)(((K4).vf),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((KC).vf),([129,2]))).S}).S+({S:"={C:c_};\u000A"}).S}).S}));
(eN)((GM),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((K4).vf),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
else{if(!(false)){throw 0xE9170000;}
}
}
// buildStats
function v1(KE /*stats*/){
let KG; // stat
let KI;
(qr)((KE),([130,134]));
while(!((qt)((KE),([130,134])))){
(KG)=((qv)((KE),([130,134])));
KI=(KG).qc;
switch(KI){
case 66049:
(KK)((KG));
break;
case 66050:
(KM)((KG));
break;
case 16843265:
(KO)((KG));
break;
case 16843266:
(KQ)((KG));
break;
case 66051:
(KS)((KG));
break;
case 526:
(KU)((KG));
break;
case 66052:
(KW)((KG));
break;
case 527:
(KY)((KG));
break;
case 528:
(La)((KG));
break;
case 529:
(Lc)((KG));
break;
case 530:
(Le)((KG));
break;
case 531:
(Lg)((KG));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(r8)((KE),([130,134]));
}
}
// refClass
function vG(Li /*ast*/){
let Lj; // info
(Lj)=((uO)((Li)));
if((Lj).uR){
return (Lj).vf;
}
((Lj).uR)=(true);
if(((Li).qz)!==(null)){
(vG)(((Li).qz));
}
(eQ)((ak),([132,134]),(Li));
return (Lj).vf;
}
// findFunc
function vO(Lo /*ast*/,Lp /*name*/){
let Lq; // items
let Ls; // item
(Lq)=((Lo).tm);
(qr)((Lq),([130,134]));
while(!((qt)((Lq),([130,134])))){
(Ls)=((qv)((Lq),([130,134])));
if(((((Ls).tX).qc)===(256))&&((((Ls).tX).qX).S===(Lp).S)){
return (Ls).tX;
}
(r8)((Lq),([130,134]));
}
return null;
}
// writeJs
function wg(Lv /*writer*/,Lw /*resFiles*/){
let Lx; // static
let L0;
let L5; // globalVar
let L6; // info
let LA; // first
let LC; // resFile
let LI;
let LO; // reader
let LQ; // line
let LT;
let LZ; // first
let Mb; // resFile
let Mh;
let Ly;
let Lz;
let LJ;
let LU;
let Mi;
(Lx)=((Ly=(pR)((Y),([133,129,2,3]),({S:"static"}),(Lz={$:(L0)},Lz)),(L0)=Lz.$,Ly));
if(Lx){
(uG)((Lv),({S:({S:({S:"\"use strict\";function "}).S+((v)(((co)((V))),([129,2]))).S}).S+({S:"(O_){\u000A"}).S}));
}
else{
(uG)((Lv),({S:"\"use strict\";!function(f){let d=document;function h(){d.removeEventListener(\"DOMContentLoaded\",h);removeEventListener(\"load\",h);f()}\"complete\"===d.readyState||\"loading\"!==d.readyState&&!d.documentElement.doScroll?setTimeout(f):(d.addEventListener(\"DOMContentLoaded\",h),addEventListener(\"load\",h))}(function(){\u000A"}));
(uG)((Lv),({S:"let O_;\u000A"}));
}
(qr)((ao),([130,134]));
while(!((qt)((ao),([130,134])))){
(L5)=((qv)((ao),([130,134])));
(L6)=((uO)((L5)));
(uG)((Lv),({S:({S:({S:"let "}).S+((v)(((L6).vf),([129,2]))).S}).S+({S:({S:({S:"="}).S+((v)(((L7)(((L5).sA))),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
(r8)((ao),([130,134]));
}
(qr)((am),([130,129,2]));
while(!((qt)((am),([130,129,2])))){
(uG)((Lv),((qv)((am),([130,129,2]))));
(r8)((am),([130,129,2]));
}
(uG)((Lv),({S:"function C_(t,v){\u000A"}));
(uG)((Lv),({S:"switch(t[0]){\u000A"}));
(uG)((Lv),({S:({S:({S:"case "}).S+((v)((0),([0]))).S}).S+({S:":\u000A"}).S}));
(uG)((Lv),({S:({S:({S:"case "}).S+((v)((1),([0]))).S}).S+({S:":\u000A"}).S}));
(uG)((Lv),({S:({S:({S:"case "}).S+((v)((2),([0]))).S}).S+({S:":\u000A"}).S}));
(uG)((Lv),({S:({S:({S:"case "}).S+((v)((3),([0]))).S}).S+({S:":\u000A"}).S}));
(uG)((Lv),({S:({S:({S:"case "}).S+((v)((4),([0]))).S}).S+({S:":\u000A"}).S}));
(uG)((Lv),({S:({S:({S:"case "}).S+((v)((5),([0]))).S}).S+({S:":\u000A"}).S}));
(uG)((Lv),({S:({S:({S:"case "}).S+((v)((6),([0]))).S}).S+({S:":\u000A"}).S}));
(uG)((Lv),({S:({S:({S:"case "}).S+((v)((7),([0]))).S}).S+({S:":\u000A"}).S}));
(uG)((Lv),({S:({S:({S:"case "}).S+((v)((8),([0]))).S}).S+({S:":\u000A"}).S}));
(uG)((Lv),({S:({S:({S:"case "}).S+((v)((9),([0]))).S}).S+({S:":\u000A"}).S}));
(uG)((Lv),({S:"return v;\u000A"}));
(uG)((Lv),({S:({S:({S:"case "}).S+((v)((129),([0]))).S}).S+({S:":\u000A"}).S}));
(uG)((Lv),({S:({S:({S:"if(t[1]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}));
(uG)((Lv),({S:"return v===null?null:{S:v.S};\u000A"}));
(uG)((Lv),({S:"else{\u000A"}));
(uG)((Lv),({S:"let a=new Array(v.length);\u000A"}));
(uG)((Lv),({S:"for(let i=0;i<v.length;i++)a[i]=C_(t.slice(1),v[i]);\u000A"}));
(uG)((Lv),({S:"return a;\u000A"}));
(uG)((Lv),({S:"}\u000A"}));
(uG)((Lv),({S:({S:({S:"case "}).S+((v)((130),([0]))).S}).S+({S:":\u000A"}).S}));
(uG)((Lv),({S:({S:({S:"case "}).S+((v)((131),([0]))).S}).S+({S:":\u000A"}).S}));
(uG)((Lv),({S:({S:({S:"case "}).S+((v)((132),([0]))).S}).S+({S:":\u000A"}).S}));
(uG)((Lv),({S:({S:({S:"case "}).S+((v)((133),([0]))).S}).S+({S:":\u000A"}).S}));
(uG)((Lv),({S:({S:({S:"case "}).S+((v)((134),([0]))).S}).S+({S:":\u000A"}).S}));
(uG)((Lv),({S:"}\u000A"}));
(uG)((Lv),({S:"}\u000A"}));
(uG)((Lv),({S:"function F_(p,f){\u000A"}));
(LA)=(true);
(qr)((Lw),([130,129,2]));
while(!((qt)((Lw),([130,129,2])))){
(LC)=((qv)((Lw),([130,129,2])));
if(LA){
(LA)=(false);
(uG)((Lv),({S:"if(p===\""}));
}
else{
(uG)((Lv),({S:"else if(p===\""}));
}
LH:
for(LI=((Z).S.length),LJ=(((LC).S.length)-(1));LI<=LJ;LI+=(1)){
(uG)((Lv),((LK)(((LC).S.charCodeAt(LI)))));
}
(uG)((Lv),({S:"\")\u000A"}));
if(((LC).S.charCodeAt(((LC).S.length)-(1)))===(0x002F)){
(uG)((Lv),({S:"return f?null:true;\u000A"}));
}
else{
(uG)((Lv),({S:"return f?\""}));
(LO)=((pB)((new pC()),(LC)));
while(!((uD)((LO)))){
(LQ)=((uF)((LO)));
LS:
for(LT=(0),LU=(((LQ).S.length)-(1));LT<=LU;LT+=(1)){
(uG)((Lv),((LK)(((LQ).S.charCodeAt(LT)))));
}
(uG)((Lv),({S:"\\n"}));
}
(pO)((LO));
(uG)((Lv),({S:"\":true;\u000A"}));
}
(r8)((Lw),([130,129,2]));
}
if(((Lw).L)>(0)){
(uG)((Lv),({S:"else return f?null:false;\u000A"}));
}
else{
(uG)((Lv),({S:"return f?null:false;\u000A"}));
}
(uG)((Lv),({S:"}\u000A"}));
(uG)((Lv),({S:"function FF_(){return["}));
(LZ)=(true);
(qr)((Lw),([130,129,2]));
while(!((qt)((Lw),([130,129,2])))){
(Mb)=((qv)((Lw),([130,129,2])));
if(LZ){
(LZ)=(false);
(uG)((Lv),({S:"\""}));
}
else{
(uG)((Lv),({S:",\""}));
}
Mg:
for(Mh=((Z).S.length),Mi=(((Mb).S.length)-(1));Mh<=Mi;Mh+=(1)){
(uG)((Lv),((LK)(((Mb).S.charCodeAt(Mh)))));
}
(uG)((Lv),({S:"\""}));
(r8)((Lw),([130,129,2]));
}
(uG)((Lv),({S:"];}\u000A"}));
(uG)((Lv),({S:"a();\u000A"}));
if(Lx){
(uG)((Lv),({S:"}\u000A"}));
}
else{
(uG)((Lv),({S:"})\u000A"}));
}
}
// initAst
function wH(Mm /*ast*/,Mn /*typeId*/,Mo /*pos*/,Mp /*name*/,Mq /*setParent*/){
if(!(!((Mm)instanceof yw))){throw 0xE9170000;}
(Mr)((Mm),(Mn),(Mo),(Mp),(Mq));
}
// make
function wI(Ms /*srcName*/,Mt /*row*/,Mu /*col*/){
let Mv; // pos
(Mv)=(new dg());
((Mv).dh)=(Ms);
((Mv).di)=(Mt);
((Mv).dj)=(Mu);
return Mv;
}
// _addStack
function wJ(Mw /*me_*/,Mx /*type*/,My /*item*/){
Mw.push(My);
}
// readChar
function wK(){
let M1; // c
let M5;
M0:
while(true){
(M1)=((xw)());
if((M1)===(0x000A)){
(M1)=((wK)());
M5=M1;
switch(M5){
case 0x000A:
return 0x000A;
break;
case 0x003B:
do{
(M1)=((M9)());
if((M1)===(0x0000)){
return 0x0000;
}
}while((M1)!==(0x000A));
(pH)=(M1);
continue M0;
break;
case 0x007C:
return (wK)();
break;
}
(pI)=(M1);
return 0x000A;
}
if((M1)!==(0x0020)){
return M1;
}
}
}
// readIdentifier
function xb(MF /*skipSpaces*/,MG /*refName*/){
let MH; // c
let MM; // buf
let MN; // pos
let MO; // at
let MR;
let MX; // srcName
let Na;
let Nc; // c2
let Nb;
let Nl;
let Nm;
(MH)=((MF)?((wK)()):((xw)()));
if(!((((((0x0061)<=(MH))&&((MH)<=(0x007A)))||(((0x0041)<=(MH))&&((MH)<=(0x005A))))||((MH)===(0x005F)))||((MG)&&(((MH)===(0x0040))||((MH)===(0x005C)))))){
(pH)=(MH);
(D)((65542),((MK)()),([((ML)((MH)))]));
return {S:""};
}
(MM)=({S:"\0".repeat(128)});
(MN)=(0);
(MO)=(false);
do{
MR=MH;
switch(MR){
case 0x0040:
if(MO){
(pH)=(MH);
(D)((65543),((MK)()),(null));
return {S:""};
}
if((MN)!==(0)){
(MX)=((p9)((MM),([129,2]),(0),(MN)));
MZ:
for(Na=(0),Nb=(((MX).S.length)-(1));Na<=Nb;Na+=(1)){
(Nc)=((MX).S.charCodeAt(Na));
if(((0x0041)<=(Nc))&&((Nc)<=(0x005A))){
(pH)=(MH);
(D)((65544),((MK)()),([(MX)]));
return {S:""};
}
}
(Nf)((MX));
}
(MO)=(true);
break;
case 0x005C:
if(MO){
(pH)=(MH);
(D)((65545),((MK)()),(null));
return {S:""};
}
break;
}
if((MN)===(128)){
(pH)=(MH);
(D)((65546),((MK)()),([(MM)]));
return {S:""};
}
(MM).S=(Nl=(MN),(MM).S.slice(0,Nl)+String.fromCharCode(MH)+(MM).S.slice(Nl+1));
(MN)=((MN)+(1));
(MH)=((xw)());
}while(((((((0x0061)<=(MH))&&((MH)<=(0x007A)))||(((0x0041)<=(MH))&&((MH)<=(0x005A))))||((MH)===(0x005F)))||(((0x0030)<=(MH))&&((MH)<=(0x0039))))||((MG)&&(((MH)===(0x0040))||((MH)===(0x005C)))));
(pH)=(MH);
return (p9)((MM),([129,2]),(0),(MN));
}
// parseFunc
function xf(No /*parentClass*/,Np /*overritten*/){
let Nq; // ast
let Ns; // c
let Nx; // row
let Ny; // col
let Nz; // s
let N4;
let Om; // arg
let Op; // type
let Os; // c
let O5; // c
let OD; // stat
(Nq)=(new c7());
((Nq).qi)=(0);
((Nq).qj)=({L:0,H:null,T:null,P:null});
(Ns)=((wK)());
if((Ns)===(0x005B)){
Nw:
while(true){
(Nx)=(pF);
(Ny)=(pG);
(Nz)=((N0)());
if(((((Nz).S.length)===(5))&&(((Nz).S.charCodeAt(0))===(0x005F)))&&(((Nz).S.charCodeAt(1))===(0x005F))){
N4=(Nz).S.charCodeAt(2);
switch(N4){
case 0x0061:
if((((Nz).S.charCodeAt(3))===(0x006E))&&(((Nz).S.charCodeAt(4))===(0x0079))){
((Nq).qi)=((N8)(((Nq).qi),([9]),(1)));
}
break;
case 0x0066:
if((((Nz).S.charCodeAt(3))===(0x0072))&&(((Nz).S.charCodeAt(4))===(0x0063))){
((Nq).qi)=((N8)(((Nq).qi),([9]),(128)));
}
break;
case 0x006B:
if((((Nz).S.charCodeAt(3))===(0x0076))&&(((Nz).S.charCodeAt(4))===(0x0066))){
((Nq).qi)=((N8)(((Nq).qi),([9]),(256)));
}
break;
case 0x006D:
if((((Nz).S.charCodeAt(3))===(0x006B))&&(((Nz).S.charCodeAt(4))===(0x0069))){
((Nq).qi)=((N8)(((Nq).qi),([9]),(2048)));
}
break;
case 0x0072:
if((((Nz).S.charCodeAt(3))===(0x0061))&&(((Nz).S.charCodeAt(4))===(0x0077))){
((Nq).qi)=((N8)(((Nq).qi),([9]),(4096)));
}
else if((((Nz).S.charCodeAt(3))===(0x006D))&&(((Nz).S.charCodeAt(4))===(0x0065))){
((Nq).qi)=((N8)(((Nq).qi),([9]),(4)));
}
else if((((Nz).S.charCodeAt(3))===(0x0063))&&(((Nz).S.charCodeAt(4))===(0x0068))){
((Nq).qi)=((N8)(((Nq).qi),([9]),(16)));
}
else if(((Nz).S.charCodeAt(3))===(0x0061)){
if(((Nz).S.charCodeAt(4))===(0x0063)){
((Nq).qi)=((N8)(((Nq).qi),([9]),(64)));
}
else if(((Nz).S.charCodeAt(4))===(0x006B)){
((Nq).qi)=((N8)(((Nq).qi),([9]),(512)));
}
else if(((Nz).S.charCodeAt(4))===(0x0076)){
((Nq).qi)=((N8)(((Nq).qi),([9]),(1024)));
}
}
break;
case 0x0074:
if((((Nz).S.charCodeAt(3))===(0x006D))&&(((Nz).S.charCodeAt(4))===(0x0065))){
((Nq).qi)=((N8)(((Nq).qi),([9]),(2)));
}
else if((((Nz).S.charCodeAt(3))===(0x0063))&&(((Nz).S.charCodeAt(4))===(0x0068))){
((Nq).qi)=((N8)(((Nq).qi),([9]),(8)));
}
else if((((Nz).S.charCodeAt(3))===(0x006B))&&(((Nz).S.charCodeAt(4))===(0x0076))){
((Nq).qi)=((N8)(((Nq).qi),([9]),(32)));
}
break;
}
}
else{
(eN)(((Nq).qj),([130,129,2]),(Nz));
}
(Ns)=((wK)());
if((Ns)===(0x0000)){
break Nw;
}
if((Ns)===(0x005D)){
break Nw;
}
if((Ns)!==(0x002C)){
(Oe)((0x002C),(Ns));
break Nw;
}
}
}
else{
(pH)=(Ns);
}
(wH)((Nq),(256),((MK)()),((xb)((true),(false))),(true));
((Nq).qg)=({L:0,H:null,T:null,P:null});
((Nq).qh)=(null);
((Nq).tv)=({L:0,H:null,T:null,P:null});
((Nq).pY)=(new Map());
(wJ)((ah),([131,134]),(Nq));
if((No)!==(null)){
(Oi)((Nq),(No));
}
(Oj)((0x0028),(true));
if((No)!==(null)){
(Om)=(new ro());
(wH)((Om),(7),((Nq).ql),(null),(false));
((Om).qX)=({S:"me"});
((Om).rp)=(2);
((Om).sP)=(false);
((Om).yb)=(null);
(On)((Om),(false));
(Op)=(new Oq());
(wH)((Op),(66565),((Nq).ql),(null),(false));
(Oi)((Op),(No));
((Om).sA)=(Op);
(eN)(((Nq).qg),([130,134]),(Om));
}
(Os)=((wK)());
if((Os)!==(0x0029)){
(pH)=(Os);
Ow:
while(true){
(eN)(((Nq).qg),([130,134]),((Ox)((2),(null))));
(Os)=((wK)());
if((Os)===(0x0000)){
break Ow;
}
if((Os)===(0x0029)){
break Ow;
}
if((Os)!==(0x002C)){
(Oe)((0x002C),(Os));
break Ow;
}
}
}
(O5)=((wK)());
if((O5)===(0x003A)){
((Nq).qh)=((O8)());
(O5)=((wK)());
}
if((O5)!==(0x000A)){
(Oe)((0x000A),(O5));
}
OC:
while(true){
(OD)=((OE)((Nq)));
if((OD)===(null)){
if(pJ){
break OC;
}
else{
continue OC;
}
}
if(((OD).qc)===(513)){
break OC;
}
(eN)(((Nq).tv),([130,134]),(OD));
}
(x2)((ah),([131,134]));
return Nq;
}
// parseVar
function xh(OM /*kind*/,ON /*parentClass*/){
let OO; // ast
(OO)=(new ua());
(wH)((OO),(2),((MK)()),(null),(false));
((OO).uc)=((Ox)((OM),(ON)));
(Oj)((0x000A),(true));
return OO;
}
// parseConst
function xj(){
let OP; // ast
(OP)=(new xk());
(wH)((OP),(3),((MK)()),(null),(false));
((OP).x0)=((Ox)((4),(null)));
(Oj)((0x000A),(true));
return OP;
}
// parseAlias
function xm(){
let OQ; // ast
(OQ)=(new xn());
(wH)((OQ),(4),((MK)()),((xb)((true),(false))),(true));
(Oj)((0x003A),(true));
((OQ).OR)=((O8)());
(Oj)((0x000A),(true));
return OQ;
}
// parseClass
function xq(){
let OS; // ast
let OU; // c
let OY; // kuinSrc
let Pd; // c
let Pi; // row
let Pj; // col
let Pk; // item
let Pu; // id
let Pv; // className
let P7;
let P9; // id2
let PC; // astEndClass
(OS)=(new eZ());
(wH)((OS),(5),((MK)()),((xb)((true),(false))),(true));
((OS).tm)=({L:0,H:null,T:null,P:null});
(Oj)((0x0028),(true));
(OU)=((wK)());
if((OU)!==(0x0029)){
(pH)=(OU);
(Oi)((OS),((xb)((true),(true))));
(Oj)((0x0029),(true));
}
else{
(OY)=((ag).S===({S:"kuin"}).S);
if(!((OY)&&(((OS).qX).S===({S:"Class"}).S))){
(Oi)((OS),((OY)?({S:"@Class"}):({S:"kuin@Class"})));
}
}
(Oj)((0x000A),(true));
((OS).pY)=(new Map());
(wJ)((ah),([131,134]),(OS));
Pc:
while(true){
(Pd)=((wK)());
if((Pd)===(0x0000)){
(D)((65551),((MK)()),([({S:"class"})]));
break Pc;
}
if((Pd)===(0x000A)){
continue Pc;
}
(Pi)=(pF);
(Pj)=(pG);
(Pk)=(new tV());
((Pk).Pl)=(false);
((Pk).Pm)=(false);
((Pk).Pn)=(null);
if((Pd)===(0x002B)){
((Pk).Pl)=(true);
}
else{
(pH)=(Pd);
}
(Pd)=((wK)());
if((Pd)===(0x002A)){
((Pk).Pm)=(true);
}
else{
(pH)=(Pd);
}
(Pu)=((xb)((true),(false)));
(Pv)=(((((OS).qU).qc)===(1))?({S:({S:"@"}).S+((OS).qX).S}):((OS).qX));
if((Pu).S===({S:"func"}).S){
((Pk).tX)=((xf)((Pv),((Pk).Pm)));
}
else if((Pu).S===({S:"var"}).S){
if((Pk).Pm){
(D)((65552),((wI)((ag),(Pi),(Pj))),([(Pu)]));
}
((Pk).tX)=((xh)((5),(Pv)));
}
else{
if((Pk).Pl){
(D)((65553),((wI)((ag),(Pi),(Pj))),([(Pu)]));
}
if((Pk).Pm){
(D)((65552),((wI)((ag),(Pi),(Pj))),([(Pu)]));
}
P7=Pu;
if(P7.S===({S:"end"}).S){
(P9)=((xb)((true),(false)));
if((P9).S!==({S:"class"}).S){
(D)((65554),((wI)((ag),(Pi),(Pj))),([({S:"class"}),(P9)]));
}
(PC)=(new c8());
(wH)((PC),(0),((wI)((ag),(Pi),(Pj))),(null),(false));
(Oj)((0x000A),(true));
break Pc;
}
else if(P7.S===({S:"const"}).S){
((Pk).tX)=((xj)());
}
else if(P7.S===({S:"alias"}).S){
((Pk).tX)=((xm)());
}
else if(P7.S===({S:"class"}).S){
((Pk).tX)=((xq)());
}
else{(D)((65555),((wI)((ag),(Pi),(Pj))),([(Pu)]));
(xv)(((xw)()));
continue Pc;
}
}
(eN)(((OS).tm),([130,134]),(Pk));
}
(x2)((ah),([131,134]));
return OS;
}
// parseEnum
function xs(){
let PH; // ast
let PL; // c
let PQ; // item
let PR; // id
let PU; // id2
let Qd; // expr
(PH)=(new xt());
(wH)((PH),(6),((MK)()),((xb)((true),(false))),(true));
((PH).PI)=({L:0,H:null,T:null,P:null});
(Oj)((0x000A),(true));
((PH).pY)=(new Map());
(wJ)((ah),([131,134]),(PH));
PK:
while(true){
(PL)=((wK)());
if((PL)===(0x0000)){
(D)((65551),((MK)()),([({S:"enum"})]));
break PK;
}
if((PL)===(0x000A)){
continue PK;
}
(pH)=(PL);
(PQ)=(null);
(PR)=((xb)((true),(false)));
if((PR).S===({S:"end"}).S){
(PU)=((xb)((true),(false)));
if((PU).S!==({S:"enum"}).S){
(D)((65554),((MK)()),([({S:"enum"}),(PU)]));
}
(Oj)((0x000A),(true));
break PK;
}
(PL)=((wK)());
if((PL)===(0x003A)){
(Oj)((0x003A),(false));
(PQ)=((PZ)());
if((PQ)===(null)){
(xv)(((xw)()));
continue PK;
}
(PL)=((wK)());
}
else{
(Qd)=(new yF());
(Qe)((Qd),(67585),((PH).ql));
((Qd).yL)=(null);
((Qd).yI)=(0x0000000000000000);
(PQ)=(Qd);
}
((PQ).qX)=(PR);
if((PL)!==(0x000A)){
(Oe)((0x000A),(PL));
}
(eN)(((PH).PI),([130,134]),(PQ));
(On)((PQ),(true));
}
(x2)((ah),([131,134]));
return PH;
}
// readUntilRet
function xv(Qh /*c*/){
while(((Qh)!==(0x000A))&&((Qh)!==(0x0000))){
(Qh)=((xw)());
}
(pH)=(Qh);
}
// read
function xw(){
let Qj; // c
let Ql;
(Qj)=((M9)());
Ql=Qj;
switch(Ql){
case 0x007B:
(Qn)();
return 0x0020;
break;
case 0x0009:
return 0x0020;
break;
}
return Qj;
}
// _getStack
function x2(Qp /*me_*/,Qq /*type*/){
return Qp.pop();
}
// initAst
function xP(Qr /*ast*/,Qs /*typeId*/,Qt /*pos*/){
if(!(!((Qr)instanceof yw))){throw 0xE9170000;}
(Qu)((Qr),(Qs),(Qt));
}
// searchStdItem
function yo(Qv /*src*/,Qw /*identifier*/,Qx /*makeExprRef*/){
let Qy; // ast
let Q1;
let Q4; // ast2
let Q7;
let QC; // expr
let Qz;
let Q0;
let Q5;
let Q6;
(Qy)=((Qz=(pR)((I),([133,129,2,134]),(Qv),(Q0={$:(Q1)},Q0)),(Q1)=Q0.$,Qz));
if((Qy)===(null)){
(D)((6),(null),([(Qv)]));
return null;
}
(Q4)=((Q5=(pR)(((Qy).pY),([133,129,2,134]),(Qw),(Q6={$:(Q7)},Q6)),(Q7)=Q6.$,Q5));
if((Qy)===(null)){
(D)((7),(null),([(Qv)]));
return null;
}
if(Qx){
(QC)=(new yw());
(yx)((QC),(2062),((wI)(({S:"kuin"}),(1),(1))));
((QC).qz)=(Q4);
return (QD)((QC));
}
return Q4;
}
// initAstExpr
function yx(QE /*ast*/,QF /*typeId*/,QG /*pos*/){
if(!((QE)instanceof yw)){throw 0xE9170000;}
(Qu)((QE),(QF),(QG));
((QE).yL)=(null);
((QE).yH)=(0);
}
// rebuildArg
function zv(QH /*ast*/){
if(((QH).zr)!==(null)){
return;
}
((QH).zr)=(QH);
((QH).sA)=((zy)(((QH).sA),(null)));
if(((QH).yb)!==(null)){
((QH).yb)=((zH)(((QH).yb),(false)));
if(((QH).yb)===(null)){
return;
}
if((((QH).rp)===(1))&&(((rt)((((QH).yb).qc),([9]),(67584)))!==(67584))){
(D)((131091),((QH).ql),([((QH).qX)]));
}
if((((QH).rp)===(4))&&(((rt)((((QH).yb).qc),([9]),(67584)))!==(67584))){
(D)((131092),((QH).ql),([((QH).qX)]));
}
if(!((QT)((((QH).yb).yL),((QH).sA),(false)))){
(D)((131093),((QH).ql),([((QH).qX)]));
}
else if(((((QH).yb).yL).qc)===(1028)){
((QH).yb)=((QW)(((QH).yb),((QH).sA)));
}
}
}
// rebuildType
function zy(QX /*ast*/,QY /*parentAlias*/){
let Rb; // type
let Rd;
let Rf; // refItem
let Rj;
let Rt; // ast2
let Ru; // items
let Rw; // arg
let R1; // ast2
if(((QX).zr)!==(null)){
return (QX).zr;
}
((QX).zr)=(QX);
(Rb)=((QX).qc);
Rd=Rb;
switch(Rd){
case 66565:
(Rf)=((QX).qz);
if((Rf)===(null)){
return null;
}
Rj=(Rf).qc;
switch(Rj){
case 5:
(Rl)((Rf));
break;
case 6:
(Rn)((Rf));
break;
case 4:
(Rp)((Rf),(QY));
((QX).zr)=((Rf).OR);
(QX)=((Rf).OR);
break;
default:
(D)((131111),((QX).ql),(null));
return null;
break;
}
break;
case 66561:
((QX).Az)=((zy)(((QX).Az),(QY)));
break;
case 66562:
(Rt)=(QX);
(Ru)=((Rt).AC);
(qr)((Ru),([130,134]));
while(!((qt)((Ru),([130,134])))){
(Rw)=((qv)((Ru),([130,134])));
((Rw).AL)=((zy)(((Rw).AL),(QY)));
(r8)((Ru),([130,134]));
}
if(((Rt).A7)!==(null)){
((Rt).A7)=((zy)(((Rt).A7),(QY)));
}
break;
case 66563:
((QX).AX)=((zy)(((QX).AX),(QY)));
break;
case 66564:
(R1)=(QX);
((R1).Be)=((zy)(((R1).Be),(QY)));
((R1).Bf)=((zy)(((R1).Bf),(QY)));
break;
default:
if(!(((((Rb)===(0))||((Rb)===(1025)))||((Rb)===(1026)))||((Rb)===(1027)))){throw 0xE9170000;}
break;
}
return QX;
}
// refreshStats
function zz(R3 /*stats*/,R4 /*retType*/,R5 /*parentFunc*/){
let R6; // stats2
let R8; // stat
(R6)=({L:0,H:null,T:null,P:null});
(qr)((R3),([130,134]));
while(!((qt)((R3),([130,134])))){
(R8)=((zR)(((qv)((R3),([130,134]))),(R4),(R5)));
if((R8)!==(null)){
(eN)((R6),([130,134]),(R8));
}
(r8)((R3),([130,134]));
}
return R6;
}
// rebuildExpr
function zH(RB /*ast*/,RC /*nullable*/){
let RG;
if((RB)===(null)){
return null;
}
RG=(RB).qc;
switch(RG){
case 0:
return null;
break;
case 2049:
(RB)=((RJ)((RB)));
break;
case 2050:
(RB)=((RM)((RB)));
break;
case 2051:
(RB)=((RO)((RB)));
break;
case 2052:
(RB)=((RR)((RB)));
break;
case 2053:
(RB)=((RU)((RB)));
break;
case 2054:
(RB)=((RX)((RB)));
break;
case 2055:
(RB)=((Sa)((RB)));
break;
case 2056:
(RB)=((Sd)((RB)));
break;
case 2057:
(RB)=((Sg)((RB)));
break;
case 2058:
(RB)=((Si)((RB)));
break;
case 2059:
(RB)=((Sl)((RB)));
break;
case 67584:
(RB)=((So)((RB)));
break;
case 67585:
(RB)=((Sq)((RB)));
break;
case 67586:
(RB)=((Ss)((RB)));
break;
case 67587:
(RB)=((Sv)((RB)));
break;
case 67588:
(RB)=((Sy)((RB)));
break;
case 2060:
(RB)=((S1)((RB)));
break;
case 2062:
(RB)=((QD)((RB)));
break;
}
if((RB)===(null)){
return null;
}
if((!(RC))&&(((RB).yL)===(null))){
(D)((131112),((RB).ql),(null));
return null;
}
return RB;
}
// rebuildStat
function zR(S8 /*ast*/,S9 /*retType*/,SA /*parentFunc*/){
let SE;
let SH; // ast2
let SL; // arg
let SO; // args
let SP; // refClass
let SQ; // items
let ST; // item
let SW; // astRef
let Tb; // astDo
let Td; // astAssign
let Tf; // astRef
if((S8)===(null)){
return null;
}
SE=(S8).qc;
switch(SE){
case 514:
case 516:
case 517:
case 518:
case 519:
return null;
break;
case 515:
(SH)=(S8);
(SJ)(((SH).SK));
(SL)=(((SH).SK).uc);
if((((SL).qX)!==(null))&&(((SL).qX).S===({S:"super"}).S)){
if(!(((SA)!==(null))&&(((SA).qX)!==(null)))){throw 0xE9170000;}
if(!((((SL).sA).qc)===(66562))){throw 0xE9170000;}
(SO)=(((SL).sA).AC);
(qr)((SO),([130,134]));
(SP)=((((qv)((SO),([130,134]))).AL).qz);
if(!(((SP).qc)===(5))){throw 0xE9170000;}
(SQ)=((SP).tm);
(qr)((SQ),([130,134]));
SS:
while(!((qt)((SQ),([130,134])))){
(ST)=((qv)((SQ),([130,134])));
if(((((ST).tX).qX)!==(null))&&((((ST).tX).qX).S===((SA).qX).S)){
if(!((ST).Pm)){throw 0xE9170000;}
(SW)=(new yw());
(yx)((SW),(2062),((S8).ql));
((SW).qz)=(((ST).Pn).tX);
((SL).yb)=(SW);
break SS;
}
(r8)((SQ),([130,134]));
}
if(!(!((qt)((SQ),([130,134]))))){throw 0xE9170000;}
}
if(((SL).yb)===(null)){
((SL).yb)=((SZ)(((SL).sA),((SL).ql)));
}
(Tb)=(new ys());
(xP)((Tb),(528),((S8).ql));
(Td)=(new zL());
(yx)((Td),(2050),((S8).ql));
((Td).zM)=(0);
(Tf)=(new yw());
(yx)((Tf),(2062),((S8).ql));
((Tf).qz)=(SL);
((Td).zP)=(Tf);
((Td).zQ)=((SL).yb);
((Tb).y2)=(Td);
((SL).yb)=(null);
(S8)=((zR)((Tb),(S9),(SA)));
break;
case 66049:
(S8)=((Th)((S8),(S9),(SA)));
break;
case 66050:
(S8)=((Tj)((S8),(S9),(SA)));
break;
case 16843265:
(S8)=((Tl)((S8),(S9),(SA)));
break;
case 16843266:
(S8)=((Tn)((S8),(S9),(SA)));
break;
case 66051:
(S8)=((Tp)((S8),(S9),(SA)));
break;
case 526:
(S8)=((Tr)((S8)));
break;
case 66052:
(S8)=((Tt)((S8),(S9),(SA)));
break;
case 527:
(S8)=((Tv)((S8),(S9)));
break;
case 528:
(S8)=((Tx)((S8)));
break;
case 529:
(S8)=((Tz)((S8),(S9),(SA)));
break;
case 530:
(S8)=((T1)((S8),(S9),(SA)));
break;
case 531:
(S8)=((T3)((S8)));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
if((S8)===(null)){
return null;
}
if(!(((S8).zr)!==(null))){throw 0xE9170000;}
return S8;
}
// isRef
function zT(T7 /*type*/){
let T8; // typeId
(T8)=((T7).qc);
return ((((T8)===(66561))||((T8)===(66563)))||((T8)===(66564)))||((T9)((T7)));
}
// makeExprNull
function Aa(TA /*pos*/){
let TB; // value
let TD; // type
(TB)=(new yG());
(yx)((TB),(67584),(TA));
(TD)=(new TE());
(xP)((TD),(1027),(TA));
((TB).yL)=(TD);
return TB;
}
// getId
function Ag(){
let TF; // curId
let TG; // newId
let TJ; // idx
let Ua;
let Ud;
let Uh;
let Ul;
let TS;
let TT;
let TW;
let TX;
(TF)=(M);
(TG)=(C_([129,2],(M)));
TI:
while(true){
(TJ)=(((TG).S.length)-(1));
TL:
while(true){
if(((TG).S.charCodeAt(TJ))===(0x007A)){
if((TJ)===(0)){
(TG)=({S:"\0".repeat(((TG).S.length)+(1))});
(TQ)((TG),([129,2]),(0x0061));
}
else{
(TG).S=(TS=(TJ),(TG).S.slice(0,TS)+String.fromCharCode(0x0061)+(TG).S.slice(TS+1));
(TJ)=((TJ)-(1));
continue TL;
}
}
else{
(TG).S=(TW=(TJ),(TG).S.slice(0,TW)+String.fromCharCode((TY)(((TG).S.charCodeAt(TJ)),(1)))+(TG).S.slice(TW+1));
}
break TL;
}
Ua=(TG).S.length;
switch(Ua){
case 2:
Ud=TG;
if(Ud.S===({S:"do"}).S||Ud.S===({S:"if"}).S||Ud.S===({S:"or"}).S){
continue TI;
}
break;
case 3:
Uh=TG;
if(Uh.S===({S:"and"}).S||Uh.S===({S:"asm"}).S||Uh.S===({S:"for"}).S||Uh.S===({S:"int"}).S||Uh.S===({S:"new"}).S||Uh.S===({S:"not"}).S||Uh.S===({S:"try"}).S||Uh.S===({S:"xor"}).S){
continue TI;
}
break;
case 4:
Ul=TG;
if(Ul.S===({S:"auto"}).S||Ul.S===({S:"bool"}).S||Ul.S===({S:"case"}).S||Ul.S===({S:"char"}).S||Ul.S===({S:"else"}).S||Ul.S===({S:"enum"}).S||Ul.S===({S:"goto"}).S||Ul.S===({S:"long"}).S||Ul.S===({S:"main"}).S||Ul.S===({S:"this"}).S||Ul.S===({S:"true"}).S||Ul.S===({S:"void"}).S){
continue TI;
}
break;
}
break TI;
}
(M)=(TG);
return TF;
}
// search
function Eq(Un /*members*/,Uo /*name*/){
let Uq; // def
(qr)((Un),([130,134]));
while(!((qt)((Un),([130,134])))){
(Uq)=(((qv)((Un),([130,134]))).tX);
if(((((Uq).qc)===(2))&&((((Uq).uc).qX)!==(null)))&&((((Uq).uc).qX).S===(Uo).S)){
return (rU)(((Uq).uc));
}
(r8)((Un),([130,134]));
}
if(!(false)){throw 0xE9170000;}
return null;
}
// buildIf
function Fl(Ut /*ast*/,Uu /*breakStat*/,Uv /*skipStat*/){
let Uw; // infoMe
let U5; // items
let U8; // item
(Uw)=((rU)((Ut)));
if(((Ut).Uy)===(null)){
(F3)(((Ut).U0),(Uu),(Uv));
if((((Uw).Aj)!==(null))&&((Uw).Ap)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((Uw).Aj),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
return;
}
(eN)((P),([130,129,2]),({S:"if("}));
(U3)(((Ut).Uy));
(eN)((P),([130,129,2]),({S:"){\u000A"}));
(F3)(((Ut).U0),(Uu),(Uv));
(eN)((P),([130,129,2]),({S:"}\u000A"}));
(U5)=((Ut).U6);
(qr)((U5),([130,134]));
while(!((qt)((U5),([130,134])))){
(U8)=((qv)((U5),([130,134])));
(eN)((P),([130,129,2]),({S:"else if("}));
(U3)(((U8).UA));
(eN)((P),([130,129,2]),({S:"){\u000A"}));
(F3)(((U8).UB),(Uu),(Uv));
(eN)((P),([130,129,2]),({S:"}\u000A"}));
(r8)((U5),([130,134]));
}
if(((Ut).UD)!==(null)){
(eN)((P),([130,129,2]),({S:"else{\u000A"}));
(F3)(((Ut).UD),(Uu),(Uv));
(eN)((P),([130,129,2]),({S:"}\u000A"}));
}
if((((Uw).Aj)!==(null))&&((Uw).Ap)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((Uw).Aj),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
}
// buildSwitch
function Fo(UH /*ast*/,UI /*breakStat*/,UJ /*skipStat*/){
let UK; // infoMe
let UL; // info
let UO; // useSwitch
let UV; // items
let UY; // item
let Va; // items2
let Vd; // exprs
let Vj; // items
let Vl; // item
let Vm; // items2
let Vo; // exprs
let Vu; // first
let Vv; // items
let Vx; // item
let V1; // first2
let V2; // items2
let V4; // exprs
(UK)=((rU)((UH)));
(UL)=((rU)(((UH).yc)));
if(!((UL).rX)){
((UL).rX)=(true);
(eN)((T),([130,134]),((UH).yc));
}
(UO)=(false);
UQ:
if(((((s9)((((UH).UR).yL)))||((US)((((UH).UR).yL))))||((UT)((((UH).UR).yL))))||(((((UH).UR).yL).qc)===(1025))){
(UO)=(true);
(UV)=((UH).UW);
(qr)((UV),([130,134]));
while(!((qt)((UV),([130,134])))){
(UY)=((qv)((UV),([130,134])));
(Va)=((UY).Vb);
(qr)((Va),([130,134]));
while(!((qt)((Va),([130,134])))){
(Vd)=((qv)((Va),([130,134])));
if((((rt)((((Vd).yM).qc),([9]),(67584)))!==(67584))||(((Vd).yR)!==(null))){
(UO)=(false);
break UQ;
}
(r8)((Va),([130,134]));
}
(r8)((UV),([130,134]));
}
}
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((UL).sT),([129,2]))).S}).S+({S:" = "}).S}));
(U3)(((UH).UR));
(eN)((P),([130,129,2]),({S:";\u000A"}));
if(UO){
(eN)((P),([130,129,2]),({S:({S:({S:"switch("}).S+((v)(((UL).sT),([129,2]))).S}).S+({S:"){\u000A"}).S}));
(Vj)=((UH).UW);
(qr)((Vj),([130,134]));
while(!((qt)((Vj),([130,134])))){
(Vl)=((qv)((Vj),([130,134])));
(Vm)=((Vl).Vb);
(qr)((Vm),([130,134]));
while(!((qt)((Vm),([130,134])))){
(Vo)=((qv)((Vm),([130,134])));
if(!(((Vo).yR)===(null))){throw 0xE9170000;}
(eN)((P),([130,129,2]),({S:"case "}));
(U3)(((Vo).yM));
(eN)((P),([130,129,2]),({S:":\u000A"}));
(r8)((Vm),([130,134]));
}
(F3)(((Vl).Vp),(UH),(UJ));
(eN)((P),([130,129,2]),({S:"break;\u000A"}));
(r8)((Vj),([130,134]));
}
if(((UH).Vr)!==(null)){
(eN)((P),([130,129,2]),({S:"default:\u000A"}));
(F3)(((UH).Vr),(UH),(UJ));
(eN)((P),([130,129,2]),({S:"break;\u000A"}));
}
(eN)((P),([130,129,2]),({S:"}\u000A"}));
}
else{
(Vu)=(true);
(Vv)=((UH).UW);
(qr)((Vv),([130,134]));
while(!((qt)((Vv),([130,134])))){
(Vx)=((qv)((Vv),([130,134])));
if(Vu){
(Vu)=(false);
(eN)((P),([130,129,2]),({S:"if("}));
}
else{
(eN)((P),([130,129,2]),({S:"else if("}));
}
(V1)=(true);
(V2)=((Vx).Vb);
(qr)((V2),([130,134]));
while(!((qt)((V2),([130,134])))){
(V4)=((qv)((V2),([130,134])));
if(V1){
(V1)=(false);
}
else{
(eN)((P),([130,129,2]),({S:" || "}));
}
if(((V4).yR)===(null)){
if((zT)((((UH).UR).yL))){
(eN)((P),([130,129,2]),({S:({S:({S:"cmp_("}).S+((v)(((UL).sT),([129,2]))).S}).S+({S:", ("}).S}));
(U3)(((V4).yM));
(eN)((P),([130,129,2]),({S:")) == 0"}));
}
else{
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((UL).sT),([129,2]))).S}).S+({S:" == ("}).S}));
(U3)(((V4).yM));
(eN)((P),([130,129,2]),({S:")"}));
}
}
else{
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((V4).yM));
(eN)((P),([130,129,2]),({S:({S:({S:") <= "}).S+((v)(((UL).sT),([129,2]))).S}).S+({S:({S:({S:" && "}).S+((v)(((UL).sT),([129,2]))).S}).S+({S:" <= ("}).S}).S}));
(U3)(((V4).yR));
(eN)((P),([130,129,2]),({S:")"}));
}
(r8)((V2),([130,134]));
}
(eN)((P),([130,129,2]),({S:"){\u000A"}));
(F3)(((Vx).Vp),(UI),(UJ));
(eN)((P),([130,129,2]),({S:"}\u000A"}));
(r8)((Vv),([130,134]));
}
if(((UH).Vr)!==(null)){
if(((Vv).L)===(0)){
(eN)((P),([130,129,2]),({S:"{"}));
}
else{
(eN)((P),([130,129,2]),({S:"else{"}));
}
(F3)(((UH).Vr),(UI),(UJ));
(eN)((P),([130,129,2]),({S:"}\u000A"}));
}
}
if((((UK).Aj)!==(null))&&((UK).Ap)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((UK).Aj),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
}
// buildWhile
function Fr(VL /*ast*/,VM /*breakStat*/,VN /*skipStat*/){
let VO; // infoMe
(VO)=((rU)((VL)));
if(((VL).VQ)===(null)){
(eN)((P),([130,129,2]),({S:"for(;;){\u000A"}));
(tu)(((VL).VS),(VL),(VL));
if((((VO).Am)!==(null))&&((VO).Aq)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((VO).Am),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
(eN)((P),([130,129,2]),({S:"}\u000A"}));
if((((VO).Aj)!==(null))&&((VO).Ap)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((VO).Aj),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
return;
}
if((VL).VY){
(eN)((P),([130,129,2]),({S:"do{\u000A"}));
(tu)(((VL).VS),(VL),(VL));
if((((VO).Am)!==(null))&&((VO).Aq)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((VO).Am),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
(eN)((P),([130,129,2]),({S:"}while("}));
(U3)(((VL).VQ));
(eN)((P),([130,129,2]),({S:");\u000A"}));
if((((VO).Aj)!==(null))&&((VO).Ap)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((VO).Aj),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
return;
}
(eN)((P),([130,129,2]),({S:"while("}));
(U3)(((VL).VQ));
(eN)((P),([130,129,2]),({S:"){\u000A"}));
(tu)(((VL).VS),(VL),(VL));
if((((VO).Am)!==(null))&&((VO).Aq)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((VO).Am),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
(eN)((P),([130,129,2]),({S:"}\u000A"}));
if((((VO).Aj)!==(null))&&((VO).Ap)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((VO).Aj),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
}
// buildFor
function Fv(Wi /*ast*/,Wj /*breakStat*/,Wk /*skipStat*/){
let Wl; // infoMe
let Wm; // info
let Wp; // endId
let Wu; // step
(Wl)=((rU)((Wi)));
(Wm)=((rU)(((Wi).yc)));
if(!((Wm).rX)){
((Wm).rX)=(true);
(eN)((T),([130,134]),((Wi).yc));
}
(Wp)=((Wq)((((Wi).Wr).yL)));
(eN)((P),([130,129,2]),({S:({S:({S:"for("}).S+((v)(((Wm).sT),([129,2]))).S}).S+({S:" = ("}).S}));
(U3)(((Wi).Ws));
(eN)((P),([130,129,2]),({S:({S:({S:"), "}).S+((v)((Wp),([129,2]))).S}).S+({S:" = ("}).S}));
(U3)(((Wi).Wr));
(eN)((P),([130,129,2]),({S:({S:({S:"); "}).S+((v)(((Wm).sT),([129,2]))).S}).S+({S:" "}).S}));
if(!(((((Wi).Wt).qc)===(67585))&&((s9)((((Wi).Wr).yL))))){throw 0xE9170000;}
(Wu)=(((Wi).Wt).yI);
if((Wu)>(0)){
(eN)((P),([130,129,2]),({S:"<="}));
}
else{
(eN)((P),([130,129,2]),({S:">="}));
}
(eN)((P),([130,129,2]),({S:({S:({S:" "}).S+((v)((Wp),([129,2]))).S}).S+({S:({S:({S:"; "}).S+((v)(((Wm).sT),([129,2]))).S}).S+({S:" += ("}).S}).S}));
(U3)(((Wi).Wt));
(eN)((P),([130,129,2]),({S:")){\u000A"}));
(tu)(((Wi).Wy),(Wi),(Wi));
if((((Wl).Am)!==(null))&&((Wl).Aq)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((Wl).Am),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
(eN)((P),([130,129,2]),({S:"}\u000A"}));
if((((Wl).Aj)!==(null))&&((Wl).Ap)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((Wl).Aj),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
}
// buildTry
function Fy(W3 /*ast*/,W4 /*breakStat*/,W5 /*skipStat*/){
let W6; // infoMe
let W7; // info
let WF; // first
let WG; // items
let WI; // item
let WM; // first2
let WN; // items2
let WP; // exprs
(W6)=((rU)((W3)));
(W7)=((rU)(((W3).yc)));
if(!((W7).rX)){
((W7).rX)=(true);
(eN)((T),([130,134]),((W3).yc));
}
if(((W3).yl)!==(null)){
(eN)((P),([130,129,2]),({S:"try{\u000A"}));
}
(eN)((P),([130,129,2]),({S:"try{\u000A"}));
(F3)(((W3).yh),(W4),(W5));
if(((W3).yl)!==(null)){
(F3)(((W3).yl),(W4),(W5));
}
(eN)((P),([130,129,2]),({S:({S:({S:"}catch(int64_t "}).S+((v)(((W7).sT),([129,2]))).S}).S+({S:"){\u000A"}).S}));
(WF)=(true);
(WG)=((W3).yi);
(qr)((WG),([130,134]));
while(!((qt)((WG),([130,134])))){
(WI)=((qv)((WG),([130,134])));
if(WF){
(WF)=(false);
(eN)((P),([130,129,2]),({S:"if("}));
}
else{
(eN)((P),([130,129,2]),({S:"else if("}));
}
(WM)=(true);
(WN)=((WI).y6);
(qr)((WN),([130,134]));
while(!((qt)((WN),([130,134])))){
(WP)=((qv)((WN),([130,134])));
if(WM){
(WM)=(false);
}
else{
(eN)((P),([130,129,2]),({S:" || "}));
}
if(((WP).yR)===(null)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((W7).sT),([129,2]))).S}).S+({S:" == ("}).S}));
(U3)(((WP).yM));
(eN)((P),([130,129,2]),({S:")"}));
}
else{
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((WP).yM));
(eN)((P),([130,129,2]),({S:({S:({S:") <= "}).S+((v)(((W7).sT),([129,2]))).S}).S+({S:({S:({S:" && "}).S+((v)(((W7).sT),([129,2]))).S}).S+({S:" <= ("}).S}).S}));
(U3)(((WP).yR));
(eN)((P),([130,129,2]),({S:")"}));
}
(r8)((WN),([130,134]));
}
(eN)((P),([130,129,2]),({S:"){\u000A"}));
(F3)(((WI).y9),(W4),(W5));
(eN)((P),([130,129,2]),({S:"}\u000A"}));
(r8)((WG),([130,134]));
}
if(WF){
(eN)((P),([130,129,2]),({S:"{\u000A"}));
}
else{
(eN)((P),([130,129,2]),({S:"else{\u000A"}));
}
(eN)((P),([130,129,2]),({S:"throw;\u000A}\u000A"}));
(eN)((P),([130,129,2]),({S:"}\u000A"}));
if(((W3).yl)!==(null)){
(eN)((P),([130,129,2]),({S:"}\u000Acatch(...){\u000A"}));
(F3)(((W3).yl),(W4),(W5));
(eN)((P),([130,129,2]),({S:"throw;\u000A}\u000A"}));
}
if((((W6).Aj)!==(null))&&((W6).Ap)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((W6).Aj),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
}
// buildThrow
function F0(Xd /*ast*/){
(eN)((P),([130,129,2]),({S:"throw "}));
(U3)(((Xd).Xe));
(eN)((P),([130,129,2]),({S:";\u000A"}));
}
// buildBlock
function F3(Xf /*ast*/,Xg /*breakStat*/,Xh /*skipStat*/){
let Xi; // infoMe
(Xi)=((rU)((Xf)));
(tu)(((Xf).yg),(Xg),(Xh));
if((((Xi).Aj)!==(null))&&((Xi).Ap)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((Xi).Aj),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
}
// buildRet
function F5(Xl /*ast*/){
if(((Xl).Xn)===(null)){
(eN)((P),([130,129,2]),({S:"return;\u000A"}));
}
else{
(eN)((P),([130,129,2]),({S:"return "}));
(U3)(((Xl).Xn));
(eN)((P),([130,129,2]),({S:";\u000A"}));
}
}
// buildDo
function F8(Xq /*ast*/){
(U3)(((Xq).y2));
(eN)((P),([130,129,2]),({S:";\u000A"}));
}
// buildBreak
function FA(Xr /*ast*/,Xs /*breakStat*/){
let Xw; // info
if(!(((rt)((((Xr).qz).qc),([9]),(66048)))===(66048))){throw 0xE9170000;}
if(((Xr).qz)===(Xs)){
(eN)((P),([130,129,2]),({S:"break;\u000A"}));
}
else{
(Xw)=((rU)(((Xr).qz)));
((Xw).Ap)=(true);
(eN)((P),([130,129,2]),({S:({S:({S:"goto "}).S+((v)(((Xw).Aj),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
}
// buildSkip
function FC(Xx /*ast*/,Xy /*skipStat*/){
let X2; // info
if(!(((rt)((((Xx).qz).qc),([9]),(16843264)))===(16843264))){throw 0xE9170000;}
if(((Xx).qz)===(Xy)){
(eN)((P),([130,129,2]),({S:"continue;\u000A"}));
}
else{
(X2)=((rU)(((Xx).qz)));
((X2).Aq)=(true);
(eN)((P),([130,129,2]),({S:({S:({S:"goto "}).S+((v)(((X2).Am),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
}
// buildAssert
function FE(X3 /*ast*/){
(eN)((P),([130,129,2]),({S:"if(!("}));
(U3)(((X3).X4));
(eN)((P),([130,129,2]),({S:({S:({S:")){\u000Athrow "}).S+((v)((0xE9170000),([6]))).S}).S+({S:"U;\u000A}\u000A"}).S}));
}
// getId
function GH(){
let X5; // curId
let X6; // newId
let X9; // idx
let XD;
let XV;
let XY;
let Yc;
let Yg;
let XF;
let XG;
let XI;
let XJ;
let XO;
let XP;
let XS;
let XT;
(X5)=(al);
(X6)=(C_([129,2],(al)));
X8:
while(true){
(X9)=(((X6).S.length)-(1));
XB:
while(true){
XD=(X6).S.charCodeAt(X9);
switch(XD){
case 0x007A:
(X6).S=(XF=(X9),(X6).S.slice(0,XF)+String.fromCharCode(((X9)===(0))?(0x0041):(0x0030))+(X6).S.slice(XF+1));
break;
case 0x0039:
(X6).S=(XI=(X9),(X6).S.slice(0,XI)+String.fromCharCode(0x0041)+(X6).S.slice(XI+1));
break;
case 0x005A:
if((X9)===(0)){
(X6)=({S:"\0".repeat(((X6).S.length)+(1))});
(TQ)((X6),([129,2]),(0x0061));
}
else{
(X6).S=(XO=(X9),(X6).S.slice(0,XO)+String.fromCharCode(0x0061)+(X6).S.slice(XO+1));
(X9)=((X9)-(1));
continue XB;
}
break;
default:
(X6).S=(XS=(X9),(X6).S.slice(0,XS)+String.fromCharCode((TY)(((X6).S.charCodeAt(X9)),(1)))+(X6).S.slice(XS+1));
break;
}
break XB;
}
XV=(X6).S.length;
switch(XV){
case 2:
XY=X6;
if(XY.S===({S:"do"}).S||XY.S===({S:"if"}).S||XY.S===({S:"in"}).S){
continue X8;
}
break;
case 3:
Yc=X6;
if(Yc.S===({S:"for"}).S||Yc.S===({S:"let"}).S||Yc.S===({S:"new"}).S||Yc.S===({S:"try"}).S||Yc.S===({S:"var"}).S||Yc.S===({S:"Map"}).S||Yc.S===({S:"NaN"}).S||Yc.S===({S:"Set"}).S){
continue X8;
}
break;
case 4:
Yg=X6;
if(Yg.S===({S:"case"}).S||Yg.S===({S:"else"}).S||Yg.S===({S:"enum"}).S||Yg.S===({S:"eval"}).S||Yg.S===({S:"name"}).S||Yg.S===({S:"null"}).S||Yg.S===({S:"this"}).S||Yg.S===({S:"true"}).S||Yg.S===({S:"void"}).S||Yg.S===({S:"with"}).S||Yg.S===({S:"Date"}).S||Yg.S===({S:"Intl"}).S||Yg.S===({S:"JSON"}).S||Yg.S===({S:"Math"}).S){
continue X8;
}
break;
}
break X8;
}
(al)=(X6);
return X5;
}
// search
function JK(Yi /*members*/,Yj /*name*/){
let Yl; // def
(qr)((Yi),([130,134]));
while(!((qt)((Yi),([130,134])))){
(Yl)=(((qv)((Yi),([130,134]))).tX);
if(((((Yl).qc)===(2))&&((((Yl).uc).qX)!==(null)))&&((((Yl).uc).qX).S===(Yj).S)){
return (uO)(((Yl).uc));
}
(r8)((Yi),([130,134]));
}
if(!(false)){throw 0xE9170000;}
return null;
}
// buildIf
function KK(Yo /*ast*/){
let Yp; // infoMe
let Y0; // items
let Y2; // item
(Yp)=((uO)((Yo)));
if(((Yo).Uy)===(null)){
if(((Yp).GK)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Yp).GK),([129,2]))).S}).S+({S:":{\u000A"}).S}));
}
(KW)(((Yo).U0));
if(((Yp).GK)!==(null)){
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
return;
}
if(((Yp).GK)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Yp).GK),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:"if("}));
(Yy)(((Yo).Uy));
(eN)((am),([130,129,2]),({S:"){\u000A"}));
(KW)(((Yo).U0));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
(Y0)=((Yo).U6);
(qr)((Y0),([130,134]));
while(!((qt)((Y0),([130,134])))){
(Y2)=((qv)((Y0),([130,134])));
(eN)((am),([130,129,2]),({S:"else if("}));
(Yy)(((Y2).UA));
(eN)((am),([130,129,2]),({S:"){\u000A"}));
(KW)(((Y2).UB));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
(r8)((Y0),([130,134]));
}
if(((Yo).UD)!==(null)){
(eN)((am),([130,129,2]),({S:"else{\u000A"}));
(KW)(((Yo).UD));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
}
// buildSwitch
function KM(Y5 /*ast*/){
let Y6; // infoMe
let Y7; // info
let YA; // useSwitch
let YE; // items
let YG; // item
let YH; // items2
let YJ; // exprs
let YR; // items
let YT; // item
let YU; // items2
let YW; // exprs
let Zc; // first
let Zd; // items
let Zf; // item
let Zj; // first2
let Zk; // items2
let Zm; // exprs
(Y6)=((uO)((Y5)));
(Y7)=((uO)(((Y5).yc)));
if(!((Y7).uR)){
((Y7).uR)=(true);
(eN)((ap),([130,134]),((Y5).yc));
}
(YA)=(false);
YC:
if(((((s9)((((Y5).UR).yL)))||((US)((((Y5).UR).yL))))||((UT)((((Y5).UR).yL))))||(((((Y5).UR).yL).qc)===(1025))){
(YA)=(true);
(YE)=((Y5).UW);
(qr)((YE),([130,134]));
while(!((qt)((YE),([130,134])))){
(YG)=((qv)((YE),([130,134])));
(YH)=((YG).Vb);
(qr)((YH),([130,134]));
while(!((qt)((YH),([130,134])))){
(YJ)=((qv)((YH),([130,134])));
if((((rt)((((YJ).yM).qc),([9]),(67584)))!==(67584))||(((YJ).yR)!==(null))){
(YA)=(false);
break YC;
}
(r8)((YH),([130,134]));
}
(r8)((YE),([130,134]));
}
}
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Y7).vf),([129,2]))).S}).S+({S:"="}).S}));
(Yy)(((Y5).UR));
(eN)((am),([130,129,2]),({S:";\u000A"}));
if(YA){
if(((Y6).GK)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Y6).GK),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:({S:({S:"switch("}).S+((v)(((Y7).vf),([129,2]))).S}).S+({S:"){\u000A"}).S}));
(YR)=((Y5).UW);
(qr)((YR),([130,134]));
while(!((qt)((YR),([130,134])))){
(YT)=((qv)((YR),([130,134])));
(YU)=((YT).Vb);
(qr)((YU),([130,134]));
while(!((qt)((YU),([130,134])))){
(YW)=((qv)((YU),([130,134])));
if(!(((YW).yR)===(null))){throw 0xE9170000;}
(eN)((am),([130,129,2]),({S:"case "}));
(Yy)(((YW).yM));
(eN)((am),([130,129,2]),({S:":\u000A"}));
(r8)((YU),([130,134]));
}
(KW)(((YT).Vp));
(eN)((am),([130,129,2]),({S:"break;\u000A"}));
(r8)((YR),([130,134]));
}
if(((Y5).Vr)!==(null)){
(eN)((am),([130,129,2]),({S:"default:\u000A"}));
(KW)(((Y5).Vr));
(eN)((am),([130,129,2]),({S:"break;\u000A"}));
}
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
else{
if(((Y6).GK)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Y6).GK),([129,2]))).S}).S+({S:":{\u000A"}).S}));
}
(Zc)=(true);
(Zd)=((Y5).UW);
(qr)((Zd),([130,134]));
while(!((qt)((Zd),([130,134])))){
(Zf)=((qv)((Zd),([130,134])));
if(Zc){
(Zc)=(false);
(eN)((am),([130,129,2]),({S:"if("}));
}
else{
(eN)((am),([130,129,2]),({S:"else if("}));
}
(Zj)=(true);
(Zk)=((Zf).Vb);
(qr)((Zk),([130,134]));
while(!((qt)((Zk),([130,134])))){
(Zm)=((qv)((Zk),([130,134])));
if(Zj){
(Zj)=(false);
}
else{
(eN)((am),([130,129,2]),({S:"||"}));
}
if(((Zm).yR)===(null)){
if((Zt)((((Y5).UR).yL))){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Y7).vf),([129,2]))).S}).S+({S:".S===("}).S}));
(Yy)(((Zm).yM));
(eN)((am),([130,129,2]),({S:").S"}));
}
else if((zT)((((Y5).UR).yL))){
(eN)((am),([130,129,2]),({S:({S:({S:"cmp_("}).S+((v)(((Y7).vf),([129,2]))).S}).S+({S:",("}).S}));
(Yy)(((Zm).yM));
(eN)((am),([130,129,2]),({S:"))==0"}));
}
else{
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Y7).vf),([129,2]))).S}).S+({S:"===("}).S}));
(Yy)(((Zm).yM));
(eN)((am),([130,129,2]),({S:")"}));
}
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((Zm).yM));
(eN)((am),([130,129,2]),({S:({S:({S:")<="}).S+((v)(((Y7).vf),([129,2]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((Y7).vf),([129,2]))).S}).S+({S:"<=("}).S}).S}));
(Yy)(((Zm).yR));
(eN)((am),([130,129,2]),({S:")"}));
}
(r8)((Zk),([130,134]));
}
(eN)((am),([130,129,2]),({S:"){\u000A"}));
(KW)(((Zf).Vp));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
(r8)((Zd),([130,134]));
}
if(((Y5).Vr)!==(null)){
if(((Zd).L)===(0)){
(eN)((am),([130,129,2]),({S:"{"}));
}
else{
(eN)((am),([130,129,2]),({S:"else{"}));
}
(KW)(((Y5).Vr));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
if(((Y6).GK)!==(null)){
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
}
}
// buildWhile
function KO(Z5 /*ast*/){
let Z6; // infoMe
(Z6)=((uO)((Z5)));
if(((Z5).VQ)===(null)){
if(((Z6).GK)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Z6).GK),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:"for(;;){\u000A"}));
(v1)(((Z5).VS));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
return;
}
if((Z5).VY){
if(((Z6).GK)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Z6).GK),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:"do{\u000A"}));
(v1)(((Z5).VS));
(eN)((am),([130,129,2]),({S:"}while("}));
(Yy)(((Z5).VQ));
(eN)((am),([130,129,2]),({S:");\u000A"}));
return;
}
if(((Z6).GK)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Z6).GK),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:"while("}));
(Yy)(((Z5).VQ));
(eN)((am),([130,129,2]),({S:"){\u000A"}));
(v1)(((Z5).VS));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
// buildFor
function KQ(ZH /*ast*/){
let ZI; // infoMe
let ZJ; // info
let ZM; // endId
let ZQ; // step
(ZI)=((uO)((ZH)));
(ZJ)=((uO)(((ZH).yc)));
if(!((ZJ).uR)){
((ZJ).uR)=(true);
(eN)((ap),([130,134]),((ZH).yc));
}
(ZM)=((ZN)((((ZH).Wr).yL)));
if(((ZI).GK)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((ZI).GK),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:({S:({S:"for("}).S+((v)(((ZJ).vf),([129,2]))).S}).S+({S:"=("}).S}));
(Yy)(((ZH).Ws));
(eN)((am),([130,129,2]),({S:({S:({S:"),"}).S+((v)((ZM),([129,2]))).S}).S+({S:"=("}).S}));
(Yy)(((ZH).Wr));
(eN)((am),([130,129,2]),({S:({S:({S:");"}).S+((v)(((ZJ).vf),([129,2]))).S}).S+({S:""}).S}));
if(!(((((ZH).Wt).qc)===(67585))&&((s9)((((ZH).Wr).yL))))){throw 0xE9170000;}
(ZQ)=(((ZH).Wt).yI);
if((ZQ)>(0)){
(eN)((am),([130,129,2]),({S:"<="}));
}
else{
(eN)((am),([130,129,2]),({S:">="}));
}
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)((ZM),([129,2]))).S}).S+({S:({S:({S:";"}).S+((v)(((ZJ).vf),([129,2]))).S}).S+({S:"+=("}).S}).S}));
(Yy)(((ZH).Wt));
(eN)((am),([130,129,2]),({S:")){\u000A"}));
(v1)(((ZH).Wy));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
// buildTry
function KS(ZU /*ast*/){
let ZV; // infoMe
let ZW; // info
let aac; // first
let aad; // items
let aaf; // item
let aaj; // first2
let aak; // items2
let aam; // exprs
(ZV)=((uO)((ZU)));
(ZW)=((uO)(((ZU).yc)));
if(!((ZW).uR)){
((ZW).uR)=(true);
(eN)((ap),([130,134]),((ZU).yc));
}
if(((ZV).GK)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((ZV).GK),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:"try{\u000A"}));
(KW)(((ZU).yh));
(eN)((am),([130,129,2]),({S:({S:({S:"}catch("}).S+((v)(((ZW).vf),([129,2]))).S}).S+({S:"){\u000A"}).S}));
(aac)=(true);
(aad)=((ZU).yi);
(qr)((aad),([130,134]));
while(!((qt)((aad),([130,134])))){
(aaf)=((qv)((aad),([130,134])));
if(aac){
(aac)=(false);
(eN)((am),([130,129,2]),({S:"if("}));
}
else{
(eN)((am),([130,129,2]),({S:"else if("}));
}
(aaj)=(true);
(aak)=((aaf).y6);
(qr)((aak),([130,134]));
while(!((qt)((aak),([130,134])))){
(aam)=((qv)((aak),([130,134])));
if(aaj){
(aaj)=(false);
}
else{
(eN)((am),([130,129,2]),({S:"||"}));
}
if(((aam).yR)===(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((ZW).vf),([129,2]))).S}).S+({S:"===("}).S}));
(Yy)(((aam).yM));
(eN)((am),([130,129,2]),({S:")"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aam).yM));
(eN)((am),([130,129,2]),({S:({S:({S:")<="}).S+((v)(((ZW).vf),([129,2]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((ZW).vf),([129,2]))).S}).S+({S:"<=("}).S}).S}));
(Yy)(((aam).yR));
(eN)((am),([130,129,2]),({S:")"}));
}
(r8)((aak),([130,134]));
}
(eN)((am),([130,129,2]),({S:"){\u000A"}));
(KW)(((aaf).y9));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
(r8)((aad),([130,134]));
}
if(aac){
(eN)((am),([130,129,2]),({S:"{\u000A"}));
}
else{
(eN)((am),([130,129,2]),({S:"else{\u000A"}));
}
(eN)((am),([130,129,2]),({S:({S:({S:"throw "}).S+((v)(((ZW).vf),([129,2]))).S}).S+({S:";\u000A}\u000A"}).S}));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
if(((ZU).yl)!==(null)){
(eN)((am),([130,129,2]),({S:"finally{\u000A"}));
(KW)(((ZU).yl));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
}
// buildThrow
function KU(aay /*ast*/){
(eN)((am),([130,129,2]),({S:"throw "}));
(Yy)(((aay).Xe));
(eN)((am),([130,129,2]),({S:";\u000A"}));
}
// buildBlock
function KW(aaz /*ast*/){
let aa0; // infoMe
(aa0)=((uO)((aaz)));
if(((aa0).GK)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((aa0).GK),([129,2]))).S}).S+({S:":{\u000A"}).S}));
}
(v1)(((aaz).yg));
if(((aa0).GK)!==(null)){
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
}
// buildRet
function KY(aa5 /*ast*/){
if(((aa5).Xn)===(null)){
(eN)((am),([130,129,2]),({S:"return;\u000A"}));
}
else{
(eN)((am),([130,129,2]),({S:"return "}));
(Yy)(((aa5).Xn));
(eN)((am),([130,129,2]),({S:";\u000A"}));
}
}
// buildDo
function La(aa9 /*ast*/){
(Yy)(((aa9).y2));
(eN)((am),([130,129,2]),({S:";\u000A"}));
}
// buildBreak
function Lc(aaA /*ast*/){
let aaB; // info
if(!(((rt)((((aaA).qz).qc),([9]),(66048)))===(66048))){throw 0xE9170000;}
(aaB)=((uO)(((aaA).qz)));
(eN)((am),([130,129,2]),({S:({S:({S:"break "}).S+((v)(((aaB).GK),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
// buildSkip
function Le(aaC /*ast*/){
let aaD; // info
if(!(((rt)((((aaC).qz).qc),([9]),(16843264)))===(16843264))){throw 0xE9170000;}
(aaD)=((uO)(((aaC).qz)));
(eN)((am),([130,129,2]),({S:({S:({S:"continue "}).S+((v)(((aaD).GK),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
// buildAssert
function Lg(aaE /*ast*/){
(eN)((am),([130,129,2]),({S:"if(!("}));
(Yy)(((aaE).X4));
(eN)((am),([130,129,2]),({S:({S:({S:")){throw "}).S+((v)((0xE9170000),([6]))).S}).S+({S:";}\u000A"}).S}));
}
// getDefaultValue
function L7(aaF /*type*/){
let aaK;
let aaP;
if((aaH)((aaF))){
return {S:"null"};
}
aaK=(aaF).qc;
switch(aaK){
case 66565:
if(!((UT)((aaF)))){throw 0xE9170000;}
return {S:"0"};
break;
case 1025:
return {S:"0"};
break;
case 1026:
aaP=(aaF).ya;
switch(aaP){
case 0:
case 2:
return {S:"0"};
break;
case 1:
return {S:"0"};
break;
case 3:
return {S:"false"};
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// escapeChar
function LK(aaV /*c*/){
let aaX;
aaX=aaV;
if(aaX===(0x0022)){
return {S:"\\\""};
}
else if(aaX===(0x0027)){
return {S:"\\\'"};
}
else if(aaX===(0x005C)){
return {S:"\\\\"};
}
else if((0x0020)<=aaX&&aaX<=(0x007E)){
return (v)((aaV),([2]));
}
else{return {S:({S:({S:"\\u"}).S+((v)(((p9)(((v)((aaV),([5]))),([129,2]),(2),(-1))),([129,2]))).S}).S+({S:""}).S};
}
}
// initAstImpl
function Mr(abd /*ast*/,abe /*typeId*/,abf /*pos*/,abg /*name*/,abh /*setParent*/){
((abd).qc)=(abe);
((abd).ql)=(abf);
((abd).qX)=(abg);
((abd).qU)=(null);
((abd).pY)=(null);
((abd).q0)=(null);
((abd).qz)=(null);
((abd).zr)=(null);
((abd).r5)=(false);
if(((abd).qX)!==(null)){
(On)((abd),(true));
}
if(abh){
((abd).qU)=((abm)((ah),([131,134])));
}
}
// readBuf
function M9(){
let abn; // c
(abn)=(0x0000);
if((pH)===(0x0000)){
if((pI)===(0x0000)){
do{
(abn)=(((uD)((af)))?(0x0000):((abt)((af))));
}while((abn)===(0x000D));
if((abn)===(0x000A)){
(pF)=((pF)+(1));
(pG)=(0);
}
else if((abn)===(0x0000)){
if(!(pJ)){
(pJ)=(true);
(abn)=(0x000A);
(pF)=((pF)+(1));
(pG)=(0);
}
}
else{
(pG)=((pG)+(1));
}
}
else{
(abn)=(pI);
(pI)=(0x0000);
}
}
else{
(abn)=(pH);
(pH)=(0x0000);
}
return abn;
}
// makePos
function MK(){
return (wI)((ag),(pF),(pG));
}
// charToStr
function ML(ab5 /*c*/){
let ab7;
ab7=ab5;
switch(ab7){
case 0x0000:
return {S:" "};
break;
case 0x000D:
if(!(false)){throw 0xE9170000;}
break;
case 0x000A:
return {S:"(RETURN)"};
break;
case 0x0009:
case 0x0020:
return {S:"(SPACE)"};
break;
}
return (v)((ab5),([2]));
}
// addSrc
function Nf(abC /*name*/){
let abG;
let abE;
let abF;
if(((abE=(pR)((ae),([133,129,2,134]),(abC),(abF={$:(abG)},abF)),(abG)=abF.$,abE))===(null)){
(bE)((ae),([133,129,2,134]),(abC),(null));
}
}
// readFuncAttr
function N0(){
let abI; // c
let abL; // buf
let abM; // pos
let abQ;
let abR;
(abI)=((wK)());
if(!(((((((0x0061)<=(abI))&&((abI)<=(0x007A)))||(((0x0041)<=(abI))&&((abI)<=(0x005A))))||(((0x0030)<=(abI))&&((abI)<=(0x0039))))||((abI)===(0x005F)))||((abI)===(0x002E)))){
(D)((65548),((MK)()),([((ML)((abI)))]));
return {S:""};
}
(abL)=({S:"\0".repeat(128)});
(abM)=(0);
do{
if((abM)===(128)){
(D)((65549),((MK)()),([(abL)]));
return {S:""};
}
(abL).S=(abQ=(abM),(abL).S.slice(0,abQ)+String.fromCharCode(abI)+(abL).S.slice(abQ+1));
(abM)=((abM)+(1));
(abI)=((xw)());
}while(((((((0x0061)<=(abI))&&((abI)<=(0x007A)))||(((0x0041)<=(abI))&&((abI)<=(0x005A))))||(((0x0030)<=(abI))&&((abI)<=(0x0039))))||((abI)===(0x005F)))||((abI)===(0x002E)));
(pH)=(abI);
return (p9)((abL),([129,2]),(0),(abM));
}
// _or
function N8(abT /*me_*/,abU /*type*/,abV /*n*/){
return abT|abV;
}
// nextCharErr
function Oe(abW /*c*/,abX /*c2*/){
(D)((65550),((MK)()),([((ML)((abW))),((ML)((abX)))]));
(xv)((abX));
}
// addScopeRefeds
function Oi(abY /*ast*/,abZ /*name*/){
let aca; // scopeRefedItem
((abY).q0)=(abZ);
(aca)=(new qw());
((aca).qy)=(abY);
((aca).qP)=((abm)((ah),([131,134])));
(eN)((ai),([130,134]),(aca));
}
// assertNextChar
function Oj(acb /*c*/,acc /*skipSpaces*/){
let acd; // c2
(acd)=((acc)?((wK)()):((xw)()));
if((acb)!==(acd)){
(Oe)((acb),(acd));
(pH)=(acd);
}
}
// addScopeName
function On(acg /*ast*/,ach /*refuseReserved*/){
let acl; // scope
let acp;
let acr; // parent
let acs; // overFunc
let acz; // child
let ac2;
let ac5; // flag
let acA; // kind
let acn;
let aco;
let ac0;
let ac1;
if(!(((acg).qX)!==(null))){throw 0xE9170000;}
if((ach)&&((acj)(((acg).qX)))){
(D)((65537),((MK)()),([((acg).qX)]));
return;
}
(acl)=((abm)((ah),([131,134])));
if(((acn=(pR)(((acl).pY),([133,129,2,134]),((acg).qX),(aco={$:(acp)},aco)),(acp)=aco.$,acn))!==(null)){
(D)((65537),((MK)()),([((acg).qX)]));
}
(acr)=(acl);
(acs)=(false);
acu:
while(true){
if(((acr).qU)===(null)){
break acu;
}
if(((((acr).qX)!==(null))&&(((acr).qX).S===((acg).qX).S))&&(!((((acr).qc)===(256))&&(((acr).q0)!==(null))))){
(D)((65538),((MK)()),([((acg).qX)]));
return;
}
(acz)=((ac0=(pR)(((acr).pY),([133,129,2,134]),((acg).qX),(ac1={$:(ac2)},ac1)),(ac2)=ac1.$,ac0));
if((acz)!==(null)){
(ac5)=(false);
if(acs){
if(((acz).qc)===(7)){
(acA)=((acz).rp);
if((((acA)===(5))||((acA)===(3)))||((acA)===(2))){
(ac5)=(true);
}
}
if((!(ac5))&&(((rt)(((acz).qc),([9]),(66048)))===(66048))){
(ac5)=(true);
}
}
if(((!(ac5))&&(((acz).qc)===(256)))&&(((acz).q0)!==(null))){
(ac5)=(true);
}
if(!(ac5)){
(D)((65538),((MK)()),([((acg).qX)]));
return;
}
}
if(((acr).qc)===(256)){
(acs)=(true);
}
(acr)=((acr).qU);
}
(bE)(((acl).pY),([133,129,2,134]),((acg).qX),(acg));
}
// parseArg
function Ox(acL /*kind*/,acM /*parentClass*/){
let acN; // ast
let acR; // c
let acZ; // c
let add;
(acN)=(new ro());
(wH)((acN),(7),((MK)()),((xb)((true),(false))),(false));
((acN).rp)=(acL);
((acN).sP)=(false);
if((acM)!==(null)){
(Oi)((acN),(acM));
}
(Oj)((0x003A),(true));
(acR)=((wK)());
if((acR)===(0x0026)){
if((acL)!==(2)){
(D)((65556),((MK)()),(null));
}
else{
((acN).sP)=(true);
}
}
else{
(pH)=(acR);
}
((acN).sA)=((O8)());
(acZ)=((wK)());
if((acZ)===(0x003A)){
(Oj)((0x003A),(false));
if(!((acL)!==(0))){throw 0xE9170000;}
add=acL;
switch(add){
case 2:
(D)((65557),((MK)()),(null));
((acN).yb)=(null);
break;
case 5:
(D)((65558),((MK)()),(null));
((acN).yb)=(null);
break;
default:
((acN).yb)=((PZ)());
break;
}
}
else{
if((acL)===(4)){
(D)((65559),((MK)()),(null));
}
((acN).yb)=(null);
(pH)=(acZ);
}
return acN;
}
// parseType
function O8(){
let adk; // pos
let adl; // ast
let adm; // c
let adp; // ast2
let adr; // id
let adu; // size
let adx; // ast2
let ad0;
let ad4;
let ad6; // ast2
let adD; // arg
let adS; // ast2
let adU; // ast2
let adW; // ast2
let adY; // ast2
let aea; // ast2
let aec; // ast2
let aee; // ast2
let aeg; // ast2
let aei; // ast2
let ady;
let adz;
(adk)=((MK)());
(adl)=(null);
(adm)=((wK)());
if((adm)===(0x005B)){
(Oj)((0x005D),(true));
(adp)=(new Ax());
(wH)((adp),(66561),(adk),(null),(false));
((adp).Az)=((O8)());
(adl)=(adp);
}
else{
(pH)=(adm);
(adr)=((xb)((true),(true)));
if((((((adr).S.length)>=(4))&&(((adr).S.charCodeAt(0))===(0x0062)))&&(((adr).S.charCodeAt(1))===(0x0069)))&&(((adr).S.charCodeAt(2))===(0x0074))){
(adu)=((p9)((adr),([129,2]),(3),(((adr).S.length)-(3))));
if(((((adu).S===({S:"8"}).S)||((adu).S===({S:"16"}).S))||((adu).S===({S:"32"}).S))||((adu).S===({S:"64"}).S)){
(adx)=(new A1());
(wH)((adx),(1025),(adk),(null),(false));
((adx).A2)=(~~(((ady=(cb)((adu),(adz={$:(ad0)},adz)),(ad0)=adz.$,ady))/(8)));
(adl)=(adx);
}
}
if((adl)===(null)){
ad4=adr;
if(ad4.S===({S:"func"}).S){
(Oj)((0x003C),(true));
(Oj)((0x0028),(true));
(ad6)=(new A5());
(wH)((ad6),(66562),(adk),(null),(false));
((ad6).ad7)=(0);
((ad6).ad8)=({L:0,H:null,T:null,P:null});
((ad6).AC)=({L:0,H:null,T:null,P:null});
((ad6).A7)=(null);
(adm)=((wK)());
if((adm)!==(0x0029)){
(pH)=(adm);
adC:
while(true){
(adD)=(new AF());
(adm)=((wK)());
if((adm)===(0x0000)){
break adC;
}
if((adm)===(0x0026)){
((adD).AN)=(true);
}
else{
((adD).AN)=(false);
(pH)=(adm);
}
((adD).AL)=((O8)());
(eN)(((ad6).AC),([130,134]),(adD));
(adm)=((wK)());
if((adm)===(0x0029)){
break adC;
}
if((adm)!==(0x002C)){
(Oe)((0x002C),(adm));
break adC;
}
}
}
(adm)=((wK)());
if((adm)===(0x003A)){
((ad6).A7)=((O8)());
(adm)=((wK)());
}
if((adm)!==(0x003E)){
(Oe)((0x003E),(adm));
}
(adl)=(ad6);
}
else if(ad4.S===({S:"list"}).S){
(Oj)((0x003C),(true));
(adS)=(new AS());
(wH)((adS),(66563),(adk),(null),(false));
((adS).AV)=(0);
((adS).AX)=((O8)());
(Oj)((0x003E),(true));
(adl)=(adS);
}
else if(ad4.S===({S:"stack"}).S){
(Oj)((0x003C),(true));
(adU)=(new AS());
(wH)((adU),(66563),(adk),(null),(false));
((adU).AV)=(1);
((adU).AX)=((O8)());
(Oj)((0x003E),(true));
(adl)=(adU);
}
else if(ad4.S===({S:"queue"}).S){
(Oj)((0x003C),(true));
(adW)=(new AS());
(wH)((adW),(66563),(adk),(null),(false));
((adW).AV)=(2);
((adW).AX)=((O8)());
(Oj)((0x003E),(true));
(adl)=(adW);
}
else if(ad4.S===({S:"dict"}).S){
(Oj)((0x003C),(true));
(adY)=(new Bd());
(wH)((adY),(66564),(adk),(null),(false));
((adY).Be)=((O8)());
(Oj)((0x002C),(true));
((adY).Bf)=((O8)());
(Oj)((0x003E),(true));
(adl)=(adY);
}
else if(ad4.S===({S:"int"}).S){
(aea)=(new xZ());
(wH)((aea),(1026),(adk),(null),(false));
((aea).ya)=(0);
(adl)=(aea);
}
else if(ad4.S===({S:"float"}).S){
(aec)=(new xZ());
(wH)((aec),(1026),(adk),(null),(false));
((aec).ya)=(1);
(adl)=(aec);
}
else if(ad4.S===({S:"char"}).S){
(aee)=(new xZ());
(wH)((aee),(1026),(adk),(null),(false));
((aee).ya)=(2);
(adl)=(aee);
}
else if(ad4.S===({S:"bool"}).S){
(aeg)=(new xZ());
(wH)((aeg),(1026),(adk),(null),(false));
((aeg).ya)=(3);
(adl)=(aeg);
}
else{(aei)=(new Oq());
(wH)((aei),(66565),(adk),(null),(false));
(Oi)((aei),(adr));
(adl)=(aei);
}
}
}
return adl;
}
// parseStat
function OE(aej /*block_*/){
let aek; // ast
let aem; // c
let aeq; // row
let aer; // col
let aes; // id
let aeu;
(aek)=(null);
(aem)=(0x0000);
do{
(aem)=((wK)());
if((aem)===(0x0000)){
(D)((65560),((MK)()),(null));
return null;
}
}while((aem)===(0x000A));
(pH)=(aem);
(aeq)=(pF);
(aer)=(pG);
(aes)=((xb)((true),(false)));
aeu=aes;
if(aeu.S===({S:"end"}).S){
(aek)=((aew)((aeq),(aer),(aej)));
}
else if(aeu.S===({S:"func"}).S){
(aek)=((aey)());
}
else if(aeu.S===({S:"var"}).S){
(aek)=((ae0)());
}
else if(aeu.S===({S:"const"}).S){
(aek)=((ae2)());
}
else if(aeu.S===({S:"alias"}).S){
(aek)=((ae4)());
}
else if(aeu.S===({S:"class"}).S){
(aek)=((ae6)());
}
else if(aeu.S===({S:"enum"}).S){
(aek)=((ae8)());
}
else if(aeu.S===({S:"if"}).S){
(aek)=((aeA)());
}
else if(aeu.S===({S:"elif"}).S){
(aek)=((aeC)((aeq),(aer),(aej)));
}
else if(aeu.S===({S:"else"}).S){
(aek)=((aeE)((aeq),(aer),(aej)));
}
else if(aeu.S===({S:"switch"}).S){
(aek)=((aeG)((aeq),(aer)));
}
else if(aeu.S===({S:"case"}).S){
(aek)=((aeI)((aeq),(aer),(aej)));
}
else if(aeu.S===({S:"default"}).S){
(aek)=((aeK)((aeq),(aer),(aej)));
}
else if(aeu.S===({S:"while"}).S){
(aek)=((aeM)());
}
else if(aeu.S===({S:"for"}).S){
(aek)=((aeO)((aeq),(aer)));
}
else if(aeu.S===({S:"try"}).S){
(aek)=((aeQ)((aeq),(aer)));
}
else if(aeu.S===({S:"catch"}).S){
(aek)=((aeS)((aeq),(aer),(aej)));
}
else if(aeu.S===({S:"finally"}).S){
(aek)=((aeU)((aeq),(aer),(aej)));
}
else if(aeu.S===({S:"throw"}).S){
(aek)=((aeW)());
}
else if(aeu.S===({S:"block"}).S){
(aek)=((aeY)());
}
else if(aeu.S===({S:"ret"}).S){
(aek)=((afa)());
}
else if(aeu.S===({S:"do"}).S){
(aek)=((afc)());
}
else if(aeu.S===({S:"break"}).S){
(aek)=((afe)());
}
else if(aeu.S===({S:"skip"}).S){
(aek)=((afg)());
}
else if(aeu.S===({S:"assert"}).S){
(aek)=((afi)());
}
else{(D)((65547),((wI)((ag),(aeq),(aer))),([(aes)]));
(xv)(((xw)()));
return null;
}
if((aek)===(null)){
return null;
}
((aek).ql)=((wI)((ag),(aeq),(aer)));
return aek;
}
// parseExpr
function PZ(){
let afm; // ast
let afo; // row
let afp; // col
let afq; // c
let aft; // ast2
let afu; // c2
let afw;
(afm)=((afn)());
(afo)=(pF);
(afp)=(pG);
(afq)=((wK)());
if((afq)===(0x003A)){
(aft)=(new zL());
(Qe)((aft),(2050),((wI)((ag),(afo),(afp))));
(afu)=((xw)());
afw=afu;
switch(afw){
case 0x003A:
((aft).zM)=(0);
break;
case 0x002B:
((aft).zM)=(1);
break;
case 0x002D:
((aft).zM)=(2);
break;
case 0x002A:
((aft).zM)=(3);
break;
case 0x002F:
((aft).zM)=(4);
break;
case 0x0025:
((aft).zM)=(5);
break;
case 0x005E:
((aft).zM)=(6);
break;
case 0x007E:
((aft).zM)=(7);
break;
case 0x0024:
((aft).zM)=(25);
break;
default:
(D)((65569),((aft).ql),([((ML)((afu)))]));
(xv)((afu));
return null;
break;
}
((aft).zP)=(afm);
((aft).zQ)=((PZ)());
(afm)=(aft);
}
else{
(pH)=(afq);
}
return afm;
}
// initAstExpr
function Qe(af8 /*ast*/,af9 /*typeId*/,afA /*pos*/){
if(!((af8)instanceof yw)){throw 0xE9170000;}
(Mr)((af8),(af9),(afA),(null),(false));
((af8).yL)=(null);
((af8).yH)=(0);
}
// readComment
function Qn(){
let afB; // row
let afC; // col
let afD; // c
let afJ; // esc
let afY; // esc
(afB)=(pF);
(afC)=(pG);
(afD)=(0x0000);
do{
(afD)=((xw)());
if((afD)===(0x0000)){
(D)((65539),((wI)((ag),(afB),(afC))),(null));
return;
}
if((afD)===(0x0022)){
(afJ)=(false);
afL:
while(true){
(afD)=((afM)());
if((afD)===(0x0000)){
(D)((65539),((wI)((ag),(afB),(afC))),(null));
return;
}
if(afJ){
if((afD)===(0x007B)){
(Qn)();
}
(afJ)=(false);
continue afL;
}
if((afD)===(0x0022)){
break afL;
}
if((afD)===(0x005C)){
(afJ)=(true);
}
}
}
else if((afD)===(0x0027)){
(afY)=(false);
aga:
while(true){
(afD)=((afM)());
if((afD)===(0x0000)){
(D)((65539),((wI)((ag),(afB),(afC))),(null));
return;
}
if(afY){
(afY)=(false);
continue aga;
}
if((afD)===(0x0027)){
break aga;
}
if((afD)===(0x005C)){
(afY)=(true);
}
}
}
else if((afD)===(0x003B)){
agl:
while(true){
(afD)=((M9)());
if((afD)===(0x0000)){
(D)((65539),((wI)((ag),(afB),(afC))),(null));
return;
}
if((afD)===(0x000A)){
break agl;
}
}
}
}while((afD)!==(0x007D));
}
// initAstImpl
function Qu(agq /*ast*/,agr /*typeId*/,ags /*pos*/){
((agq).qc)=(agr);
((agq).ql)=(ags);
((agq).qX)=(null);
((agq).qU)=(null);
((agq).pY)=(null);
((agq).q0)=(null);
((agq).qz)=(null);
((agq).zr)=(null);
((agq).r5)=(false);
}
// rebuildExprRef
function QD(agt /*ast*/){
let agw; // refItem
let ag0;
let ag2; // func_
let ag4; // type
let ag6; // items
let ag8; // arg
let ag9; // arg2
let agB; // arg
let agD;
if(((agt).zr)!==(null)){
return (agt).zr;
}
((agt).zr)=(agt);
if(!(((agt).qc)===(2062))){throw 0xE9170000;}
(agw)=((agt).qz);
if((agw)===(null)){
return null;
}
ag0=(agw).qc;
switch(ag0){
case 256:
(ag2)=((agt).qz);
(rD)((ag2));
(ag4)=(new A5());
(xP)((ag4),(66562),((agt).ql));
((ag4).ad7)=((ag2).qi);
((ag4).ad8)=((ag2).qj);
((ag4).AC)=({L:0,H:null,T:null,P:null});
(ag6)=((ag2).qg);
(qr)((ag6),([130,134]));
while(!((qt)((ag6),([130,134])))){
(ag8)=((qv)((ag6),([130,134])));
(ag9)=(new AF());
((ag9).AN)=((ag8).sP);
((ag9).AL)=((ag8).sA);
(eN)(((ag4).AC),([130,134]),(ag9));
(r8)((ag6),([130,134]));
}
((ag4).A7)=((ag2).qh);
((agt).yL)=(ag4);
((agt).yH)=(1);
break;
case 7:
(agB)=((agt).qz);
(zv)((agB));
agD=(agB).rp;
switch(agD){
case 1:
((agt).yL)=((agB).sA);
((agt).yH)=(3);
break;
case 2:
((agt).yL)=((agB).sA);
((agt).yH)=(((agB).sP)?(4):(2));
break;
case 3:
((agt).yL)=((agB).sA);
((agt).yH)=(2);
break;
case 4:
if(((agB).yb)===(null)){
return null;
}
if(!(((rt)((((agB).yb).qc),([9]),(67584)))===(67584))){throw 0xE9170000;}
((agt).zr)=((agB).yb);
return (agt).zr;
break;
case 5:
(D)((131075),((agt).ql),([((agt).q0)]));
return null;
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
break;
case 66050:
case 16843266:
case 66051:
if(!(((agw).zr)!==(null))){throw 0xE9170000;}
((agt).qz)=((agw).yc);
((agt).yL)=(((agw).yc).sA);
((agt).yH)=(2);
break;
default:
if(((((rt)(((agw).qc),([9]),(2048)))===(2048))&&(((agw).zr)!==(null)))&&((UT)((((agw).zr).yL)))){
((agt).zr)=((agw).zr);
return (agt).zr;
}
(D)((131136),((agt).ql),([((agt).q0)]));
return null;
break;
}
return agt;
}
// cmpType
function QT(agQ /*type1*/,agR /*type2*/,agS /*strict*/){
let agV; // typeId1
let agW; // typeId2
let agY; // nullable1
let agZ; // nullable2
let ahi; // func1
let ahj; // func2
let ahk; // args1
let ahl; // args2
let ahn; // arg1
let aho; // arg2
let ah3; // dict1
let ah4; // dict2
let ahE; // class1
let ahF; // class2
let ahG; // ptr
if(((agQ)===(null))||((agR)===(null))){
return false;
}
(agV)=((agQ).qc);
(agW)=((agR).qc);
(agY)=((((agV)===(66565))&&((((agQ).qz).qc)===(6)))?(false):(((rt)((agV),([9]),(66560)))===(66560)));
(agZ)=((((agW)===(66565))&&((((agR).qz).qc)===(6)))?(false):(((rt)((agW),([9]),(66560)))===(66560)));
if((((agY)&&((agW)===(1027)))||(((agV)===(1027))&&(agZ)))||(((agV)===(1027))&&((agW)===(1027)))){
return true;
}
if(((agV)===(66561))&&((agW)===(66561))){
return (QT)(((agQ).Az),((agR).Az),(true));
}
if(((agV)===(1025))&&((agW)===(1025))){
return ((agQ).A2)===((agR).A2);
}
if(((agV)===(66562))&&((agW)===(66562))){
(ahi)=(agQ);
(ahj)=(agR);
(ahk)=((ahi).AC);
(ahl)=((ahj).AC);
(qr)((ahk),([130,134]));
(qr)((ahl),([130,134]));
while((!((qt)((ahk),([130,134]))))&&(!((qt)((ahl),([130,134]))))){
(ahn)=((qv)((ahk),([130,134])));
(aho)=((qv)((ahl),([130,134])));
if((((ahn).AN)!==((aho).AN))||(!((QT)(((ahn).AL),((aho).AL),(true))))){
return false;
}
(r8)((ahk),([130,134]));
(r8)((ahl),([130,134]));
}
if(!(((qt)((ahk),([130,134])))&&((qt)((ahl),([130,134]))))){
return false;
}
if((((ahi).A7)===(null))&&(((ahj).A7)===(null))){
return true;
}
if((((ahi).A7)===(null))||(((ahj).A7)===(null))){
return false;
}
return (QT)(((ahi).A7),((ahj).A7),(true));
}
if(((agV)===(66563))&&((agW)===(66563))){
if(((agQ).AV)!==((agR).AV)){
return false;
}
return (QT)(((agQ).AX),((agR).AX),(true));
}
if(((agV)===(66564))&&((agW)===(66564))){
(ah3)=(agQ);
(ah4)=(agR);
return ((QT)(((ah3).Be),((ah4).Be),(true)))&&((QT)(((ah3).Bf),((ah4).Bf),(true)));
}
if(((agV)===(1026))&&((agW)===(1026))){
return ((agQ).ya)===((agR).ya);
}
if(((agV)===(66565))&&((agW)===(66565))){
if(!(((((agQ).qz).qc)!==(4))&&((((agR).qz).qc)!==(4)))){throw 0xE9170000;}
if(((((agQ).qz).qc)===(5))&&((((agR).qz).qc)===(5))){
if(agS){
return ((agQ).qz)===((agR).qz);
}
else{
(ahE)=((agQ).qz);
(ahF)=((agR).qz);
(ahG)=(null);
(ahG)=(ahE);
while((ahG)!==(null)){
if((ahG)===(ahF)){
return true;
}
(ahG)=((ahG).qz);
}
return false;
}
}
return ((agQ).qz)===((agR).qz);
}
if((((((agV)===(66565))&&((((agQ).qz).qc)===(6)))||((agV)===(1028)))&&((((agW)===(66565))&&((((agR).qz).qc)===(6)))||((agW)===(1028))))&&(!(((agV)===(1028))&&((agW)===(1028))))){
return true;
}
return false;
}
// rebuildEnumElement
function QW(ahM /*enumElement*/,ahN /*type*/){
let ahO; // enumElement2
if(!(((ahM).qc)===(67587))){throw 0xE9170000;}
if(!((UT)((ahN)))){throw 0xE9170000;}
(ahO)=(new yF());
(yx)((ahO),(67585),((ahM).ql));
((ahO).yI)=((ahP)((ahM),((ahN).qz)));
((ahO).yL)=(ahN);
(ahO)=((Sq)((ahO)));
return ahO;
}
// rebuildClass
function Rl(ahQ /*ast*/){
let ahT; // dtor
let ahU; // copy
let ahV; // toBin
let ahW; // fromBin
let ahY;
let ahZ;
let aia;
let aib;
if(((ahQ).zr)!==(null)){
return;
}
((ahQ).zr)=(ahQ);
(ahT)=(null);
(ahU)=(null);
(ahV)=(null);
(ahW)=(null);
((ahX)((ahQ),(ahY={$:(ahT)},ahY),(ahZ={$:(ahU)},ahZ),(aia={$:(ahV)},aia),(aib={$:(ahW)},aib)),(ahT)=ahY.$,(ahU)=ahZ.$,(ahV)=aia.$,(ahW)=aib.$);
(aic)((ahQ),(ahT),(ahU),(ahV),(ahW));
(rD)((ahT));
(rD)((ahU));
(rD)((ahV));
(rD)((ahW));
}
// rebuildEnum
function Rn(aid /*ast*/){
let aig; // type
let aih; // defaultNum
let aii; // enumValues
let aij; // items
let aim; // item
let ain; // itemName
let ais; // item2
let ai0; // value
let ai4;
let ai2;
let ai3;
if(((aid).zr)!==(null)){
return;
}
((aid).zr)=(aid);
(aig)=(new Oq());
(xP)((aig),(66565),((aid).ql));
((aig).zr)=(aig);
((aig).qz)=(aid);
(aih)=(-1);
(aii)=(new Map());
(aij)=((aid).PI);
(qr)((aij),([130,134]));
ail:
while(!((qt)((aij),([130,134])))){
(aim)=((qv)((aij),([130,134])));
(ain)=((aim).qX);
(aim)=((zH)((aim),(((aim).yL)===(null))));
if((aim)===(null)){
continue ail;
}
((aim).qX)=(ain);
(t2)((aij),([130,134]),(aim));
(t4)((aij),([130,134]));
if((((aim).qc)!==(67585))||((((aim).yL)!==(null))&&(!((s9)(((aim).yL)))))){
(D)((131087),((aid).ql),([((aid).qX),((aim).qX)]));
return;
}
(ais)=(aim);
if(((aim).yL)===(null)){
if((aih)===(9223372036854775807)){
(D)((131088),((aid).ql),([((aid).qX),((aim).qX)]));
return;
}
(aih)=((aih)+(1));
((ais).yI)=(aih);
}
else{
(aih)=((ais).yI);
}
(ai0)=((ais).yI);
if((ai2=(pR)((aii),([133,0,3]),(ai0),(ai3={$:(ai4)},ai3)),(ai4)=ai3.$,ai2)){
(D)((131089),((aid).ql),([((aid).qX),((aim).qX),((v)((ai0),([0])))]));
return;
}
(bE)((aii),([133,0,3]),(ai0),(true));
((aim).yL)=(aig);
}
}
// rebuildAlias
function Rp(ai6 /*ast*/,ai7 /*parent*/){
if((ai6)===(ai7)){
(D)((131079),((ai7).ql),([((ai7).qX)]));
((ai6).OR)=(null);
return;
}
if(((ai6).zr)!==(null)){
return;
}
((ai6).zr)=(ai6);
((ai6).OR)=((zy)(((ai6).OR),(ai6)));
}
// rebuildExpr1
function RJ(aiC /*ast*/){
let aiI; // childType
let aiK;
let aiZ; // expr
let aja; // expr
let aji; // expr
let ajp; // type
if(((aiC).zr)!==(null)){
return (aiC).zr;
}
((aiC).zr)=(aiC);
((aiC).aiF)=((zH)(((aiC).aiF),(false)));
if(((aiC).aiF)===(null)){
return null;
}
if(!(((aiC).yL)===(null))){throw 0xE9170000;}
(aiI)=(((aiC).aiF).yL);
aiK=(aiC).aiL;
switch(aiK){
case 0:
if((((s9)((aiI)))||((aiO)((aiI))))||(((aiI).qc)===(1025))){
if(((rt)((((aiC).aiF).qc),([9]),(67584)))===(67584)){
((aiC).zr)=((aiC).aiF);
return (aiC).zr;
}
((aiC).yL)=(aiI);
}
break;
case 1:
if(((s9)((aiI)))||((aiO)((aiI)))){
if(((rt)((((aiC).aiF).qc),([9]),(67584)))===(67584)){
if((s9)((aiI))){
(aiZ)=(new yF());
(yx)((aiZ),(67585),((aiC).ql));
((aiZ).yL)=(aiI);
((aiZ).yI)=(-(((aiC).aiF).yI));
(aiZ)=((Sq)((aiZ)));
((aiC).zr)=(aiZ);
return (aiC).zr;
}
if(!((aiO)((aiI)))){throw 0xE9170000;}
(aja)=(new Sz());
(yx)((aja),(67588),((aiC).ql));
((aja).yL)=(aiI);
((aja).ajb)=(-(((aiC).aiF).ajb));
(aja)=((Sy)((aja)));
((aiC).zr)=(aja);
return (aiC).zr;
}
((aiC).yL)=(aiI);
}
break;
case 2:
if((aje)((aiI))){
if((((aiC).aiF).qc)===(67585)){
(aji)=(new yF());
(yx)((aji),(67585),((aiC).ql));
((aji).yL)=(aiI);
((aji).yI)=(((((aiC).aiF).yI)!==(0x0000000000000000))?(0x0000000000000000):(0x0000000000000001));
(aji)=((Sq)((aji)));
((aiC).zr)=(aji);
return (aiC).zr;
}
((aiC).yL)=(aiI);
}
break;
case 3:
if(((((T9)((aiI)))||(((aiI).qc)===(66561)))||(((aiI).qc)===(66563)))||(((aiI).qc)===(66564))){
((aiC).yL)=(aiI);
}
break;
case 4:
if(((((aiI).qc)===(66561))||(((aiI).qc)===(66563)))||(((aiI).qc)===(66564))){
(ajp)=(new xZ());
(xP)((ajp),(1026),((aiC).ql));
((ajp).ya)=(0);
((aiC).yL)=(ajp);
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
if(((aiC).yL)===(null)){
(D)((131113),((aiC).ql),(null));
return null;
}
((aiC).yH)=(1);
return aiC;
}
// rebuildExpr2
function RM(ajt /*ast*/){
let aj3; // correct
let aj5;
let ajB; // ptr
let ajM; // value
let ajW; // type
let akf; // value
let akg; // children0Type
let akj; // n1
let akk; // n2
let akm;
let akt; // n1
let aku; // n2
let akw;
let ak3; // n1
let ak4; // n2
let ak6;
let akD; // cmp
let akH;
let akN; // expr
let akT; // type
let alb; // value
let alc; // children0Type
let alf; // n1
let alg; // n2
let ali;
let aln; // n1
let alo; // n2
let alq;
let alv; // cmp
let alx;
let al1; // expr
let al5; // type
let alF; // s1
let alG; // s2
let alH; // expr
let alP; // n1
let alQ; // n2
let alS;
let ami; // expr
let aml; // n1
let amm; // n2
let amo;
let am4; // expr
let am6; // n1
let am7; // n2
let am9;
let amP; // expr
if(((ajt).zr)!==(null)){
return (ajt).zr;
}
((ajt).zr)=(ajt);
((ajt).zP)=((zH)(((ajt).zP),(false)));
if(((ajt).zP)===(null)){
return null;
}
((ajt).zQ)=((zH)(((ajt).zQ),(false)));
if(((ajt).zQ)===(null)){
return null;
}
if(!((QT)((((ajt).zQ).yL),(((ajt).zP).yL),(false)))){
(D)((131113),((ajt).ql),(null));
return null;
}
(aj3)=(false);
aj5=(ajt).zM;
switch(aj5){
case 0:
if((((ajt).zP).yH)===(1)){
(D)((131114),((ajt).ql),(null));
return null;
}
if(((T9)((((ajt).zP).yL)))&&((T9)((((ajt).zQ).yL)))){
(ajB)=((((ajt).zQ).yL).qz);
while(((((ajt).zP).yL).qz)!==(ajB)){
(ajB)=((ajB).qz);
if((ajB)===(null)){
(D)((131113),((ajt).ql),(null));
return null;
}
}
}
if(((((ajt).zQ).yL).qc)===(1028)){
((ajt).zQ)=((QW)(((ajt).zQ),(((ajt).zP).yL)));
}
((ajt).yL)=(null);
(aj3)=(true);
break;
case 8:
case 9:
if((aje)((((ajt).zP).yL))){
if((((ajt).zP).qc)===(67585)){
(ajM)=((((ajt).zP).yI)!==(0x0000000000000000));
if(((ajt).zM)===(8)){
((ajt).zr)=((ajM)?((ajt).zP):((ajt).zQ));
}
else{
if(!(((ajt).zM)===(9))){throw 0xE9170000;}
((ajt).zr)=((!(ajM))?((ajt).zP):((ajt).zQ));
}
return (ajt).zr;
}
((ajt).yL)=(((ajt).zP).yL);
(aj3)=(true);
}
break;
case 10:
case 11:
case 12:
case 13:
if((((((ajt).zP).yL).qc)===(1027))||(((((ajt).zQ).yL).qc)===(1027))){
(D)((131115),((ajt).ql),(null));
return null;
}
if((ajU)((((ajt).zP).yL),(true))){
(ajW)=(new xZ());
(xP)((ajW),(1026),((ajt).ql));
((ajW).ya)=(3);
if(((((ajt).zP).yL).qc)===(1028)){
if(((((ajt).zQ).yL).qc)===(1028)){
if(!((((ajt).zP).qc)===(67587))){throw 0xE9170000;}
(D)((131116),((ajt).ql),([(((ajt).zP).akb)]));
return null;
}
((ajt).zP)=((QW)(((ajt).zP),(((ajt).zQ).yL)));
}
else if(((((ajt).zQ).yL).qc)===(1028)){
((ajt).zQ)=((QW)(((ajt).zQ),(((ajt).zP).yL)));
}
if((((rt)((((ajt).zP).qc),([9]),(67584)))===(67584))&&(((rt)((((ajt).zQ).qc),([9]),(67584)))===(67584))){
(akf)=(false);
(akg)=(((ajt).zP).yL);
if((((akg).qc)===(1025))||((US)((akg)))){
(akj)=(((ajt).zP).yI);
(akk)=(((ajt).zQ).yI);
akm=(ajt).zM;
switch(akm){
case 10:
(akf)=((akj)<(akk));
break;
case 11:
(akf)=((akj)>(akk));
break;
case 12:
(akf)=((akj)<=(akk));
break;
case 13:
(akf)=((akj)>=(akk));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else if(((s9)((akg)))||((UT)((akg)))){
(akt)=(((ajt).zP).yI);
(aku)=(((ajt).zQ).yI);
akw=(ajt).zM;
switch(akw){
case 10:
(akf)=((akt)<(aku));
break;
case 11:
(akf)=((akt)>(aku));
break;
case 12:
(akf)=((akt)<=(aku));
break;
case 13:
(akf)=((akt)>=(aku));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else if((aiO)((akg))){
(ak3)=(((ajt).zP).ajb);
(ak4)=(((ajt).zQ).ajb);
ak6=(ajt).zM;
switch(ak6){
case 10:
(akf)=((ak3)<(ak4));
break;
case 11:
(akf)=((ak3)>(ak4));
break;
case 12:
(akf)=((ak3)<=(ak4));
break;
case 13:
(akf)=((ak3)>=(ak4));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{
if(!((Zt)((akg)))){throw 0xE9170000;}
(akD)=((akE)((((ajt).zP).akF),(((ajt).zQ).akF)));
akH=(ajt).zM;
switch(akH){
case 10:
(akf)=((akD)<(0));
break;
case 11:
(akf)=((akD)>(0));
break;
case 12:
(akf)=((akD)<=(0));
break;
case 13:
(akf)=((akD)>=(0));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
(akN)=(new yF());
(yx)((akN),(67585),((ajt).ql));
((akN).yL)=(ajW);
((akN).yI)=((akf)?(0x0000000000000001):(0x0000000000000000));
(akN)=((Sq)((akN)));
((ajt).zr)=(akN);
return (ajt).zr;
}
((ajt).yL)=(ajW);
(aj3)=(true);
}
break;
case 14:
case 15:
if((((((ajt).zP).yL).qc)===(1027))||(((((ajt).zQ).yL).qc)===(1027))){
(D)((131115),((ajt).ql),(null));
return null;
}
if((ajU)((((ajt).zP).yL),(false))){
(akT)=(new xZ());
(xP)((akT),(1026),((ajt).ql));
((akT).ya)=(3);
if(((((ajt).zP).yL).qc)===(1028)){
if(((((ajt).zQ).yL).qc)===(1028)){
if(!((((ajt).zP).qc)===(67587))){throw 0xE9170000;}
(D)((131116),((ajt).ql),([(((ajt).zP).akb)]));
return null;
}
((ajt).zP)=((QW)(((ajt).zP),(((ajt).zQ).yL)));
}
else if(((((ajt).zQ).yL).qc)===(1028)){
((ajt).zQ)=((QW)(((ajt).zQ),(((ajt).zP).yL)));
}
if((((rt)((((ajt).zP).qc),([9]),(67584)))===(67584))&&(((rt)((((ajt).zQ).qc),([9]),(67584)))===(67584))){
(alb)=(false);
(alc)=(((ajt).zP).yL);
if(((((((alc).qc)===(1025))||((s9)((alc))))||((US)((alc))))||((aje)((alc))))||((UT)((alc)))){
(alf)=(((ajt).zP).yI);
(alg)=(((ajt).zQ).yI);
ali=(ajt).zM;
switch(ali){
case 14:
(alb)=((alf)===(alg));
break;
case 15:
(alb)=((alf)!==(alg));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else if((aiO)((alc))){
(aln)=(((ajt).zP).ajb);
(alo)=(((ajt).zQ).ajb);
alq=(ajt).zM;
switch(alq){
case 14:
(alb)=((aln)===(alo));
break;
case 15:
(alb)=((aln)!==(alo));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{
if(!((Zt)((alc)))){throw 0xE9170000;}
(alv)=((akE)((((ajt).zP).akF),(((ajt).zQ).akF)));
alx=(ajt).zM;
switch(alx){
case 14:
(alb)=((alv)===(0));
break;
case 15:
(alb)=((alv)!==(0));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
(al1)=(new yF());
(yx)((al1),(67585),((ajt).ql));
((al1).yL)=(akT);
((al1).yI)=((alb)?(0x0000000000000001):(0x0000000000000000));
(al1)=((Sq)((al1)));
((ajt).zr)=(al1);
return (ajt).zr;
}
((ajt).yL)=(akT);
(aj3)=(true);
}
break;
case 16:
case 17:
if(((aaH)((((ajt).zP).yL)))||(((((ajt).zP).yL).qc)===(1027))){
(al5)=(new xZ());
(xP)((al5),(1026),((ajt).ql));
((al5).ya)=(3);
((ajt).yL)=(al5);
(aj3)=(true);
}
break;
case 18:
if((((((ajt).zP).yL).qc)===(1027))||(((((ajt).zQ).yL).qc)===(1027))){
(D)((131117),((ajt).ql),(null));
return null;
}
if(((((ajt).zP).yL).qc)===(66561)){
if((((rt)((((ajt).zP).qc),([9]),(67584)))===(67584))&&(((rt)((((ajt).zQ).qc),([9]),(67584)))===(67584))){
if((Zt)((((ajt).zP).yL))){
(alF)=(((ajt).zP).akF);
(alG)=(((ajt).zQ).akF);
(alH)=(new St());
(yx)((alH),(67586),((ajt).ql));
((alH).yL)=(((ajt).zP).yL);
((alH).akF)=({S:(alF).S+(alG).S});
(alH)=((Ss)((alH)));
((ajt).zr)=(alH);
return (ajt).zr;
}
}
((ajt).yL)=(((ajt).zP).yL);
(aj3)=(true);
}
break;
case 19:
case 20:
case 21:
case 22:
case 23:
if(((((((ajt).zP).yL).qc)===(1025))||((s9)((((ajt).zP).yL))))||((aiO)((((ajt).zP).yL)))){
if((((rt)((((ajt).zP).qc),([9]),(67584)))===(67584))&&(((rt)((((ajt).zQ).qc),([9]),(67584)))===(67584))){
if(((((ajt).zP).yL).qc)===(1025)){
(alP)=(((ajt).zP).yI);
(alQ)=(((ajt).zQ).yI);
alS=(ajt).zM;
switch(alS){
case 19:
(alP)=((alP)+(alQ));
break;
case 20:
(alP)=((alP)-(alQ));
break;
case 21:
(alP)=((alP)*(alQ));
break;
case 22:
if((alQ)===(0x0000000000000000)){
(D)((131118),((ajt).ql),(null));
return null;
}
(alP)=(~~((alP)/(alQ)));
break;
case 23:
if((alQ)===(0x0000000000000000)){
(D)((131118),((ajt).ql),(null));
return null;
}
(alP)=((alP)%(alQ));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(ami)=(new yF());
(yx)((ami),(67585),((ajt).ql));
((ami).yL)=(((ajt).zP).yL);
((ami).yI)=((amj)(((((ajt).zP).yL).A2),(alP)));
(ami)=((Sq)((ami)));
((ajt).zr)=(ami);
return (ajt).zr;
}
else if((s9)((((ajt).zP).yL))){
(aml)=(((ajt).zP).yI);
(amm)=(((ajt).zQ).yI);
amo=(ajt).zM;
switch(amo){
case 19:
(aml)=((aml)+(amm));
break;
case 20:
(aml)=((aml)-(amm));
break;
case 21:
(aml)=((aml)*(amm));
break;
case 22:
if((amm)===(0)){
(D)((131118),((ajt).ql),(null));
return null;
}
(aml)=(~~((aml)/(amm)));
break;
case 23:
if((amm)===(0)){
(D)((131118),((ajt).ql),(null));
return null;
}
(aml)=((aml)%(amm));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(am4)=(new yF());
(yx)((am4),(67585),((ajt).ql));
((am4).yL)=(((ajt).zP).yL);
((am4).yI)=(aml);
(am4)=((Sq)((am4)));
((ajt).zr)=(am4);
return (ajt).zr;
}
else{
if(!((aiO)((((ajt).zP).yL)))){throw 0xE9170000;}
(am6)=(((ajt).zP).ajb);
(am7)=(((ajt).zQ).ajb);
am9=(ajt).zM;
switch(am9){
case 19:
(am6)=((am6)+(am7));
break;
case 20:
(am6)=((am6)-(am7));
break;
case 21:
(am6)=((am6)*(am7));
break;
case 22:
if(((am6)===(0))&&((am7)===(0))){
(D)((131118),((ajt).ql),(null));
return null;
}
(am6)=((am6)/(am7));
break;
case 23:
if(((am6)===(0))&&((am7)===(0))){
(D)((131118),((ajt).ql),(null));
return null;
}
(am6)=((am6)%(am7));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(amP)=(new Sz());
(yx)((amP),(67588),((ajt).ql));
((amP).yL)=(((ajt).zP).yL);
((amP).ajb)=(am6);
(amP)=((Sy)((amP)));
((ajt).zr)=(amP);
return (ajt).zr;
}
}
((ajt).yL)=(((ajt).zP).yL);
(aj3)=(true);
}
break;
case 24:
if(((s9)((((ajt).zP).yL)))||((aiO)((((ajt).zP).yL)))){
((ajt).yL)=(((ajt).zP).yL);
(aj3)=(true);
}
break;
case 25:
if(((((ajt).zP).yH)===(1))||((((ajt).zQ).yH)===(1))){
(D)((131119),((ajt).ql),(null));
return null;
}
if(!(((T9)((((ajt).zP).yL)))&&(((((ajt).zP).yL).qz)!==((((ajt).zQ).yL).qz)))){
((ajt).yL)=(((ajt).zP).yL);
(aj3)=(true);
}
break;
}
if(!(aj3)){
(D)((131113),((ajt).ql),(null));
return null;
}
((ajt).yH)=(1);
return ajt;
}
// rebuildExpr3
function RO(ana /*ast*/){
if(((ana).zr)!==(null)){
return (ana).zr;
}
((ana).zr)=(ana);
((ana).and)=((zH)(((ana).and),(false)));
if(((ana).and)===(null)){
return null;
}
((ana).ang)=((zH)(((ana).ang),(false)));
if(((ana).ang)===(null)){
return null;
}
((ana).anj)=((zH)(((ana).anj),(false)));
if(((ana).anj)===(null)){
return null;
}
if(!((aje)((((ana).and).yL)))){
(D)((131120),((ana).ql),(null));
return null;
}
if((!((QT)((((ana).ang).yL),(((ana).anj).yL),(false))))&&(!((QT)((((ana).anj).yL),(((ana).ang).yL),(false))))){
(D)((131121),((ana).ql),(null));
return null;
}
if((((ana).and).qc)===(67585)){
((ana).zr)=(((((ana).and).yI)!==(0x0000000000000000))?((ana).ang):((ana).anj));
return (ana).zr;
}
if(((((ana).ang).yL).qc)===(1028)){
if(((((ana).anj).yL).qc)===(1028)){
if(!((((ana).ang).qc)===(67587))){throw 0xE9170000;}
(D)((131116),((ana).ql),([(((ana).ang).akb)]));
return null;
}
((ana).ang)=((QW)(((ana).ang),(((ana).anj).yL)));
}
else if(((((ana).anj).yL).qc)===(1028)){
((ana).anj)=((QW)(((ana).anj),(((ana).ang).yL)));
}
if((QT)((((ana).ang).yL),(((ana).anj).yL),(false))){
((ana).yL)=((((((ana).anj).yL).qc)===(1027))?(((ana).ang).yL):(((ana).anj).yL));
}
else{
((ana).yL)=((((((ana).ang).yL).qc)===(1027))?(((ana).anj).yL):(((ana).ang).yL));
}
((ana).yH)=(1);
return ana;
}
// rebuildExprNew
function RR(an0 /*ast*/){
if(((an0).zr)!==(null)){
return (an0).zr;
}
((an0).zr)=(an0);
((an0).an3)=((zy)(((an0).an3),(null)));
if(((an0).an3)===(null)){
return null;
}
if(((T9)(((an0).an3)))&&((((an0).an3).qz)===(null))){
return null;
}
if(!((((T9)(((an0).an3)))||((((an0).an3).qc)===(66563)))||((((an0).an3).qc)===(66564)))){
(D)((131122),((an0).ql),(null));
return null;
}
((an0).yL)=((an0).an3);
((an0).yH)=(1);
return an0;
}
// rebuildExprNewArray
function RU(anA /*ast*/){
let anE; // items
let anI; // data
let anR; // type
let anU;
let anW; // type2
let anV;
if(((anA).zr)!==(null)){
return (anA).zr;
}
((anA).zr)=(anA);
(anE)=((anA).anF);
(qr)((anE),([130,134]));
anH:
while(!((qt)((anE),([130,134])))){
(anI)=((qv)((anE),([130,134])));
(anI)=((zH)((anI),(false)));
if((anI)===(null)){
return null;
}
if(!((s9)(((anI).yL)))){
(D)((131123),((anI).ql),(null));
return null;
}
(t2)((anE),([130,134]),(anI));
(t4)((anE),([130,134]));
}
((anA).anN)=((zy)(((anA).anN),(null)));
if(((anA).anN)===(null)){
return null;
}
(anR)=((anA).anN);
anT:
for(anU=(0),anV=((((anA).anF).L)-(1));anU<=anV;anU+=(1)){
(anW)=(new Ax());
(xP)((anW),(66561),((anA).ql));
((anW).Az)=(anR);
(anR)=(anW);
}
((anA).yL)=(anR);
((anA).yH)=(1);
return anA;
}
// rebuildExprAs
function RX(anX /*ast*/){
let aoh;
let aok; // t1
let aol; // t2
let aoO; // n
let aoR; // expr
let aoT; // expr
let aoV; // expr
let apa; // expr
let apc; // expr
let ape; // expr
let apg; // n
let apj; // expr
let apl; // expr
let app; // type
if(((anX).zr)!==(null)){
return (anX).zr;
}
((anX).zr)=(anX);
((anX).aoa)=((zH)(((anX).aoa),(false)));
if(((anX).aoa)===(null)){
return null;
}
((anX).aod)=((zy)(((anX).aod),(null)));
if(((anX).aod)===(null)){
return null;
}
if(!(((anX).yL)===(null))){throw 0xE9170000;}
aoh=(anX).aoi;
switch(aoh){
case 0:
(aok)=(((anX).aoa).yL);
(aol)=((anX).aod);
if((((aok).qc)===(1025))||((s9)((aok)))){
if((((((((aol).qc)===(1025))||((s9)((aol))))||((aiO)((aol))))||((US)((aol))))||((aje)((aol))))||((UT)((aol)))){
if((QT)((aok),(aol),(false))){
((anX).zr)=((anX).aoa);
return (anX).zr;
}
((anX).yL)=(aol);
}
}
else if((aiO)((aok))){
if(((((aol).qc)===(1025))||((s9)((aol))))||((aiO)((aol)))){
if((QT)((aok),(aol),(false))){
((anX).zr)=((anX).aoa);
return (anX).zr;
}
((anX).yL)=(aol);
}
}
else if((US)((aok))){
if(((((aol).qc)===(1025))||((s9)((aol))))||((US)((aol)))){
if((QT)((aok),(aol),(false))){
((anX).zr)=((anX).aoa);
return (anX).zr;
}
((anX).yL)=(aol);
}
}
else if((aje)((aok))){
if(((((aol).qc)===(1025))||((s9)((aol))))||((aje)((aol)))){
if((QT)((aok),(aol),(false))){
((anX).zr)=((anX).aoa);
return (anX).zr;
}
((anX).yL)=(aol);
}
}
else if((T9)((aok))){
if((T9)((aol))){
((anX).yL)=(aol);
}
}
else if((UT)((aok))){
if(((((aol).qc)===(1025))||((s9)((aol))))||((UT)((aol)))){
if((QT)((aok),(aol),(false))){
((anX).zr)=((anX).aoa);
return (anX).zr;
}
((anX).yL)=(aol);
}
}
else if(((aok).qc)===(1028)){
if((UT)((aol))){
((anX).yL)=(aol);
}
}
if(((anX).yL)!==(null)){
if(((rt)((((anX).aoa).qc),([9]),(67584)))===(67584)){
if(((((((aok).qc)===(1025))||((US)((aok))))||((aje)((aok))))||((s9)((aok))))||((UT)((aok)))){
(aoO)=(((anX).aoa).yI);
if(((aol).qc)===(1025)){
(aoR)=(new yF());
(yx)((aoR),(67585),((anX).ql));
((aoR).yL)=((anX).yL);
((aoR).yI)=((amj)(((aol).A2),(aoO)));
(aoR)=((Sq)((aoR)));
((anX).zr)=(aoR);
return (anX).zr;
}
else if(((s9)((aol)))||((UT)((aol)))){
(aoT)=(new yF());
(yx)((aoT),(67585),((anX).ql));
((aoT).yL)=((anX).yL);
((aoT).yI)=(aoO);
(aoT)=((Sq)((aoT)));
((anX).zr)=(aoT);
return (anX).zr;
}
else if((aiO)((aol))){
(aoV)=(new Sz());
(yx)((aoV),(67588),((anX).ql));
((aoV).yL)=((anX).yL);
if(((s9)((aok)))||((UT)((aok)))){
((aoV).ajb)=(aoO);
}
else{
((aoV).ajb)=(aoO);
}
(aoV)=((Sy)((aoV)));
((anX).zr)=(aoV);
return (anX).zr;
}
else if((US)((aol))){
(apa)=(new yF());
(yx)((apa),(67585),((anX).ql));
((apa).yL)=((anX).yL);
((apa).yI)=((amj)((2),(aoO)));
(apa)=((Sq)((apa)));
((anX).zr)=(apa);
return (anX).zr;
}
else{
if(!((aje)((aol)))){throw 0xE9170000;}
(apc)=(new yF());
(yx)((apc),(67585),((anX).ql));
((apc).yL)=((anX).yL);
((apc).yI)=(((aoO)!==(0x0000000000000000))?(0x0000000000000001):(0x0000000000000000));
(apc)=((Sq)((apc)));
((anX).zr)=(apc);
return (anX).zr;
}
}
else if(((aok).qc)===(1028)){
if(!((((aol).qz).qc)===(6))){throw 0xE9170000;}
(ape)=(new yF());
(yx)((ape),(67585),((anX).ql));
((ape).yL)=((anX).yL);
((ape).yI)=((ahP)(((anX).aoa),((aol).qz)));
(ape)=((Sq)((ape)));
((anX).zr)=(ape);
return (anX).zr;
}
else{
if(!((aiO)((aok)))){throw 0xE9170000;}
(apg)=(((anX).aoa).ajb);
if(((aol).qc)===(1025)){
(apj)=(new yF());
(yx)((apj),(67585),((anX).ql));
((apj).yL)=((anX).yL);
((apj).yI)=((amj)(((aol).A2),(~~(apg))));
(apj)=((Sq)((apj)));
((anX).zr)=(apj);
return (anX).zr;
}
else{
if(!((s9)((aol)))){throw 0xE9170000;}
(apl)=(new yF());
(yx)((apl),(67585),((anX).ql));
((apl).yL)=((anX).yL);
((apl).yI)=(~~(apg));
(apl)=((Sq)((apl)));
((anX).zr)=(apl);
return (anX).zr;
}
}
}
}
break;
case 1:
case 2:
if(((T9)((((anX).aoa).yL)))&&((T9)(((anX).aod)))){
(app)=(new xZ());
(xP)((app),(1026),((anX).ql));
((app).ya)=(3);
((anX).yL)=(app);
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
if(((anX).yL)===(null)){
(D)((131113),((anX).ql),(null));
return null;
}
((anX).yH)=(1);
return anX;
}
// rebuildExprToBin
function Sa(apt /*ast*/){
if(((apt).zr)!==(null)){
return (apt).zr;
}
((apt).zr)=(apt);
((apt).apw)=((zH)(((apt).apw),(false)));
if(((apt).apw)===(null)){
return null;
}
if((((((apt).apw).yL).qc)===(1027))||(((((apt).apw).yL).qc)===(1028))){
(D)((131113),((apt).ql),(null));
return null;
}
if((((((apt).ap2).qc)!==(66561))||(((((apt).ap2).Az).qc)!==(1025)))||(((((apt).ap2).Az).A2)!==(1))){
(D)((131113),((apt).ql),(null));
return null;
}
((apt).yL)=((apt).ap2);
((apt).yH)=(1);
return apt;
}
// rebuildExprFromBin
function Sd(ap4 /*ast*/){
if(((ap4).zr)!==(null)){
return (ap4).zr;
}
((ap4).zr)=(ap4);
((ap4).ap7)=((zH)(((ap4).ap7),(false)));
if(((ap4).ap7)===(null)){
return null;
}
if(((((((ap4).ap7).yL).qc)!==(66561))||((((((ap4).ap7).yL).Az).qc)!==(1025)))||((((((ap4).ap7).yL).Az).A2)!==(1))){
(D)((131113),((ap4).ql),(null));
return null;
}
((ap4).yL)=((ap4).apC);
((ap4).yH)=(1);
((ap4).apD)=((zH)(((ap4).apD),(false)));
return ap4;
}
// rebuildExprCall
function Sg(apE /*ast*/){
let apK; // type
let apN; // valueType
let apP; // expr
let apV; // me_
let aqc; // meType
let aqe; // expr
let aqh; // value
let aqj; // prim
let aqu; // n
let aqv; // itemsExpr
let aqw; // itemsType
let aqy; // argExpr
let aqz; // argType
if(((apE).zr)!==(null)){
return (apE).zr;
}
((apE).zr)=(apE);
((apE).y1)=((zH)(((apE).y1),(false)));
if(((apE).y1)===(null)){
return null;
}
(apK)=(((apE).y1).yL);
if(((rt)(((apK).ad7),([9]),(2048)))!==(0)){
(apN)=(new za());
if(!(((apK).A7)!==(null))){throw 0xE9170000;}
(apP)=(new RS());
(yx)((apP),(2052),((apE).ql));
((apP).an3)=((apK).A7);
((apN).zf)=((zH)((apP),(false)));
((apN).zb)=(false);
((apN).zc)=(false);
if((((apE).yy).L)===(0)){
(eN)(((apE).yy),([130,134]),(apN));
}
else{
(qr)(((apE).yy),([130,134]));
(t2)(((apE).yy),([130,134]),(apN));
}
}
if(((((apE).y1).qc)===(2059))&&(((((apE).y1).yL).qc)===(66562))){
(apV)=(new za());
((apV).zf)=(((apE).y1).apW);
((apV).zb)=(false);
((apV).zc)=(false);
if((((apE).yy).L)===(0)){
(eN)(((apE).yy),([130,134]),(apV));
}
else{
(qr)(((apE).yy),([130,134]));
(t2)(((apE).yy),([130,134]),(apV));
}
if(((rt)(((apK).ad7),([9]),(1)))!==(0)){
(aqc)=(new za());
(aqe)=(new S2());
(yx)((aqe),(2060),((apE).ql));
((aqe).aqf)=({L:0,H:null,T:null,P:null});
(aqh)=(new yF());
(yx)((aqh),(67585),((apE).ql));
((aqh).yI)=(0x0000000000000000);
(aqj)=(new xZ());
(xP)((aqj),(1026),((apE).ql));
((aqj).ya)=(0);
((aqh).yL)=(aqj);
(eN)(((aqe).aqf),([130,134]),(aqh));
((aqc).zf)=((zH)((aqe),(false)));
((aqc).zb)=(false);
((aqc).zc)=(false);
if((((apE).yy).L)===(1)){
(eN)(((apE).yy),([130,134]),(aqc));
}
else{
if(!((((apE).yy).L)>=(2))){throw 0xE9170000;}
(qr)(((apE).yy),([130,134]));
(r8)(((apE).yy),([130,134]));
(t2)(((apE).yy),([130,134]),(aqc));
}
}
}
else{
if(((apK).qc)!==(66562)){
(D)((131124),((apE).ql),(null));
return null;
}
(apK)=(((apE).y1).yL);
}
((apE).yL)=((apK).A7);
if((((apE).yy).L)!==(((apK).AC).L)){
(D)((131125),((apE).ql),([((v)((((apK).AC).L),([0]))),((v)((((apE).yy).L),([0]))),((aqs)((apK)))]));
return null;
}
(aqu)=(0);
(aqv)=((apE).yy);
(aqw)=((apK).AC);
(qr)((aqv),([130,134]));
(qr)((aqw),([130,134]));
while(!((qt)((aqv),([130,134])))){
(aqy)=((qv)((aqv),([130,134])));
(aqz)=((qv)((aqw),([130,134])));
if((aqy).zc){
((((aqy).zf).qz).sA)=((aqz).AL);
}
((aqy).zf)=((zH)(((aqy).zf),(false)));
if(((aqy).zf)!==(null)){
if((((aqy).zb)&&(!((aqy).zc)))&&((((aqy).zf).yH)===(1))){
(D)((131126),((apE).ql),([((v)(((aqu)+(1)),([0])))]));
return null;
}
if((((aqy).zb)!==((aqz).AN))||(!((QT)((((aqy).zf).yL),((aqz).AL),(false))))){
(D)((131127),((apE).ql),([((v)(((aqu)+(1)),([0]))),({S:(((aqz).AN)?({S:"&"}):({S:""})).S+((aqs)(((aqz).AL))).S}),({S:(((aqy).zb)?({S:"&"}):({S:""})).S+((aqs)((((aqy).zf).yL))).S})]));
return null;
}
if(((((aqy).zf).yL).qc)===(1028)){
((aqy).zf)=((QW)(((aqy).zf),((aqz).AL)));
}
}
(r8)((aqv),([130,134]));
(r8)((aqw),([130,134]));
(aqu)=((aqu)+(1));
}
((apE).yH)=(1);
return apE;
}
// rebuildExprArray
function Si(aqB /*ast*/){
if(((aqB).zr)!==(null)){
return (aqB).zr;
}
((aqB).zr)=(aqB);
((aqB).aqE)=((zH)(((aqB).aqE),(false)));
if(((aqB).aqE)===(null)){
return null;
}
if(((((aqB).aqE).yL).qc)!==(66561)){
(D)((131128),((aqB).ql),(null));
return null;
}
((aqB).aqJ)=((zH)(((aqB).aqJ),(false)));
if(((aqB).aqJ)===(null)){
return null;
}
if(!((s9)((((aqB).aqJ).yL)))){
(D)((131129),(((aqB).aqJ).ql),(null));
return null;
}
((aqB).yL)=((((aqB).aqE).yL).Az);
((aqB).yH)=(3);
return aqB;
}
// rebuildExprDot
function Sl(aqO /*ast*/){
let aqV; // found
let aqW; // ptr
let aqY; // items
let ara; // item
let arf; // type
let arh; // items2
let arj; // arg
let ark; // arg2
let arr; // varType
let aru; // member
let ar0; // expr
let ar4; // func_
let ar9; // argType
let arU; // type
let arW; // item
let arY; // item
let asa; // item
let asr; // type
let asw; // type
let as1; // type
let arw;
let ary;
if(((aqO).zr)!==(null)){
return (aqO).zr;
}
((aqO).zr)=(aqO);
((aqO).apW)=((zH)(((aqO).apW),(false)));
if(((aqO).apW)===(null)){
return null;
}
if((T9)((((aqO).apW).yL))){
(aqV)=(false);
(aqW)=((((aqO).apW).yL).qz);
while((aqW)!==(null)){
(aqY)=((aqW).tm);
(qr)((aqY),([130,134]));
while(!((qt)((aqY),([130,134])))){
(ara)=((qv)((aqY),([130,134])));
if(((((ara).tX).qc)===(2))&&(((aqO).arc).S===((((ara).tX).uc).qX).S)){
((aqO).yL)=((((ara).tX).uc).sA);
((aqO).yH)=(3);
(aqV)=(true);
}
else if(((((ara).tX).qc)===(256))&&(((aqO).arc).S===(((ara).tX).qX).S)){
(arf)=(new A5());
(xP)((arf),(66562),((aqO).ql));
((arf).ad7)=(((ara).tX).qi);
((arf).ad8)=(((ara).tX).qj);
((arf).AC)=({L:0,H:null,T:null,P:null});
(arh)=(((ara).tX).qg);
(qr)((arh),([130,134]));
while(!((qt)((arh),([130,134])))){
(arj)=((qv)((arh),([130,134])));
(ark)=(new AF());
((ark).AL)=((arj).sA);
((ark).AN)=((arj).sP);
(eN)(((arf).AC),([130,134]),(ark));
(r8)((arh),([130,134]));
}
((arf).A7)=(((ara).tX).qh);
((aqO).yL)=(arf);
((aqO).yH)=(1);
(aqV)=(true);
}
if(aqV){
if((!((ara).Pl))&&(((((aqO).apW).q0)===(null))||((((aqO).apW).q0).S!==({S:"me"}).S))){
(D)((131131),((aqO).ql),([((aqO).arc)]));
return null;
}
((aqO).arp)=(ara);
return aqO;
}
(r8)((aqY),([130,134]));
}
(aqW)=((aqW).qz);
}
}
else{
(arr)=(((aqO).apW).yL);
if(((arr).qc)===(1028)){
if(!((((aqO).apW).qc)===(67587))){throw 0xE9170000;}
(D)((131116),((aqO).ql),([(((aqO).apW).akb)]));
return null;
}
(aru)=((aqO).arc);
if((arw=(arx)((ary={$:(aru)},ary),(arr)),(aru)=ary.$,arw)){
(ar0)=((yo)(({S:"kuin"}),({S:({S:"_"}).S+(aru).S}),(true)));
if((ar0)===(null)){
if(!(false)){throw 0xE9170000;}
return null;
}
(ar4)=((ar0).yL);
if(((rt)(((ar4).ad7),([9]),(1)))!==(0)){
if(!((((ar4).AC).L)>=(2))){throw 0xE9170000;}
(qr)(((ar4).AC),([130,134]));
if(!((s9)((((qv)(((ar4).AC),([130,134]))).AL)))){throw 0xE9170000;}
(r8)(((ar4).AC),([130,134]));
(ar9)=(((qv)(((ar4).AC),([130,134]))).AL);
if(!((((ar9).qc)===(66561))&&((s9)(((ar9).Az))))){throw 0xE9170000;}
(qr)(((ar4).AC),([130,134]));
(((qv)(((ar4).AC),([130,134]))).AL)=(arr);
}
if(((rt)(((ar4).ad7),([9]),(2)))!==(0)){
if(!(((rt)(((ar4).ad7),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(8)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(32)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(256)))===(0))){throw 0xE9170000;}
if(!((((ar4).AC).L)>=(3))){throw 0xE9170000;}
(qr)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
if(!((s9)((((qv)(((ar4).AC),([130,134]))).AL)))){throw 0xE9170000;}
(qr)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
(((qv)(((ar4).AC),([130,134]))).AL)=(arr);
}
if(((rt)(((ar4).ad7),([9]),(8)))!==(0)){
if(!(((rt)(((ar4).ad7),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(2)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(32)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(256)))===(0))){throw 0xE9170000;}
if(!((((ar4).AC).L)>=(3))){throw 0xE9170000;}
(qr)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
if(!((s9)((((qv)(((ar4).AC),([130,134]))).AL)))){throw 0xE9170000;}
(qr)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
if(((arr).qc)===(66561)){
(((qv)(((ar4).AC),([130,134]))).AL)=((arr).Az);
}
else if(((arr).qc)===(66563)){
(((qv)(((ar4).AC),([130,134]))).AL)=((arr).AX);
}
else{
if(!(((arr).qc)===(66564))){throw 0xE9170000;}
(((qv)(((ar4).AC),([130,134]))).AL)=((arr).Be);
}
}
if(((rt)(((ar4).ad7),([9]),(32)))!==(0)){
if(!(((rt)(((ar4).ad7),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(2)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(8)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(256)))===(0))){throw 0xE9170000;}
if(!((((ar4).AC).L)>=(4))){throw 0xE9170000;}
(qr)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
if(!((s9)((((qv)(((ar4).AC),([130,134]))).AL)))){throw 0xE9170000;}
(r8)(((ar4).AC),([130,134]));
if(!((s9)((((qv)(((ar4).AC),([130,134]))).AL)))){throw 0xE9170000;}
if(!(((arr).qc)===(66564))){throw 0xE9170000;}
(qr)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
(((qv)(((ar4).AC),([130,134]))).AL)=((arr).Be);
(r8)(((ar4).AC),([130,134]));
(((qv)(((ar4).AC),([130,134]))).AL)=((arr).Bf);
}
if(((rt)(((ar4).ad7),([9]),(256)))!==(0)){
if(!(((rt)(((ar4).ad7),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(2)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(8)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(32)))===(0))){throw 0xE9170000;}
if(!((((ar4).AC).L)>=(3))){throw 0xE9170000;}
(qr)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
if(!((s9)((((qv)(((ar4).AC),([130,134]))).AL)))){throw 0xE9170000;}
if(!(((arr).qc)===(66564))){throw 0xE9170000;}
(arU)=(new A5());
(xP)((arU),(66562),((aqO).ql));
((arU).ad7)=(0);
((arU).ad8)=({L:0,H:null,T:null,P:null});
((arU).AC)=({L:0,H:null,T:null,P:null});
(arW)=(new AF());
((arW).AL)=((arr).Be);
((arW).AN)=(false);
(eN)(((arU).AC),([130,134]),(arW));
(arY)=(new AF());
((arY).AL)=((arr).Bf);
((arY).AN)=(false);
(eN)(((arU).AC),([130,134]),(arY));
(asa)=(new AF());
(qr)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
((asa).AL)=(((qv)(((ar4).AC),([130,134]))).AL);
((asa).AN)=(false);
(eN)(((arU).AC),([130,134]),(asa));
((arU).A7)=((ar4).A7);
(qr)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
(r8)(((ar4).AC),([130,134]));
(((qv)(((ar4).AC),([130,134]))).AL)=(arU);
}
if(((rt)(((ar4).ad7),([9]),(4)))!==(0)){
if(!(((rt)(((ar4).ad7),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(16)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(64)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(512)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(1024)))===(0))){throw 0xE9170000;}
if(!((s9)(((ar4).A7)))){throw 0xE9170000;}
((ar4).A7)=(arr);
}
if(((rt)(((ar4).ad7),([9]),(16)))!==(0)){
if(!(((rt)(((ar4).ad7),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(4)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(64)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(512)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(1024)))===(0))){throw 0xE9170000;}
if(!((s9)(((ar4).A7)))){throw 0xE9170000;}
if(((arr).qc)===(66561)){
((ar4).A7)=((arr).Az);
}
else if(((arr).qc)===(66563)){
((ar4).A7)=((arr).AX);
}
else{
if(!(((arr).qc)===(66564))){throw 0xE9170000;}
((ar4).A7)=((arr).Bf);
}
}
if(((rt)(((ar4).ad7),([9]),(64)))!==(0)){
if(!(((rt)(((ar4).ad7),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(4)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(16)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(512)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(1024)))===(0))){throw 0xE9170000;}
if(!((s9)(((ar4).A7)))){throw 0xE9170000;}
if(!(((arr).qc)===(66563))){throw 0xE9170000;}
if(!(((arr).AV)===(0))){throw 0xE9170000;}
(asr)=(new Ax());
(xP)((asr),(66561),((aqO).ql));
((asr).Az)=((arr).AX);
((ar4).A7)=(asr);
}
if(((rt)(((ar4).ad7),([9]),(512)))!==(0)){
if(!(((rt)(((ar4).ad7),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(4)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(16)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(64)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(1024)))===(0))){throw 0xE9170000;}
if(!((s9)(((ar4).A7)))){throw 0xE9170000;}
if(!(((arr).qc)===(66564))){throw 0xE9170000;}
(asw)=(new Ax());
(xP)((asw),(66561),((aqO).ql));
((asw).Az)=((arr).Be);
((ar4).A7)=(asw);
}
if(((rt)(((ar4).ad7),([9]),(1024)))!==(0)){
if(!(((rt)(((ar4).ad7),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(4)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(16)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(64)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ar4).ad7),([9]),(512)))===(0))){throw 0xE9170000;}
if(!((s9)(((ar4).A7)))){throw 0xE9170000;}
if(!(((arr).qc)===(66564))){throw 0xE9170000;}
(as1)=(new Ax());
(xP)((as1),(66561),((aqO).ql));
((as1).Az)=((arr).Bf);
((ar4).A7)=(as1);
}
((aqO).qz)=(ar0);
((aqO).yL)=((ar0).yL);
((aqO).yH)=(1);
return aqO;
}
}
(D)((131130),((aqO).ql),([((aqO).arc)]));
return null;
}
// rebuildExprValue
function So(as2 /*ast*/){
if(((as2).zr)!==(null)){
return (as2).zr;
}
((as2).zr)=(as2);
if(!(((as2).qc)===(67584))){throw 0xE9170000;}
((as2).yH)=(1);
return as2;
}
// rebuildExprValuePrim
function Sq(as5 /*ast*/){
if(((as5).zr)!==(null)){
return (as5).zr;
}
((as5).zr)=(as5);
((as5).yH)=(1);
return as5;
}
// rebuildExprValueStr
function Ss(as8 /*ast*/){
if(((as8).zr)!==(null)){
return (as8).zr;
}
((as8).zr)=(as8);
((as8).yH)=(1);
return as8;
}
// rebuildExprValueEnumElement
function Sv(asB /*ast*/){
if(((asB).zr)!==(null)){
return (asB).zr;
}
((asB).zr)=(asB);
((asB).yH)=(1);
return asB;
}
// rebuildExprValueFloat
function Sy(asE /*ast*/){
if(((asE).zr)!==(null)){
return (asE).zr;
}
((asE).zr)=(asE);
((asE).yH)=(1);
return asE;
}
// rebuildExprValueArray
function S1(asH /*ast*/){
let asL; // nullSet
let asM; // enumSet
let asN; // items
let asP; // data
let asT; // dataType
let ati; // type
let atr; // items
let att; // item
let atz; // isConst
let at1; // items
let at8; // ast2
let at9; // s
let atA; // idx
let atB; // items
let atD;
let atE;
if(((asH).zr)!==(null)){
return (asH).zr;
}
((asH).zr)=(asH);
if(!(((asH).yL)===(null))){throw 0xE9170000;}
(asL)=(false);
(asM)=(false);
(asN)=((asH).aqf);
(qr)((asN),([130,134]));
while(!((qt)((asN),([130,134])))){
(asP)=((qv)((asN),([130,134])));
(asP)=((zH)((asP),(false)));
if((asP)===(null)){
return null;
}
(asT)=((asP).yL);
if(((asH).yL)===(null)){
if(((asT).qc)===(1027)){
if(asM){
(D)((131132),((asH).ql),(null));
return null;
}
(asL)=(true);
}
else if(((asT).qc)===(1028)){
if(asL){
(D)((131133),((asH).ql),(null));
return null;
}
(asM)=(true);
}
else{
if((asL)&&(!((aaH)((asT))))){
(D)((131133),((asH).ql),(null));
return null;
}
if((asM)&&(!((UT)((asT))))){
(D)((131132),((asH).ql),(null));
return null;
}
(ati)=(new Ax());
(xP)((ati),(66561),((asT).ql));
((ati).Az)=(asT);
((asH).yL)=(ati);
}
}
else if(!((QT)((((asH).yL).Az),(asT),(false)))){
(D)((131132),((asH).ql),(null));
return null;
}
(t2)((asN),([130,134]),(asP));
(t4)((asN),([130,134]));
}
if(((asH).yL)===(null)){
if(asM){
(D)((131134),((asH).ql),(null));
return null;
}
else{
(D)((131135),((asH).ql),(null));
return null;
}
}
if((UT)((((asH).yL).Az))){
(atr)=((asH).aqf);
(qr)((atr),([130,134]));
while(!((qt)((atr),([130,134])))){
(att)=((qv)((atr),([130,134])));
if((((att).yL).qc)===(1028)){
(att)=((QW)((att),(((asH).yL).Az)));
(t2)((atr),([130,134]),(att));
(t4)((atr),([130,134]));
}
else{
(r8)((atr),([130,134]));
}
}
}
if((Zt)(((asH).yL))){
(atz)=(true);
(at1)=((asH).aqf);
(qr)((at1),([130,134]));
at3:
while(!((qt)((at1),([130,134])))){
if((((qv)((at1),([130,134]))).qc)!==(67584)){
(atz)=(false);
break at3;
}
(r8)((at1),([130,134]));
}
if(atz){
(at8)=(new St());
(yx)((at8),(67586),((asH).ql));
((at8).yL)=((asH).yL);
(at9)=({S:"\0".repeat(((asH).aqf).L)});
(atA)=(0);
(atB)=((asH).aqf);
(qr)((atB),([130,134]));
while(!((qt)((atB),([130,134])))){
(at9).S=(atD=(atA),(at9).S.slice(0,atD)+String.fromCharCode(((qv)((atB),([130,134]))).yI)+(at9).S.slice(atD+1));
(r8)((atB),([130,134]));
(atA)=((atA)+(1));
}
((at8).akF)=(at9);
(at8)=((Ss)((at8)));
((asH).zr)=(asH);
return (asH).zr;
}
}
((asH).yH)=(1);
return asH;
}
// rebuildVar
function SJ(atG /*ast*/){
if(((atG).zr)!==(null)){
return;
}
((atG).zr)=(atG);
(zv)(((atG).uc));
}
// makeExprDefaultValue
function SZ(atJ /*type*/,atK /*pos*/){
let atN; // value
let atS; // value
let atU;
let atW; // value
if((UT)((atJ))){
(atN)=(new yF());
(yx)((atN),(67585),(atK));
((atN).yL)=(atJ);
((atN).yI)=(0x0000000000000000);
return atN;
}
if((aaH)((atJ))){
return (Aa)((atK));
}
if((aiO)((atJ))){
(atS)=(new Sz());
(yx)((atS),(67588),(atK));
((atS).yL)=(atJ);
((atS).ajb)=(0);
return atS;
}
atU=(atJ).qc;
switch(atU){
case 1025:
case 1026:
(atW)=(new yF());
(yx)((atW),(67585),(atK));
((atW).yL)=(atJ);
((atW).yI)=(0x0000000000000000);
return atW;
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// rebuildIf
function Th(atY /*ast*/,atZ /*retType*/,aua /*parentFunc*/){
let aug; // items
let aui; // elIf
let aup; // stats
let auw; // items
let auz; // elIf
let au8; // block_
if(((atY).zr)!==(null)){
return (atY).zr;
}
((atY).zr)=(atY);
((atY).Uy)=((zH)(((atY).Uy),(false)));
if((((atY).Uy)!==(null))&&(!((aje)((((atY).Uy).yL))))){
(D)((131094),(((atY).Uy).ql),(null));
}
((atY).U0)=((Tt)(((atY).U0),(atZ),(aua)));
(aug)=((atY).U6);
(qr)((aug),([130,134]));
while(!((qt)((aug),([130,134])))){
(aui)=((qv)((aug),([130,134])));
((aui).UA)=((zH)(((aui).UA),(false)));
if((((aui).UA)!==(null))&&(!((aje)((((aui).UA).yL))))){
(D)((131095),(((aui).UA).ql),(null));
}
((aui).UB)=((Tt)(((aui).UB),(atZ),(aua)));
(r8)((aug),([130,134]));
}
if(((atY).UD)!==(null)){
((atY).UD)=((Tt)(((atY).UD),(atZ),(aua)));
}
if(((atY).Uy)!==(null)){
(aup)=(null);
if((((atY).Uy).qc)!==(67585)){
return atY;
}
if((((atY).Uy).yI)!==(0x0000000000000000)){
(aup)=((atY).U0);
}
if((aup)!==(null)){
(auw)=((atY).U6);
(qr)((auw),([130,134]));
auy:
while(!((qt)((auw),([130,134])))){
(auz)=((qv)((auw),([130,134])));
if((((auz).UA).qc)!==(67585)){
return atY;
}
if((((auz).UA).yI)!==(0x0000000000000000)){
(aup)=((auz).UB);
break auy;
}
(r8)((auw),([130,134]));
}
if((aup)===(null)){
if(((atY).UD)===(null)){
(au8)=(new yf());
(xP)((au8),(66052),((atY).ql));
((au8).qX)=({S:"$"});
((au8).yg)=({L:0,H:null,T:null,P:null});
(aup)=(au8);
}
else{
(aup)=((atY).UD);
}
}
}
((atY).Uy)=(null);
((atY).U0)=(aup);
}
return atY;
}
// rebuildSwitch
function Tj(auA /*ast*/,auB /*retType*/,auC /*parentFunc*/){
let auK; // items
let auM; // case_
let auN; // items2
let auP; // exprs
if(((auA).zr)!==(null)){
return (auA).zr;
}
((auA).zr)=(auA);
((auA).UR)=((zH)(((auA).UR),(false)));
if(((auA).UR)!==(null)){
if(!((ajU)((((auA).UR).yL),(true)))){
(D)((131096),(((auA).UR).ql),(null));
}
(((auA).yc).sA)=(((auA).UR).yL);
}
(auK)=((auA).UW);
(qr)((auK),([130,134]));
while(!((qt)((auK),([130,134])))){
(auM)=((qv)((auK),([130,134])));
(auN)=((auM).Vb);
(qr)((auN),([130,134]));
while(!((qt)((auN),([130,134])))){
(auP)=((qv)((auN),([130,134])));
((auP).yM)=((zH)(((auP).yM),(false)));
if((((auA).UR)!==(null))&&(((auP).yM)!==(null))){
if(!((QT)((((auA).UR).yL),(((auP).yM).yL),(false)))){
(D)((131097),(((auP).yM).ql),(null));
}
else if(((((auP).yM).yL).qc)===(1028)){
((auP).yM)=((QW)(((auP).yM),(((auA).UR).yL)));
}
}
if(((auP).yR)!==(null)){
((auP).yR)=((zH)(((auP).yR),(false)));
if((((auA).UR)!==(null))&&(((auP).yR)!==(null))){
if(!((QT)((((auA).UR).yL),(((auP).yR).yL),(false)))){
(D)((131097),(((auP).yR).ql),(null));
}
else if(((((auP).yR).yL).qc)===(1028)){
((auP).yR)=((QW)(((auP).yR),(((auA).UR).yL)));
}
}
}
(r8)((auN),([130,134]));
}
((auM).Vp)=((Tt)(((auM).Vp),(auB),(auC)));
(r8)((auK),([130,134]));
}
if(((auA).Vr)!==(null)){
((auA).Vr)=((Tt)(((auA).Vr),(auB),(auC)));
}
return auA;
}
// rebuildWhile
function Tl(ave /*ast*/,avf /*retType*/,avg /*parentFunc*/){
if(((ave).zr)!==(null)){
return (ave).zr;
}
((ave).zr)=(ave);
if(((ave).VQ)!==(null)){
((ave).VQ)=((zH)(((ave).VQ),(false)));
if((((ave).VQ)!==(null))&&(!((aje)((((ave).VQ).yL))))){
(D)((131098),(((ave).VQ).ql),(null));
}
}
((ave).VS)=((zz)(((ave).VS),(avf),(avg)));
return ave;
}
// rebuildFor
function Tn(avn /*ast*/,avo /*retType*/,avp /*parentFunc*/){
if(((avn).zr)!==(null)){
return (avn).zr;
}
((avn).zr)=(avn);
((avn).Ws)=((zH)(((avn).Ws),(false)));
if(((avn).Ws)!==(null)){
if(!((s9)((((avn).Ws).yL)))){
(D)((131099),(((avn).Ws).ql),(null));
}
(((avn).yc).sA)=(((avn).Ws).yL);
}
((avn).Wr)=((zH)(((avn).Wr),(false)));
if((((avn).Wr)!==(null))&&(!((s9)((((avn).Wr).yL))))){
(D)((131100),(((avn).Wr).ql),(null));
}
((avn).Wt)=((zH)(((avn).Wt),(false)));
if(((avn).Wt)!==(null)){
if(!((s9)((((avn).Wt).yL)))){
(D)((131101),(((avn).Wt).ql),(null));
}
if((((avn).Wt).qc)!==(67585)){
(D)((131102),(((avn).Wt).ql),(null));
}
if((((avn).Wt).yI)===(0x0000000000000000)){
(D)((131103),(((avn).Wt).ql),(null));
}
}
((avn).Wy)=((zz)(((avn).Wy),(avo),(avp)));
return avn;
}
// rebuildTry
function Tp(av6 /*ast*/,av7 /*retType*/,av8 /*parentFunc*/){
let avD; // items
let avF; // catch_
let avG; // items2
let avI; // exprs
if(((av6).zr)!==(null)){
return (av6).zr;
}
((av6).zr)=(av6);
(zv)(((av6).yc));
((av6).yh)=((Tt)(((av6).yh),(av7),(av8)));
if((((av6).yi).L)!==(0)){
(avD)=((av6).yi);
(qr)((avD),([130,134]));
while(!((qt)((avD),([130,134])))){
(avF)=((qv)((avD),([130,134])));
(avG)=((avF).y6);
(qr)((avG),([130,134]));
while(!((qt)((avG),([130,134])))){
(avI)=((qv)((avG),([130,134])));
((avI).yM)=((zH)(((avI).yM),(false)));
if((((avI).yM)!==(null))&&((!((s9)((((avI).yM).yL))))||((((avI).yM).qc)!==(67585)))){
(D)((131104),(((avI).yM).ql),(null));
}
if(((avI).yR)!==(null)){
((avI).yR)=((zH)(((avI).yR),(false)));
if((((avI).yR)!==(null))&&((!((s9)((((avI).yR).yL))))||((((avI).yR).qc)!==(67585)))){
(D)((131104),(((avI).yR).ql),(null));
}
}
(r8)((avG),([130,134]));
}
((avF).y9)=((Tt)(((avF).y9),(av7),(av8)));
(r8)((avD),([130,134]));
}
}
if(((av6).yl)!==(null)){
((av6).yl)=((Tt)(((av6).yl),(av7),(av8)));
}
return av6;
}
// rebuildThrow
function Tr(avR /*ast*/){
if(((avR).zr)!==(null)){
return (avR).zr;
}
((avR).zr)=(avR);
((avR).Xe)=((zH)(((avR).Xe),(false)));
if((((avR).Xe)!==(null))&&(!((s9)((((avR).Xe).yL))))){
(D)((131105),(((avR).Xe).ql),(null));
}
return avR;
}
// rebuildBlock
function Tt(avW /*ast*/,avX /*retType*/,avY /*parentFunc*/){
if(((avW).zr)!==(null)){
return (avW).zr;
}
((avW).zr)=(avW);
((avW).yg)=((zz)(((avW).yg),(avX),(avY)));
return avW;
}
// rebuildRet
function Tv(awb /*ast*/,awc /*retType*/){
if(((awb).zr)!==(null)){
return (awb).zr;
}
((awb).zr)=(awb);
if(((awb).Xn)===(null)){
if((awc)!==(null)){
(D)((131106),((awb).ql),(null));
}
}
else{
((awb).Xn)=((zH)(((awb).Xn),(false)));
if(((awb).Xn)!==(null)){
if(((awc)===(null))||(!((QT)((((awb).Xn).yL),(awc),(false))))){
(D)((131107),((awb).ql),(null));
}
else if(((((awb).Xn).yL).qc)===(1028)){
((awb).Xn)=((QW)(((awb).Xn),(awc)));
}
}
}
return awb;
}
// rebuildDo
function Tx(awp /*ast*/){
let awu; // expr
let awv; // kind
let awx;
let aw7; // block_
let aw9; // lhs
let awE; // lhs2
let awH; // lhs2
let awI; // exprAssign
let awK; // exprOne
if(((awp).zr)!==(null)){
return (awp).zr;
}
((awp).zr)=(awp);
if((((awp).y2)!==(null))&&((((awp).y2).qc)===(2050))){
(awu)=((awp).y2);
(awv)=(0);
awx=(awu).zM;
switch(awx){
case 1:
(awv)=(19);
break;
case 2:
(awv)=(20);
break;
case 3:
(awv)=(21);
break;
case 4:
(awv)=(22);
break;
case 5:
(awv)=(23);
break;
case 6:
(awv)=(24);
break;
case 7:
(awv)=(18);
break;
}
if((awv)!==(0)){
(aw7)=(new yf());
(xP)((aw7),(66052),((awp).ql));
((aw7).zr)=(aw7);
((aw7).qX)=({S:"$"});
((aw7).yc)=(null);
((aw7).yg)=({L:0,H:null,T:null,P:null});
(aw9)=((zH)(((awu).zP),(false)));
if((aw9)===(null)){
return null;
}
if(((aw9).qc)===(2059)){
(awE)=(aw9);
((awE).apW)=((awF)(((aw7).yg),((awE).apW),((awp).ql)));
}
else if(((aw9).qc)===(2058)){
(awH)=(aw9);
((awH).aqE)=((awF)(((aw7).yg),((awH).aqE),((awp).ql)));
((awH).aqJ)=((awF)(((aw7).yg),((awH).aqJ),((awp).ql)));
}
(awI)=(new zL());
(yx)((awI),(2050),((awp).ql));
((awI).zM)=(0);
((awI).zP)=(aw9);
(awK)=(new zL());
(yx)((awK),(2050),((awp).ql));
((awK).zM)=(awv);
((awK).zP)=(aw9);
((awK).zQ)=((awu).zQ);
((awI).zQ)=(awK);
((awp).y2)=((zH)((awI),(true)));
(eN)(((aw7).yg),([130,134]),(awp));
return aw7;
}
}
((awp).y2)=((zH)(((awp).y2),(true)));
if(((awp).y2)===(null)){
return null;
}
if(!((((((awp).y2).qc)===(2050))&&(((((awp).y2).zM)===(0))||((((awp).y2).zM)===(25))))||((((awp).y2).qc)===(2057)))){
(D)((131108),(((awp).y2).ql),(null));
}
return awp;
}
// rebuildBreak
function Tz(awP /*ast*/,awQ /*retType*/,awR /*parentFunc*/){
if(((awP).zr)!==(null)){
return (awP).zr;
}
((awP).zr)=(awP);
if((((awP).qz)===(null))||(((rt)((((awP).qz).qc),([9]),(66048)))!==(66048))){
(D)((131109),((awP).ql),([({S:"break"})]));
return null;
}
((awP).qz)=((zR)(((awP).qz),(awQ),(awR)));
return awP;
}
// rebuildSkip
function T1(awW /*ast*/,awX /*retType*/,awY /*parentFunc*/){
if(((awW).zr)!==(null)){
return (awW).zr;
}
((awW).zr)=(awW);
if((((awW).qz)===(null))||(((rt)((((awW).qz).qc),([9]),(66048)))!==(66048))){
(D)((131109),((awW).ql),([({S:"skip"})]));
return null;
}
((awW).qz)=((zR)(((awW).qz),(awX),(awY)));
return awW;
}
// rebuildAssert
function T3(axd /*ast*/){
if(((axd).zr)!==(null)){
return (axd).zr;
}
if(aY){
return null;
}
((axd).zr)=(axd);
((axd).X4)=((zH)(((axd).X4),(false)));
if((((axd).X4)!==(null))&&(!((aje)((((axd).X4).yL))))){
(D)((131110),(((axd).X4).ql),(null));
}
return axd;
}
// isClass
function T9(axk /*type*/){
return (((axk).qc)===(66565))&&((((axk).qz).qc)===(5));
}
// _fill
function TQ(axl /*me_*/,axm /*type*/,axn /*value*/){
if(axm[0]===129&&axm[1]===2)
axl.S=String.fromCharCode(axn).repeat(axl.S.length);
else
axl.fill(axn);
}
// _offset
function TY(axo /*me_*/,axp /*n*/){
return (axo)+(axp);
}
// buildExpr
function U3(axq /*ast*/){
let axs;
axs=(axq).qc;
switch(axs){
case 2049:
(axu)((axq));
break;
case 2050:
(axw)((axq));
break;
case 2051:
(axy)((axq));
break;
case 2052:
(ax0)((axq));
break;
case 2053:
(ax2)((axq));
break;
case 2054:
(ax4)((axq));
break;
case 2055:
(ax6)((axq));
break;
case 2056:
(ax8)((axq));
break;
case 2057:
(axA)((axq));
break;
case 2058:
(axC)((axq));
break;
case 2059:
(axE)((axq));
break;
case 67584:
(axG)((axq));
break;
case 67585:
(axI)((axq));
break;
case 67586:
(axK)((axq));
break;
case 67588:
(axM)((axq));
break;
case 2060:
(axO)((axq));
break;
case 2062:
(axQ)((axq));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// isChar
function US(axS /*type*/){
return (((axS).qc)===(1026))&&(((axS).ya)===(2));
}
// isEnum
function UT(axT /*type*/){
return (((axT).qc)===(66565))&&((((axT).qz).qc)===(6));
}
// addTmpVar
function Wq(axU /*type*/){
let axV; // tmpVar
(axV)=(new t7());
((axV).t9)=((Ag)());
((axV).t8)=(axU);
(eN)((R),([130,134]),(axV));
return (axV).t9;
}
// buildExpr
function Yy(axW /*ast*/){
let axY;
axY=(axW).qc;
switch(axY){
case 2049:
(aya)((axW));
break;
case 2050:
(ayc)((axW));
break;
case 2051:
(aye)((axW));
break;
case 2052:
(ayg)((axW));
break;
case 2053:
(ayi)((axW));
break;
case 2054:
(ayk)((axW));
break;
case 2055:
(aym)((axW));
break;
case 2056:
(ayo)((axW));
break;
case 2057:
(ayq)((axW));
break;
case 2058:
(ays)((axW));
break;
case 2059:
(ayu)((axW));
break;
case 67584:
(ayw)((axW));
break;
case 67585:
(ayy)((axW));
break;
case 67586:
(ay0)((axW));
break;
case 67588:
(ay2)((axW));
break;
case 2060:
(ay4)((axW));
break;
case 2062:
(ay6)((axW));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// isStr
function Zt(ay8 /*type*/){
let ayB; // itemType
if(((ay8).qc)===(66561)){
(ayB)=((ay8).Az);
if((((ayB).qc)===(1026))&&(((ayB).ya)===(2))){
return true;
}
}
return false;
}
// addTmpVar
function ZN(ayE /*type*/){
let ayF; // tmpVar
(ayF)=(new vA());
((ayF).vB)=((GH)());
((ayF).ayG)=(ayE);
(eN)((an),([130,134]),(ayF));
return (ayF).vB;
}
// isNullable
function aaH(ayH /*type*/){
return (((rt)(((ayH).qc),([9]),(66560)))===(66560))&&(!((UT)((ayH))));
}
// _peekStack
function abm(ayI /*me_*/,ayJ /*type*/){
return ayI[ayI.length-1];
}
// isReserved
function acj(ayK /*name*/){
let ayR;
let ayS;
if((ac)===(null)){
(ac)=([({S:"alias"}),({S:"assert"}),({S:"bit16"}),({S:"bit32"}),({S:"bit64"}),({S:"bit8"}),({S:"block"}),({S:"bool"}),({S:"break"}),({S:"case"}),({S:"catch"}),({S:"char"}),({S:"class"}),({S:"const"}),({S:"dbg"}),({S:"default"}),({S:"dict"}),({S:"do"}),({S:"elif"}),({S:"else"}),({S:"end"}),({S:"enum"}),({S:"env"}),({S:"false"}),({S:"finally"}),({S:"float"}),({S:"for"}),({S:"func"}),({S:"if"}),({S:"include"}),({S:"inf"}),({S:"int"}),({S:"list"}),({S:"me"}),({S:"null"}),({S:"queue"}),({S:"ret"}),({S:"skip"}),({S:"stack"}),({S:"super"}),({S:"switch"}),({S:"throw"}),({S:"to"}),({S:"true"}),({S:"try"}),({S:"var"}),({S:"while"})]);
ayQ:
for(ayR=(0),ayS=(((ac).length)-(2));ayR<=ayS;ayR+=(1)){
if(!(((ac)[ayR]).S<((ac)[(ayR)+(1)]).S)){throw 0xE9170000;}
}
}
return ((ayT)((ac),([129,129,2]),(ayK)))!==(-1);
}
// parseStatEnd
function aew(ayU /*row*/,ayV /*col*/,ayW /*block_*/){
let ayX; // ast
let ayY; // id
let ayZ; // err
let azb;
(ayX)=(new xU());
(wH)((ayX),(513),((wI)((ag),(ayU),(ayV))),(null),(false));
(ayY)=((xb)((true),(false)));
(ayZ)=(false);
(Oj)((0x000A),(true));
azb=ayY;
if(azb.S===({S:"func"}).S){
if(((ayW).qc)!==(256)){
(ayZ)=(true);
}
}
else if(azb.S===({S:"if"}).S){
if(((ayW).qc)!==(66049)){
(ayZ)=(true);
}
}
else if(azb.S===({S:"switch"}).S){
if(((ayW).qc)!==(66050)){
(ayZ)=(true);
}
}
else if(azb.S===({S:"while"}).S){
if(((ayW).qc)!==(16843265)){
(ayZ)=(true);
}
}
else if(azb.S===({S:"for"}).S){
if(((ayW).qc)!==(16843266)){
(ayZ)=(true);
}
}
else if(azb.S===({S:"try"}).S){
if(((ayW).qc)!==(66051)){
(ayZ)=(true);
}
}
else if(azb.S===({S:"block"}).S){
if(((ayW).qc)!==(66052)){
(ayZ)=(true);
}
}
else{(D)((65561),((wI)((ag),(ayU),(ayV))),([(ayY)]));
}
if(ayZ){
(D)((65562),((wI)((ag),(ayU),(ayV))),([(ayY)]));
}
return ayX;
}
// parseStatFunc
function aey(){
let az0; // ast
(az0)=(new az1());
(wH)((az0),(514),(null),(null),(false));
((az0).az2)=((xf)((null),(false)));
return az0;
}
// parseStatVar
function ae0(){
let az3; // ast
(az3)=(new SI());
(wH)((az3),(515),(null),(null),(false));
((az3).SK)=((xh)((3),(null)));
return az3;
}
// parseStatConst
function ae2(){
let az4; // ast
(az4)=(new az5());
(wH)((az4),(516),(null),(null),(false));
((az4).az6)=((xj)());
return az4;
}
// parseStatAlias
function ae4(){
let az7; // ast
(az7)=(new az8());
(wH)((az7),(517),(null),(null),(false));
((az7).az9)=((xm)());
return az7;
}
// parseStatClass
function ae6(){
let azA; // ast
(azA)=(new azB());
(wH)((azA),(518),(null),(null),(false));
((azA).azC)=((xq)());
return azA;
}
// parseStatEnum
function ae8(){
let azD; // ast
(azD)=(new azE());
(wH)((azD),(519),(null),(null),(false));
((azD).azF)=((xs)());
return azD;
}
// parseStatIf
function aeA(){
let azG; // ast
let azK; // stat
let azL; // typeId
let azR; // elIf
let azM;
let azO;
let azP;
let azS;
let azT;
let azU;
let azW;
let azX;
let azY;
(azG)=(new Fm());
(wH)((azG),(66049),((MK)()),(null),(false));
((azG).yc)=(null);
((azG).U6)=({L:0,H:null,T:null,P:null});
((azG).UD)=(null);
(azH)((azG));
(azI)((azG));
((azG).Uy)=((PZ)());
(Oj)((0x0029),(true));
(Oj)((0x000A),(true));
(azK)=(null);
(azL)=(0);
((azG).U0)=((azM=(azN)((azO={$:(azK)},azO),(azP={$:(azL)},azP),(66049),(azG)),(azK)=azO.$,(azL)=azP.$,azM));
while((azL)===(520)){
(azR)=(azK);
((azR).UB)=((azS=(azN)((azT={$:(azK)},azT),(azU={$:(azL)},azU),(520),(azG)),(azK)=azT.$,(azL)=azU.$,azS));
(eN)(((azG).U6),([130,134]),(azR));
}
while((azL)===(521)){
((azG).UD)=((azW=(azN)((azX={$:(azK)},azX),(azY={$:(azL)},azY),(521),(azG)),(azK)=azX.$,(azL)=azY.$,azW));
}
if(!((azL)===(513))){throw 0xE9170000;}
(x2)((ah),([131,134]));
return azG;
}
// parseStatElIf
function aeC(azZ /*row*/,a0a /*col*/,a0b /*block_*/){
let a0c; // ast
(a0c)=(new U9());
(wH)((a0c),(520),(null),(null),(false));
((a0c).UB)=(null);
if(((a0b).qc)!==(66049)){
(D)((65566),((wI)((ag),(azZ),(a0a))),([({S:"if"}),({S:"elif"})]));
(xv)(((xw)()));
return null;
}
(Oj)((0x0028),(true));
((a0c).UA)=((PZ)());
(Oj)((0x0029),(true));
(Oj)((0x000A),(true));
return a0c;
}
// parseStatElse
function aeE(a0f /*row*/,a0g /*col*/,a0h /*block_*/){
let a0i; // ast
(a0i)=(new xU());
(wH)((a0i),(521),(null),(null),(false));
if(((a0h).qc)!==(66049)){
(D)((65566),((wI)((ag),(a0f),(a0g))),([({S:"if"}),({S:"else"})]));
(xv)(((xw)()));
return null;
}
(Oj)((0x000A),(true));
return a0i;
}
// parseStatSwitch
function aeG(a0l /*row*/,a0m /*col*/){
let a0n; // ast
let a0q; // stat
let a0r; // typeId
let a02; // case_
let a03;
let a04;
let a05;
let a07;
let a08;
let a09;
(a0n)=(new Fp());
(wH)((a0n),(66050),((MK)()),(null),(false));
((a0n).yc)=((a0o)(((a0n).ql)));
((a0n).UW)=({L:0,H:null,T:null,P:null});
((a0n).Vr)=(null);
(azH)((a0n));
(azI)((a0n));
((a0n).UR)=((PZ)());
(Oj)((0x0029),(true));
(Oj)((0x000A),(true));
(a0q)=(null);
(a0r)=(0);
a0t:
while(true){
(a0q)=((OE)((a0n)));
if((a0q)===(null)){
if(pJ){
return null;
}
else{
continue a0t;
}
}
break a0t;
}
(a0r)=((a0q).qc);
if(!((((a0r)===(522))||((a0r)===(523)))||((a0r)===(513)))){
(D)((65567),((MK)()),(null));
}
while((a0r)===(522)){
(a02)=(a0q);
((a02).Vp)=((a03=(azN)((a04={$:(a0q)},a04),(a05={$:(a0r)},a05),(522),(a0n)),(a0q)=a04.$,(a0r)=a05.$,a03));
(eN)(((a0n).UW),([130,134]),(a02));
}
while((a0r)===(523)){
((a0n).Vr)=((a07=(azN)((a08={$:(a0q)},a08),(a09={$:(a0r)},a09),(523),(a0n)),(a0q)=a08.$,(a0r)=a09.$,a07));
}
if(!((a0r)===(513))){throw 0xE9170000;}
(x2)((ah),([131,134]));
return a0n;
}
// parseStatCase
function aeI(a0A /*row*/,a0B /*col*/,a0C /*block_*/){
let a0D; // ast
let a0I; // exprs
let a0J; // c
let a0Q; // id
(a0D)=(new UZ());
(wH)((a0D),(522),(null),(null),(false));
((a0D).Vb)=({L:0,H:null,T:null,P:null});
((a0D).Vp)=(null);
if(((a0C).qc)!==(66050)){
(D)((65566),((wI)((ag),(a0A),(a0B))),([({S:"switch"}),({S:"case"})]));
(xv)(((xw)()));
return null;
}
a0H:
while(true){
(a0I)=(new yC());
((a0I).yM)=((PZ)());
((a0I).yR)=(null);
(a0J)=((wK)());
if((a0J)===(0x0000)){
break a0H;
}
if((a0J)===(0x000A)){
(eN)(((a0D).Vb),([130,134]),(a0I));
break a0H;
}
if((a0J)===(0x002C)){
(eN)(((a0D).Vb),([130,134]),(a0I));
continue a0H;
}
(pH)=(a0J);
(a0Q)=((xb)((true),(false)));
if((a0Q).S!==({S:"to"}).S){
(D)((65568),((MK)()),([({S:"to"}),(a0Q)]));
(xv)(((xw)()));
return null;
}
((a0I).yR)=((PZ)());
(a0J)=((wK)());
if((a0J)===(0x0000)){
break a0H;
}
(eN)(((a0D).Vb),([130,134]),(a0I));
if((a0J)===(0x000A)){
break a0H;
}
if((a0J)!==(0x002C)){
(Oe)((0x002C),(a0J));
}
}
return a0D;
}
// parseStatDefault
function aeK(a0Z /*row*/,a1a /*col*/,a1b /*block_*/){
let a1c; // ast
(a1c)=(new xU());
(wH)((a1c),(523),(null),(null),(false));
if(((a1b).qc)!==(66050)){
(D)((65566),((wI)((ag),(a0Z),(a1a))),([({S:"switch"}),({S:"default"})]));
(xv)(((xw)()));
return null;
}
(Oj)((0x000A),(true));
return a1c;
}
// parseStatWhile
function aeM(){
let a1f; // ast
let a1h; // c
let a1k; // id
let a1q; // stat
(a1f)=(new Fs());
(wH)((a1f),(16843265),((MK)()),(null),(false));
((a1f).yc)=(null);
((a1f).VY)=(false);
((a1f).VS)=({L:0,H:null,T:null,P:null});
(azH)((a1f));
(azI)((a1f));
((a1f).VQ)=((PZ)());
(a1h)=((wK)());
if((a1h)===(0x002C)){
(a1k)=((xb)((true),(false)));
if((a1k).S!==({S:"skip"}).S){
(D)((65568),((MK)()),([({S:"skip"}),(a1k)]));
}
((a1f).VY)=(true);
}
else{
(pH)=(a1h);
}
(Oj)((0x0029),(true));
(Oj)((0x000A),(true));
a1p:
while(true){
(a1q)=((OE)((a1f)));
if((a1q)===(null)){
if(pJ){
return null;
}
else{
continue a1p;
}
}
if(((a1q).qc)===(513)){
break a1p;
}
(eN)(((a1f).VS),([130,134]),(a1q));
}
(x2)((ah),([131,134]));
return a1f;
}
// parseStatFor
function aeO(a1y /*row*/,a1z /*col*/){
let a10; // ast
let a12; // c
let a19; // stat
(a10)=(new Fw());
(wH)((a10),(16843266),((MK)()),(null),(false));
((a10).yc)=((a0o)(((a10).ql)));
((a10).Wy)=({L:0,H:null,T:null,P:null});
(azH)((a10));
(azI)((a10));
((a10).Ws)=((PZ)());
(Oj)((0x002C),(true));
((a10).Wr)=((PZ)());
(a12)=((wK)());
if((a12)===(0x002C)){
((a10).Wt)=((PZ)());
(Oj)((0x0029),(true));
(Oj)((0x000A),(true));
}
else{
((a10).Wt)=((a16)(((MK)()),(0),(0x0000000000000001)));
(pH)=(a12);
(Oj)((0x0029),(true));
(Oj)((0x000A),(true));
}
a18:
while(true){
(a19)=((OE)((a10)));
if((a19)===(null)){
if(pJ){
return null;
}
else{
continue a18;
}
}
if(((a19).qc)===(513)){
break a18;
}
(eN)(((a10).Wy),([130,134]),(a19));
}
(x2)((ah),([131,134]));
return a10;
}
// parseStatTry
function aeQ(a1H /*row*/,a1I /*col*/){
let a1J; // ast
let a1L; // c
let a1Q; // type
let a1S; // stat
let a1T; // typeId
let a1Y; // catch_
let a1U;
let a1V;
let a1W;
let a1Z;
let a2a;
let a2b;
let a2e;
let a2f;
let a2g;
(a1J)=(new xS());
(wH)((a1J),(66051),((MK)()),(null),(false));
((a1J).yc)=((a0o)(((a1J).ql)));
((a1J).yi)=({L:0,H:null,T:null,P:null});
((a1J).yl)=(null);
(azH)((a1J));
(a1L)=((wK)());
if((a1L)!==(0x000A)){
(pH)=(a1L);
((a1J).qX)=((xb)((true),(false)));
(On)((a1J),(true));
(Oj)((0x000A),(true));
}
else{
((a1J).qX)=({S:"$"});
}
(a1Q)=(new xZ());
(wH)((a1Q),(1026),((wI)((ag),(a1H),(a1I))),(null),(false));
((a1Q).ya)=(0);
(((a1J).yc).sA)=(a1Q);
(a1S)=(null);
(a1T)=(0);
((a1J).yh)=((a1U=(azN)((a1V={$:(a1S)},a1V),(a1W={$:(a1T)},a1W),(66051),(a1J)),(a1S)=a1V.$,(a1T)=a1W.$,a1U));
while((a1T)===(524)){
(a1Y)=(a1S);
((a1Y).y9)=((a1Z=(azN)((a2a={$:(a1S)},a2a),(a2b={$:(a1T)},a2b),(524),(a1J)),(a1S)=a2a.$,(a1T)=a2b.$,a1Z));
(eN)(((a1J).yi),([130,134]),(a1Y));
}
if((a1T)===(525)){
((a1J).yl)=((a2e=(azN)((a2f={$:(a1S)},a2f),(a2g={$:(a1T)},a2g),(525),(a1J)),(a1S)=a2f.$,(a1T)=a2g.$,a2e));
}
if(!((a1T)===(513))){throw 0xE9170000;}
(x2)((ah),([131,134]));
return a1J;
}
// parseStatCatch
function aeS(a2h /*row*/,a2i /*col*/,a2j /*block_*/){
let a2k; // ast
let a2o; // c
let a2r; // exprs
let a2s; // pos
let a2w; // exprs
let a23; // id
(a2k)=(new y5());
(wH)((a2k),(524),(null),(null),(false));
((a2k).y6)=({L:0,H:null,T:null,P:null});
((a2k).y9)=(null);
if(((a2j).qc)!==(66051)){
(D)((65566),((wI)((ag),(a2h),(a2i))),([({S:"try"}),({S:"catch"})]));
(xv)(((xw)()));
return null;
}
(a2o)=((wK)());
if((a2o)===(0x000A)){
(a2r)=(new yC());
(a2s)=((MK)());
((a2r).yM)=((a16)((a2s),(0),(0x0000000000000000)));
((a2r).yR)=((a16)((a2s),(0),(0x00000000FFFFFFFF)));
(eN)(((a2k).y6),([130,134]),(a2r));
}
else{
(pH)=(a2o);
a2v:
while(true){
(a2w)=(new yC());
((a2w).yM)=((PZ)());
((a2w).yR)=(null);
(a2o)=((wK)());
if((a2o)===(0x0000)){
break a2v;
}
if((a2o)===(0x000A)){
(eN)(((a2k).y6),([130,134]),(a2w));
break a2v;
}
if((a2o)===(0x002C)){
(eN)(((a2k).y6),([130,134]),(a2w));
continue a2v;
}
(pH)=(a2o);
(a23)=((xb)((true),(false)));
if((a23).S!==({S:"to"}).S){
(D)((65568),((MK)()),([({S:"to"}),(a23)]));
}
((a2w).yR)=((PZ)());
(a2o)=((wK)());
if((a2o)===(0x0000)){
break a2v;
}
(eN)(((a2k).y6),([130,134]),(a2w));
if((a2o)===(0x000A)){
break a2v;
}
if((a2o)!==(0x002C)){
(Oe)((0x002C),(a2o));
}
}
}
return a2k;
}
// parseStatFinally
function aeU(a2C /*row*/,a2D /*col*/,a2E /*block_*/){
let a2F; // ast
(a2F)=(new xU());
(wH)((a2F),(525),(null),(null),(false));
if(((a2E).qc)!==(66051)){
(D)((65566),((wI)((ag),(a2C),(a2D))),([({S:"try"}),({S:"finally"})]));
(xv)(((xw)()));
return null;
}
(Oj)((0x000A),(true));
return a2F;
}
// parseStatThrow
function aeW(){
let a2I; // ast
(a2I)=(new F1());
(wH)((a2I),(526),((MK)()),(null),(false));
((a2I).Xe)=((PZ)());
(Oj)((0x000A),(true));
return a2I;
}
// parseStatBlock
function aeY(){
let a2J; // ast
let a2L; // c
let a2R; // stat
(a2J)=(new yf());
(wH)((a2J),(66052),((MK)()),(null),(false));
((a2J).yc)=(null);
((a2J).yg)=({L:0,H:null,T:null,P:null});
(azH)((a2J));
(a2L)=((wK)());
if((a2L)!==(0x000A)){
(pH)=(a2L);
((a2J).qX)=((xb)((true),(false)));
(On)((a2J),(true));
(Oj)((0x000A),(true));
}
else{
((a2J).qX)=({S:"$"});
}
a2Q:
while(true){
(a2R)=((OE)((a2J)));
if((a2R)===(null)){
if(pJ){
return null;
}
else{
continue a2Q;
}
}
if(((a2R).qc)===(513)){
break a2Q;
}
(eN)(((a2J).yg),([130,134]),(a2R));
}
(x2)((ah),([131,134]));
return a2J;
}
// parseStatRet
function afa(){
let a2Z; // ast
let a3b; // c
(a2Z)=(new F6());
(wH)((a2Z),(527),((MK)()),(null),(false));
(a3b)=((wK)());
if((a3b)!==(0x000A)){
(pH)=(a3b);
((a2Z).Xn)=((PZ)());
(Oj)((0x000A),(true));
}
else{
((a2Z).Xn)=(null);
}
return a2Z;
}
// parseStatDo
function afc(){
let a3f; // ast
(a3f)=(new ys());
(wH)((a3f),(528),((MK)()),(null),(false));
((a3f).y2)=((PZ)());
(Oj)((0x000A),(true));
return a3f;
}
// parseStatBreak
function afe(){
let a3g; // ast
(a3g)=(new xU());
(wH)((a3g),(529),((MK)()),(null),(false));
(Oi)((a3g),((xb)((true),(false))));
(Oj)((0x000A),(true));
return a3g;
}
// parseStatSkip
function afg(){
let a3h; // ast
(a3h)=(new xU());
(wH)((a3h),(530),((MK)()),(null),(false));
(Oi)((a3h),((xb)((true),(false))));
(Oj)((0x000A),(true));
return a3h;
}
// parseStatAssert
function afi(){
let a3i; // ast
(a3i)=(new FF());
(wH)((a3i),(531),((MK)()),(null),(false));
((a3i).X4)=((PZ)());
(Oj)((0x000A),(true));
return a3i;
}
// parseExprThree
function afn(){
let a3j; // ast
let a3n; // row
let a3o; // col
let a3p; // c
let a3s; // ast2
(a3j)=((a3k)());
a3m:
while(true){
(a3n)=(pF);
(a3o)=(pG);
(a3p)=((wK)());
if((a3p)===(0x003F)){
(Oj)((0x0028),(false));
(a3s)=(new RP());
(Qe)((a3s),(2051),((wI)((ag),(a3n),(a3o))));
((a3s).and)=(a3j);
((a3s).ang)=((PZ)());
(Oj)((0x002C),(true));
((a3s).anj)=((PZ)());
(a3j)=(a3s);
(Oj)((0x0029),(true));
}
else{
(pH)=(a3p);
break a3m;
}
}
return a3j;
}
// readInStr
function afM(){
let a3w; // c
let a3y;
a3v:
while(true){
(a3w)=((M9)());
a3y=a3w;
switch(a3y){
case 0x0009:
(D)((65540),((MK)()),(null));
continue a3v;
break;
case 0x000A:
(D)((65541),((MK)()),(null));
break;
}
return a3w;
}
}
// searchEnumElementValue
function ahP(a31 /*ast*/,a32 /*enum_*/){
let a33; // name
let a34; // items
let a36; // item
if(!((((a31).yL).qc)===(1028))){throw 0xE9170000;}
(Rn)((a32));
(a33)=((a31).akb);
(a34)=((a32).PI);
(qr)((a34),([130,134]));
while(!((qt)((a34),([130,134])))){
(a36)=((qv)((a34),([130,134])));
if((a33).S===((a36).qX).S){
if(((a36).qc)!==(67585)){
return 0x0000000000000000;
}
return (a36).yI;
}
(r8)((a34),([130,134]));
}
(D)((131090),((a31).ql),([(a33)]));
return 0x0000000000000000;
}
// process1
function ahX(a3B /*ast*/,a3C /*dtor*/,a3D /*copy*/,a3E /*toBin*/,a3F /*fromBin*/){
let a3I; // parent
let a3N; // parent
let a3O; // chk
let a3T;
let a3W; // astItems
let a3Y; // item
let a3Z; // memberName
let a4b; // def
let a4g; // parentItem
let a4i; // parent
let a4k; // items
let a4m; // parentName
let a4n; // item2
let a4o; // def
let a46; // func1
let a47; // func2
let a4A; // items1
let a4B; // items2
let a4E;
let a4G; // arg1
let a4H; // arg2
let a4L;
let a4N; // func_
let a4R;
let a4Y; // def
let a5b; // idx
let a5i; // type
let a5l; // type
let a5n; // type2
let a5r; // arg
let a5t; // type
let a5v; // type2
let a5x; // arg
let a5z; // type
let a3R;
let a3S;
let a4F;
if(((a3B).qz)!==(null)){
(a3I)=((a3B).qz);
if(((a3I).qc)===(4)){
(Rp)((a3I),(null));
((a3B).qz)=(((a3I).OR).qz);
if(!((((a3B).qz).qc)===(5))){throw 0xE9170000;}
}
else{
if(!(((a3I).qc)===(5))){throw 0xE9170000;}
(Rl)((a3I));
}
}
(a3N)=(a3B);
(a3O)=(new Map());
while((a3N)!==(null)){
if((a3R=(pR)((a3O),([133,134,3]),(a3N),(a3S={$:(a3T)},a3S)),(a3T)=a3S.$,a3R)){
(D)((131080),((a3B).ql),([((a3B).qX)]));
return;
}
(bE)((a3O),([133,134,3]),(a3N),(true));
(a3N)=((a3N).qz);
}
(a3W)=((a3B).tm);
(qr)((a3W),([130,134]));
while(!((qt)((a3W),([130,134])))){
(a3Y)=((qv)((a3W),([130,134])));
(a3Z)=(null);
(a4b)=((a3Y).tX);
if(((a4b).qc)===(2)){
(a3Z)=(((a4b).uc).qX);
}
else if(((a4b).qc)===(3)){
(a3Z)=(((a4b).x0).qX);
}
else{
(a3Z)=((a4b).qX);
}
(a4g)=(null);
(a4i)=((a3B).qz);
while(((a4g)===(null))&&((a4i)!==(null))){
(a4k)=((a4i).tm);
(qr)((a4k),([130,134]));
while(!((qt)((a4k),([130,134])))){
(a4m)=(null);
(a4n)=((qv)((a4k),([130,134])));
(a4o)=((a4n).tX);
if(((a4o).qc)===(2)){
(a4m)=(((a4o).uc).qX);
}
else if(((a4o).qc)===(3)){
(a4m)=(((a4o).x0).qX);
}
else{
(a4m)=((a4o).qX);
}
if((a3Z).S===(a4m).S){
(a4g)=(a4n);
}
(r8)((a4k),([130,134]));
}
(a4i)=((a4i).qz);
}
if((a4g)===(null)){
if((a3Y).Pm){
(D)((131081),(((a3Y).tX).ql),([(a3Z)]));
return;
}
}
else{
if(!((a3Y).Pm)){
(D)((131082),(((a3Y).tX).ql),([(a3Z)]));
return;
}
if(!(((((a3Y).tX).qc)===(256))&&((((a4g).tX).qc)===(256)))){
(D)((131083),(((a3Y).tX).ql),([(a3Z)]));
return;
}
if(((a3Y).Pl)!==((a4g).Pl)){
(D)((131084),(((a3Y).tX).ql),([(a3Z)]));
return;
}
(a46)=((a3Y).tX);
(a47)=((a4g).tX);
if(((((((a46).qh)===(null))&&(((a47).qh)!==(null)))||((((a46).qh)!==(null))&&(((a47).qh)===(null))))||(((((a46).qh)!==(null))&&(((a47).qh)!==(null)))&&(!((QT)(((a46).qh),((a47).qh),(false))))))||((((a46).qg).L)!==(((a47).qg).L))){
(D)((131085),(((a3Y).tX).ql),([(a3Z)]));
return;
}
(a4A)=((a46).qg);
(a4B)=((a47).qg);
(qr)((a4A),([130,134]));
(qr)((a4B),([130,134]));
a4D:
for(a4E=(0),a4F=(((a4A).L)-(1));a4E<=a4F;a4E+=(1)){
(a4G)=((qv)((a4A),([130,134])));
(a4H)=((qv)((a4B),([130,134])));
if(((((((((a4G).sA).qc)===(66565))&&((((a4G).sA).qz)===(null)))||(((((a4H).sA).qc)===(66565))&&((((a4H).sA).qz)===(null))))||(!((QT)(((a4G).sA),((a4H).sA),(false)))))||(((((a4G).qX)!==(null))&&(((a4H).qX)!==(null)))&&(((a4G).qX).S!==((a4H).qX).S)))||(((a4G).sP)!==((a4H).sP))){
(D)((131085),(((a3Y).tX).ql),([(a3Z)]));
return;
}
(r8)((a4A),([130,134]));
(r8)((a4B),([130,134]));
}
((a3Y).Pn)=(a4g);
}
a4L=a3Z;
if(a4L.S===({S:"_dtor"}).S||a4L.S===({S:"_copy"}).S||a4L.S===({S:"_toBin"}).S||a4L.S===({S:"_fromBin"}).S){
if(!((((a3Y).tX).qc)===(256))){throw 0xE9170000;}
(a4N)=((a3Y).tX);
if(((a3Y).Pm)&&(((rt)((((a3Y).tX).qi),([9]),(128)))===(0))){
(D)((131086),((a4N).ql),([(a3Z)]));
return;
}
a4R=(a3Z).S.charCodeAt(1);
switch(a4R){
case 0x0064:
(a3C.$)=(a4N);
break;
case 0x0063:
(a3D.$)=(a4N);
break;
case 0x0074:
(a3E.$)=(a4N);
break;
case 0x0066:
(a3F.$)=(a4N);
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{(a4Y)=((a3Y).tX);
if(((a4Y).qc)===(256)){
(a5b)=((tt)((a3W),([130,134])));
if(!((a5b)!==(-1))){throw 0xE9170000;}
(rD)((a4Y));
(qr)((a3W),([130,134]));
(tw)((a3W),([130,134]),(a5b));
}
else if(((a4Y).qc)===(2)){
(SJ)((a4Y));
}
}
(r8)((a3W),([130,134]));
}
if((a3C.$)===(null)){
(a3C.$)=((a5f)((a3B),({S:"_dtor"})));
}
if((a3D.$)===(null)){
(a3D.$)=((a5f)((a3B),({S:"_copy"})));
(a5i)=(new Oq());
(xP)((a5i),(66565),((a3B).ql));
((a5i).qz)=(a3B);
((a3D.$).qh)=(a5i);
}
if((a3E.$)===(null)){
(a3E.$)=((a5f)((a3B),({S:"_toBin"})));
(a5l)=(new Ax());
(xP)((a5l),(66561),((a3B).ql));
(a5n)=(new A1());
(xP)((a5n),(1025),((a3B).ql));
((a5n).A2)=(1);
((a5l).Az)=(a5n);
((a3E.$).qh)=(a5l);
}
if((a3F.$)===(null)){
(a3F.$)=((a5f)((a3B),({S:"_fromBin"})));
(a5r)=(new ro());
(xP)((a5r),(7),((a3B).ql));
((a5r).rp)=(2);
((a5r).sP)=(false);
((a5r).yb)=(null);
(a5t)=(new Ax());
(xP)((a5t),(66561),((a3B).ql));
(a5v)=(new A1());
(xP)((a5v),(1025),((a3B).ql));
((a5v).A2)=(1);
((a5t).Az)=(a5v);
((a5r).sA)=(a5t);
(eN)(((a3F.$).qg),([130,134]),(a5r));
(a5x)=(new ro());
(xP)((a5x),(7),((a3B).ql));
((a5x).rp)=(2);
((a5x).sP)=(true);
((a5x).yb)=(null);
(a5z)=(new xZ());
(xP)((a5z),(1026),((a3B).ql));
((a5z).ya)=(0);
((a5x).sA)=(a5z);
(eN)(((a3F.$).qg),([130,134]),(a5x));
(qr)(((a3F.$).qg),([130,134]));
((a3F.$).qh)=(((qv)(((a3F.$).qg),([130,134]))).sA);
}
}
// process2
function aic(a50 /*ast*/,a51 /*dtor*/,a52 /*copy*/,a53 /*toBin*/,a54 /*fromBin*/){
let a56; // ptr
let a58; // items
let a5A; // item
let a5D; // do_
let a5F; // assign
let a5I; // result
let a5K; // var_
let a5M; // var2
let a5O; // arg
let a5Q; // type
let a5S; // new_
let a5V; // type
let a5X; // ptr
let a5Z; // items
let a6b; // item
let a6e; // member
let a6g; // do_
let a6i; // assign
let a6k; // dot
let a6n; // copy2
let a6q; // ret_
let a6s; // as
let a6u; // result
let a6w; // var_
let a6y; // var2
let a60; // arg
let a62; // new_
let a64; // value
let a66; // prim
let a68; // type
let a6A; // type
let a6C; // type2
let a6F; // type
let a6H; // ptr
let a6J; // items
let a6L; // item
let a6O; // member
let a6Q; // do_
let a6S; // assign
let a6U; // expr
let a6W; // array_
let a6Y; // bit
let a7a; // ret_
let a7c; // result
let a7e; // var_
let a7g; // var2
let a7i; // arg
let a7k; // new_
let a7n; // type
let a7p; // ptr
let a7r; // items
let a7t; // item
let a7w; // member
let a7y; // do_
let a70; // assign
let a72; // dot
let a74; // expr
let a76; // ref
let a78; // ref
let a7A; // ret_
(a56)=(a50);
while((a56)!==(null)){
(a58)=((a56).tm);
(qr)((a58),([130,134]));
while(!((qt)((a58),([130,134])))){
(a5A)=((qv)((a58),([130,134])));
if(((((a5A).tX).qc)===(2))&&((zT)(((((a5A).tX).uc).sA)))){
(a5D)=(new ys());
(xP)((a5D),(528),((a50).ql));
(a5F)=(new zL());
(yx)((a5F),(2050),((a50).ql));
((a5F).zM)=(0);
(qr)(((a51).qg),([130,134]));
((a5F).zP)=((a5G)((a50),((qv)(((a51).qg),([130,134]))),((((a5A).tX).uc).qX)));
((a5F).zQ)=((Aa)(((a50).ql)));
((a5D).y2)=(a5F);
(eN)(((a51).tv),([130,134]),((zR)((a5D),((a51).qh),(a51))));
}
(r8)((a58),([130,134]));
}
(a56)=((a56).qz);
}
(a5I)=(null);
(a5K)=(new SI());
(xP)((a5K),(515),((a50).ql));
(a5M)=(new ua());
(xP)((a5M),(2),((a50).ql));
(a5O)=(new ro());
(xP)((a5O),(7),((a50).ql));
((a5O).rp)=(3);
((a5O).sP)=(false);
(a5Q)=(new Oq());
(xP)((a5Q),(66565),((a50).ql));
((a5Q).qz)=(a50);
((a5O).sA)=(a5Q);
(a5S)=(new RS());
(yx)((a5S),(2052),((a50).ql));
((a5S).an3)=((a5O).sA);
((a5O).yb)=(a5S);
((a5M).uc)=(a5O);
((a5K).SK)=(a5M);
(eN)(((a52).tv),([130,134]),((zR)((a5K),((a52).qh),(a52))));
(a5I)=(new yw());
(yx)((a5I),(2062),((a50).ql));
((a5I).q0)=({S:"me"});
((a5I).qz)=(((a5K).SK).uc);
(a5V)=(new Oq());
(xP)((a5V),(66565),((a50).ql));
((a5V).qz)=(a50);
((a5I).yL)=(a5V);
(a5X)=(a50);
while((a5X)!==(null)){
(a5Z)=((a5X).tm);
(qr)((a5Z),([130,134]));
while(!((qt)((a5Z),([130,134])))){
(a6b)=((qv)((a5Z),([130,134])));
if((((a6b).tX).qc)===(2)){
(a6e)=(((a6b).tX).uc);
(a6g)=(new ys());
(xP)((a6g),(528),((a50).ql));
(a6i)=(new zL());
(yx)((a6i),(2050),((a50).ql));
((a6i).zM)=(0);
(a6k)=(new Sm());
(yx)((a6k),(2059),((a50).ql));
((a6k).apW)=(a5I);
((a6k).arc)=((a6e).qX);
((a6k).arp)=(null);
((a6i).zP)=(a6k);
if((zT)(((a6e).sA))){
(a6n)=(new RK());
(yx)((a6n),(2049),((a50).ql));
((a6n).aiL)=(3);
(qr)(((a52).qg),([130,134]));
((a6n).aiF)=((a5G)((a50),((qv)(((a52).qg),([130,134]))),((a6e).qX)));
((a6i).zQ)=(a6n);
}
else{
(qr)(((a52).qg),([130,134]));
((a6i).zQ)=((a5G)((a50),((qv)(((a52).qg),([130,134]))),((a6e).qX)));
}
((a6g).y2)=(a6i);
(eN)(((a52).tv),([130,134]),((zR)((a6g),((a52).qh),(a52))));
}
(r8)((a5Z),([130,134]));
}
(a5X)=((a5X).qz);
}
(a6q)=(new F6());
(xP)((a6q),(527),((a50).ql));
(a6s)=(new RY());
(yx)((a6s),(2054),((a50).ql));
((a6s).aoi)=(0);
((a6s).aoa)=(a5I);
((a6s).aod)=((a52).qh);
((a6q).Xn)=(a6s);
(eN)(((a52).tv),([130,134]),((zR)((a6q),((a52).qh),(a52))));
(a6u)=(null);
(a6w)=(new SI());
(xP)((a6w),(515),((a50).ql));
(a6y)=(new ua());
(xP)((a6y),(2),((a50).ql));
(a60)=(new ro());
(xP)((a60),(7),((a50).ql));
((a60).rp)=(3);
((a60).sP)=(false);
(a62)=(new RV());
(yx)((a62),(2053),((a50).ql));
((a62).anF)=({L:0,H:null,T:null,P:null});
(a64)=(new yF());
(yx)((a64),(67585),((a50).ql));
((a64).yI)=(0x0000000000000008);
(a66)=(new xZ());
(xP)((a66),(1026),((a50).ql));
((a66).ya)=(0);
((a64).yL)=(a66);
(eN)(((a62).anF),([130,134]),(a64));
(a68)=(new A1());
(xP)((a68),(1025),((a50).ql));
((a68).A2)=(1);
((a62).anN)=(a68);
((a60).yb)=(a62);
(a6A)=(new Ax());
(xP)((a6A),(66561),((a50).ql));
(a6C)=(new A1());
(xP)((a6C),(1025),((a50).ql));
((a6C).A2)=(1);
((a6A).Az)=(a6C);
((a60).sA)=(a6A);
((a6y).uc)=(a60);
((a6w).SK)=(a6y);
(eN)(((a53).tv),([130,134]),((zR)((a6w),((a53).qh),(a53))));
(a6u)=(new yw());
(yx)((a6u),(2062),((a50).ql));
((a6u).qz)=(((a6w).SK).uc);
(a6F)=(new Oq());
(xP)((a6F),(66565),((a50).ql));
((a6F).qz)=(a50);
((a6u).yL)=(a6F);
(a6H)=(a50);
while((a6H)!==(null)){
(a6J)=((a6H).tm);
(qr)((a6J),([130,134]));
while(!((qt)((a6J),([130,134])))){
(a6L)=((qv)((a6J),([130,134])));
if((((a6L).tX).qc)===(2)){
(a6O)=(((a6L).tX).uc);
(a6Q)=(new ys());
(xP)((a6Q),(528),((a50).ql));
(a6S)=(new zL());
(yx)((a6S),(2050),((a50).ql));
((a6S).zM)=(7);
((a6S).zP)=(a6u);
(a6U)=(new Sb());
(yx)((a6U),(2055),((a50).ql));
(qr)(((a53).qg),([130,134]));
((a6U).apw)=((a5G)((a50),((qv)(((a53).qg),([130,134]))),((a6O).qX)));
(a6W)=(new Ax());
(xP)((a6W),(66561),((a50).ql));
(a6Y)=(new A1());
(xP)((a6Y),(1025),((a50).ql));
((a6Y).A2)=(1);
((a6W).Az)=(a6Y);
((a6U).ap2)=(a6W);
((a6S).zQ)=(a6U);
((a6Q).y2)=(a6S);
(eN)(((a53).tv),([130,134]),((zR)((a6Q),((a53).qh),(a53))));
}
(r8)((a6J),([130,134]));
}
(a6H)=((a6H).qz);
}
(a7a)=(new F6());
(xP)((a7a),(527),((a50).ql));
((a7a).Xn)=(a6u);
(eN)(((a53).tv),([130,134]),((zR)((a7a),((a53).qh),(a53))));
(a7c)=(null);
(a7e)=(new SI());
(xP)((a7e),(515),((a50).ql));
(a7g)=(new ua());
(xP)((a7g),(2),((a50).ql));
(a7i)=(new ro());
(xP)((a7i),(7),((a50).ql));
((a7i).rp)=(3);
((a7i).sP)=(false);
(qr)(((a54).qg),([130,134]));
((a7i).sA)=(((qv)(((a54).qg),([130,134]))).sA);
(a7k)=(new RS());
(yx)((a7k),(2052),((a50).ql));
((a7k).an3)=((a7i).sA);
((a7i).yb)=(a7k);
((a7g).uc)=(a7i);
((a7e).SK)=(a7g);
(eN)(((a54).tv),([130,134]),((zR)((a7e),((a54).qh),(a54))));
(a7c)=(new yw());
(yx)((a7c),(2062),((a50).ql));
((a7c).qz)=(((a7e).SK).uc);
((a7c).q0)=({S:"me"});
(a7n)=(new Oq());
(xP)((a7n),(66565),((a50).ql));
((a7n).qz)=(a50);
((a7c).yL)=(a7n);
(a7p)=(a50);
while((a7p)!==(null)){
(a7r)=((a7p).tm);
(qr)((a7r),([130,134]));
while(!((qt)((a7r),([130,134])))){
(a7t)=((qv)((a7r),([130,134])));
if((((a7t).tX).qc)===(2)){
(a7w)=(((a7t).tX).uc);
(a7y)=(new ys());
(xP)((a7y),(528),((a50).ql));
(a70)=(new zL());
(yx)((a70),(2050),((a50).ql));
((a70).zM)=(0);
(a72)=(new Sm());
(yx)((a72),(2059),((a50).ql));
((a72).arp)=(null);
((a72).apW)=(a7c);
((a72).arc)=((a7w).qX);
((a70).zP)=(a72);
(a74)=(new Se());
(yx)((a74),(2056),((a50).ql));
(a76)=(new yw());
(yx)((a76),(2062),((a50).ql));
(qr)(((a54).qg),([130,134]));
(r8)(((a54).qg),([130,134]));
((a76).qz)=((qv)(((a54).qg),([130,134])));
if(!(((a76).qz)!==(null))){throw 0xE9170000;}
((a74).ap7)=(a76);
((a74).apC)=((a7w).sA);
(a78)=(new yw());
(yx)((a78),(2062),((a50).ql));
(qr)(((a54).qg),([130,134]));
(r8)(((a54).qg),([130,134]));
(r8)(((a54).qg),([130,134]));
((a78).qz)=((qv)(((a54).qg),([130,134])));
if(!(((a78).qz)!==(null))){throw 0xE9170000;}
((a74).apD)=(a78);
((a70).zQ)=(a74);
((a7y).y2)=(a70);
(eN)(((a54).tv),([130,134]),((zR)((a7y),((a54).qh),(a54))));
}
(r8)((a7r),([130,134]));
}
(a7p)=((a7p).qz);
}
(a7A)=(new F6());
(xP)((a7A),(527),((a50).ql));
((a7A).Xn)=(a7c);
(eN)(((a54).tv),([130,134]),((zR)((a7A),((a54).qh),(a54))));
}
// isFloat
function aiO(a7B /*type*/){
return (((a7B).qc)===(1026))&&(((a7B).ya)===(1));
}
// isBool
function aje(a7C /*type*/){
return (((a7C).qc)===(1026))&&(((a7C).ya)===(3));
}
// isComparable
function ajU(a7D /*type*/,a7E /*lessOrGreater*/){
if((((((((((a7D).qc)===(1025))||((s9)((a7D))))||((aiO)((a7D))))||((US)((a7D))))||((UT)((a7D))))||((T9)((a7D))))||((Zt)((a7D))))||(((a7D).qc)===(1028))){
return true;
}
if((!(a7E))&&((aje)((a7D)))){
return true;
}
return false;
}
// cmp
function akE(a7J /*s1*/,a7K /*s2*/){
let a7L; // p
(a7L)=(0);
while(((a7L)<((a7J).S.length))&&((a7L)<((a7K).S.length))){
if(((a7J).S.charCodeAt(a7L))!==((a7K).S.charCodeAt(a7L))){
return (((a7J).S.charCodeAt(a7L))>((a7K).S.charCodeAt(a7L)))?(1):((((a7J).S.charCodeAt(a7L))<((a7K).S.charCodeAt(a7L)))?(-1):(0));
}
(a7L)=((a7L)+(1));
}
return (((a7J).S.length)>((a7K).S.length))?(1):((((a7J).S.length)<((a7K).S.length))?(-1):(0));
}
// bitCast
function amj(a7Q /*size*/,a7R /*n*/){
let a7T;
a7T=a7Q;
switch(a7T){
case 1:
return a7R;
break;
case 2:
return a7R;
break;
case 4:
return a7R;
break;
case 8:
return a7R;
if(!(false)){throw 0xE9170000;}
break;
}
return 0x0000000000000000;
}
// getTypeName
function aqs(a7Y /*type*/){
let a8c;
let a8g; // type2
let a8h; // s
let a8i; // first
let a8j; // items
let a8l; // arg
let a80; // type2
let a81; // s
let a83;
let a89; // type2
let a8B; // type2
let a8D;
if((a7Y)===(null)){
return {S:""};
}
a8c=(a7Y).qc;
switch(a8c){
case 66561:
return {S:({S:"[]"}).S+((aqs)(((a7Y).Az))).S};
break;
case 1025:
return {S:({S:"bit"}).S+((v)((((a7Y).A2)*(8)),([0]))).S};
break;
case 66562:
(a8g)=(a7Y);
(a8h)=({S:"func<("});
(a8i)=(true);
(a8j)=((a8g).AC);
(qr)((a8j),([130,134]));
while(!((qt)((a8j),([130,134])))){
(a8l)=((qv)((a8j),([130,134])));
if(a8i){
(a8i)=(false);
}
else{
(a8h)=({S:(a8h).S+({S:", "}).S});
}
if((a8l).AN){
(a8h)=({S:(a8h).S+({S:"&"}).S});
}
(a8h)=({S:(a8h).S+((aqs)(((a8l).AL))).S});
(r8)((a8j),([130,134]));
}
if(((a8g).A7)===(null)){
(a8h)=({S:(a8h).S+({S:")>"}).S});
}
else{
(a8h)=({S:(a8h).S+({S:({S:({S:"): "}).S+((aqs)(((a8g).A7))).S}).S+({S:">"}).S}).S});
}
return a8h;
break;
case 66563:
(a80)=(a7Y);
(a81)=(null);
a83=(a80).AV;
switch(a83){
case 0:
(a81)=({S:"list<"});
break;
case 1:
(a81)=({S:"stack<"});
break;
case 2:
(a81)=({S:"queue<"});
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
return {S:({S:(a81).S+((aqs)(((a80).AX))).S}).S+({S:">"}).S};
break;
case 66564:
(a89)=(a7Y);
return {S:({S:({S:({S:({S:"dict<"}).S+((aqs)(((a89).Be))).S}).S+({S:", "}).S}).S+((aqs)(((a89).Bf))).S}).S+({S:">"}).S};
break;
case 1026:
(a8B)=(a7Y);
a8D=(a8B).ya;
switch(a8D){
case 0:
return {S:"int"};
break;
case 1:
return {S:"float"};
break;
case 2:
return {S:"char"};
break;
case 3:
return {S:"bool"};
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
break;
case 66565:
return {S:((((a7Y).q0).S===({S:"@"}).S)?(((a7Y).ql).dh):({S:""})).S+((a7Y).q0).S};
break;
case 1028:
return {S:"(UNKNOWN)"};
break;
default:
if(!(false)){throw 0xE9170000;}
return {S:""};
break;
}
}
// chkBuiltinFuncType
function arx(a8M /*member*/,a8N /*type*/){
let a8Q; // found
let a8R; // kind
let a8X;
let a9u;
let a95;
let a9P;
let aAa;
let aAs;
let aA1;
let a8S;
let a8T;
if((J)===(null)){
(J)=(new Map());
(bE)((J),([133,129,2,9]),({S:"abs"}),(10));
(bE)((J),([133,129,2,9]),({S:"add"}),(6));
(bE)((J),([133,129,2,9]),({S:"and"}),(1));
(bE)((J),([133,129,2,9]),({S:"clamp"}),(10));
(bE)((J),([133,129,2,9]),({S:"clampMax"}),(10));
(bE)((J),([133,129,2,9]),({S:"clampMin"}),(10));
(bE)((J),([133,129,2,9]),({S:"del"}),(14));
(bE)((J),([133,129,2,9]),({S:"delNext"}),(8));
(bE)((J),([133,129,2,9]),({S:"endian"}),(3));
(bE)((J),([133,129,2,9]),({S:"exist"}),(12));
(bE)((J),([133,129,2,9]),({S:"fill"}),(4));
(bE)((J),([133,129,2,9]),({S:"find"}),(13));
(bE)((J),([133,129,2,9]),({S:"findBin"}),(4));
(bE)((J),([133,129,2,9]),({S:"findLast"}),(13));
(bE)((J),([133,129,2,9]),({S:"findStr"}),(5));
(bE)((J),([133,129,2,9]),({S:"findStrEx"}),(5));
(bE)((J),([133,129,2,9]),({S:"findStrLast"}),(5));
(bE)((J),([133,129,2,9]),({S:"forEach"}),(12));
(bE)((J),([133,129,2,9]),({S:"get"}),(7));
(bE)((J),([133,129,2,9]),({S:"getOffset"}),(8));
(bE)((J),([133,129,2,9]),({S:"head"}),(8));
(bE)((J),([133,129,2,9]),({S:"idx"}),(8));
(bE)((J),([133,129,2,9]),({S:"ins"}),(8));
(bE)((J),([133,129,2,9]),({S:"join"}),(11));
(bE)((J),([133,129,2,9]),({S:"lower"}),(5));
(bE)((J),([133,129,2,9]),({S:"max"}),(4));
(bE)((J),([133,129,2,9]),({S:"min"}),(4));
(bE)((J),([133,129,2,9]),({S:"moveOffset"}),(8));
(bE)((J),([133,129,2,9]),({S:"next"}),(8));
(bE)((J),([133,129,2,9]),({S:"not"}),(1));
(bE)((J),([133,129,2,9]),({S:"offset"}),(2));
(bE)((J),([133,129,2,9]),({S:"or"}),(1));
(bE)((J),([133,129,2,9]),({S:"peek"}),(9));
(bE)((J),([133,129,2,9]),({S:"prev"}),(8));
(bE)((J),([133,129,2,9]),({S:"repeat"}),(4));
(bE)((J),([133,129,2,9]),({S:"replace"}),(5));
(bE)((J),([133,129,2,9]),({S:"reverse"}),(4));
(bE)((J),([133,129,2,9]),({S:"sar"}),(3));
(bE)((J),([133,129,2,9]),({S:"shl"}),(3));
(bE)((J),([133,129,2,9]),({S:"shr"}),(3));
(bE)((J),([133,129,2,9]),({S:"shuffle"}),(4));
(bE)((J),([133,129,2,9]),({S:"sign"}),(10));
(bE)((J),([133,129,2,9]),({S:"sort"}),(13));
(bE)((J),([133,129,2,9]),({S:"sortDesc"}),(13));
(bE)((J),([133,129,2,9]),({S:"split"}),(5));
(bE)((J),([133,129,2,9]),({S:"sub"}),(4));
(bE)((J),([133,129,2,9]),({S:"tail"}),(8));
(bE)((J),([133,129,2,9]),({S:"term"}),(8));
(bE)((J),([133,129,2,9]),({S:"termOffset"}),(8));
(bE)((J),([133,129,2,9]),({S:"toArray"}),(8));
(bE)((J),([133,129,2,9]),({S:"toArrayKey"}),(12));
(bE)((J),([133,129,2,9]),({S:"toArrayValue"}),(12));
(bE)((J),([133,129,2,9]),({S:"toBit64"}),(5));
(bE)((J),([133,129,2,9]),({S:"toFloat"}),(5));
(bE)((J),([133,129,2,9]),({S:"toInt"}),(5));
(bE)((J),([133,129,2,9]),({S:"toStr"}),(0));
(bE)((J),([133,129,2,9]),({S:"toStrFmt"}),(10));
(bE)((J),([133,129,2,9]),({S:"trim"}),(5));
(bE)((J),([133,129,2,9]),({S:"trimLeft"}),(5));
(bE)((J),([133,129,2,9]),({S:"trimRight"}),(5));
(bE)((J),([133,129,2,9]),({S:"upper"}),(5));
(bE)((J),([133,129,2,9]),({S:"xor"}),(1));
}
(a8Q)=(false);
(a8R)=((a8S=(pR)((J),([133,129,2,9]),(a8M.$),(a8T={$:(a8Q)},a8T)),(a8Q)=a8T.$,a8S));
if(!(a8Q)){
return false;
}
a8X=a8R;
switch(a8X){
case 0:
if(((((((s9)((a8N)))||((aiO)((a8N))))||((US)((a8N))))||((aje)((a8N))))||(((a8N).qc)===(1025)))||((Zt)((a8N)))){
return true;
}
break;
case 1:
if((((a8N).qc)===(1025))||((UT)((a8N)))){
return true;
}
break;
case 2:
if((US)((a8N))){
return true;
}
break;
case 3:
if(((a8N).qc)===(1025)){
return true;
}
break;
case 4:
if(((a8N).qc)===(66561)){
return true;
}
break;
case 5:
if((Zt)((a8N))){
return true;
}
break;
case 6:
if(((a8N).qc)===(66563)){
a9u=(a8N).AV;
switch(a9u){
case 0:
(a8M.$)=({S:"addList"});
break;
case 1:
(a8M.$)=({S:"addStack"});
break;
case 2:
(a8M.$)=({S:"addQueue"});
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
return true;
}
if(((a8N).qc)===(66564)){
(a8M.$)=({S:"addDict"});
return true;
}
break;
case 7:
if(((a8N).qc)===(66563)){
a95=(a8N).AV;
switch(a95){
case 0:
(a8M.$)=({S:"getList"});
break;
case 1:
(a8M.$)=({S:"getStack"});
break;
case 2:
(a8M.$)=({S:"getQueue"});
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
return true;
}
if(((a8N).qc)===(66564)){
(a8M.$)=({S:"getDict"});
return true;
}
break;
case 8:
if((((a8N).qc)===(66563))&&(((a8N).AV)===(0))){
return true;
}
break;
case 9:
if(((a8N).qc)===(66563)){
if(((a8N).AV)===(1)){
(a8M.$)=({S:"peekStack"});
return true;
}
else if(((a8N).AV)===(2)){
(a8M.$)=({S:"peekQueue"});
return true;
}
}
break;
case 10:
if((s9)((a8N))){
a9P=a8M.$;
if(a9P.S===({S:"abs"}).S){
(a8M.$)=({S:"absInt"});
}
else if(a9P.S===({S:"clamp"}).S){
(a8M.$)=({S:"clampInt"});
}
else if(a9P.S===({S:"clampMin"}).S){
(a8M.$)=({S:"clampMinInt"});
}
else if(a9P.S===({S:"clampMax"}).S){
(a8M.$)=({S:"clampMaxInt"});
}
else if(a9P.S===({S:"sign"}).S){
(a8M.$)=({S:"signInt"});
}
else if(a9P.S===({S:"toStrFmt"}).S){
(a8M.$)=({S:"toStrFmtInt"});
}
else{if(!(false)){throw 0xE9170000;}
}
return true;
}
if((aiO)((a8N))){
aAa=a8M.$;
if(aAa.S===({S:"abs"}).S){
(a8M.$)=({S:"absFloat"});
}
else if(aAa.S===({S:"clamp"}).S){
(a8M.$)=({S:"clampFloat"});
}
else if(aAa.S===({S:"clampMin"}).S){
(a8M.$)=({S:"clampMinFloat"});
}
else if(aAa.S===({S:"clampMax"}).S){
(a8M.$)=({S:"clampMaxFloat"});
}
else if(aAa.S===({S:"sign"}).S){
(a8M.$)=({S:"signFloat"});
}
else if(aAa.S===({S:"toStrFmt"}).S){
(a8M.$)=({S:"toStrFmtFloat"});
}
else{if(!(false)){throw 0xE9170000;}
}
return true;
}
break;
case 11:
if((((a8N).qc)===(66561))&&((Zt)(((a8N).Az)))){
return true;
}
break;
case 12:
if(((a8N).qc)===(66564)){
return true;
}
break;
case 13:
if(((a8N).qc)===(66561)){
aAs=a8M.$;
if(aAs.S===({S:"sort"}).S){
(a8M.$)=({S:"sortArray"});
}
else if(aAs.S===({S:"sortDesc"}).S){
(a8M.$)=({S:"sortDescArray"});
}
else if(aAs.S===({S:"find"}).S){
(a8M.$)=({S:"findArray"});
}
else if(aAs.S===({S:"findLast"}).S){
(a8M.$)=({S:"findLastArray"});
}
else{if(!(false)){throw 0xE9170000;}
}
return true;
}
if((((a8N).qc)===(66563))&&(((a8N).AV)===(0))){
aA1=a8M.$;
if(aA1.S===({S:"sort"}).S){
(a8M.$)=({S:"sortList"});
}
else if(aA1.S===({S:"sortDesc"}).S){
(a8M.$)=({S:"sortDescList"});
}
else if(aA1.S===({S:"find"}).S){
(a8M.$)=({S:"findList"});
}
else if(aA1.S===({S:"findLast"}).S){
(a8M.$)=({S:"findLastList"});
}
else{if(!(false)){throw 0xE9170000;}
}
return true;
}
break;
case 14:
if((((a8N).qc)===(66563))&&(((a8N).AV)===(0))){
return true;
}
if(((a8N).qc)===(66564)){
(a8M.$)=({S:"delDict"});
return true;
}
break;
}
return false;
}
// cacheSubExpr
function awF(aAC /*stats*/,aAD /*ast*/,aAE /*pos*/){
let aAJ; // ref
let aAL; // arg
let aAN; // do_
let aAP; // exprAssign
if((aAD)===(null)){
return null;
}
if((((aAD).qc)===(2062))||(((rt)(((aAD).qc),([9]),(67584)))===(67584))){
return aAD;
}
(aAJ)=(new yw());
(yx)((aAJ),(2062),(aAE));
((aAJ).q0)=({S:"$"});
((aAJ).yH)=(2);
((aAJ).zr)=(aAJ);
(aAL)=(new ro());
(xP)((aAL),(7),(aAE));
((aAL).rp)=(3);
((aAL).sP)=(false);
((aAL).sA)=((aAD).yL);
((aAL).yb)=(null);
((aAL).zr)=(aAL);
((aAJ).qz)=(aAL);
((aAJ).yL)=((aAL).sA);
(aAN)=(new ys());
(xP)((aAN),(528),(aAE));
(aAP)=(new zL());
(yx)((aAP),(2050),(aAE));
((aAP).zM)=(0);
((aAP).zP)=(aAJ);
((aAP).zQ)=(aAD);
((aAN).y2)=(aAP);
(eN)((aAC),([130,134]),((Tx)((aAN))));
return aAJ;
}
// buildExpr1
function axu(aAQ /*ast*/){
let aAS;
if(!(((aAQ).yH)!==(0))){throw 0xE9170000;}
aAS=(aAQ).aiL;
switch(aAS){
case 0:
(U3)(((aAQ).aiF));
break;
case 1:
(eN)((P),([130,129,2]),({S:"-("}));
(U3)(((aAQ).aiF));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 2:
(eN)((P),([130,129,2]),({S:"!("}));
(U3)(((aAQ).aiF));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 3:
(eN)((P),([130,129,2]),({S:"copy_("}));
(U3)(((aAQ).aiF));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 4:
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aAQ).aiF));
(eN)((P),([130,129,2]),({S:")->Len()"}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// buildExpr2
function axw(aAZ /*ast*/){
let aBa; // type
let aBc;
let aBK; // tmpVar
if(!(((aAZ).yH)!==(0))){throw 0xE9170000;}
(aBa)=(((aAZ).zP).yL);
aBc=(aAZ).zM;
switch(aBc){
case 0:
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:") = ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 8:
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:") || ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 9:
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:") && ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 10:
if((zT)((aBa))){
(eN)((P),([130,129,2]),({S:"cmp_(("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:"), ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")) < 0"}));
}
else{
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:") < ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")"}));
}
break;
case 11:
if((zT)((aBa))){
(eN)((P),([130,129,2]),({S:"cmp_(("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:"), ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")) > 0"}));
}
else{
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:") > ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")"}));
}
break;
case 12:
if((zT)((aBa))){
(eN)((P),([130,129,2]),({S:"cmp_(("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:"), ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")) <= 0"}));
}
else{
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:") <= ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")"}));
}
break;
case 13:
if((zT)((aBa))){
(eN)((P),([130,129,2]),({S:"cmp_(("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:"), ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")) >= 0"}));
}
else{
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:") >= ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")"}));
}
break;
case 14:
if((zT)((aBa))){
(eN)((P),([130,129,2]),({S:"cmp_(("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:"), ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")) == 0"}));
}
else{
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:") == ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")"}));
}
break;
case 15:
if((zT)((aBa))){
(eN)((P),([130,129,2]),({S:"cmp_(("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:"), ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")) != 0"}));
}
else{
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:") != ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")"}));
}
break;
case 16:
(eN)((P),([130,129,2]),({S:"eqAddr_(("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:"), ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:"))"}));
break;
case 17:
(eN)((P),([130,129,2]),({S:"!eqAddr_(("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:"), ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:"))"}));
break;
case 18:
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:")->Cat("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 19:
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:") + ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 20:
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:") - ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 21:
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:") * ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 22:
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:") / ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 23:
if(((s9)((aBa)))||(((rt)(((aBa).qc),([9]),(1025)))===(1025))){
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:") % ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:")"}));
}
else{
if(!((aiO)((aBa)))){throw 0xE9170000;}
(eN)((P),([130,129,2]),({S:"fmod(("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:"), ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:"))"}));
}
break;
case 24:
if(((s9)((aBa)))||(((rt)(((aBa).qc),([9]),(1025)))===(1025))){
(eN)((P),([130,129,2]),({S:"powI_(("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:"), ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:"))"}));
}
else{
if(!((aiO)((aBa)))){throw 0xE9170000;}
(eN)((P),([130,129,2]),({S:"pow(("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:"), ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:"))"}));
}
break;
case 25:
(aBK)=((Wq)((aBa)));
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)((aBK),([129,2]))).S}).S+({S:" = ("}).S}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:"), ("}));
(U3)(((aAZ).zP));
(eN)((P),([130,129,2]),({S:") = ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:"), ("}));
(U3)(((aAZ).zQ));
(eN)((P),([130,129,2]),({S:({S:({S:") = ("}).S+((v)((aBK),([129,2]))).S}).S+({S:")"}).S}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// buildExpr3
function axy(aBM /*ast*/){
if(!(((aBM).yH)!==(0))){throw 0xE9170000;}
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aBM).and));
(eN)((P),([130,129,2]),({S:") ? ("}));
(U3)(((aBM).ang));
(eN)((P),([130,129,2]),({S:") : ("}));
(U3)(((aBM).anj));
(eN)((P),([130,129,2]),({S:")"}));
}
// buildExprNew
function ax0(aBN /*ast*/){
let aBQ; // class_
let aBR; // id
let aBV; // gen
let aBX;
let aCd; // dict_
if(!(((aBN).yH)!==(0))){throw 0xE9170000;}
if((T9)(((aBN).an3))){
(aBQ)=(((aBN).an3).qz);
(aBR)=((tE)((aBQ)));
(eN)((P),([130,129,2]),({S:({S:({S:"new "}).S+((v)((aBR),([129,2]))).S}).S+({S:"()"}).S}));
}
else{
if((((aBN).an3).qc)===(66563)){
(aBV)=((aBN).an3);
aBX=(aBV).AV;
switch(aBX){
case 0:
(eN)((P),([130,129,2]),({S:({S:({S:"new List_<"}).S+((v)(((sw)(((aBV).AX))),([129,2]))).S}).S+({S:">()"}).S}));
break;
case 1:
(eN)((P),([130,129,2]),({S:({S:({S:"new Stack_<"}).S+((v)(((sw)(((aBV).AX))),([129,2]))).S}).S+({S:">()"}).S}));
break;
case 2:
(eN)((P),([130,129,2]),({S:({S:({S:"new Queue_<"}).S+((v)(((sw)(((aBV).AX))),([129,2]))).S}).S+({S:">()"}).S}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{
if(!((((aBN).an3).qc)===(66564))){throw 0xE9170000;}
(aCd)=((aBN).an3);
(eN)((P),([130,129,2]),({S:({S:({S:"new Dict_<"}).S+((v)(((sw)(((aCd).Be))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sw)(((aCd).Bf))),([129,2]))).S}).S+({S:">()"}).S}).S}));
}
}
}
// buildExprNewArray
function ax2(aCe /*ast*/){
let aCg; // items
if(!(((aCe).yH)!==(0))){throw 0xE9170000;}
(eN)((P),([130,129,2]),({S:({S:({S:"newArray_<"}).S+((v)(((sw)(((aCe).anN))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sw)(((aCe).yL))),([129,2]))).S}).S+({S:({S:({S:">("}).S+((v)((((aCe).anF).L),([0]))).S}).S+({S:""}).S}).S}).S}));
(aCg)=((aCe).anF);
(qr)((aCg),([130,134]));
while(!((qt)((aCg),([130,134])))){
(eN)((P),([130,129,2]),({S:", ("}));
(U3)(((qv)((aCg),([130,134]))));
(eN)((P),([130,129,2]),({S:")"}));
(r8)((aCg),([130,134]));
}
(eN)((P),([130,129,2]),({S:")"}));
}
// buildExprAs
function ax4(aCi /*ast*/){
let aCk;
let aCm; // t1
let aCn; // t2
let aCq; // id
let aCr; // info
let aCu; // info
let aCw; // info
if(!(((aCi).yH)!==(0))){throw 0xE9170000;}
aCk=(aCi).aoi;
switch(aCk){
case 0:
(aCm)=(((aCi).aoa).yL);
(aCn)=((aCi).aod);
if((T9)((aCm))){
if(!((T9)((aCn)))){throw 0xE9170000;}
(aCq)=((tE)(((aCn).qz)));
(aCr)=((rU)(((aCn).qz)));
(eN)((P),([130,129,2]),({S:({S:({S:"as_<"}).S+((v)((aCq),([129,2]))).S}).S+({S:">(classTable_, ("}).S}));
(U3)(((aCi).aoa));
(eN)((P),([130,129,2]),({S:({S:({S:"), "}).S+((v)((((aCr).tJ)*(2)),([0]))).S}).S+({S:")"}).S}));
}
else{
(eN)((P),([130,129,2]),({S:({S:({S:"static_cast<"}).S+((v)(((sw)(((aCi).aod))),([129,2]))).S}).S+({S:">("}).S}));
(U3)(((aCi).aoa));
(eN)((P),([130,129,2]),({S:")"}));
}
break;
case 1:
(tE)((((aCi).aod).qz));
(aCu)=((rU)((((aCi).aod).qz)));
(eN)((P),([130,129,2]),({S:"is_(classTable_, ("}));
(U3)(((aCi).aoa));
(eN)((P),([130,129,2]),({S:({S:({S:"), "}).S+((v)((((aCu).tJ)*(2)),([0]))).S}).S+({S:")"}).S}));
break;
case 2:
(tE)((((aCi).aod).qz));
(aCw)=((rU)((((aCi).aod).qz)));
(eN)((P),([130,129,2]),({S:"!is_(classTable_, ("}));
(U3)(((aCi).aoa));
(eN)((P),([130,129,2]),({S:({S:({S:"), "}).S+((v)((((aCw).tJ)*(2)),([0]))).S}).S+({S:")"}).S}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// buildExprToBin
function ax6(aCy /*ast*/){
if(!(((aCy).yH)!==(0))){throw 0xE9170000;}
(eN)((P),([130,129,2]),({S:"toBin_("}));
(U3)(((aCy).apw));
(eN)((P),([130,129,2]),({S:")"}));
}
// buildExprFromBin
function ax8(aCz /*ast*/){
if(!(((aCz).yH)!==(0))){throw 0xE9170000;}
(eN)((P),([130,129,2]),({S:({S:({S:"fromBin_<"}).S+((v)(((sw)(((aCz).apC))),([129,2]))).S}).S+({S:">(("}).S}));
(U3)(((aCz).ap7));
(eN)((P),([130,129,2]),({S:"), ("}));
(U3)(((aCz).apD));
(eN)((P),([130,129,2]),({S:"))"}));
}
// buildExprCall
function axA(aC0 /*ast*/){
let aC1; // funcType
let aC2; // template
let aC5; // items
let aC6; // meType
let aDa; // first
let aDb; // items
let aDd; // item
let aDk; // type
if(!(((aC0).yH)!==(0))){throw 0xE9170000;}
(aC1)=(((aC0).y1).yL);
(aC2)=(null);
if(((aC1)!==(null))&&(((rt)(((aC1).ad7),([9]),(1)))===(1))){
(aC5)=((aC0).yy);
(qr)((aC5),([130,134]));
(aC6)=((((qv)((aC5),([130,134]))).zf).yL);
if(((rt)(((aC1).ad7),([9]),(32)))===(32)){
(aC2)=({S:({S:({S:"<"}).S+((v)(((sw)((aC6))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sw)(((aC6).Be))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sw)(((aC6).Bf))),([129,2]))).S}).S+({S:">"}).S}).S}).S});
}
else if(((rt)(((aC1).ad7),([9]),(8)))===(8)){
if(((rt)(((aC1).ad7),([9]),(16)))===(16)){
(aC2)=({S:({S:({S:"<"}).S+((v)(((sw)((aC6))),([129,2]))).S}).S+({S:", "}).S});
if(((aC6).qc)===(66563)){
(aC2)=({S:(aC2).S+({S:({S:({S:""}).S+((v)(((sw)(((aC6).AX))),([129,2]))).S}).S+({S:", "}).S}).S});
}
else{
if(!(((aC6).qc)===(66564))){throw 0xE9170000;}
(aC2)=({S:(aC2).S+({S:({S:({S:""}).S+((v)(((sw)(((aC6).Be))),([129,2]))).S}).S+({S:", "}).S}).S});
}
(aC2)=({S:(aC2).S+({S:({S:({S:""}).S+((v)(((sw)(((aC1).A7))),([129,2]))).S}).S+({S:">"}).S}).S});
}
else{
(aC2)=({S:({S:({S:"<"}).S+((v)(((sw)((aC6))),([129,2]))).S}).S+({S:", "}).S});
if(((aC6).qc)===(66561)){
(aC2)=({S:(aC2).S+({S:({S:({S:""}).S+((v)(((sw)(((aC6).Az))),([129,2]))).S}).S+({S:">"}).S}).S});
}
else if(((aC6).qc)===(66563)){
(aC2)=({S:(aC2).S+({S:({S:({S:""}).S+((v)(((sw)(((aC6).AX))),([129,2]))).S}).S+({S:">"}).S}).S});
}
else{
if(!(((aC6).qc)===(66564))){throw 0xE9170000;}
(aC2)=({S:(aC2).S+({S:({S:({S:""}).S+((v)(((sw)(((aC6).Be))),([129,2]))).S}).S+({S:">"}).S}).S});
}
}
}
else if(((rt)(((aC1).ad7),([9]),(16)))===(16)){
(aC2)=({S:({S:({S:"<"}).S+((v)(((sw)((aC6))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sw)(((aC1).A7))),([129,2]))).S}).S+({S:">"}).S}).S});
}
else if(((rt)(((aC1).ad7),([9]),(256)))===(256)){
(aC2)=({S:({S:({S:"<"}).S+((v)(((sw)((aC6))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sw)(((aC6).Be))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sw)(((aC6).Bf))),([129,2]))).S}).S+({S:">"}).S}).S}).S});
}
else if(((rt)(((aC1).ad7),([9]),(64)))===(64)){
(aC2)=({S:({S:({S:"<"}).S+((v)(((sw)((aC6))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sw)(((aC6).AX))),([129,2]))).S}).S+({S:">"}).S}).S});
}
else if(((rt)(((aC1).ad7),([9]),(512)))===(512)){
(aC2)=({S:({S:({S:"<"}).S+((v)(((sw)((aC6))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sw)(((aC6).Be))),([129,2]))).S}).S+({S:">"}).S}).S});
}
else if(((rt)(((aC1).ad7),([9]),(1024)))===(1024)){
(aC2)=({S:({S:({S:"<"}).S+((v)(((sw)((aC6))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sw)(((aC6).Bf))),([129,2]))).S}).S+({S:">"}).S}).S});
}
else{
(aC2)=({S:({S:({S:"<"}).S+((v)(((sw)((aC6))),([129,2]))).S}).S+({S:">"}).S});
}
}
if((aC2)===(null)){
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aC0).y1));
(eN)((P),([130,129,2]),({S:")"}));
}
else{
(U3)(((aC0).y1));
(eN)((P),([130,129,2]),(aC2));
}
(eN)((P),([130,129,2]),({S:"("}));
(aDa)=(true);
(aDb)=((aC0).yy);
(qr)((aDb),([130,134]));
while(!((qt)((aDb),([130,134])))){
(aDd)=((qv)((aDb),([130,134])));
if(aDa){
(aDa)=(false);
(eN)((P),([130,129,2]),({S:"("}));
}
else{
(eN)((P),([130,129,2]),({S:", ("}));
}
if((aDd).zb){
(eN)((P),([130,129,2]),({S:"&"}));
}
(U3)(((aDd).zf));
(eN)((P),([130,129,2]),({S:")"}));
(r8)((aDb),([130,134]));
}
(eN)((P),([130,129,2]),({S:")"}));
(aDk)=((aC0).yL);
if((aDk)!==(null)){
if((T9)((aDk))){
(tE)(((aDk).qz));
}
}
}
// buildExprArray
function axC(aDp /*ast*/){
if(!(((aDp).yH)!==(0))){throw 0xE9170000;}
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aDp).aqE));
(eN)((P),([130,129,2]),({S:")->At("}));
(U3)(((aDp).aqJ));
(eN)((P),([130,129,2]),({S:")"}));
}
// buildExprDot
function axE(aDq /*ast*/){
let aDt; // classItem
let aDu; // info
if(!(((aDq).yH)!==(0))){throw 0xE9170000;}
if((T9)((((aDq).apW).yL))){
(aDt)=((aDq).arp);
if(!((aDt)!==(null))){throw 0xE9170000;}
(tE)(((((aDq).apW).yL).qz));
(aDu)=(null);
if((((aDt).tX).qc)===(2)){
(aDu)=((rU)((((aDt).tX).uc)));
(eN)((P),([130,129,2]),({S:"("}));
(U3)(((aDq).apW));
(eN)((P),([130,129,2]),({S:({S:({S:")->"}).S+((v)(((aDu).sT),([129,2]))).S}).S+({S:""}).S}));
}
else{
if(!((((aDt).tX).qc)===(256))){throw 0xE9170000;}
(aDu)=((rU)(((aDt).tX)));
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((aDu).sT),([129,2]))).S}).S+({S:""}).S}));
}
}
else{
if(!((((aDq).qz).qc)===(2062))){throw 0xE9170000;}
(axQ)(((aDq).qz));
}
}
// buildExprValue
function axG(aDz /*ast*/){
if(!((((aDz).yL).qc)===(1027))){throw 0xE9170000;}
(eN)((P),([130,129,2]),({S:"nullptr"}));
}
// buildExprValuePrim
function axI(aD0 /*ast*/){
let aD1; // type
let aD8;
(aD1)=((aD0).yL);
if(((s9)((aD1)))||((UT)((aD1)))){
(eN)((P),([130,129,2]),({S:((v)(((aD0).yI),([0]))).S+({S:"LL"}).S}));
}
else if((US)((aD1))){
(eN)((P),([130,129,2]),({S:({S:({S:"u\'\\u"}).S+((v)(((p9)(((v)(((aD0).yI),([5]))),([129,2]),(2),(-1))),([129,2]))).S}).S+({S:"\'"}).S}));
}
else if((aje)((aD1))){
(eN)((P),([130,129,2]),((((aD0).yI)===(0x0000000000000000))?({S:"false"}):({S:"true"})));
}
else if(((aD1).qc)===(1025)){
aD8=(aD1).A2;
switch(aD8){
case 1:
(eN)((P),([130,129,2]),({S:({S:({S:"static_cast<uint8_t>("}).S+((v)(((aD0).yI),([4]))).S}).S+({S:"U)"}).S}));
break;
case 2:
(eN)((P),([130,129,2]),({S:({S:({S:"static_cast<uint16_t>("}).S+((v)(((aD0).yI),([5]))).S}).S+({S:"U)"}).S}));
break;
case 4:
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((aD0).yI),([6]))).S}).S+({S:"U"}).S}));
break;
case 8:
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((aD0).yI),([7]))).S}).S+({S:"ULL"}).S}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{
if(!(false)){throw 0xE9170000;}
}
}
// buildExprValueStr
function axK(aDF /*ast*/){
let aDG; // value
let aDH; // s
let aDK;
let aDL;
(aDG)=((aDF).akF);
(aDH)=({S:({S:({S:"new Array_<char16_t>("}).S+((v)(((aDG).S.length),([0]))).S}).S+({S:""}).S});
aDJ:
for(aDK=(0),aDL=(((aDG).S.length)-(1));aDK<=aDL;aDK+=(1)){
(aDH)=({S:(aDH).S+({S:({S:({S:", u\'\\u"}).S+((v)(((p9)(((v)(((aDG).S.charCodeAt(aDK)),([5]))),([129,2]),(2),(-1))),([129,2]))).S}).S+({S:"\'"}).S}).S});
}
(aDH)=({S:(aDH).S+({S:")"}).S});
(eN)((P),([130,129,2]),(aDH));
}
// buildExprValueFloat
function axM(aDO /*ast*/){
let aDP; // value
(aDP)=((v)(((aDO).ajb),([1])));
if((aDP).S===({S:"inf"}).S){
(eN)((P),([130,129,2]),({S:"std::numeric_limits<double>::infinity()"}));
}
else if(((q3)((aDP),([129,2]),(0x002E),(-1)))===(-1)){
(eN)((P),([130,129,2]),({S:(aDP).S+({S:".0"}).S}));
}
else{
(eN)((P),([130,129,2]),(aDP));
}
}
// buildExprValueArray
function axO(aDU /*ast*/){
let aDV; // items
(eN)((P),([130,129,2]),({S:({S:({S:"new Array_<"}).S+((v)(((sw)((((aDU).yL).Az))),([129,2]))).S}).S+({S:({S:({S:">("}).S+((v)((((aDU).aqf).L),([0]))).S}).S+({S:""}).S}).S}));
(aDV)=((aDU).aqf);
(qr)((aDV),([130,134]));
while(!((qt)((aDV),([130,134])))){
(eN)((P),([130,129,2]),({S:", ("}));
(U3)(((qv)((aDV),([130,134]))));
(eN)((P),([130,129,2]),({S:")"}));
(r8)((aDV),([130,134]));
}
(eN)((P),([130,129,2]),({S:")"}));
}
// buildExprRef
function axQ(aDX /*ast*/){
let aDY; // ast2
let aDZ; // info
let aEd; // arg
let aEf;
(aDY)=((aDX).qz);
(aDZ)=((rU)((aDY)));
if(((aDY).qc)===(256)){
(eQ)((K),([132,134]),(aDY));
}
else{
if(!(((aDY).qc)===(7))){throw 0xE9170000;}
(aEd)=(aDY);
aEf=(aEd).rp;
switch(aEf){
case 1:
if(!((aDZ).rX)){
((aDZ).rX)=(true);
(eN)((S),([130,134]),(aEd));
}
break;
case 2:
break;
case 3:
if(!((aDZ).rX)){
((aDZ).rX)=(true);
(eN)((T),([130,134]),(aEd));
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
if((aEd).sP){
(eN)((P),([130,129,2]),({S:"*"}));
}
}
(eN)((P),([130,129,2]),((aDZ).sT));
}
// buildExpr1
function aya(aEq /*ast*/){
let aEs;
let aEx; // typeId
let aE0; // type
let aE4;
if(!(((aEq).yH)!==(0))){throw 0xE9170000;}
aEs=(aEq).aiL;
switch(aEs){
case 0:
(Yy)(((aEq).aiF));
break;
case 1:
(eN)((am),([130,129,2]),({S:"-("}));
(Yy)(((aEq).aiF));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 2:
(eN)((am),([130,129,2]),({S:"!("}));
(Yy)(((aEq).aiF));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 3:
(aEx)=((aEy)((((aEq).aiF).yL)));
(eN)((am),([130,129,2]),({S:({S:({S:"C_("}).S+((v)((aEx),([129,2]))).S}).S+({S:",("}).S}));
(Yy)(((aEq).aiF));
(eN)((am),([130,129,2]),({S:"))"}));
break;
case 4:
(aE0)=(((aEq).aiF).yL);
if(((aE0).qc)===(66563)){
aE4=(aE0).AV;
switch(aE4){
case 0:
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEq).aiF));
(eN)((am),([130,129,2]),({S:").L"}));
break;
case 1:
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEq).aiF));
(eN)((am),([130,129,2]),({S:").length"}));
break;
case 2:
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEq).aiF));
(eN)((am),([130,129,2]),({S:").length"}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else if(((aE0).qc)===(66564)){
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEq).aiF));
(eN)((am),([130,129,2]),({S:").size"}));
}
else{
if(!(((aE0).qc)===(66561))){throw 0xE9170000;}
if((US)(((aE0).Az))){
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEq).aiF));
(eN)((am),([130,129,2]),({S:").S.length"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEq).aiF));
(eN)((am),([130,129,2]),({S:").length"}));
}
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// buildExpr2
function ayc(aEF /*ast*/){
let aEG; // type
let aEI;
let aEM; // ast2
let aEN; // tmpIdx
let aEO; // tmpChar
let aFE; // tmpVar
if(!(((aEF).yH)!==(0))){throw 0xE9170000;}
(aEG)=(((aEF).zP).yL);
aEI=(aEF).zM;
switch(aEI){
case 0:
if(((((aEF).zP).qc)===(2058))&&((US)((((aEF).zP).yL)))){
(aEM)=((aEF).zP);
(aEN)=((ZN)((((aEM).aqJ).yL)));
(aEO)=((ZN)(((aEM).yL)));
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEM).aqE));
(eN)((am),([130,129,2]),({S:({S:({S:").S=("}).S+((v)((aEN),([129,2]))).S}).S+({S:"=("}).S}));
(Yy)(((aEM).aqJ));
(eN)((am),([130,129,2]),({S:"),("}));
(Yy)(((aEM).aqE));
(eN)((am),([130,129,2]),({S:({S:({S:").S.slice(0,"}).S+((v)((aEN),([129,2]))).S}).S+({S:")+String.fromCharCode("}).S}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:")+("}));
(Yy)(((aEM).aqE));
(eN)((am),([130,129,2]),({S:({S:({S:").S.slice("}).S+((v)((aEN),([129,2]))).S}).S+({S:"+1))"}).S}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:")=("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:")"}));
}
break;
case 8:
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:")||("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 9:
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:")&&("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 10:
if((Zt)((aEG))){
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:").S<("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:").S"}));
}
else if((zT)((aEG))){
(eN)((am),([130,129,2]),({S:"cmp_(("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:"),("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:"))<0"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:")<("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:")"}));
}
break;
case 11:
if((Zt)((aEG))){
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:").S>("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:").S"}));
}
else if((zT)((aEG))){
(eN)((am),([130,129,2]),({S:"cmp_(("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:"),("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:"))>0"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:")>("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:")"}));
}
break;
case 12:
if((Zt)((aEG))){
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:").S<=("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:").S"}));
}
else if((zT)((aEG))){
(eN)((am),([130,129,2]),({S:"cmp_(("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:"),("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:"))<=0"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:")<=("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:")"}));
}
break;
case 13:
if((Zt)((aEG))){
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:").S>=("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:").S"}));
}
else if((zT)((aEG))){
(eN)((am),([130,129,2]),({S:"cmp_(("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:"),("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:"))>=0"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:")>=("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:")"}));
}
break;
case 14:
if((Zt)((aEG))){
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:").S===("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:").S"}));
}
else if((zT)((aEG))){
(eN)((am),([130,129,2]),({S:"cmp_(("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:"),("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:"))==0"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:")===("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:")"}));
}
break;
case 15:
if((Zt)((aEG))){
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:").S!==("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:").S"}));
}
else if((zT)((aEG))){
(eN)((am),([130,129,2]),({S:"cmp_(("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:"),("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:"))!=0"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:")!==("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:")"}));
}
break;
case 16:
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:")===("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 17:
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:")!==("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 18:
if((Zt)((aEG))){
(eN)((am),([130,129,2]),({S:"{S:("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:").S+("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:").S}"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:").concat("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:")"}));
}
break;
case 19:
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:")+("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 20:
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:")-("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 21:
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:")*("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 22:
if(!((aiO)((aEG)))){
(eN)((am),([130,129,2]),({S:"~~("}));
}
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:")/("}));
(Yy)(((aEF).zQ));
if(!((aiO)((aEG)))){
(eN)((am),([130,129,2]),({S:"))"}));
}
else{
(eN)((am),([130,129,2]),({S:")"}));
}
break;
case 23:
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:")%("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 24:
(eN)((am),([130,129,2]),({S:"Math.pow(("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:"),("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:"))"}));
break;
case 25:
(aFE)=((ZN)((aEG)));
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)((aFE),([129,2]))).S}).S+({S:"=("}).S}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:"),("}));
(Yy)(((aEF).zP));
(eN)((am),([130,129,2]),({S:")=("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:"),("}));
(Yy)(((aEF).zQ));
(eN)((am),([130,129,2]),({S:({S:({S:")=("}).S+((v)((aFE),([129,2]))).S}).S+({S:")"}).S}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// buildExpr3
function aye(aFG /*ast*/){
if(!(((aFG).yH)!==(0))){throw 0xE9170000;}
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aFG).and));
(eN)((am),([130,129,2]),({S:")?("}));
(Yy)(((aFG).ang));
(eN)((am),([130,129,2]),({S:"):("}));
(Yy)(((aFG).anj));
(eN)((am),([130,129,2]),({S:")"}));
}
// buildExprNew
function ayg(aFH /*ast*/){
let aFK; // class_
let aFL; // id
let aFP; // gen
let aFR;
if(!(((aFH).yH)!==(0))){throw 0xE9170000;}
if((T9)(((aFH).an3))){
(aFK)=(((aFH).an3).qz);
(aFL)=((vG)((aFK)));
(eN)((am),([130,129,2]),({S:({S:({S:"new "}).S+((v)((aFL),([129,2]))).S}).S+({S:"()"}).S}));
}
else{
if((((aFH).an3).qc)===(66563)){
(aFP)=((aFH).an3);
aFR=(aFP).AV;
switch(aFR){
case 0:
(eN)((am),([130,129,2]),({S:"{L:0,H:null,T:null,P:null}"}));
break;
case 1:
(eN)((am),([130,129,2]),({S:"[]"}));
break;
case 2:
(eN)((am),([130,129,2]),({S:"[]"}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{
if(!((((aFH).an3).qc)===(66564))){throw 0xE9170000;}
(eN)((am),([130,129,2]),({S:"new Map()"}));
}
}
}
// buildExprNewArray
function ayi(aFX /*ast*/){
let aFZ; // items
let aGf; // first
let aGo; // first
if(!(((aFX).yH)!==(0))){throw 0xE9170000;}
(aFZ)=((aFX).anF);
(qr)((aFZ),([130,134]));
if((US)(((aFX).anN))){
if(((aFZ).L)===(1)){
(eN)((am),([130,129,2]),({S:"{S:\"\\0\".repeat("}));
(Yy)(((qv)((aFZ),([130,134]))));
(eN)((am),([130,129,2]),({S:")}"}));
}
else{
(eN)((am),([130,129,2]),({S:({S:({S:"(function A_(n){if(n.length===1)return{S:\"\\0\".repeat("}).S+((v)(((L7)(((aFX).anN))),([129,2]))).S}).S+({S:")};else{let a=new Array(n[0]),m=n.shift(),i;for(i=0;i<n[0];i++)a[i]=A_(m);return a;}})(["}).S}));
(aGf)=(true);
while(!((qt)((aFZ),([130,134])))){
if(aGf){
(aGf)=(false);
(eN)((am),([130,129,2]),({S:"("}));
}
else{
(eN)((am),([130,129,2]),({S:",("}));
}
(Yy)(((qv)((aFZ),([130,134]))));
(eN)((am),([130,129,2]),({S:")"}));
(r8)((aFZ),([130,134]));
}
(eN)((am),([130,129,2]),({S:"])"}));
}
}
else{
if(((aFZ).L)===(1)){
(eN)((am),([130,129,2]),({S:"new Array("}));
(Yy)(((qv)((aFZ),([130,134]))));
(eN)((am),([130,129,2]),({S:({S:({S:").fill("}).S+((v)(((L7)(((aFX).anN))),([129,2]))).S}).S+({S:")"}).S}));
}
else{
(eN)((am),([130,129,2]),({S:({S:({S:"(function A_(n){if(n.length===1)return new Array(n[0]).fill("}).S+((v)(((L7)(((aFX).anN))),([129,2]))).S}).S+({S:")else{let a=new Array(n[0]),m=n.shift(),i;for(i=0;i<n[0];i++)a[i]=A_(m);return a}})(["}).S}));
(aGo)=(true);
while(!((qt)((aFZ),([130,134])))){
if(aGo){
(aGo)=(false);
}
else{
(eN)((am),([130,129,2]),({S:",("}));
}
(Yy)(((qv)((aFZ),([130,134]))));
(eN)((am),([130,129,2]),({S:")"}));
(r8)((aFZ),([130,134]));
}
(eN)((am),([130,129,2]),({S:"])"}));
}
}
}
// buildExprAs
function ayk(aGt /*ast*/){
let aGv;
let aGx; // t1
let aGy; // t2
let aGG; // info
let aGI; // info
if(!(((aGt).yH)!==(0))){throw 0xE9170000;}
aGv=(aGt).aoi;
switch(aGv){
case 0:
(aGx)=(((aGt).aoa).yL);
(aGy)=((aGt).aod);
if((T9)((aGx))){
if(!((T9)((aGy)))){throw 0xE9170000;}
(vG)(((aGy).qz));
(Yy)(((aGt).aoa));
}
else{
if((((((aGx).qc)===(1025))||((s9)((aGx))))||((US)((aGx))))||((UT)((aGx)))){
if(((((((aGy).qc)===(1025))||((s9)((aGy))))||((US)((aGy))))||((UT)((aGy))))||((aiO)((aGy)))){
(Yy)(((aGt).aoa));
}
else{
if(!((aje)((aGy)))){throw 0xE9170000;}
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aGt).aoa));
(eN)((am),([130,129,2]),({S:")!=0"}));
}
}
else if((aiO)((aGx))){
if((((aGy).qc)===(1025))||((s9)((aGy)))){
(eN)((am),([130,129,2]),({S:"~~("}));
(Yy)(((aGt).aoa));
(eN)((am),([130,129,2]),({S:")"}));
}
else{
if(!((aiO)((aGy)))){throw 0xE9170000;}
(Yy)(((aGt).aoa));
}
}
else{
if(!((aje)((aGx)))){throw 0xE9170000;}
if((((aGy).qc)===(1025))||((s9)((aGy)))){
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aGt).aoa));
(eN)((am),([130,129,2]),({S:")?1:0"}));
}
else{
if(!((aje)((aGy)))){throw 0xE9170000;}
(Yy)(((aGt).aoa));
}
}
}
break;
case 1:
(vG)((((aGt).aod).qz));
(aGG)=((uO)((((aGt).aod).qz)));
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aGt).aoa));
(eN)((am),([130,129,2]),({S:({S:({S:")instanceof "}).S+((v)(((aGG).vf),([129,2]))).S}).S+({S:""}).S}));
break;
case 2:
(vG)((((aGt).aod).qz));
(aGI)=((uO)((((aGt).aod).qz)));
(eN)((am),([130,129,2]),({S:"!(("}));
(Yy)(((aGt).aoa));
(eN)((am),([130,129,2]),({S:({S:({S:")instanceof "}).S+((v)(((aGI).vf),([129,2]))).S}).S+({S:")"}).S}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// buildExprToBin
function aym(aGK /*ast*/){
if(!(((aGK).yH)!==(0))){throw 0xE9170000;}
(eN)((am),([130,129,2]),({S:"toBin_("}));
(Yy)(((aGK).apw));
(eN)((am),([130,129,2]),({S:")"}));
}
// buildExprFromBin
function ayo(aGL /*ast*/){
if(!(((aGL).yH)!==(0))){throw 0xE9170000;}
(eN)((am),([130,129,2]),({S:"fromBin_(("}));
(Yy)(((aGL).ap7));
(eN)((am),([130,129,2]),({S:"),("}));
(Yy)(((aGL).apD));
(eN)((am),([130,129,2]),({S:"))"}));
}
// buildExprCall
function ayq(aGM /*ast*/){
let aGN; // funcType
let aGO; // meTypeId
let aGR; // items
let aGS; // refNum
let aGU; // items
let aGZ; // resultVar
let aHa; // refVar
let aHg; // idx
let aHh; // refCnt
let aHi; // first
let aHj; // items
let aHl; // item
let aHy; // idx
let aHz; // refCnt
let aH0; // items
let aH2; // item
let aHB; // type
if(!(((aGM).yH)!==(0))){throw 0xE9170000;}
(aGN)=(((aGM).y1).yL);
(aGO)=(null);
if(((aGN)!==(null))&&(((rt)(((aGN).ad7),([9]),(1)))===(1))){
(aGR)=((aGM).yy);
(qr)((aGR),([130,134]));
(aGO)=((aEy)(((((qv)((aGR),([130,134]))).zf).yL)));
}
(aGS)=(0);
(aGU)=((aGM).yy);
(qr)((aGU),([130,134]));
while(!((qt)((aGU),([130,134])))){
if(((qv)((aGU),([130,134]))).zb){
(aGS)=((aGS)+(1));
}
(r8)((aGU),([130,134]));
}
(aGZ)=(null);
(aHa)=(null);
if((aGS)>(0)){
(eN)((am),([130,129,2]),({S:"("}));
if(((aGM).yL)!==(null)){
(aGZ)=((ZN)(((aGM).yL)));
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)((aGZ),([129,2]))).S}).S+({S:"="}).S}));
}
(aHa)=(new Array(aGS).fill(null));
}
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aGM).y1));
(eN)((am),([130,129,2]),({S:")("}));
(aHg)=(0);
(aHh)=(0);
(aHi)=(true);
(aHj)=((aGM).yy);
(qr)((aHj),([130,134]));
while(!((qt)((aHj),([130,134])))){
(aHl)=((qv)((aHj),([130,134])));
if(aHi){
(aHi)=(false);
(eN)((am),([130,129,2]),({S:"("}));
}
else{
(eN)((am),([130,129,2]),({S:",("}));
}
if(((aGO)!==(null))&&((aHg)===(1))){
(eN)((am),([130,129,2]),(aGO));
}
else if((aHl).zb){
((aHa)[aHh])=((ZN)((((aHl).zf).yL)));
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((aHa)[aHh]),([129,2]))).S}).S+({S:"={$:("}).S}));
(Yy)(((aHl).zf));
(eN)((am),([130,129,2]),({S:({S:({S:")},"}).S+((v)(((aHa)[aHh]),([129,2]))).S}).S+({S:""}).S}));
(aHh)=((aHh)+(1));
}
else{
(Yy)(((aHl).zf));
}
(eN)((am),([130,129,2]),({S:")"}));
(aHg)=((aHg)+(1));
(r8)((aHj),([130,134]));
}
(eN)((am),([130,129,2]),({S:")"}));
if((aGS)>(0)){
(aHy)=(0);
(aHz)=(0);
(aH0)=((aGM).yy);
(qr)((aH0),([130,134]));
while(!((qt)((aH0),([130,134])))){
(aH2)=((qv)((aH0),([130,134])));
if(((aGO)!==(null))&&((aHy)===(1))){
}
else if((aH2).zb){
(eN)((am),([130,129,2]),({S:",("}));
(Yy)(((aH2).zf));
(eN)((am),([130,129,2]),({S:({S:({S:")="}).S+((v)(((aHa)[aHz]),([129,2]))).S}).S+({S:".$"}).S}));
(aHz)=((aHz)+(1));
}
(aHy)=((aHy)+(1));
(r8)((aH0),([130,134]));
}
if(((aGM).yL)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:","}).S+((v)((aGZ),([129,2]))).S}).S+({S:""}).S}));
}
(eN)((am),([130,129,2]),({S:")"}));
}
(aHB)=((aGM).yL);
if((aHB)!==(null)){
if((T9)((aHB))){
(vG)(((aHB).qz));
}
}
}
// buildExprArray
function ays(aHG /*ast*/){
if(!(((aHG).yH)!==(0))){throw 0xE9170000;}
if((US)(((aHG).yL))){
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aHG).aqE));
(eN)((am),([130,129,2]),({S:").S.charCodeAt("}));
(Yy)(((aHG).aqJ));
(eN)((am),([130,129,2]),({S:")"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aHG).aqE));
(eN)((am),([130,129,2]),({S:")["}));
(Yy)(((aHG).aqJ));
(eN)((am),([130,129,2]),({S:"]"}));
}
}
// buildExprDot
function ayu(aHK /*ast*/){
let aHN; // classItem
let aHO; // info
if(!(((aHK).yH)!==(0))){throw 0xE9170000;}
if((T9)((((aHK).apW).yL))){
(aHN)=((aHK).arp);
if(!((aHN)!==(null))){throw 0xE9170000;}
(vG)(((((aHK).apW).yL).qz));
(aHO)=(null);
if((((aHN).tX).qc)===(2)){
(aHO)=((uO)((((aHN).tX).uc)));
(eN)((am),([130,129,2]),({S:"("}));
(Yy)(((aHK).apW));
(eN)((am),([130,129,2]),({S:({S:({S:")."}).S+((v)(((aHO).vf),([129,2]))).S}).S+({S:""}).S}));
}
else{
if(!((((aHN).tX).qc)===(256))){throw 0xE9170000;}
(aHO)=((uO)(((aHN).tX)));
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((aHO).vf),([129,2]))).S}).S+({S:""}).S}));
}
}
else{
if(!((((aHK).qz).qc)===(2062))){throw 0xE9170000;}
(ay6)(((aHK).qz));
}
}
// buildExprValue
function ayw(aHT /*ast*/){
if(!((((aHT).yL).qc)===(1027))){throw 0xE9170000;}
(eN)((am),([130,129,2]),({S:"null"}));
}
// buildExprValuePrim
function ayy(aHU /*ast*/){
let aHV; // type
let aIc;
(aHV)=((aHU).yL);
if(((s9)((aHV)))||((UT)((aHV)))){
(eN)((am),([130,129,2]),((v)(((aHU).yI),([0]))));
}
else if((US)((aHV))){
(eN)((am),([130,129,2]),((v)(((aHU).yI),([5]))));
}
else if((aje)((aHV))){
(eN)((am),([130,129,2]),((((aHU).yI)===(0x0000000000000000))?({S:"false"}):({S:"true"})));
}
else if(((aHV).qc)===(1025)){
aIc=(aHV).A2;
switch(aIc){
case 1:
(eN)((am),([130,129,2]),((v)(((aHU).yI),([4]))));
break;
case 2:
(eN)((am),([130,129,2]),((v)(((aHU).yI),([5]))));
break;
case 4:
(eN)((am),([130,129,2]),((v)(((aHU).yI),([6]))));
break;
case 8:
(eN)((am),([130,129,2]),((v)(((aHU).yI),([7]))));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{
if(!(false)){throw 0xE9170000;}
}
}
// buildExprValueStr
function ay0(aIj /*ast*/){
let aIk; // value
let aIl; // s
let aIo;
let aIp;
(aIk)=((aIj).akF);
(aIl)=({S:"{S:\""});
aIn:
for(aIo=(0),aIp=(((aIk).S.length)-(1));aIo<=aIp;aIo+=(1)){
(aIl)=({S:(aIl).S+((LK)(((aIk).S.charCodeAt(aIo)))).S});
}
(aIl)=({S:(aIl).S+({S:"\"}"}).S});
(eN)((am),([130,129,2]),(aIl));
}
// buildExprValueFloat
function ay2(aIs /*ast*/){
let aIt; // value
(aIt)=((v)(((aIs).ajb),([1])));
if((aIt).S===({S:"inf"}).S){
(eN)((am),([130,129,2]),({S:"Infinity"}));
}
else{
(eN)((am),([130,129,2]),(aIt));
}
}
// buildExprValueArray
function ay4(aIx /*ast*/){
let aIy; // first
let aIz; // items
(eN)((am),([130,129,2]),({S:"["}));
(aIy)=(true);
(aIz)=((aIx).aqf);
(qr)((aIz),([130,134]));
while(!((qt)((aIz),([130,134])))){
if(aIy){
(aIy)=(false);
(eN)((am),([130,129,2]),({S:"("}));
}
else{
(eN)((am),([130,129,2]),({S:",("}));
}
(Yy)(((qv)((aIz),([130,134]))));
(eN)((am),([130,129,2]),({S:")"}));
(r8)((aIz),([130,134]));
}
(eN)((am),([130,129,2]),({S:"]"}));
}
// buildExprRef
function ay6(aI4 /*ast*/){
let aI5; // ast2
let aI6; // info
let aIA; // arg
let aIC;
(aI5)=((aI4).qz);
(aI6)=((uO)((aI5)));
if(((aI5).qc)===(256)){
(eQ)((aj),([132,134]),(aI5));
(eN)((am),([130,129,2]),((aI6).vf));
}
else{
if(!(((aI5).qc)===(7))){throw 0xE9170000;}
(aIA)=(aI5);
aIC=(aIA).rp;
switch(aIC){
case 1:
if(!((aI6).uR)){
((aI6).uR)=(true);
(eN)((ao),([130,134]),(aIA));
}
break;
case 2:
break;
case 3:
if(!((aI6).uR)){
((aI6).uR)=(true);
(eN)((ap),([130,134]),(aIA));
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
if((aIA).sP){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((aI6).vf),([129,2]))).S}).S+({S:".$"}).S}));
}
else{
(eN)((am),([130,129,2]),((aI6).vf));
}
}
}
// _findBin
function ayT(aIO /*me_*/,aIP /*type*/,aIQ /*item*/){
let a_=0,b_=aIO.length-1,c_,m_,f_;
switch(aIP[0]){
case 0:
case 1:
case 2:
case 4:
case 5:
case 6:
case 7:
case 9:
f_=function(a,b){return a>b?1:a<b?-1:0};
break;
case 129:
f_=function(a,b){return a.S>b.S?1:a.S<b.S?-1:0};
break;
default:
break;
}
while (a_<=b_){
c_=~~((a_+b_)/2);
m_=f_(aIQ,aIO[c_]);
if(m_<0)b_=c_-1;
else if(m_>0)a_=c_+1;
else return c_;
}
return -1;
}
// pushDummyScope
function azH(aIR /*ast*/){
let aIS; // dummy
(aIS)=(new c8());
(wH)((aIS),(0),(null),(null),(true));
(bE)((((abm)((ah),([131,134]))).pY),([133,129,2,134]),({S:({S:"$"}).S+((v)((pK),([0]))).S}),(aIS));
(pK)=((pK)+(1));
((aIS).pY)=(new Map());
(wJ)((ah),([131,134]),(aIS));
((aIR).qU)=(aIS);
}
// obtainBlockName
function azI(aIU /*ast*/){
let aIV; // c
(aIV)=((wK)());
if((aIV)!==(0x0028)){
(pH)=(aIV);
((aIU).qX)=((xb)((true),(false)));
(On)((aIU),(true));
(Oj)((0x0028),(true));
}
else{
((aIU).qX)=({S:"$"});
}
}
// parseDummyBlock
function azN(aIZ /*outStat*/,aJa /*outTypeId*/,aJb /*typeId*/,aJc /*block_*/){
let aJd; // ast
let aJg; // stat
let aJm; // endFlag
let aJo;
let aJr;
let aJv;
let aJz;
let aJ4;
let aJ8;
let aJD;
let aJH;
let aJL;
(aJd)=(new yf());
(wH)((aJd),(66052),((MK)()),(null),(false));
((aJd).yc)=(null);
((aJd).yg)=({L:0,H:null,T:null,P:null});
(azH)((aJd));
((aJd).qX)=({S:"$"});
aJf:
while(true){
(aJg)=((OE)((aJc)));
if((aJg)===(null)){
if(pJ){
(aIZ.$)=(null);
(aJa.$)=(513);
break aJf;
}
else{
continue aJf;
}
}
(aJm)=(false);
aJo=aJb;
switch(aJo){
case 66049:
aJr=(aJg).qc;
switch(aJr){
case 520:
case 521:
case 513:
(aJm)=(true);
break;
}
break;
case 520:
aJv=(aJg).qc;
switch(aJv){
case 520:
case 521:
case 513:
(aJm)=(true);
break;
}
break;
case 521:
aJz=(aJg).qc;
switch(aJz){
case 520:
case 521:
(D)((65563),((MK)()),(null));
continue aJf;
break;
case 513:
(aJm)=(true);
break;
}
break;
case 522:
aJ4=(aJg).qc;
switch(aJ4){
case 522:
case 523:
case 513:
(aJm)=(true);
break;
}
break;
case 523:
aJ8=(aJg).qc;
switch(aJ8){
case 522:
case 523:
(D)((65564),((MK)()),(null));
continue aJf;
break;
case 513:
(aJm)=(true);
break;
}
break;
case 66051:
aJD=(aJg).qc;
switch(aJD){
case 524:
case 525:
(aJm)=(true);
break;
}
break;
case 524:
aJH=(aJg).qc;
switch(aJH){
case 524:
case 525:
case 520:
(aJm)=(true);
break;
}
break;
case 525:
aJL=(aJg).qc;
switch(aJL){
case 524:
case 525:
(D)((65565),((MK)()),(null));
continue aJf;
break;
case 513:
(aJm)=(true);
break;
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
if(aJm){
(aIZ.$)=(aJg);
(aJa.$)=((aJg).qc);
break aJf;
}
(eN)(((aJd).yg),([130,134]),(aJg));
}
(x2)((ah),([131,134]));
return aJd;
}
// makeBlockVar
function a0o(aJR /*pos*/){
let aJS; // arg
(aJS)=(new ro());
(wH)((aJS),(7),(aJR),(null),(false));
((aJS).rp)=(3);
((aJS).sP)=(false);
((aJS).sA)=(null);
((aJS).yb)=(null);
return aJS;
}
// makePrimValue
function a16(aJT /*pos*/,aJU /*kind*/,aJV /*value*/){
let aJW; // expr
let aJY; // type
(aJW)=(new yF());
(Qe)((aJW),(67585),(aJT));
(aJY)=(new xZ());
(wH)((aJY),(1026),(aJT),(null),(false));
((aJY).ya)=(aJU);
((aJW).yL)=(aJY);
((aJW).yI)=(aJV);
return aJW;
}
// parseExprOr
function a3k(){
let aJZ; // ast
let aKd; // row
let aKe; // col
let aKf; // c
let aKi; // ast2
(aJZ)=((aKa)());
aKc:
while(true){
(aKd)=(pF);
(aKe)=(pG);
(aKf)=((wK)());
if((aKf)===(0x007C)){
(aKi)=(new zL());
(Qe)((aKi),(2050),((wI)((ag),(aKd),(aKe))));
((aKi).zM)=(8);
((aKi).zP)=(aJZ);
((aKi).zQ)=((aKa)());
(aJZ)=(aKi);
}
else{
(pH)=(aKf);
break aKc;
}
}
return aJZ;
}
// addSpecialFunc
function a5f(aKk /*class_*/,aKl /*name*/){
let aKm; // ast
let aKo; // me_
let aKq; // type
let aKs; // item
let aKt; // ptr
let aKv; // items
let aKy; // item2
(aKm)=(new c7());
(xP)((aKm),(256),((aKk).ql));
((aKm).qX)=(aKl);
((aKm).qi)=(0);
((aKm).qj)=({L:0,H:null,T:null,P:null});
((aKm).qg)=({L:0,H:null,T:null,P:null});
((aKm).qh)=(null);
((aKm).tv)=({L:0,H:null,T:null,P:null});
(aKo)=(new ro());
(xP)((aKo),(7),((aKk).ql));
((aKo).rp)=(2);
((aKo).sP)=(false);
((aKo).yb)=(null);
(aKq)=(new Oq());
(xP)((aKq),(66565),((aKk).ql));
((aKq).qz)=(aKk);
((aKo).sA)=(aKq);
(eN)(((aKm).qg),([130,134]),(aKo));
(aKs)=(new tV());
((aKs).Pm)=(true);
((aKs).tX)=(aKm);
((aKs).Pn)=(null);
(aKt)=((aKk).qz);
while(((aKt).qz)!==(null)){
(aKt)=((aKt).qz);
}
(aKv)=((aKt).tm);
(qr)((aKv),([130,134]));
aKx:
while(!((qt)((aKv),([130,134])))){
(aKy)=((qv)((aKv),([130,134])));
if((((aKy).tX).qX).S===(aKl).S){
((aKs).Pn)=(aKy);
break aKx;
}
(r8)((aKv),([130,134]));
}
if(!(((aKs).Pn)!==(null))){throw 0xE9170000;}
((aKs).Pl)=(((aKs).Pn).Pl);
(eN)(((aKk).tm),([130,134]),(aKs));
return aKm;
}
// makeMeDot
function a5G(aK1 /*class_*/,aK2 /*arg*/,aK3 /*name*/){
let aK4; // ast
let aK6; // me_
let aK8; // type
(aK4)=(new Sm());
(yx)((aK4),(2059),((aK1).ql));
((aK4).arc)=(aK3);
((aK4).arp)=(null);
(aK6)=(new yw());
(yx)((aK6),(2062),((aK1).ql));
((aK6).q0)=({S:"me"});
((aK6).qz)=(aK2);
(aK8)=(new Oq());
(xP)((aK8),(66565),((aK1).ql));
((aK8).qz)=(aK1);
((aK6).yL)=(aK8);
((aK4).apW)=(aK6);
return aK4;
}
// makeTypeId
function aEy(aK9 /*type*/){
let aKA; // result
let aKB; // first
let aKC; // items
(aKA)=({S:"["});
(aKB)=(true);
(aKC)=((aKD)((aK9)));
(qr)((aKC),([130,0]));
while(!((qt)((aKC),([130,0])))){
if(aKB){
(aKB)=(false);
}
else{
(aKA)=({S:(aKA).S+({S:","}).S});
}
(aKA)=({S:(aKA).S+((v)(((qv)((aKC),([130,0]))),([0]))).S});
(r8)((aKC),([130,0]));
}
(aKA)=({S:(aKA).S+({S:"]"}).S});
return aKA;
}
// parseExprAnd
function aKa(){
let aKL; // ast
let aKP; // row
let aKQ; // col
let aKR; // c
let aKU; // ast2
(aKL)=((aKM)());
aKO:
while(true){
(aKP)=(pF);
(aKQ)=(pG);
(aKR)=((wK)());
if((aKR)===(0x0026)){
(aKU)=(new zL());
(Qe)((aKU),(2050),((wI)((ag),(aKP),(aKQ))));
((aKU).zM)=(9);
((aKU).zP)=(aKL);
((aKU).zQ)=((aKM)());
(aKL)=(aKU);
}
else{
(pH)=(aKR);
break aKO;
}
}
return aKL;
}
// getTypeId
function aKD(aKW /*type*/){
let aKX; // result
(aKX)=({L:0,H:null,T:null,P:null});
(aKY)((aKW),(aKX));
return aKX;
}
// parseExprCmp
function aKM(){
let aKZ; // ast
let aLd; // row
let aLe; // col
let aLf; // c
let aLh;
let aLk;
let aLm; // ast2
let aLp;
let aLr; // ast2
let aLt; // ast2
let aLv; // ast2
let aLx; // ast2
let aLz; // ast2
let aL5;
let aL7; // ast2
let aL9; // ast2
let aLB; // ast2
(aKZ)=((aLa)());
aLc:
while(true){
(aLd)=(pF);
(aLe)=(pG);
(aLf)=((wK)());
aLh=aLf;
switch(aLh){
case 0x003C:
(aLf)=((xw)());
aLk=aLf;
switch(aLk){
case 0x003D:
(aLm)=(new zL());
(Qe)((aLm),(2050),((wI)((ag),(aLd),(aLe))));
((aLm).zM)=(12);
((aLm).zP)=(aKZ);
((aLm).zQ)=((aLa)());
(aKZ)=(aLm);
break;
case 0x003E:
(aLf)=((xw)());
aLp=aLf;
switch(aLp){
case 0x0026:
(aLr)=(new zL());
(Qe)((aLr),(2050),((wI)((ag),(aLd),(aLe))));
((aLr).zM)=(17);
((aLr).zP)=(aKZ);
((aLr).zQ)=((aLa)());
(aKZ)=(aLr);
break;
case 0x0024:
(aLt)=(new RY());
(Qe)((aLt),(2054),((wI)((ag),(aLd),(aLe))));
((aLt).aoi)=(2);
((aLt).aoa)=(aKZ);
((aLt).aod)=((O8)());
(aKZ)=(aLt);
break;
default:
(pH)=(aLf);
(aLv)=(new zL());
(Qe)((aLv),(2050),((wI)((ag),(aLd),(aLe))));
((aLv).zM)=(15);
((aLv).zP)=(aKZ);
((aLv).zQ)=((aLa)());
(aKZ)=(aLv);
break;
}
break;
default:
(pH)=(aLf);
(aLx)=(new zL());
(Qe)((aLx),(2050),((wI)((ag),(aLd),(aLe))));
((aLx).zM)=(10);
((aLx).zP)=(aKZ);
((aLx).zQ)=((aLa)());
(aKZ)=(aLx);
break;
}
break;
case 0x003E:
(aLz)=(new zL());
(Qe)((aLz),(2050),((wI)((ag),(aLd),(aLe))));
(aLf)=((xw)());
if((aLf)===(0x003D)){
((aLz).zM)=(13);
}
else{
(pH)=(aLf);
((aLz).zM)=(11);
}
((aLz).zP)=(aKZ);
((aLz).zQ)=((aLa)());
(aKZ)=(aLz);
break;
case 0x003D:
(aLf)=((xw)());
aL5=aLf;
switch(aL5){
case 0x0026:
(aL7)=(new zL());
(Qe)((aL7),(2050),((wI)((ag),(aLd),(aLe))));
((aL7).zM)=(16);
((aL7).zP)=(aKZ);
((aL7).zQ)=((aLa)());
(aKZ)=(aL7);
break;
case 0x0024:
(aL9)=(new RY());
(Qe)((aL9),(2054),((wI)((ag),(aLd),(aLe))));
((aL9).aoi)=(1);
((aL9).aoa)=(aKZ);
((aL9).aod)=((O8)());
(aKZ)=(aL9);
break;
default:
(pH)=(aLf);
(aLB)=(new zL());
(Qe)((aLB),(2050),((wI)((ag),(aLd),(aLe))));
((aLB).zM)=(14);
((aLB).zP)=(aKZ);
((aLB).zQ)=((aLa)());
(aKZ)=(aLB);
break;
}
break;
default:
(pH)=(aLf);
break aLc;
break;
}
}
return aKZ;
}
// makeTypeIdRecursion
function aKY(aLD /*type*/,aLE /*output*/){
let aLQ;
let aMf;
if((s9)((aLD))){
(eN)((aLE),([130,0]),(0));
return;
}
if((aiO)((aLD))){
(eN)((aLE),([130,0]),(1));
return;
}
if((US)((aLD))){
(eN)((aLE),([130,0]),(2));
return;
}
if((aje)((aLD))){
(eN)((aLE),([130,0]),(3));
return;
}
if(((aLD).qc)===(1025)){
aLQ=(aLD).A2;
switch(aLQ){
case 1:
(eN)((aLE),([130,0]),(4));
break;
case 2:
(eN)((aLE),([130,0]),(5));
break;
case 4:
(eN)((aLE),([130,0]),(6));
break;
case 8:
(eN)((aLE),([130,0]),(7));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
return;
}
if(((aLD).qc)===(66562)){
(eN)((aLE),([130,0]),(8));
return;
}
if((UT)((aLD))){
(eN)((aLE),([130,0]),(9));
return;
}
if(((aLD).qc)===(66561)){
(eN)((aLE),([130,0]),(129));
(aKY)(((aLD).Az),(aLE));
return;
}
if(((aLD).qc)===(66563)){
aMf=(aLD).AV;
switch(aMf){
case 0:
(eN)((aLE),([130,0]),(130));
break;
case 1:
(eN)((aLE),([130,0]),(131));
break;
case 2:
(eN)((aLE),([130,0]),(132));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(aKY)(((aLD).AX),(aLE));
return;
}
if(((aLD).qc)===(66564)){
(eN)((aLE),([130,0]),(133));
(aKY)(((aLD).Be),(aLE));
(aKY)(((aLD).Bf),(aLE));
return;
}
if(!((T9)((aLD)))){throw 0xE9170000;}
(eN)((aLE),([130,0]),(134));
}
// parseExprCat
function aLa(){
let aMm; // ast
let aMq; // row
let aMr; // col
let aMs; // c
let aMv; // ast2
(aMm)=((aMn)());
aMp:
while(true){
(aMq)=(pF);
(aMr)=(pG);
(aMs)=((wK)());
if((aMs)===(0x007E)){
(aMv)=(new zL());
(Qe)((aMv),(2050),((wI)((ag),(aMq),(aMr))));
((aMv).zM)=(18);
((aMv).zP)=(aMm);
((aMv).zQ)=((aMn)());
(aMm)=(aMv);
}
else{
(pH)=(aMs);
break aMp;
}
}
return aMm;
}
// parseExprAdd
function aMn(){
let aMx; // ast
let aM1; // row
let aM2; // col
let aM3; // c
let aM5;
let aM7; // ast2
let aM9; // ast2
(aMx)=((aMy)());
aM0:
while(true){
(aM1)=(pF);
(aM2)=(pG);
(aM3)=((wK)());
aM5=aM3;
switch(aM5){
case 0x002B:
(aM7)=(new zL());
(Qe)((aM7),(2050),((wI)((ag),(aM1),(aM2))));
((aM7).zM)=(19);
((aM7).zP)=(aMx);
((aM7).zQ)=((aMy)());
(aMx)=(aM7);
break;
case 0x002D:
(aM9)=(new zL());
(Qe)((aM9),(2050),((wI)((ag),(aM1),(aM2))));
((aM9).zM)=(20);
((aM9).zP)=(aMx);
((aM9).zQ)=((aMy)());
(aMx)=(aM9);
break;
default:
(pH)=(aM3);
break aM0;
break;
}
}
return aMx;
}
// parseExprMul
function aMy(){
let aMB; // ast
let aMF; // row
let aMG; // col
let aMH; // c
let aMJ;
let aML; // ast2
let aMN; // ast2
let aMP; // ast2
(aMB)=((aMC)());
aME:
while(true){
(aMF)=(pF);
(aMG)=(pG);
(aMH)=((wK)());
aMJ=aMH;
switch(aMJ){
case 0x002A:
(aML)=(new zL());
(Qe)((aML),(2050),((wI)((ag),(aMF),(aMG))));
((aML).zM)=(21);
((aML).zP)=(aMB);
((aML).zQ)=((aMC)());
(aMB)=(aML);
break;
case 0x002F:
(aMN)=(new zL());
(Qe)((aMN),(2050),((wI)((ag),(aMF),(aMG))));
((aMN).zM)=(22);
((aMN).zP)=(aMB);
((aMN).zQ)=((aMC)());
(aMB)=(aMN);
break;
case 0x0025:
(aMP)=(new zL());
(Qe)((aMP),(2050),((wI)((ag),(aMF),(aMG))));
((aMP).zM)=(23);
((aMP).zP)=(aMB);
((aMP).zQ)=((aMC)());
(aMB)=(aMP);
break;
default:
(pH)=(aMH);
break aME;
break;
}
}
return aMB;
}
// parseExprPlus
function aMC(){
let aMR; // ast
let aMV; // row
let aMW; // col
let aMX; // c
let aNb;
let aNd; // ast2
let aNn; // ast2
let aNp; // ast2
let aNr; // ast2
let aNt;
(aMR)=((aMS)());
if((aMR)!==(null)){
return aMR;
}
(aMV)=(pF);
(aMW)=(pG);
(aMX)=((wK)());
if((aMX)===(0x0023)){
(aMX)=((xw)());
aNb=aMX;
switch(aNb){
case 0x005B:
(aNd)=(new RV());
(Qe)((aNd),(2053),((wI)((ag),(aMV),(aMW))));
((aNd).anF)=({L:0,H:null,T:null,P:null});
aNf:
while(true){
(eN)(((aNd).anF),([130,134]),((PZ)()));
(aMX)=((wK)());
if((aMX)===(0x0000)){
break aNf;
}
if((aMX)===(0x005D)){
break aNf;
}
if((aMX)!==(0x002C)){
(Oe)((0x002C),(aMX));
return null;
}
}
((aNd).anN)=((O8)());
(aMR)=(aNd);
break;
case 0x0023:
(aNn)=(new RK());
(Qe)((aNn),(2049),((wI)((ag),(aMV),(aMW))));
((aNn).aiL)=(3);
((aNn).aiF)=((aMC)());
(aMR)=(aNn);
break;
default:
(pH)=(aMX);
(aNp)=(new RS());
(Qe)((aNp),(2052),((wI)((ag),(aMV),(aMW))));
((aNp).an3)=((O8)());
(aMR)=(aNp);
break;
}
}
else{
(aNr)=(new RK());
(Qe)((aNr),(2049),((wI)((ag),(aMV),(aMW))));
aNt=aMX;
switch(aNt){
case 0x002B:
((aNr).aiL)=(0);
break;
case 0x002D:
((aNr).aiL)=(1);
break;
case 0x0021:
((aNr).aiL)=(2);
break;
case 0x005E:
((aNr).aiL)=(4);
break;
default:
(D)((65569),((aNr).ql),([((ML)((aMX)))]));
(xv)((aMX));
return null;
break;
}
((aNr).aiF)=((aMC)());
(aMR)=(aNr);
}
return aMR;
}
// parseExprPow
function aMS(){
let aNz; // ast
let aN3; // row
let aN4; // col
let aN5; // c
let aN8; // ast2
(aNz)=((aN0)());
if((aNz)===(null)){
return aNz;
}
(aN3)=(pF);
(aN4)=(pG);
(aN5)=((wK)());
if((aN5)===(0x005E)){
(aN8)=(new zL());
(Qe)((aN8),(2050),((wI)((ag),(aN3),(aN4))));
((aN8).zM)=(24);
((aN8).zP)=(aNz);
((aN8).zQ)=((aMC)());
(aNz)=(aN8);
}
else{
(pH)=(aN5);
}
return aNz;
}
// parseExprCall
function aN0(){
let aNA; // ast
let aNG; // row
let aNH; // col
let aNI; // c
let aNK;
let aNM; // ast2
let aNR; // arg
let aNZ; // ast3
let aOi; // ast2
let aOk; // ast2
let aOn;
let aOp; // ast2
let aOr; // ast2
let aOt; // ast2
(aNA)=((aNB)());
if((aNA)===(null)){
return aNA;
}
aNF:
while(true){
(aNG)=(pF);
(aNH)=(pG);
(aNI)=((wK)());
aNK=aNI;
switch(aNK){
case 0x0028:
if(!((aNA)!==(null))){throw 0xE9170000;}
(aNM)=(new yv());
(Qe)((aNM),(2057),((wI)((ag),(aNG),(aNH))));
((aNM).y1)=(aNA);
((aNM).yy)=({L:0,H:null,T:null,P:null});
(aNI)=((wK)());
if((aNI)!==(0x0029)){
(pH)=(aNI);
aNQ:
while(true){
(aNR)=(new za());
((aNR).zc)=(false);
(aNI)=((wK)());
if((aNI)===(0x0026)){
((aNR).zb)=(true);
(aNI)=((wK)());
if(((aNI)===(0x002C))||((aNI)===(0x0029))){
((aNR).zc)=(true);
}
}
else{
((aNR).zb)=(false);
}
(pH)=(aNI);
if((aNR).zc){
(aNZ)=(new yw());
(Qe)((aNZ),(2062),((aNM).ql));
((aNZ).q0)=({S:"$"});
((aNZ).qz)=((a0o)(((aNZ).ql)));
((aNR).zf)=(aNZ);
}
else{
((aNR).zf)=((PZ)());
}
(eN)(((aNM).yy),([130,134]),(aNR));
(aNI)=((wK)());
if((aNI)===(0x0000)){
break aNQ;
}
if((aNI)===(0x0029)){
break aNQ;
}
if((aNI)!==(0x002C)){
(Oe)((0x002C),(aNI));
return null;
}
}
}
(aNA)=(aNM);
break;
case 0x005B:
if(!((aNA)!==(null))){throw 0xE9170000;}
(aOi)=(new Sj());
(Qe)((aOi),(2058),((wI)((ag),(aNG),(aNH))));
((aOi).aqE)=(aNA);
((aOi).aqJ)=((PZ)());
(Oj)((0x005D),(true));
(aNA)=(aOi);
break;
case 0x002E:
if(!((aNA)!==(null))){throw 0xE9170000;}
(aOk)=(new Sm());
(Qe)((aOk),(2059),((wI)((ag),(aNG),(aNH))));
((aOk).apW)=(aNA);
((aOk).arc)=((xb)((true),(false)));
((aOk).arp)=(null);
(aNA)=(aOk);
break;
case 0x0024:
if(!((aNA)!==(null))){throw 0xE9170000;}
(aNI)=((xw)());
aOn=aNI;
switch(aOn){
case 0x003E:
(aOp)=(new Sb());
(Qe)((aOp),(2055),((wI)((ag),(aNG),(aNH))));
((aOp).apw)=(aNA);
((aOp).ap2)=((O8)());
(aNA)=(aOp);
break;
case 0x003C:
(aOr)=(new Se());
(Qe)((aOr),(2056),((wI)((ag),(aNG),(aNH))));
((aOr).ap7)=(aNA);
((aOr).apC)=((O8)());
((aOr).apD)=((a16)(((aOr).ql),(0),(0x0000000000000000)));
(aNA)=(aOr);
break;
default:
(pH)=(aNI);
(aOt)=(new RY());
(Qe)((aOt),(2054),((wI)((ag),(aNG),(aNH))));
((aOt).aoi)=(0);
((aOt).aoa)=(aNA);
((aOt).aod)=((O8)());
(aNA)=(aOt);
break;
}
break;
default:
(pH)=(aNI);
break aNF;
break;
}
}
return aNA;
}
// parseExprValue
function aNB(){
let aOv; // row
let aOw; // col
let aOx; // c
let aOy; // pos
let aO0;
let aO2; // buf
let aO3; // len
let aO4; // esc
let aOD; // cat
let aOF; // cat2
let aOI; // call
let aOK; // dot
let aPb; // buf
let aPc; // set
let aPd; // esc
let aPv; // ast
let aPz; // ast
let aP4; // expr
let aPE; // id
let aPF; // expr
let aPH; // type
let aPP; // id
let aPR;
let aPX; // ast
let aPZ; // type
let aQd; // ast
let aON;
let aOO;
let aOX;
let aOY;
(aOv)=(pF);
(aOw)=(pG);
(aOx)=((wK)());
(aOy)=((wI)((ag),(aOv),(aOw)));
aO0=aOx;
switch(aO0){
case 0x0022:
(aO2)=({S:"\0".repeat(1024)});
(aO3)=(0);
(aO4)=(false);
aO6:
while(true){
(aOx)=((afM)());
if((aOx)===(0x0000)){
(D)((65573),(aOy),(null));
return null;
}
if(aO4){
if((aOx)===(0x007B)){
(aOD)=(new zL());
(Qe)((aOD),(2050),(aOy));
((aOD).zM)=(18);
(aOF)=(new zL());
(Qe)((aOF),(2050),(aOy));
((aOF).zM)=(18);
((aOF).zP)=((aOG)((aOy),((p9)((aO2),([129,2]),(0),(aO3)))));
(aOI)=(new yv());
(Qe)((aOI),(2057),(aOy));
((aOI).yy)=({L:0,H:null,T:null,P:null});
(aOK)=(new Sm());
(Qe)((aOK),(2059),(aOy));
((aOK).apW)=((PZ)());
((aOK).arc)=({S:"toStr"});
((aOK).arp)=(null);
((aOI).y1)=(aOK);
((aOF).zQ)=(aOI);
(Oj)((0x007D),(false));
((aOD).zP)=(aOF);
(pH)=(0x0022);
((aOD).zQ)=((aNB)());
return aOD;
}
if((aO3)===(1024)){
(D)((65570),(aOy),([(aO2)]));
(xv)((aOx));
return null;
}
(aO2).S=(aON=(aO3),(aO2).S.slice(0,aON)+String.fromCharCode((aOP)((aOx)))+(aO2).S.slice(aON+1));
(aO3)=((aO3)+(1));
(aO4)=(false);
continue aO6;
}
if((aOx)===(0x0022)){
break aO6;
}
if((aOx)===(0x005C)){
(aO4)=(true);
continue aO6;
}
if((aO3)===(1024)){
(D)((65570),(aOy),([(aO2)]));
(xv)((aOx));
return null;
}
(aO2).S=(aOX=(aO3),(aO2).S.slice(0,aOX)+String.fromCharCode(aOx)+(aO2).S.slice(aOX+1));
(aO3)=((aO3)+(1));
}
return (aOG)((aOy),((p9)((aO2),([129,2]),(0),(aO3))));
break;
case 0x0027:
(aPb)=(0x0000);
(aPc)=(false);
(aPd)=(false);
aPf:
while(true){
(aOx)=((afM)());
if((aOx)===(0x0000)){
(D)((65573),(aOy),(null));
return null;
}
if(aPd){
if(aPc){
(D)((65574),(aOy),([((ML)((aPb)))]));
(xv)((aOx));
return null;
}
(aPb)=((aOP)((aOx)));
(aPc)=(true);
(aPd)=(false);
continue aPf;
}
if((aOx)===(0x0027)){
break aPf;
}
if((aOx)===(0x005C)){
(aPd)=(true);
continue aPf;
}
if(aPc){
(D)((65574),(aOy),([((ML)((aPb)))]));
(xv)((aOx));
return null;
}
(aPb)=(aOx);
(aPc)=(true);
}
if(!(aPc)){
(D)((65575),(aOy),(null));
(xv)((aOx));
return null;
}
return (a16)((aOy),(2),(aPb));
break;
case 0x0028:
(aPv)=((PZ)());
(aOx)=((wK)());
if((aOx)!==(0x0029)){
(D)((65576),(aOy),(null));
(xv)((aOx));
return null;
}
return aPv;
break;
case 0x005B:
(aPz)=(new S2());
(Qe)((aPz),(2060),(aOy));
((aPz).aqf)=({L:0,H:null,T:null,P:null});
(aOx)=((wK)());
if((aOx)!==(0x005D)){
(pH)=(aOx);
aP3:
while(true){
(aP4)=((PZ)());
if((aP4)!==(null)){
(eN)(((aPz).aqf),([130,134]),(aP4));
}
(aOx)=((wK)());
if((aOx)===(0x0000)){
break aP3;
}
if((aOx)===(0x005D)){
break aP3;
}
if((aOx)!==(0x002C)){
(Oe)((0x002C),(aOx));
return null;
}
}
}
return aPz;
break;
case 0x0025:
(aPE)=((xb)((false),(false)));
(aPF)=(new Sw());
(Qe)((aPF),(67587),(aOy));
(aPH)=(new aPI());
(wH)((aPH),(1028),(aOy),(null),(false));
((aPF).yL)=(aPH);
((aPF).akb)=(aPE);
return aPF;
break;
default:
if(((0x0030)<=(aOx))&&((aOx)<=(0x0039))){
return (aPM)((aOv),(aOw),(aOx));
}
if(((((((0x0061)<=(aOx))&&((aOx)<=(0x007A)))||(((0x0041)<=(aOx))&&((aOx)<=(0x005A))))||((aOx)===(0x005F)))||((aOx)===(0x0040)))||((aOx)===(0x005C))){
(pH)=(aOx);
(aPP)=((xb)((true),(true)));
aPR=aPP;
if(aPR.S===({S:"false"}).S){
return (a16)((aOy),(3),(0x0000000000000000));
}
else if(aPR.S===({S:"true"}).S){
return (a16)((aOy),(3),(0x0000000000000001));
}
else if(aPR.S===({S:"inf"}).S){
return (aPV)((aOy),(Infinity));
}
else if(aPR.S===({S:"null"}).S){
(aPX)=(new yG());
(Qe)((aPX),(67584),(aOy));
(aPZ)=(new TE());
(wH)((aPZ),(1027),(aOy),(null),(false));
((aPX).yL)=(aPZ);
return aPX;
}
else if(aPR.S===({S:"dbg"}).S){
return (a16)((aOy),(3),((aY)?(0x0000000000000000):(0x0000000000000001)));
}
else if(aPR.S===({S:"env"}).S){
return (a16)((aOy),(0),(bL));
}
else{(aQd)=(new yw());
(Qe)((aQd),(2062),(aOy));
(Oi)((aQd),(aPP));
return aQd;
}
}
break;
}
(pH)=(aOx);
return null;
}
// makeStrValue
function aOG(aQe /*pos*/,aQf /*value*/){
let aQg; // expr
let aQi; // type
let aQk; // type2
(aQg)=(new St());
(Qe)((aQg),(67586),(aQe));
(aQi)=(new Ax());
(wH)((aQi),(66561),(aQe),(null),(false));
(aQk)=(new xZ());
(wH)((aQk),(1026),(aQe),(null),(false));
((aQk).ya)=(2);
((aQi).Az)=(aQk);
((aQg).yL)=(aQi);
((aQg).akF)=(aQf);
return aQg;
}
// escChar
function aOP(aQl /*c*/){
let aQn;
let aQt; // buf
let aQ0;
let aQ8;
let aQu;
let aQv;
let aQw;
let aQx;
let aQ1;
let aQ4;
let aQ5;
let aQ6;
let aQ7;
aQn=aQl;
switch(aQn){
case 0x0022:
case 0x0027:
case 0x005C:
return aQl;
break;
case 0x0030:
return 0x0000;
break;
case 0x006E:
return 0x000A;
break;
case 0x0074:
return 0x0009;
break;
case 0x0075:
(aQt)=({S:"\0".repeat(6)});
(aQt).S=(aQu=(0),(aQt).S.slice(0,aQu)+String.fromCharCode(0x0030)+(aQt).S.slice(aQu+1));
(aQt).S=(aQw=(1),(aQt).S.slice(0,aQw)+String.fromCharCode(0x0078)+(aQt).S.slice(aQw+1));
aQz:
for(aQ0=(0),aQ1=(3);aQ0<=aQ1;aQ0+=(1)){
(aQl)=((afM)());
if(!((((0x0030)<=(aQl))&&((aQl)<=(0x0039)))||(((0x0041)<=(aQl))&&((aQl)<=(0x0046))))){
(D)((65572),((MK)()),(null));
return 0x0075;
}
(aQt).S=(aQ4=((2)+(aQ0)),(aQt).S.slice(0,aQ4)+String.fromCharCode(aQl)+(aQt).S.slice(aQ4+1));
}
return (aQ6=(cb)((aQt),(aQ7={$:(aQ8)},aQ7)),(aQ8)=aQ7.$,aQ6);
break;
default:
(D)((65571),((MK)()),([((ML)((aQl)))]));
return aQl;
break;
}
}
// parseExprNumber
function aPM(aQA /*row*/,aQB /*col*/,aQC /*c*/){
let aQD; // ast
let aQE; // pos
let aQF; // buf
let aQG; // len
let aQH; // base
let aQI; // changeBase
let aQJ; // floatType
let aQK; // byteSize
let aQO;
let aRA; // success
let aRB; // value
let aRH; // ast2
let aRM;
let aRU; // value
let aRV; // success
let aSi; // ast2
let aSl; // type
let aSq; // type
let aQZ;
let aRa;
let aRf;
let aRg;
let aRr;
let aRs;
let aRy;
let aRz;
let aR6;
let aR7;
let aRC;
let aRE;
let aRY;
let aSa;
let aSc;
let aSd;
(aQD)=(null);
(aQE)=((wI)((ag),(aQA),(aQB)));
(aQF)=({S:"\0".repeat(1024)});
(aQG)=(0);
(aQH)=(10);
(aQI)=(false);
(aQJ)=(false);
(aQK)=(0);
aQM:
while(true){
aQO=aQC;
if(aQO===(0x0078)){
if((aQI)||(aQJ)){
(D)((65577),(aQE),([({S:"x"})]));
(xv)((aQC));
return null;
}
if(((aQG)!==(1))||(((aQF).S.charCodeAt(0))!==(0x0030))){
(D)((65579),(aQE),(null));
(xv)((aQC));
return null;
}
(aQG)=(0);
(aQH)=(16);
(aQI)=(true);
}
else if(aQO===(0x002E)){
if((aQI)||(aQJ)){
(D)((65577),(aQE),([({S:"."})]));
(xv)((aQC));
return null;
}
if((aQG)===(1024)){
(D)((65578),(aQE),([((p9)((aQF),([129,2]),(0),(aQG)))]));
(xv)((aQC));
return null;
}
(aQF).S=(aQZ=(aQG),(aQF).S.slice(0,aQZ)+String.fromCharCode(aQC)+(aQF).S.slice(aQZ+1));
(aQG)=((aQG)+(1));
(aQJ)=(true);
}
else if((0x0030)<=aQO&&aQO<=(0x0039)||(0x0041)<=aQO&&aQO<=(0x0046)){
if((aQG)===(1024)){
(D)((65578),(aQE),([((p9)((aQF),([129,2]),(0),(aQG)))]));
(xv)((aQC));
return null;
}
(aQF).S=(aRf=(aQG),(aQF).S.slice(0,aRf)+String.fromCharCode(aQC)+(aQF).S.slice(aRf+1));
(aQG)=((aQG)+(1));
}
else{(pH)=(aQC);
break aQM;
}
(aQC)=((xw)());
}
if(((aQG)===(0))||(((aQF).S.charCodeAt((aQG)-(1)))===(0x002E))){
(D)((65577),(aQE),([({S:"."})]));
(xv)(((xw)()));
return null;
}
if(aQJ){
(aQC)=((xw)());
if((aQC)===(0x0065)){
if((aQG)===(1024)){
(D)((65578),(aQE),([((p9)((aQF),([129,2]),(0),(aQG)))]));
(xv)((aQC));
return null;
}
(aQF).S=(aRr=(aQG),(aQF).S.slice(0,aRr)+String.fromCharCode(aQC)+(aQF).S.slice(aRr+1));
(aQG)=((aQG)+(1));
(aQC)=((xw)());
if(((aQC)!==(0x002B))&&((aQC)!==(0x002D))){
(D)((65580),(aQE),(null));
(xv)((aQC));
return null;
}
if((aQG)===(1024)){
(D)((65578),(aQE),([((p9)((aQF),([129,2]),(0),(aQG)))]));
(xv)((aQC));
return null;
}
(aQF).S=(aRy=(aQG),(aQF).S.slice(0,aRy)+String.fromCharCode(aQC)+(aQF).S.slice(aRy+1));
(aQG)=((aQG)+(1));
(aQC)=((xw)());
if(!(((0x0030)<=(aQC))&&((aQC)<=(0x0039)))){
(D)((65580),(aQE),(null));
(xv)((aQC));
return null;
}
do{
if((aQG)===(1024)){
(D)((65578),(aQE),([((p9)((aQF),([129,2]),(0),(aQG)))]));
(xv)((aQC));
return null;
}
(aQF).S=(aR6=(aQG),(aQF).S.slice(0,aR6)+String.fromCharCode(aQC)+(aQF).S.slice(aR6+1));
(aQG)=((aQG)+(1));
(aQC)=((xw)());
}while(((0x0030)<=(aQC))&&((aQC)<=(0x0039)));
}
(pH)=(aQC);
(aRA)=(false);
(aRB)=((aRC=(aRD)(((p9)((aQF),([129,2]),(0),(aQG))),(aRE={$:(aRA)},aRE)),(aRA)=aRE.$,aRC));
if(!(aRA)){
(D)((65581),(aQE),([((p9)((aQF),([129,2]),(0),(aQG)))]));
(xv)(((xw)()));
return null;
}
(aRH)=(new Sz());
(Qe)((aRH),(67588),(aQE));
((aRH).ajb)=(aRB);
(aQD)=(aRH);
}
else{
(aQC)=((xw)());
if((aQC)===(0x0062)){
(aQC)=((xw)());
aRM=aQC;
switch(aRM){
case 0x0038:
(aQK)=(1);
break;
case 0x0031:
(Oj)((0x0036),(false));
(aQK)=(2);
break;
case 0x0033:
(Oj)((0x0032),(false));
(aQK)=(4);
break;
case 0x0036:
(Oj)((0x0034),(false));
(aQK)=(8);
break;
default:
(D)((65582),(aQE),([((p9)((aQF),([129,2]),(0),(aQG)))]));
(xv)((aQC));
break;
}
}
else{
(pH)=(aQC);
}
(aRU)=(0x0000000000000000);
(aRV)=(false);
if((aQH)===(10)){
(aRU)=((aRY=(aRZ)(((p9)((aQF),([129,2]),(0),(aQG))),(aSa={$:(aRV)},aSa)),(aRV)=aSa.$,aRY));
}
else{
if(!((aQH)===(16))){throw 0xE9170000;}
(aRU)=((aSc=(aRZ)(({S:({S:"0x"}).S+((p9)((aQF),([129,2]),(0),(aQG))).S}),(aSd={$:(aRV)},aSd)),(aRV)=aSd.$,aSc));
}
if(!(aRV)){
(D)((65583),(aQE),([((p9)((aQF),([129,2]),(0),(aQG)))]));
(xv)(((xw)()));
return null;
}
if((((((aQK)===(1))&&((aRU)>(0x00000000000000FF)))||(((aQK)===(2))&&((aRU)>(0x000000000000FFFF))))||(((aQK)===(4))&&((aRU)>(0x00000000FFFFFFFF))))||(((aQK)===(0))&&((aRU)>(0x7FFFFFFFFFFFFFFF)))){
(D)((65583),(aQE),([((p9)((aQF),([129,2]),(0),(aQG)))]));
(xv)(((xw)()));
return null;
}
(aSi)=(new yF());
(Qe)((aSi),(67585),(aQE));
((aSi).yI)=(aRU);
(aQD)=(aSi);
}
if((aQK)===(0)){
(aSl)=(new xZ());
(wH)((aSl),(1026),(aQE),(null),(false));
if(aQJ){
((aSl).ya)=(1);
}
else{
((aSl).ya)=(0);
}
((aQD).yL)=(aSl);
}
else{
(aSq)=(new A1());
(wH)((aSq),(1025),(aQE),(null),(false));
((aSq).A2)=(aQK);
((aQD).yL)=(aSq);
}
return aQD;
}
// makeFloatValue
function aPV(aSr /*pos*/,aSs /*value*/){
let aSt; // expr
let aSv; // type
(aSt)=(new Sz());
(Qe)((aSt),(67588),(aSr));
(aSv)=(new xZ());
(wH)((aSv),(1026),(aSr),(null),(false));
((aSv).ya)=(1);
((aSt).yL)=(aSv);
((aSt).ajb)=(aSs);
return aSt;
}
// _toFloat
function aRD(aSw /*me_*/,aSx /*success*/){
let r_=Number(aSw.S);
aSx.$=!isNaN(r_);
return r_;
}
// _toBit64
function aRZ(aSy /*me_*/,aSz /*success*/){
if(aSy.S.length>=2&&aSy.S[0]==="0"&&aSy.S[1]==="x"){
let s_=aSy.S.slice(2),r_=Number(aSy.S);
aSz.$=!isNaN(r_);
return parseInt(s_,16);
}else{
let r_=Number(aSy.S);
aSz.$=!isNaN(r_);
return parseInt(aSy.S,10);
}
}
// Class
function cA(){
Object.call(this);
aS0(this);
}
cA.prototype = Object.create(Object.prototype);
// HasType
function c9(){
cA.call(this);
}
c9.prototype = Object.create(cA.prototype);
// Ast
function c8(){
c9.call(this);
}
c8.prototype = Object.create(c9.prototype);
// AstFunc
function c7(){
c8.call(this);
}
c7.prototype = Object.create(c8.prototype);
// ResFiles
function cF(){
cA.call(this);
}
cF.prototype = Object.create(cA.prototype);
// Pos
function dg(){
cA.call(this);
}
dg.prototype = Object.create(cA.prototype);
// Bool
function e2(){
cA.call(this);
}
e2.prototype = Object.create(cA.prototype);
// AstClass
function eZ(){
c8.call(this);
}
eZ.prototype = Object.create(c8.prototype);
// Reader
function pC(){
cA.call(this);
}
pC.prototype = Object.create(cA.prototype);
// AstRoot
function pN(){
c8.call(this);
}
pN.prototype = Object.create(c8.prototype);
// ScopeRefedItem
function qw(){
cA.call(this);
}
qw.prototype = Object.create(cA.prototype);
// AstArg
function ro(){
c8.call(this);
}
ro.prototype = Object.create(c8.prototype);
// CppInfo
function rV(){
c9.call(this);
}
rV.prototype = Object.create(c9.prototype);
// AstType
function tj(){
c8.call(this);
}
tj.prototype = Object.create(c8.prototype);
// TmpVar
function t7(){
cA.call(this);
}
t7.prototype = Object.create(cA.prototype);
// AstClassItem
function tV(){
cA.call(this);
}
tV.prototype = Object.create(cA.prototype);
// AstVar
function ua(){
c8.call(this);
}
ua.prototype = Object.create(c8.prototype);
// Writer
function uA(){
cA.call(this);
}
uA.prototype = Object.create(cA.prototype);
// WebInfo
function uP(){
c9.call(this);
}
uP.prototype = Object.create(c9.prototype);
// TmpVar
function vA(){
cA.call(this);
}
vA.prototype = Object.create(cA.prototype);
// AstConst
function xk(){
c8.call(this);
}
xk.prototype = Object.create(c8.prototype);
// AstAlias
function xn(){
c8.call(this);
}
xn.prototype = Object.create(c8.prototype);
// AstEnum
function xt(){
c8.call(this);
}
xt.prototype = Object.create(c8.prototype);
// AstStat
function xU(){
c8.call(this);
}
xU.prototype = Object.create(c8.prototype);
// AstStatBreakable
function xT(){
xU.call(this);
}
xT.prototype = Object.create(xU.prototype);
// AstStatTry
function xS(){
xT.call(this);
}
xS.prototype = Object.create(xT.prototype);
// AstTypePrim
function xZ(){
tj.call(this);
}
xZ.prototype = Object.create(tj.prototype);
// AstStatBlock
function yf(){
xT.call(this);
}
yf.prototype = Object.create(xT.prototype);
// AstStatDo
function ys(){
xU.call(this);
}
ys.prototype = Object.create(xU.prototype);
// AstExpr
function yw(){
c8.call(this);
}
yw.prototype = Object.create(c8.prototype);
// AstExprCall
function yv(){
yw.call(this);
}
yv.prototype = Object.create(yw.prototype);
// AstStatCatch
function y5(){
xU.call(this);
}
y5.prototype = Object.create(xU.prototype);
// ExprPair
function yC(){
cA.call(this);
}
yC.prototype = Object.create(cA.prototype);
// AstExprValue
function yG(){
yw.call(this);
}
yG.prototype = Object.create(yw.prototype);
// AstExprValuePrim
function yF(){
yG.call(this);
}
yF.prototype = Object.create(yG.prototype);
// AstExprCallArg
function za(){
cA.call(this);
}
za.prototype = Object.create(cA.prototype);
// AstExpr2
function zL(){
yw.call(this);
}
zL.prototype = Object.create(yw.prototype);
// AstTypeNullable
function Ay(){
tj.call(this);
}
Ay.prototype = Object.create(tj.prototype);
// AstTypeArray
function Ax(){
Ay.call(this);
}
Ax.prototype = Object.create(Ay.prototype);
// AstTypeBit
function A1(){
tj.call(this);
}
A1.prototype = Object.create(tj.prototype);
// AstTypeFunc
function A5(){
Ay.call(this);
}
A5.prototype = Object.create(Ay.prototype);
// AstTypeFuncArg
function AF(){
cA.call(this);
}
AF.prototype = Object.create(cA.prototype);
// AstTypeGen
function AS(){
Ay.call(this);
}
AS.prototype = Object.create(Ay.prototype);
// AstTypeDict
function Bd(){
Ay.call(this);
}
Bd.prototype = Object.create(Ay.prototype);
// AstStatIf
function Fm(){
xT.call(this);
}
Fm.prototype = Object.create(xT.prototype);
// AstStatSwitch
function Fp(){
xT.call(this);
}
Fp.prototype = Object.create(xT.prototype);
// AstStatSkipable
function Ft(){
xT.call(this);
}
Ft.prototype = Object.create(xT.prototype);
// AstStatWhile
function Fs(){
Ft.call(this);
}
Fs.prototype = Object.create(Ft.prototype);
// AstStatFor
function Fw(){
Ft.call(this);
}
Fw.prototype = Object.create(Ft.prototype);
// AstStatThrow
function F1(){
xU.call(this);
}
F1.prototype = Object.create(xU.prototype);
// AstStatRet
function F6(){
xU.call(this);
}
F6.prototype = Object.create(xU.prototype);
// AstStatAssert
function FF(){
xU.call(this);
}
FF.prototype = Object.create(xU.prototype);
// AstTypeUser
function Oq(){
Ay.call(this);
}
Oq.prototype = Object.create(Ay.prototype);
// AstExpr1
function RK(){
yw.call(this);
}
RK.prototype = Object.create(yw.prototype);
// AstExpr3
function RP(){
yw.call(this);
}
RP.prototype = Object.create(yw.prototype);
// AstExprNew
function RS(){
yw.call(this);
}
RS.prototype = Object.create(yw.prototype);
// AstExprNewArray
function RV(){
yw.call(this);
}
RV.prototype = Object.create(yw.prototype);
// AstExprAs
function RY(){
yw.call(this);
}
RY.prototype = Object.create(yw.prototype);
// AstExprToBin
function Sb(){
yw.call(this);
}
Sb.prototype = Object.create(yw.prototype);
// AstExprFromBin
function Se(){
yw.call(this);
}
Se.prototype = Object.create(yw.prototype);
// AstExprArray
function Sj(){
yw.call(this);
}
Sj.prototype = Object.create(yw.prototype);
// AstExprDot
function Sm(){
yw.call(this);
}
Sm.prototype = Object.create(yw.prototype);
// AstExprValueStr
function St(){
yG.call(this);
}
St.prototype = Object.create(yG.prototype);
// AstExprValueEnumElement
function Sw(){
yG.call(this);
}
Sw.prototype = Object.create(yG.prototype);
// AstExprValueFloat
function Sz(){
yG.call(this);
}
Sz.prototype = Object.create(yG.prototype);
// AstExprValueArray
function S2(){
yw.call(this);
}
S2.prototype = Object.create(yw.prototype);
// AstStatVar
function SI(){
xU.call(this);
}
SI.prototype = Object.create(xU.prototype);
// AstTypeNull
function TE(){
tj.call(this);
}
TE.prototype = Object.create(tj.prototype);
// AstStatElIf
function U9(){
xU.call(this);
}
U9.prototype = Object.create(xU.prototype);
// AstStatCase
function UZ(){
xU.call(this);
}
UZ.prototype = Object.create(xU.prototype);
// AstStatFunc
function az1(){
xU.call(this);
}
az1.prototype = Object.create(xU.prototype);
// AstStatConst
function az5(){
xU.call(this);
}
az5.prototype = Object.create(xU.prototype);
// AstStatAlias
function az8(){
xU.call(this);
}
az8.prototype = Object.create(xU.prototype);
// AstStatClass
function azB(){
xU.call(this);
}
azB.prototype = Object.create(xU.prototype);
// AstStatEnum
function azE(){
xU.call(this);
}
azE.prototype = Object.create(xU.prototype);
// AstTypeEnumElement
function aPI(){
tj.call(this);
}
aPI.prototype = Object.create(tj.prototype);
// ctor
function aS0(aS1 /*me*/){
}
// _dtor
function aS2(aS3 /*me*/){
}
// cmp
function aS4(aS5 /*me*/,aS6 /*t*/){
throw 3910598660;
}
// _copy
function aS7(aS8 /*me*/){
let aS9;
(aS9)=(new cA());
return aS9;
}
// _toBin
function aSA(aSB /*me*/){
let aSC;
(aSC)=(new Array(8).fill(0));
return aSC;
}
// _fromBin
function aSD(aSE /*me*/,aSF /*bin*/,aSG /*idx*/){
let aSH;
(aSH)=(new cA());
return aSH;
}
// toStr
function aSI(aSJ /*me*/){
return {S:""};
}
// _dtor
function aSK(aSL){
}
// _copy
function aSM(aSN){
let aSO;
(aSO)=(new c9());
((aSO).qc)=((aSN).qc);
return aSO;
}
// _toBin
function aSP(aSQ){
let aSR;
(aSR)=(new Array(8).fill(0));
(aSR)=((aSR).concat(toBin_((aSQ).qc)));
return aSR;
}
// _fromBin
function aST(aSU,aSV,aSW){
let aSX;
(aSX)=(new c9());
((aSX).qc)=(fromBin_((aSV),(aSW.$)));
return aSX;
}
// cmp
function aSY(aSZ /*me*/,aTa /*t*/){
let aTb; // meAddr
let aTd; // tAddr
(aTb)=((aTc)((aSZ)));
(aTd)=((aTc)((aTa)));
return ((aTb)>(aTd))?(1):(((aTb)<(aTd))?(-1):(0));
}
// _dtor
function aTe(aTf){
((aTf).ql)=(null);
((aTf).qX)=(null);
((aTf).qU)=(null);
((aTf).pY)=(null);
((aTf).q0)=(null);
((aTf).qz)=(null);
((aTf).zr)=(null);
}
// _copy
function aTg(aTh){
let aTi;
(aTi)=(new c8());
((aTi).ql)=(C_([134],((aTh).ql)));
((aTi).qX)=(C_([129,2],((aTh).qX)));
((aTi).qU)=(C_([134],((aTh).qU)));
((aTi).pY)=(C_([133,129,2,134],((aTh).pY)));
((aTi).q0)=(C_([129,2],((aTh).q0)));
((aTi).qz)=(C_([134],((aTh).qz)));
((aTi).zr)=(C_([134],((aTh).zr)));
((aTi).r5)=((aTh).r5);
((aTi).qc)=((aTh).qc);
return aTi;
}
// _toBin
function aTj(aTk){
let aTl;
(aTl)=(new Array(8).fill(0));
(aTl)=((aTl).concat(toBin_((aTk).ql)));
(aTl)=((aTl).concat(toBin_((aTk).qX)));
(aTl)=((aTl).concat(toBin_((aTk).qU)));
(aTl)=((aTl).concat(toBin_((aTk).pY)));
(aTl)=((aTl).concat(toBin_((aTk).q0)));
(aTl)=((aTl).concat(toBin_((aTk).qz)));
(aTl)=((aTl).concat(toBin_((aTk).zr)));
(aTl)=((aTl).concat(toBin_((aTk).r5)));
(aTl)=((aTl).concat(toBin_((aTk).qc)));
return aTl;
}
// _fromBin
function aTv(aTw,aTx,aTy){
let aTz;
(aTz)=(new c8());
((aTz).ql)=(fromBin_((aTx),(aTy.$)));
((aTz).qX)=(fromBin_((aTx),(aTy.$)));
((aTz).qU)=(fromBin_((aTx),(aTy.$)));
((aTz).pY)=(fromBin_((aTx),(aTy.$)));
((aTz).q0)=(fromBin_((aTx),(aTy.$)));
((aTz).qz)=(fromBin_((aTx),(aTy.$)));
((aTz).zr)=(fromBin_((aTx),(aTy.$)));
((aTz).r5)=(fromBin_((aTx),(aTy.$)));
((aTz).qc)=(fromBin_((aTx),(aTy.$)));
return aTz;
}
// _dtor
function aT0(aT1){
((aT1).qj)=(null);
((aT1).qg)=(null);
((aT1).qh)=(null);
((aT1).tv)=(null);
((aT1).ql)=(null);
((aT1).qX)=(null);
((aT1).qU)=(null);
((aT1).pY)=(null);
((aT1).q0)=(null);
((aT1).qz)=(null);
((aT1).zr)=(null);
}
// _copy
function aT2(aT3){
let aT4;
(aT4)=(new c7());
((aT4).qi)=((aT3).qi);
((aT4).qj)=(C_([130,129,2],((aT3).qj)));
((aT4).qg)=(C_([130,134],((aT3).qg)));
((aT4).qh)=(C_([134],((aT3).qh)));
((aT4).tv)=(C_([130,134],((aT3).tv)));
((aT4).ql)=(C_([134],((aT3).ql)));
((aT4).qX)=(C_([129,2],((aT3).qX)));
((aT4).qU)=(C_([134],((aT3).qU)));
((aT4).pY)=(C_([133,129,2,134],((aT3).pY)));
((aT4).q0)=(C_([129,2],((aT3).q0)));
((aT4).qz)=(C_([134],((aT3).qz)));
((aT4).zr)=(C_([134],((aT3).zr)));
((aT4).r5)=((aT3).r5);
((aT4).qc)=((aT3).qc);
return aT4;
}
// _toBin
function aT5(aT6){
let aT7;
(aT7)=(new Array(8).fill(0));
(aT7)=((aT7).concat(toBin_((aT6).qi)));
(aT7)=((aT7).concat(toBin_((aT6).qj)));
(aT7)=((aT7).concat(toBin_((aT6).qg)));
(aT7)=((aT7).concat(toBin_((aT6).qh)));
(aT7)=((aT7).concat(toBin_((aT6).tv)));
(aT7)=((aT7).concat(toBin_((aT6).ql)));
(aT7)=((aT7).concat(toBin_((aT6).qX)));
(aT7)=((aT7).concat(toBin_((aT6).qU)));
(aT7)=((aT7).concat(toBin_((aT6).pY)));
(aT7)=((aT7).concat(toBin_((aT6).q0)));
(aT7)=((aT7).concat(toBin_((aT6).qz)));
(aT7)=((aT7).concat(toBin_((aT6).zr)));
(aT7)=((aT7).concat(toBin_((aT6).r5)));
(aT7)=((aT7).concat(toBin_((aT6).qc)));
return aT7;
}
// _fromBin
function aTM(aTN,aTO,aTP){
let aTQ;
(aTQ)=(new c7());
((aTQ).qi)=(fromBin_((aTO),(aTP.$)));
((aTQ).qj)=(fromBin_((aTO),(aTP.$)));
((aTQ).qg)=(fromBin_((aTO),(aTP.$)));
((aTQ).qh)=(fromBin_((aTO),(aTP.$)));
((aTQ).tv)=(fromBin_((aTO),(aTP.$)));
((aTQ).ql)=(fromBin_((aTO),(aTP.$)));
((aTQ).qX)=(fromBin_((aTO),(aTP.$)));
((aTQ).qU)=(fromBin_((aTO),(aTP.$)));
((aTQ).pY)=(fromBin_((aTO),(aTP.$)));
((aTQ).q0)=(fromBin_((aTO),(aTP.$)));
((aTQ).qz)=(fromBin_((aTO),(aTP.$)));
((aTQ).zr)=(fromBin_((aTO),(aTP.$)));
((aTQ).r5)=(fromBin_((aTO),(aTP.$)));
((aTQ).qc)=(fromBin_((aTO),(aTP.$)));
return aTQ;
}
// _dtor
function aTR(aTS){
((aTS).cG)=(null);
}
// _copy
function aTT(aTU){
let aTV;
(aTV)=(new cF());
((aTV).cG)=(C_([130,129,2],((aTU).cG)));
return aTV;
}
// _toBin
function aTW(aTX){
let aTY;
(aTY)=(new Array(8).fill(0));
(aTY)=((aTY).concat(toBin_((aTX).cG)));
return aTY;
}
// _fromBin
function aUa(aUb,aUc,aUd){
let aUe;
(aUe)=(new cF());
((aUe).cG)=(fromBin_((aUc),(aUd.$)));
return aUe;
}
// _dtor
function aUf(aUg){
((aUg).dh)=(null);
}
// _copy
function aUh(aUi){
let aUj;
(aUj)=(new dg());
((aUj).dh)=(C_([129,2],((aUi).dh)));
((aUj).di)=((aUi).di);
((aUj).dj)=((aUi).dj);
return aUj;
}
// _toBin
function aUk(aUl){
let aUm;
(aUm)=(new Array(8).fill(0));
(aUm)=((aUm).concat(toBin_((aUl).dh)));
(aUm)=((aUm).concat(toBin_((aUl).di)));
(aUm)=((aUm).concat(toBin_((aUl).dj)));
return aUm;
}
// _fromBin
function aUq(aUr,aUs,aUt){
let aUu;
(aUu)=(new dg());
((aUu).dh)=(fromBin_((aUs),(aUt.$)));
((aUu).di)=(fromBin_((aUs),(aUt.$)));
((aUu).dj)=(fromBin_((aUs),(aUt.$)));
return aUu;
}
// cmp
function aUv(aUw /*me*/,aUx /*t*/){
return (aUy)(((((aUw).e3)?1:0)-(((aUx).e3)?1:0)));
}
// toStr
function aUz(aU0 /*me*/){
return (v)(((aU0).e3),([3]));
}
// _dtor
function aU1(aU2){
}
// _copy
function aU3(aU4){
let aU5;
(aU5)=(new e2());
((aU5).e3)=((aU4).e3);
return aU5;
}
// _toBin
function aU6(aU7){
let aU8;
(aU8)=(new Array(8).fill(0));
(aU8)=((aU8).concat(toBin_((aU7).e3)));
return aU8;
}
// _fromBin
function aUA(aUB,aUC,aUD){
let aUE;
(aUE)=(new e2());
((aUE).e3)=(fromBin_((aUC),(aUD.$)));
return aUE;
}
// _dtor
function aUF(aUG){
((aUG).tm)=(null);
((aUG).ql)=(null);
((aUG).qX)=(null);
((aUG).qU)=(null);
((aUG).pY)=(null);
((aUG).q0)=(null);
((aUG).qz)=(null);
((aUG).zr)=(null);
}
// _copy
function aUH(aUI){
let aUJ;
(aUJ)=(new eZ());
((aUJ).tm)=(C_([130,134],((aUI).tm)));
((aUJ).ql)=(C_([134],((aUI).ql)));
((aUJ).qX)=(C_([129,2],((aUI).qX)));
((aUJ).qU)=(C_([134],((aUI).qU)));
((aUJ).pY)=(C_([133,129,2,134],((aUI).pY)));
((aUJ).q0)=(C_([129,2],((aUI).q0)));
((aUJ).qz)=(C_([134],((aUI).qz)));
((aUJ).zr)=(C_([134],((aUI).zr)));
((aUJ).r5)=((aUI).r5);
((aUJ).qc)=((aUI).qc);
return aUJ;
}
// _toBin
function aUK(aUL){
let aUM;
(aUM)=(new Array(8).fill(0));
(aUM)=((aUM).concat(toBin_((aUL).tm)));
(aUM)=((aUM).concat(toBin_((aUL).ql)));
(aUM)=((aUM).concat(toBin_((aUL).qX)));
(aUM)=((aUM).concat(toBin_((aUL).qU)));
(aUM)=((aUM).concat(toBin_((aUL).pY)));
(aUM)=((aUM).concat(toBin_((aUL).q0)));
(aUM)=((aUM).concat(toBin_((aUL).qz)));
(aUM)=((aUM).concat(toBin_((aUL).zr)));
(aUM)=((aUM).concat(toBin_((aUL).r5)));
(aUM)=((aUM).concat(toBin_((aUL).qc)));
return aUM;
}
// _fromBin
function aUX(aUY,aUZ,aVa){
let aVb;
(aVb)=(new eZ());
((aVb).tm)=(fromBin_((aUZ),(aVa.$)));
((aVb).ql)=(fromBin_((aUZ),(aVa.$)));
((aVb).qX)=(fromBin_((aUZ),(aVa.$)));
((aVb).qU)=(fromBin_((aUZ),(aVa.$)));
((aVb).pY)=(fromBin_((aUZ),(aVa.$)));
((aVb).q0)=(fromBin_((aUZ),(aVa.$)));
((aVb).qz)=(fromBin_((aUZ),(aVa.$)));
((aVb).zr)=(fromBin_((aUZ),(aVa.$)));
((aVb).r5)=(fromBin_((aUZ),(aVa.$)));
((aVb).qc)=(fromBin_((aUZ),(aVa.$)));
return aVb;
}
// _dtor
function aVc(aVd /*me*/){
}
// fin
function pO(aVe /*me*/){
aVe.wF.F=null;
}
// setPos
function aVf(aVg /*me*/,aVh /*origin*/,aVi /*pos*/){
aVg.wF.I=aVi;
}
// getPos
function aVj(aVk /*me*/){
return aVk.wF.I;
}
// delimiter
function aVl(aVm /*me*/,aVn /*delimiters*/){
}
// read
function aVo(aVp /*me*/,aVq /*size*/){
}
// readLetter
function abt(aVr /*me*/){
return aVr.wF.F.charCodeAt(aVr.wF.I++);
}
// readInt
function aVs(aVt /*me*/){
}
// readFloat
function aVu(aVv /*me*/){
}
// readChar
function aVw(aVx /*me*/){
}
// readStr
function aVy(aVz /*me*/){
}
// readLine
function uF(aV0 /*me*/){
let aV1; // buf
let aV4; // c
(aV1)=({S:""});
aV3:
while(!((uD)((aV0)))){
(aV4)=((abt)((aV0)));
if((aV4)===(0x000D)){
continue aV3;
}
if((aV4)===(0x000A)){
break aV3;
}
(aV1)=({S:(aV1).S+((v)((aV4),([2]))).S});
}
return aV1;
}
// fileSize
function aVA(aVB /*me*/){
}
// term
function uD(aVC /*me*/){
return aVC.wF.I>=aVC.wF.F.length;
}
// _copy
function aVD(aVE){
let aVF;
(aVF)=(new pC());
((aVF).wF)=((aVE).wF);
((aVF).aVG)=((aVE).aVG);
((aVF).aVH)=((aVE).aVH);
((aVF).aVI)=((aVE).aVI);
return aVF;
}
// _toBin
function aVJ(aVK){
let aVL;
(aVL)=(new Array(8).fill(0));
(aVL)=((aVL).concat(toBin_((aVK).wF)));
(aVL)=((aVL).concat(toBin_((aVK).aVG)));
(aVL)=((aVL).concat(toBin_((aVK).aVH)));
(aVL)=((aVL).concat(toBin_((aVK).aVI)));
return aVL;
}
// _fromBin
function aVQ(aVR,aVS,aVT){
let aVU;
(aVU)=(new pC());
((aVU).wF)=(fromBin_((aVS),(aVT.$)));
((aVU).aVG)=(fromBin_((aVS),(aVT.$)));
((aVU).aVH)=(fromBin_((aVS),(aVT.$)));
((aVU).aVI)=(fromBin_((aVS),(aVT.$)));
return aVU;
}
// _dtor
function aVV(aVW){
((aVW).rI)=(null);
((aVW).qq)=(null);
((aVW).ql)=(null);
((aVW).qX)=(null);
((aVW).qU)=(null);
((aVW).pY)=(null);
((aVW).q0)=(null);
((aVW).qz)=(null);
((aVW).zr)=(null);
}
// _copy
function aVX(aVY){
let aVZ;
(aVZ)=(new pN());
((aVZ).rI)=(C_([130,134],((aVY).rI)));
((aVZ).qq)=(C_([130,134],((aVY).qq)));
((aVZ).ql)=(C_([134],((aVY).ql)));
((aVZ).qX)=(C_([129,2],((aVY).qX)));
((aVZ).qU)=(C_([134],((aVY).qU)));
((aVZ).pY)=(C_([133,129,2,134],((aVY).pY)));
((aVZ).q0)=(C_([129,2],((aVY).q0)));
((aVZ).qz)=(C_([134],((aVY).qz)));
((aVZ).zr)=(C_([134],((aVY).zr)));
((aVZ).r5)=((aVY).r5);
((aVZ).qc)=((aVY).qc);
return aVZ;
}
// _toBin
function aWa(aWb){
let aWc;
(aWc)=(new Array(8).fill(0));
(aWc)=((aWc).concat(toBin_((aWb).rI)));
(aWc)=((aWc).concat(toBin_((aWb).qq)));
(aWc)=((aWc).concat(toBin_((aWb).ql)));
(aWc)=((aWc).concat(toBin_((aWb).qX)));
(aWc)=((aWc).concat(toBin_((aWb).qU)));
(aWc)=((aWc).concat(toBin_((aWb).pY)));
(aWc)=((aWc).concat(toBin_((aWb).q0)));
(aWc)=((aWc).concat(toBin_((aWb).qz)));
(aWc)=((aWc).concat(toBin_((aWb).zr)));
(aWc)=((aWc).concat(toBin_((aWb).r5)));
(aWc)=((aWc).concat(toBin_((aWb).qc)));
return aWc;
}
// _fromBin
function aWo(aWp,aWq,aWr){
let aWs;
(aWs)=(new pN());
((aWs).rI)=(fromBin_((aWq),(aWr.$)));
((aWs).qq)=(fromBin_((aWq),(aWr.$)));
((aWs).ql)=(fromBin_((aWq),(aWr.$)));
((aWs).qX)=(fromBin_((aWq),(aWr.$)));
((aWs).qU)=(fromBin_((aWq),(aWr.$)));
((aWs).pY)=(fromBin_((aWq),(aWr.$)));
((aWs).q0)=(fromBin_((aWq),(aWr.$)));
((aWs).qz)=(fromBin_((aWq),(aWr.$)));
((aWs).zr)=(fromBin_((aWq),(aWr.$)));
((aWs).r5)=(fromBin_((aWq),(aWr.$)));
((aWs).qc)=(fromBin_((aWq),(aWr.$)));
return aWs;
}
// _dtor
function aWt(aWu){
((aWu).qy)=(null);
((aWu).qP)=(null);
}
// _copy
function aWv(aWw){
let aWx;
(aWx)=(new qw());
((aWx).qy)=(C_([134],((aWw).qy)));
((aWx).qP)=(C_([134],((aWw).qP)));
return aWx;
}
// _toBin
function aWy(aWz){
let aW0;
(aW0)=(new Array(8).fill(0));
(aW0)=((aW0).concat(toBin_((aWz).qy)));
(aW0)=((aW0).concat(toBin_((aWz).qP)));
return aW0;
}
// _fromBin
function aW3(aW4,aW5,aW6){
let aW7;
(aW7)=(new qw());
((aW7).qy)=(fromBin_((aW5),(aW6.$)));
((aW7).qP)=(fromBin_((aW5),(aW6.$)));
return aW7;
}
// _dtor
function aW8(aW9){
((aW9).sA)=(null);
((aW9).yb)=(null);
((aW9).ql)=(null);
((aW9).qX)=(null);
((aW9).qU)=(null);
((aW9).pY)=(null);
((aW9).q0)=(null);
((aW9).qz)=(null);
((aW9).zr)=(null);
}
// _copy
function aWA(aWB){
let aWC;
(aWC)=(new ro());
((aWC).rp)=((aWB).rp);
((aWC).sP)=((aWB).sP);
((aWC).sA)=(C_([134],((aWB).sA)));
((aWC).yb)=(C_([134],((aWB).yb)));
((aWC).ql)=(C_([134],((aWB).ql)));
((aWC).qX)=(C_([129,2],((aWB).qX)));
((aWC).qU)=(C_([134],((aWB).qU)));
((aWC).pY)=(C_([133,129,2,134],((aWB).pY)));
((aWC).q0)=(C_([129,2],((aWB).q0)));
((aWC).qz)=(C_([134],((aWB).qz)));
((aWC).zr)=(C_([134],((aWB).zr)));
((aWC).r5)=((aWB).r5);
((aWC).qc)=((aWB).qc);
return aWC;
}
// _toBin
function aWD(aWE){
let aWF;
(aWF)=(new Array(8).fill(0));
(aWF)=((aWF).concat(toBin_((aWE).rp)));
(aWF)=((aWF).concat(toBin_((aWE).sP)));
(aWF)=((aWF).concat(toBin_((aWE).sA)));
(aWF)=((aWF).concat(toBin_((aWE).yb)));
(aWF)=((aWF).concat(toBin_((aWE).ql)));
(aWF)=((aWF).concat(toBin_((aWE).qX)));
(aWF)=((aWF).concat(toBin_((aWE).qU)));
(aWF)=((aWF).concat(toBin_((aWE).pY)));
(aWF)=((aWF).concat(toBin_((aWE).q0)));
(aWF)=((aWF).concat(toBin_((aWE).qz)));
(aWF)=((aWF).concat(toBin_((aWE).zr)));
(aWF)=((aWF).concat(toBin_((aWE).r5)));
(aWF)=((aWF).concat(toBin_((aWE).qc)));
return aWF;
}
// _fromBin
function aWT(aWU,aWV,aWW){
let aWX;
(aWX)=(new ro());
((aWX).rp)=(fromBin_((aWV),(aWW.$)));
((aWX).sP)=(fromBin_((aWV),(aWW.$)));
((aWX).sA)=(fromBin_((aWV),(aWW.$)));
((aWX).yb)=(fromBin_((aWV),(aWW.$)));
((aWX).ql)=(fromBin_((aWV),(aWW.$)));
((aWX).qX)=(fromBin_((aWV),(aWW.$)));
((aWX).qU)=(fromBin_((aWV),(aWW.$)));
((aWX).pY)=(fromBin_((aWV),(aWW.$)));
((aWX).q0)=(fromBin_((aWV),(aWW.$)));
((aWX).qz)=(fromBin_((aWV),(aWW.$)));
((aWX).zr)=(fromBin_((aWV),(aWW.$)));
((aWX).r5)=(fromBin_((aWV),(aWW.$)));
((aWX).qc)=(fromBin_((aWV),(aWW.$)));
return aWX;
}
// _dtor
function aWY(aWZ){
((aWZ).sT)=(null);
((aWZ).Aj)=(null);
((aWZ).Am)=(null);
}
// _copy
function aXa(aXb){
let aXc;
(aXc)=(new rV());
((aXc).sT)=(C_([129,2],((aXb).sT)));
((aXc).Aj)=(C_([129,2],((aXb).Aj)));
((aXc).Am)=(C_([129,2],((aXb).Am)));
((aXc).tJ)=((aXb).tJ);
((aXc).rX)=((aXb).rX);
((aXc).Ap)=((aXb).Ap);
((aXc).Aq)=((aXb).Aq);
((aXc).qc)=((aXb).qc);
return aXc;
}
// _toBin
function aXd(aXe){
let aXf;
(aXf)=(new Array(8).fill(0));
(aXf)=((aXf).concat(toBin_((aXe).sT)));
(aXf)=((aXf).concat(toBin_((aXe).Aj)));
(aXf)=((aXf).concat(toBin_((aXe).Am)));
(aXf)=((aXf).concat(toBin_((aXe).tJ)));
(aXf)=((aXf).concat(toBin_((aXe).rX)));
(aXf)=((aXf).concat(toBin_((aXe).Ap)));
(aXf)=((aXf).concat(toBin_((aXe).Aq)));
(aXf)=((aXf).concat(toBin_((aXe).qc)));
return aXf;
}
// _fromBin
function aXo(aXp,aXq,aXr){
let aXs;
(aXs)=(new rV());
((aXs).sT)=(fromBin_((aXq),(aXr.$)));
((aXs).Aj)=(fromBin_((aXq),(aXr.$)));
((aXs).Am)=(fromBin_((aXq),(aXr.$)));
((aXs).tJ)=(fromBin_((aXq),(aXr.$)));
((aXs).rX)=(fromBin_((aXq),(aXr.$)));
((aXs).Ap)=(fromBin_((aXq),(aXr.$)));
((aXs).Aq)=(fromBin_((aXq),(aXr.$)));
((aXs).qc)=(fromBin_((aXq),(aXr.$)));
return aXs;
}
// _dtor
function aXt(aXu){
((aXu).ql)=(null);
((aXu).qX)=(null);
((aXu).qU)=(null);
((aXu).pY)=(null);
((aXu).q0)=(null);
((aXu).qz)=(null);
((aXu).zr)=(null);
}
// _copy
function aXv(aXw){
let aXx;
(aXx)=(new tj());
((aXx).ql)=(C_([134],((aXw).ql)));
((aXx).qX)=(C_([129,2],((aXw).qX)));
((aXx).qU)=(C_([134],((aXw).qU)));
((aXx).pY)=(C_([133,129,2,134],((aXw).pY)));
((aXx).q0)=(C_([129,2],((aXw).q0)));
((aXx).qz)=(C_([134],((aXw).qz)));
((aXx).zr)=(C_([134],((aXw).zr)));
((aXx).r5)=((aXw).r5);
((aXx).qc)=((aXw).qc);
return aXx;
}
// _toBin
function aXy(aXz){
let aX0;
(aX0)=(new Array(8).fill(0));
(aX0)=((aX0).concat(toBin_((aXz).ql)));
(aX0)=((aX0).concat(toBin_((aXz).qX)));
(aX0)=((aX0).concat(toBin_((aXz).qU)));
(aX0)=((aX0).concat(toBin_((aXz).pY)));
(aX0)=((aX0).concat(toBin_((aXz).q0)));
(aX0)=((aX0).concat(toBin_((aXz).qz)));
(aX0)=((aX0).concat(toBin_((aXz).zr)));
(aX0)=((aX0).concat(toBin_((aXz).r5)));
(aX0)=((aX0).concat(toBin_((aXz).qc)));
return aX0;
}
// _fromBin
function aXA(aXB,aXC,aXD){
let aXE;
(aXE)=(new tj());
((aXE).ql)=(fromBin_((aXC),(aXD.$)));
((aXE).qX)=(fromBin_((aXC),(aXD.$)));
((aXE).qU)=(fromBin_((aXC),(aXD.$)));
((aXE).pY)=(fromBin_((aXC),(aXD.$)));
((aXE).q0)=(fromBin_((aXC),(aXD.$)));
((aXE).qz)=(fromBin_((aXC),(aXD.$)));
((aXE).zr)=(fromBin_((aXC),(aXD.$)));
((aXE).r5)=(fromBin_((aXC),(aXD.$)));
((aXE).qc)=(fromBin_((aXC),(aXD.$)));
return aXE;
}
// _dtor
function aXF(aXG){
((aXG).t9)=(null);
((aXG).t8)=(null);
}
// _copy
function aXH(aXI){
let aXJ;
(aXJ)=(new t7());
((aXJ).t9)=(C_([129,2],((aXI).t9)));
((aXJ).t8)=(C_([134],((aXI).t8)));
return aXJ;
}
// _toBin
function aXK(aXL){
let aXM;
(aXM)=(new Array(8).fill(0));
(aXM)=((aXM).concat(toBin_((aXL).t9)));
(aXM)=((aXM).concat(toBin_((aXL).t8)));
return aXM;
}
// _fromBin
function aXP(aXQ,aXR,aXS){
let aXT;
(aXT)=(new t7());
((aXT).t9)=(fromBin_((aXR),(aXS.$)));
((aXT).t8)=(fromBin_((aXR),(aXS.$)));
return aXT;
}
// _dtor
function aXU(aXV){
((aXV).tX)=(null);
((aXV).Pn)=(null);
}
// _copy
function aXW(aXX){
let aXY;
(aXY)=(new tV());
((aXY).Pl)=((aXX).Pl);
((aXY).Pm)=((aXX).Pm);
((aXY).tX)=(C_([134],((aXX).tX)));
((aXY).Pn)=(C_([134],((aXX).Pn)));
return aXY;
}
// _toBin
function aXZ(aYa){
let aYb;
(aYb)=(new Array(8).fill(0));
(aYb)=((aYb).concat(toBin_((aYa).Pl)));
(aYb)=((aYb).concat(toBin_((aYa).Pm)));
(aYb)=((aYb).concat(toBin_((aYa).tX)));
(aYb)=((aYb).concat(toBin_((aYa).Pn)));
return aYb;
}
// _fromBin
function aYg(aYh,aYi,aYj){
let aYk;
(aYk)=(new tV());
((aYk).Pl)=(fromBin_((aYi),(aYj.$)));
((aYk).Pm)=(fromBin_((aYi),(aYj.$)));
((aYk).tX)=(fromBin_((aYi),(aYj.$)));
((aYk).Pn)=(fromBin_((aYi),(aYj.$)));
return aYk;
}
// _dtor
function aYl(aYm){
((aYm).uc)=(null);
((aYm).ql)=(null);
((aYm).qX)=(null);
((aYm).qU)=(null);
((aYm).pY)=(null);
((aYm).q0)=(null);
((aYm).qz)=(null);
((aYm).zr)=(null);
}
// _copy
function aYn(aYo){
let aYp;
(aYp)=(new ua());
((aYp).uc)=(C_([134],((aYo).uc)));
((aYp).ql)=(C_([134],((aYo).ql)));
((aYp).qX)=(C_([129,2],((aYo).qX)));
((aYp).qU)=(C_([134],((aYo).qU)));
((aYp).pY)=(C_([133,129,2,134],((aYo).pY)));
((aYp).q0)=(C_([129,2],((aYo).q0)));
((aYp).qz)=(C_([134],((aYo).qz)));
((aYp).zr)=(C_([134],((aYo).zr)));
((aYp).r5)=((aYo).r5);
((aYp).qc)=((aYo).qc);
return aYp;
}
// _toBin
function aYq(aYr){
let aYs;
(aYs)=(new Array(8).fill(0));
(aYs)=((aYs).concat(toBin_((aYr).uc)));
(aYs)=((aYs).concat(toBin_((aYr).ql)));
(aYs)=((aYs).concat(toBin_((aYr).qX)));
(aYs)=((aYs).concat(toBin_((aYr).qU)));
(aYs)=((aYs).concat(toBin_((aYr).pY)));
(aYs)=((aYs).concat(toBin_((aYr).q0)));
(aYs)=((aYs).concat(toBin_((aYr).qz)));
(aYs)=((aYs).concat(toBin_((aYr).zr)));
(aYs)=((aYs).concat(toBin_((aYr).r5)));
(aYs)=((aYs).concat(toBin_((aYr).qc)));
return aYs;
}
// _fromBin
function aY3(aY4,aY5,aY6){
let aY7;
(aY7)=(new ua());
((aY7).uc)=(fromBin_((aY5),(aY6.$)));
((aY7).ql)=(fromBin_((aY5),(aY6.$)));
((aY7).qX)=(fromBin_((aY5),(aY6.$)));
((aY7).qU)=(fromBin_((aY5),(aY6.$)));
((aY7).pY)=(fromBin_((aY5),(aY6.$)));
((aY7).q0)=(fromBin_((aY5),(aY6.$)));
((aY7).qz)=(fromBin_((aY5),(aY6.$)));
((aY7).zr)=(fromBin_((aY5),(aY6.$)));
((aY7).r5)=(fromBin_((aY5),(aY6.$)));
((aY7).qc)=(fromBin_((aY5),(aY6.$)));
return aY7;
}
// _dtor
function aY8(aY9 /*me*/){
}
// fin
function uI(aYA /*me*/){
var d_=aYA.Gw.F.replace("\n", "\u000D\n");
if(O_&&O_.writeFile){O_.writeFile(aYA.Gw.P,d_);return;}
let b_=new Blob([d_]);
let l_=document.createElement("a");
l_.download=aYA.Gw.P;
l_.href=(URL||webkitURL).createObjectURL(b_);
l_.setAttribute("style","display:none");
document.body.appendChild(l_);
l_.click();
document.body.removeChild(l_);
aYA.Gw.F=null;
}
// setPos
function aYB(aYC /*me*/,aYD /*origin*/,aYE /*pos*/){
aYC.Gw.I=aYE;
}
// getPos
function aYF(aYG /*me*/){
return aYG.Gw.I;
}
// write
function aYH(aYI /*me*/,aYJ /*bin*/){
}
// writeInt
function aYK(aYL /*me*/,aYM /*n*/){
let aYN; // s
let aYQ;
let aYR;
(aYN)=((v)((aYM),([0])));
aYP:
for(aYQ=(0),aYR=(((aYN).S.length)-(1));aYQ<=aYR;aYQ+=(1)){
(aYS)((aYL),((aYN).S.charCodeAt(aYQ)));
}
}
// writeFloat
function aYT(aYU /*me*/,aYV /*n*/){
let aYW; // s
let aYZ;
let aZa;
(aYW)=((v)((aYV),([1])));
aYY:
for(aYZ=(0),aZa=(((aYW).S.length)-(1));aYZ<=aZa;aYZ+=(1)){
(aYS)((aYU),((aYW).S.charCodeAt(aYZ)));
}
}
// writeChar
function aYS(aZb /*me*/,aZc /*n*/){
if(aZb.Gw.I<aZb.Gw.F.length)
aZb.Gw.F=aZb.Gw.F.slice(0,aZb.Gw.I)+String.fromCharCode(aZc)+aZb.Gw.F.slice(aZb.Gw.I+1);
else{
aZb.Gw.F+=String.fromCharCode(aZc);
}
aZb.Gw.I++;
}
// writeStr
function uG(aZd /*me*/,aZe /*n*/){
let aZh;
let aZi;
aZg:
for(aZh=(0),aZi=(((aZe).S.length)-(1));aZh<=aZi;aZh+=(1)){
(aYS)((aZd),((aZe).S.charCodeAt(aZh)));
}
}
// _copy
function aZj(aZk){
let aZl;
(aZl)=(new uA());
((aZl).Gw)=((aZk).Gw);
return aZl;
}
// _toBin
function aZm(aZn){
let aZo;
(aZo)=(new Array(8).fill(0));
(aZo)=((aZo).concat(toBin_((aZn).Gw)));
return aZo;
}
// _fromBin
function aZq(aZr,aZs,aZt){
let aZu;
(aZu)=(new uA());
((aZu).Gw)=(fromBin_((aZs),(aZt.$)));
return aZu;
}
// _dtor
function aZv(aZw){
((aZw).vf)=(null);
((aZw).GK)=(null);
}
// _copy
function aZx(aZy){
let aZz;
(aZz)=(new uP());
((aZz).vf)=(C_([129,2],((aZy).vf)));
((aZz).GK)=(C_([129,2],((aZy).GK)));
((aZz).uR)=((aZy).uR);
((aZz).qc)=((aZy).qc);
return aZz;
}
// _toBin
function aZ0(aZ1){
let aZ2;
(aZ2)=(new Array(8).fill(0));
(aZ2)=((aZ2).concat(toBin_((aZ1).vf)));
(aZ2)=((aZ2).concat(toBin_((aZ1).GK)));
(aZ2)=((aZ2).concat(toBin_((aZ1).uR)));
(aZ2)=((aZ2).concat(toBin_((aZ1).qc)));
return aZ2;
}
// _fromBin
function aZ7(aZ8,aZ9,aZA){
let aZB;
(aZB)=(new uP());
((aZB).vf)=(fromBin_((aZ9),(aZA.$)));
((aZB).GK)=(fromBin_((aZ9),(aZA.$)));
((aZB).uR)=(fromBin_((aZ9),(aZA.$)));
((aZB).qc)=(fromBin_((aZ9),(aZA.$)));
return aZB;
}
// _dtor
function aZC(aZD){
((aZD).vB)=(null);
((aZD).ayG)=(null);
}
// _copy
function aZE(aZF){
let aZG;
(aZG)=(new vA());
((aZG).vB)=(C_([129,2],((aZF).vB)));
((aZG).ayG)=(C_([134],((aZF).ayG)));
return aZG;
}
// _toBin
function aZH(aZI){
let aZJ;
(aZJ)=(new Array(8).fill(0));
(aZJ)=((aZJ).concat(toBin_((aZI).vB)));
(aZJ)=((aZJ).concat(toBin_((aZI).ayG)));
return aZJ;
}
// _fromBin
function aZM(aZN,aZO,aZP){
let aZQ;
(aZQ)=(new vA());
((aZQ).vB)=(fromBin_((aZO),(aZP.$)));
((aZQ).ayG)=(fromBin_((aZO),(aZP.$)));
return aZQ;
}
// _dtor
function aZR(aZS){
((aZS).x0)=(null);
((aZS).ql)=(null);
((aZS).qX)=(null);
((aZS).qU)=(null);
((aZS).pY)=(null);
((aZS).q0)=(null);
((aZS).qz)=(null);
((aZS).zr)=(null);
}
// _copy
function aZT(aZU){
let aZV;
(aZV)=(new xk());
((aZV).x0)=(C_([134],((aZU).x0)));
((aZV).ql)=(C_([134],((aZU).ql)));
((aZV).qX)=(C_([129,2],((aZU).qX)));
((aZV).qU)=(C_([134],((aZU).qU)));
((aZV).pY)=(C_([133,129,2,134],((aZU).pY)));
((aZV).q0)=(C_([129,2],((aZU).q0)));
((aZV).qz)=(C_([134],((aZU).qz)));
((aZV).zr)=(C_([134],((aZU).zr)));
((aZV).r5)=((aZU).r5);
((aZV).qc)=((aZU).qc);
return aZV;
}
// _toBin
function aZW(aZX){
let aZY;
(aZY)=(new Array(8).fill(0));
(aZY)=((aZY).concat(toBin_((aZX).x0)));
(aZY)=((aZY).concat(toBin_((aZX).ql)));
(aZY)=((aZY).concat(toBin_((aZX).qX)));
(aZY)=((aZY).concat(toBin_((aZX).qU)));
(aZY)=((aZY).concat(toBin_((aZX).pY)));
(aZY)=((aZY).concat(toBin_((aZX).q0)));
(aZY)=((aZY).concat(toBin_((aZX).qz)));
(aZY)=((aZY).concat(toBin_((aZX).zr)));
(aZY)=((aZY).concat(toBin_((aZX).r5)));
(aZY)=((aZY).concat(toBin_((aZX).qc)));
return aZY;
}
// _fromBin
function baj(bak,bal,bam){
let ban;
(ban)=(new xk());
((ban).x0)=(fromBin_((bal),(bam.$)));
((ban).ql)=(fromBin_((bal),(bam.$)));
((ban).qX)=(fromBin_((bal),(bam.$)));
((ban).qU)=(fromBin_((bal),(bam.$)));
((ban).pY)=(fromBin_((bal),(bam.$)));
((ban).q0)=(fromBin_((bal),(bam.$)));
((ban).qz)=(fromBin_((bal),(bam.$)));
((ban).zr)=(fromBin_((bal),(bam.$)));
((ban).r5)=(fromBin_((bal),(bam.$)));
((ban).qc)=(fromBin_((bal),(bam.$)));
return ban;
}
// _dtor
function bao(bap){
((bap).OR)=(null);
((bap).ql)=(null);
((bap).qX)=(null);
((bap).qU)=(null);
((bap).pY)=(null);
((bap).q0)=(null);
((bap).qz)=(null);
((bap).zr)=(null);
}
// _copy
function baq(bar){
let bas;
(bas)=(new xn());
((bas).OR)=(C_([134],((bar).OR)));
((bas).ql)=(C_([134],((bar).ql)));
((bas).qX)=(C_([129,2],((bar).qX)));
((bas).qU)=(C_([134],((bar).qU)));
((bas).pY)=(C_([133,129,2,134],((bar).pY)));
((bas).q0)=(C_([129,2],((bar).q0)));
((bas).qz)=(C_([134],((bar).qz)));
((bas).zr)=(C_([134],((bar).zr)));
((bas).r5)=((bar).r5);
((bas).qc)=((bar).qc);
return bas;
}
// _toBin
function bat(bau){
let bav;
(bav)=(new Array(8).fill(0));
(bav)=((bav).concat(toBin_((bau).OR)));
(bav)=((bav).concat(toBin_((bau).ql)));
(bav)=((bav).concat(toBin_((bau).qX)));
(bav)=((bav).concat(toBin_((bau).qU)));
(bav)=((bav).concat(toBin_((bau).pY)));
(bav)=((bav).concat(toBin_((bau).q0)));
(bav)=((bav).concat(toBin_((bau).qz)));
(bav)=((bav).concat(toBin_((bau).zr)));
(bav)=((bav).concat(toBin_((bau).r5)));
(bav)=((bav).concat(toBin_((bau).qc)));
return bav;
}
// _fromBin
function ba6(ba7,ba8,ba9){
let baA;
(baA)=(new xn());
((baA).OR)=(fromBin_((ba8),(ba9.$)));
((baA).ql)=(fromBin_((ba8),(ba9.$)));
((baA).qX)=(fromBin_((ba8),(ba9.$)));
((baA).qU)=(fromBin_((ba8),(ba9.$)));
((baA).pY)=(fromBin_((ba8),(ba9.$)));
((baA).q0)=(fromBin_((ba8),(ba9.$)));
((baA).qz)=(fromBin_((ba8),(ba9.$)));
((baA).zr)=(fromBin_((ba8),(ba9.$)));
((baA).r5)=(fromBin_((ba8),(ba9.$)));
((baA).qc)=(fromBin_((ba8),(ba9.$)));
return baA;
}
// _dtor
function baB(baC){
((baC).PI)=(null);
((baC).ql)=(null);
((baC).qX)=(null);
((baC).qU)=(null);
((baC).pY)=(null);
((baC).q0)=(null);
((baC).qz)=(null);
((baC).zr)=(null);
}
// _copy
function baD(baE){
let baF;
(baF)=(new xt());
((baF).PI)=(C_([130,134],((baE).PI)));
((baF).ql)=(C_([134],((baE).ql)));
((baF).qX)=(C_([129,2],((baE).qX)));
((baF).qU)=(C_([134],((baE).qU)));
((baF).pY)=(C_([133,129,2,134],((baE).pY)));
((baF).q0)=(C_([129,2],((baE).q0)));
((baF).qz)=(C_([134],((baE).qz)));
((baF).zr)=(C_([134],((baE).zr)));
((baF).r5)=((baE).r5);
((baF).qc)=((baE).qc);
return baF;
}
// _toBin
function baG(baH){
let baI;
(baI)=(new Array(8).fill(0));
(baI)=((baI).concat(toBin_((baH).PI)));
(baI)=((baI).concat(toBin_((baH).ql)));
(baI)=((baI).concat(toBin_((baH).qX)));
(baI)=((baI).concat(toBin_((baH).qU)));
(baI)=((baI).concat(toBin_((baH).pY)));
(baI)=((baI).concat(toBin_((baH).q0)));
(baI)=((baI).concat(toBin_((baH).qz)));
(baI)=((baI).concat(toBin_((baH).zr)));
(baI)=((baI).concat(toBin_((baH).r5)));
(baI)=((baI).concat(toBin_((baH).qc)));
return baI;
}
// _fromBin
function baT(baU,baV,baW){
let baX;
(baX)=(new xt());
((baX).PI)=(fromBin_((baV),(baW.$)));
((baX).ql)=(fromBin_((baV),(baW.$)));
((baX).qX)=(fromBin_((baV),(baW.$)));
((baX).qU)=(fromBin_((baV),(baW.$)));
((baX).pY)=(fromBin_((baV),(baW.$)));
((baX).q0)=(fromBin_((baV),(baW.$)));
((baX).qz)=(fromBin_((baV),(baW.$)));
((baX).zr)=(fromBin_((baV),(baW.$)));
((baX).r5)=(fromBin_((baV),(baW.$)));
((baX).qc)=(fromBin_((baV),(baW.$)));
return baX;
}
// _dtor
function baY(baZ){
((baZ).ql)=(null);
((baZ).qX)=(null);
((baZ).qU)=(null);
((baZ).pY)=(null);
((baZ).q0)=(null);
((baZ).qz)=(null);
((baZ).zr)=(null);
}
// _copy
function bba(bbb){
let bbc;
(bbc)=(new xU());
((bbc).ql)=(C_([134],((bbb).ql)));
((bbc).qX)=(C_([129,2],((bbb).qX)));
((bbc).qU)=(C_([134],((bbb).qU)));
((bbc).pY)=(C_([133,129,2,134],((bbb).pY)));
((bbc).q0)=(C_([129,2],((bbb).q0)));
((bbc).qz)=(C_([134],((bbb).qz)));
((bbc).zr)=(C_([134],((bbb).zr)));
((bbc).r5)=((bbb).r5);
((bbc).qc)=((bbb).qc);
return bbc;
}
// _toBin
function bbd(bbe){
let bbf;
(bbf)=(new Array(8).fill(0));
(bbf)=((bbf).concat(toBin_((bbe).ql)));
(bbf)=((bbf).concat(toBin_((bbe).qX)));
(bbf)=((bbf).concat(toBin_((bbe).qU)));
(bbf)=((bbf).concat(toBin_((bbe).pY)));
(bbf)=((bbf).concat(toBin_((bbe).q0)));
(bbf)=((bbf).concat(toBin_((bbe).qz)));
(bbf)=((bbf).concat(toBin_((bbe).zr)));
(bbf)=((bbf).concat(toBin_((bbe).r5)));
(bbf)=((bbf).concat(toBin_((bbe).qc)));
return bbf;
}
// _fromBin
function bbp(bbq,bbr,bbs){
let bbt;
(bbt)=(new xU());
((bbt).ql)=(fromBin_((bbr),(bbs.$)));
((bbt).qX)=(fromBin_((bbr),(bbs.$)));
((bbt).qU)=(fromBin_((bbr),(bbs.$)));
((bbt).pY)=(fromBin_((bbr),(bbs.$)));
((bbt).q0)=(fromBin_((bbr),(bbs.$)));
((bbt).qz)=(fromBin_((bbr),(bbs.$)));
((bbt).zr)=(fromBin_((bbr),(bbs.$)));
((bbt).r5)=(fromBin_((bbr),(bbs.$)));
((bbt).qc)=(fromBin_((bbr),(bbs.$)));
return bbt;
}
// _dtor
function bbu(bbv){
((bbv).yc)=(null);
((bbv).ql)=(null);
((bbv).qX)=(null);
((bbv).qU)=(null);
((bbv).pY)=(null);
((bbv).q0)=(null);
((bbv).qz)=(null);
((bbv).zr)=(null);
}
// _copy
function bbw(bbx){
let bby;
(bby)=(new xT());
((bby).yc)=(C_([134],((bbx).yc)));
((bby).ql)=(C_([134],((bbx).ql)));
((bby).qX)=(C_([129,2],((bbx).qX)));
((bby).qU)=(C_([134],((bbx).qU)));
((bby).pY)=(C_([133,129,2,134],((bbx).pY)));
((bby).q0)=(C_([129,2],((bbx).q0)));
((bby).qz)=(C_([134],((bbx).qz)));
((bby).zr)=(C_([134],((bbx).zr)));
((bby).r5)=((bbx).r5);
((bby).qc)=((bbx).qc);
return bby;
}
// _toBin
function bbz(bb0){
let bb1;
(bb1)=(new Array(8).fill(0));
(bb1)=((bb1).concat(toBin_((bb0).yc)));
(bb1)=((bb1).concat(toBin_((bb0).ql)));
(bb1)=((bb1).concat(toBin_((bb0).qX)));
(bb1)=((bb1).concat(toBin_((bb0).qU)));
(bb1)=((bb1).concat(toBin_((bb0).pY)));
(bb1)=((bb1).concat(toBin_((bb0).q0)));
(bb1)=((bb1).concat(toBin_((bb0).qz)));
(bb1)=((bb1).concat(toBin_((bb0).zr)));
(bb1)=((bb1).concat(toBin_((bb0).r5)));
(bb1)=((bb1).concat(toBin_((bb0).qc)));
return bb1;
}
// _fromBin
function bbC(bbD,bbE,bbF){
let bbG;
(bbG)=(new xT());
((bbG).yc)=(fromBin_((bbE),(bbF.$)));
((bbG).ql)=(fromBin_((bbE),(bbF.$)));
((bbG).qX)=(fromBin_((bbE),(bbF.$)));
((bbG).qU)=(fromBin_((bbE),(bbF.$)));
((bbG).pY)=(fromBin_((bbE),(bbF.$)));
((bbG).q0)=(fromBin_((bbE),(bbF.$)));
((bbG).qz)=(fromBin_((bbE),(bbF.$)));
((bbG).zr)=(fromBin_((bbE),(bbF.$)));
((bbG).r5)=(fromBin_((bbE),(bbF.$)));
((bbG).qc)=(fromBin_((bbE),(bbF.$)));
return bbG;
}
// _dtor
function bbH(bbI){
((bbI).yh)=(null);
((bbI).yi)=(null);
((bbI).yl)=(null);
((bbI).yc)=(null);
((bbI).ql)=(null);
((bbI).qX)=(null);
((bbI).qU)=(null);
((bbI).pY)=(null);
((bbI).q0)=(null);
((bbI).qz)=(null);
((bbI).zr)=(null);
}
// _copy
function bbJ(bbK){
let bbL;
(bbL)=(new xS());
((bbL).yh)=(C_([134],((bbK).yh)));
((bbL).yi)=(C_([130,134],((bbK).yi)));
((bbL).yl)=(C_([134],((bbK).yl)));
((bbL).yc)=(C_([134],((bbK).yc)));
((bbL).ql)=(C_([134],((bbK).ql)));
((bbL).qX)=(C_([129,2],((bbK).qX)));
((bbL).qU)=(C_([134],((bbK).qU)));
((bbL).pY)=(C_([133,129,2,134],((bbK).pY)));
((bbL).q0)=(C_([129,2],((bbK).q0)));
((bbL).qz)=(C_([134],((bbK).qz)));
((bbL).zr)=(C_([134],((bbK).zr)));
((bbL).r5)=((bbK).r5);
((bbL).qc)=((bbK).qc);
return bbL;
}
// _toBin
function bbM(bbN){
let bbO;
(bbO)=(new Array(8).fill(0));
(bbO)=((bbO).concat(toBin_((bbN).yh)));
(bbO)=((bbO).concat(toBin_((bbN).yi)));
(bbO)=((bbO).concat(toBin_((bbN).yl)));
(bbO)=((bbO).concat(toBin_((bbN).yc)));
(bbO)=((bbO).concat(toBin_((bbN).ql)));
(bbO)=((bbO).concat(toBin_((bbN).qX)));
(bbO)=((bbO).concat(toBin_((bbN).qU)));
(bbO)=((bbO).concat(toBin_((bbN).pY)));
(bbO)=((bbO).concat(toBin_((bbN).q0)));
(bbO)=((bbO).concat(toBin_((bbN).qz)));
(bbO)=((bbO).concat(toBin_((bbN).zr)));
(bbO)=((bbO).concat(toBin_((bbN).r5)));
(bbO)=((bbO).concat(toBin_((bbN).qc)));
return bbO;
}
// _fromBin
function bcc(bcd,bce,bcf){
let bcg;
(bcg)=(new xS());
((bcg).yh)=(fromBin_((bce),(bcf.$)));
((bcg).yi)=(fromBin_((bce),(bcf.$)));
((bcg).yl)=(fromBin_((bce),(bcf.$)));
((bcg).yc)=(fromBin_((bce),(bcf.$)));
((bcg).ql)=(fromBin_((bce),(bcf.$)));
((bcg).qX)=(fromBin_((bce),(bcf.$)));
((bcg).qU)=(fromBin_((bce),(bcf.$)));
((bcg).pY)=(fromBin_((bce),(bcf.$)));
((bcg).q0)=(fromBin_((bce),(bcf.$)));
((bcg).qz)=(fromBin_((bce),(bcf.$)));
((bcg).zr)=(fromBin_((bce),(bcf.$)));
((bcg).r5)=(fromBin_((bce),(bcf.$)));
((bcg).qc)=(fromBin_((bce),(bcf.$)));
return bcg;
}
// _dtor
function bch(bci){
((bci).ql)=(null);
((bci).qX)=(null);
((bci).qU)=(null);
((bci).pY)=(null);
((bci).q0)=(null);
((bci).qz)=(null);
((bci).zr)=(null);
}
// _copy
function bcj(bck){
let bcl;
(bcl)=(new xZ());
((bcl).ya)=((bck).ya);
((bcl).ql)=(C_([134],((bck).ql)));
((bcl).qX)=(C_([129,2],((bck).qX)));
((bcl).qU)=(C_([134],((bck).qU)));
((bcl).pY)=(C_([133,129,2,134],((bck).pY)));
((bcl).q0)=(C_([129,2],((bck).q0)));
((bcl).qz)=(C_([134],((bck).qz)));
((bcl).zr)=(C_([134],((bck).zr)));
((bcl).r5)=((bck).r5);
((bcl).qc)=((bck).qc);
return bcl;
}
// _toBin
function bcm(bcn){
let bco;
(bco)=(new Array(8).fill(0));
(bco)=((bco).concat(toBin_((bcn).ya)));
(bco)=((bco).concat(toBin_((bcn).ql)));
(bco)=((bco).concat(toBin_((bcn).qX)));
(bco)=((bco).concat(toBin_((bcn).qU)));
(bco)=((bco).concat(toBin_((bcn).pY)));
(bco)=((bco).concat(toBin_((bcn).q0)));
(bco)=((bco).concat(toBin_((bcn).qz)));
(bco)=((bco).concat(toBin_((bcn).zr)));
(bco)=((bco).concat(toBin_((bcn).r5)));
(bco)=((bco).concat(toBin_((bcn).qc)));
return bco;
}
// _fromBin
function bcz(bc0,bc1,bc2){
let bc3;
(bc3)=(new xZ());
((bc3).ya)=(fromBin_((bc1),(bc2.$)));
((bc3).ql)=(fromBin_((bc1),(bc2.$)));
((bc3).qX)=(fromBin_((bc1),(bc2.$)));
((bc3).qU)=(fromBin_((bc1),(bc2.$)));
((bc3).pY)=(fromBin_((bc1),(bc2.$)));
((bc3).q0)=(fromBin_((bc1),(bc2.$)));
((bc3).qz)=(fromBin_((bc1),(bc2.$)));
((bc3).zr)=(fromBin_((bc1),(bc2.$)));
((bc3).r5)=(fromBin_((bc1),(bc2.$)));
((bc3).qc)=(fromBin_((bc1),(bc2.$)));
return bc3;
}
// _dtor
function bc4(bc5){
((bc5).yg)=(null);
((bc5).yc)=(null);
((bc5).ql)=(null);
((bc5).qX)=(null);
((bc5).qU)=(null);
((bc5).pY)=(null);
((bc5).q0)=(null);
((bc5).qz)=(null);
((bc5).zr)=(null);
}
// _copy
function bc6(bc7){
let bc8;
(bc8)=(new yf());
((bc8).yg)=(C_([130,134],((bc7).yg)));
((bc8).yc)=(C_([134],((bc7).yc)));
((bc8).ql)=(C_([134],((bc7).ql)));
((bc8).qX)=(C_([129,2],((bc7).qX)));
((bc8).qU)=(C_([134],((bc7).qU)));
((bc8).pY)=(C_([133,129,2,134],((bc7).pY)));
((bc8).q0)=(C_([129,2],((bc7).q0)));
((bc8).qz)=(C_([134],((bc7).qz)));
((bc8).zr)=(C_([134],((bc7).zr)));
((bc8).r5)=((bc7).r5);
((bc8).qc)=((bc7).qc);
return bc8;
}
// _toBin
function bc9(bcA){
let bcB;
(bcB)=(new Array(8).fill(0));
(bcB)=((bcB).concat(toBin_((bcA).yg)));
(bcB)=((bcB).concat(toBin_((bcA).yc)));
(bcB)=((bcB).concat(toBin_((bcA).ql)));
(bcB)=((bcB).concat(toBin_((bcA).qX)));
(bcB)=((bcB).concat(toBin_((bcA).qU)));
(bcB)=((bcB).concat(toBin_((bcA).pY)));
(bcB)=((bcB).concat(toBin_((bcA).q0)));
(bcB)=((bcB).concat(toBin_((bcA).qz)));
(bcB)=((bcB).concat(toBin_((bcA).zr)));
(bcB)=((bcB).concat(toBin_((bcA).r5)));
(bcB)=((bcB).concat(toBin_((bcA).qc)));
return bcB;
}
// _fromBin
function bcN(bcO,bcP,bcQ){
let bcR;
(bcR)=(new yf());
((bcR).yg)=(fromBin_((bcP),(bcQ.$)));
((bcR).yc)=(fromBin_((bcP),(bcQ.$)));
((bcR).ql)=(fromBin_((bcP),(bcQ.$)));
((bcR).qX)=(fromBin_((bcP),(bcQ.$)));
((bcR).qU)=(fromBin_((bcP),(bcQ.$)));
((bcR).pY)=(fromBin_((bcP),(bcQ.$)));
((bcR).q0)=(fromBin_((bcP),(bcQ.$)));
((bcR).qz)=(fromBin_((bcP),(bcQ.$)));
((bcR).zr)=(fromBin_((bcP),(bcQ.$)));
((bcR).r5)=(fromBin_((bcP),(bcQ.$)));
((bcR).qc)=(fromBin_((bcP),(bcQ.$)));
return bcR;
}
// _dtor
function bcS(bcT){
((bcT).y2)=(null);
((bcT).ql)=(null);
((bcT).qX)=(null);
((bcT).qU)=(null);
((bcT).pY)=(null);
((bcT).q0)=(null);
((bcT).qz)=(null);
((bcT).zr)=(null);
}
// _copy
function bcU(bcV){
let bcW;
(bcW)=(new ys());
((bcW).y2)=(C_([134],((bcV).y2)));
((bcW).ql)=(C_([134],((bcV).ql)));
((bcW).qX)=(C_([129,2],((bcV).qX)));
((bcW).qU)=(C_([134],((bcV).qU)));
((bcW).pY)=(C_([133,129,2,134],((bcV).pY)));
((bcW).q0)=(C_([129,2],((bcV).q0)));
((bcW).qz)=(C_([134],((bcV).qz)));
((bcW).zr)=(C_([134],((bcV).zr)));
((bcW).r5)=((bcV).r5);
((bcW).qc)=((bcV).qc);
return bcW;
}
// _toBin
function bcX(bcY){
let bcZ;
(bcZ)=(new Array(8).fill(0));
(bcZ)=((bcZ).concat(toBin_((bcY).y2)));
(bcZ)=((bcZ).concat(toBin_((bcY).ql)));
(bcZ)=((bcZ).concat(toBin_((bcY).qX)));
(bcZ)=((bcZ).concat(toBin_((bcY).qU)));
(bcZ)=((bcZ).concat(toBin_((bcY).pY)));
(bcZ)=((bcZ).concat(toBin_((bcY).q0)));
(bcZ)=((bcZ).concat(toBin_((bcY).qz)));
(bcZ)=((bcZ).concat(toBin_((bcY).zr)));
(bcZ)=((bcZ).concat(toBin_((bcY).r5)));
(bcZ)=((bcZ).concat(toBin_((bcY).qc)));
return bcZ;
}
// _fromBin
function bdk(bdl,bdm,bdn){
let bdo;
(bdo)=(new ys());
((bdo).y2)=(fromBin_((bdm),(bdn.$)));
((bdo).ql)=(fromBin_((bdm),(bdn.$)));
((bdo).qX)=(fromBin_((bdm),(bdn.$)));
((bdo).qU)=(fromBin_((bdm),(bdn.$)));
((bdo).pY)=(fromBin_((bdm),(bdn.$)));
((bdo).q0)=(fromBin_((bdm),(bdn.$)));
((bdo).qz)=(fromBin_((bdm),(bdn.$)));
((bdo).zr)=(fromBin_((bdm),(bdn.$)));
((bdo).r5)=(fromBin_((bdm),(bdn.$)));
((bdo).qc)=(fromBin_((bdm),(bdn.$)));
return bdo;
}
// _dtor
function bdp(bdq){
((bdq).yL)=(null);
((bdq).ql)=(null);
((bdq).qX)=(null);
((bdq).qU)=(null);
((bdq).pY)=(null);
((bdq).q0)=(null);
((bdq).qz)=(null);
((bdq).zr)=(null);
}
// _copy
function bdr(bds){
let bdt;
(bdt)=(new yw());
((bdt).yL)=(C_([134],((bds).yL)));
((bdt).yH)=((bds).yH);
((bdt).ql)=(C_([134],((bds).ql)));
((bdt).qX)=(C_([129,2],((bds).qX)));
((bdt).qU)=(C_([134],((bds).qU)));
((bdt).pY)=(C_([133,129,2,134],((bds).pY)));
((bdt).q0)=(C_([129,2],((bds).q0)));
((bdt).qz)=(C_([134],((bds).qz)));
((bdt).zr)=(C_([134],((bds).zr)));
((bdt).r5)=((bds).r5);
((bdt).qc)=((bds).qc);
return bdt;
}
// _toBin
function bdu(bdv){
let bdw;
(bdw)=(new Array(8).fill(0));
(bdw)=((bdw).concat(toBin_((bdv).yL)));
(bdw)=((bdw).concat(toBin_((bdv).yH)));
(bdw)=((bdw).concat(toBin_((bdv).ql)));
(bdw)=((bdw).concat(toBin_((bdv).qX)));
(bdw)=((bdw).concat(toBin_((bdv).qU)));
(bdw)=((bdw).concat(toBin_((bdv).pY)));
(bdw)=((bdw).concat(toBin_((bdv).q0)));
(bdw)=((bdw).concat(toBin_((bdv).qz)));
(bdw)=((bdw).concat(toBin_((bdv).zr)));
(bdw)=((bdw).concat(toBin_((bdv).r5)));
(bdw)=((bdw).concat(toBin_((bdv).qc)));
return bdw;
}
// _fromBin
function bd8(bd9,bdA,bdB){
let bdC;
(bdC)=(new yw());
((bdC).yL)=(fromBin_((bdA),(bdB.$)));
((bdC).yH)=(fromBin_((bdA),(bdB.$)));
((bdC).ql)=(fromBin_((bdA),(bdB.$)));
((bdC).qX)=(fromBin_((bdA),(bdB.$)));
((bdC).qU)=(fromBin_((bdA),(bdB.$)));
((bdC).pY)=(fromBin_((bdA),(bdB.$)));
((bdC).q0)=(fromBin_((bdA),(bdB.$)));
((bdC).qz)=(fromBin_((bdA),(bdB.$)));
((bdC).zr)=(fromBin_((bdA),(bdB.$)));
((bdC).r5)=(fromBin_((bdA),(bdB.$)));
((bdC).qc)=(fromBin_((bdA),(bdB.$)));
return bdC;
}
// _dtor
function bdD(bdE){
((bdE).y1)=(null);
((bdE).yy)=(null);
((bdE).yL)=(null);
((bdE).ql)=(null);
((bdE).qX)=(null);
((bdE).qU)=(null);
((bdE).pY)=(null);
((bdE).q0)=(null);
((bdE).qz)=(null);
((bdE).zr)=(null);
}
// _copy
function bdF(bdG){
let bdH;
(bdH)=(new yv());
((bdH).y1)=(C_([134],((bdG).y1)));
((bdH).yy)=(C_([130,134],((bdG).yy)));
((bdH).yL)=(C_([134],((bdG).yL)));
((bdH).yH)=((bdG).yH);
((bdH).ql)=(C_([134],((bdG).ql)));
((bdH).qX)=(C_([129,2],((bdG).qX)));
((bdH).qU)=(C_([134],((bdG).qU)));
((bdH).pY)=(C_([133,129,2,134],((bdG).pY)));
((bdH).q0)=(C_([129,2],((bdG).q0)));
((bdH).qz)=(C_([134],((bdG).qz)));
((bdH).zr)=(C_([134],((bdG).zr)));
((bdH).r5)=((bdG).r5);
((bdH).qc)=((bdG).qc);
return bdH;
}
// _toBin
function bdI(bdJ){
let bdK;
(bdK)=(new Array(8).fill(0));
(bdK)=((bdK).concat(toBin_((bdJ).y1)));
(bdK)=((bdK).concat(toBin_((bdJ).yy)));
(bdK)=((bdK).concat(toBin_((bdJ).yL)));
(bdK)=((bdK).concat(toBin_((bdJ).yH)));
(bdK)=((bdK).concat(toBin_((bdJ).ql)));
(bdK)=((bdK).concat(toBin_((bdJ).qX)));
(bdK)=((bdK).concat(toBin_((bdJ).qU)));
(bdK)=((bdK).concat(toBin_((bdJ).pY)));
(bdK)=((bdK).concat(toBin_((bdJ).q0)));
(bdK)=((bdK).concat(toBin_((bdJ).qz)));
(bdK)=((bdK).concat(toBin_((bdJ).zr)));
(bdK)=((bdK).concat(toBin_((bdJ).r5)));
(bdK)=((bdK).concat(toBin_((bdJ).qc)));
return bdK;
}
// _fromBin
function bdY(bdZ,bea,beb){
let bec;
(bec)=(new yv());
((bec).y1)=(fromBin_((bea),(beb.$)));
((bec).yy)=(fromBin_((bea),(beb.$)));
((bec).yL)=(fromBin_((bea),(beb.$)));
((bec).yH)=(fromBin_((bea),(beb.$)));
((bec).ql)=(fromBin_((bea),(beb.$)));
((bec).qX)=(fromBin_((bea),(beb.$)));
((bec).qU)=(fromBin_((bea),(beb.$)));
((bec).pY)=(fromBin_((bea),(beb.$)));
((bec).q0)=(fromBin_((bea),(beb.$)));
((bec).qz)=(fromBin_((bea),(beb.$)));
((bec).zr)=(fromBin_((bea),(beb.$)));
((bec).r5)=(fromBin_((bea),(beb.$)));
((bec).qc)=(fromBin_((bea),(beb.$)));
return bec;
}
// _dtor
function bed(bee){
((bee).y6)=(null);
((bee).y9)=(null);
((bee).ql)=(null);
((bee).qX)=(null);
((bee).qU)=(null);
((bee).pY)=(null);
((bee).q0)=(null);
((bee).qz)=(null);
((bee).zr)=(null);
}
// _copy
function bef(beg){
let beh;
(beh)=(new y5());
((beh).y6)=(C_([130,134],((beg).y6)));
((beh).y9)=(C_([134],((beg).y9)));
((beh).ql)=(C_([134],((beg).ql)));
((beh).qX)=(C_([129,2],((beg).qX)));
((beh).qU)=(C_([134],((beg).qU)));
((beh).pY)=(C_([133,129,2,134],((beg).pY)));
((beh).q0)=(C_([129,2],((beg).q0)));
((beh).qz)=(C_([134],((beg).qz)));
((beh).zr)=(C_([134],((beg).zr)));
((beh).r5)=((beg).r5);
((beh).qc)=((beg).qc);
return beh;
}
// _toBin
function bei(bej){
let bek;
(bek)=(new Array(8).fill(0));
(bek)=((bek).concat(toBin_((bej).y6)));
(bek)=((bek).concat(toBin_((bej).y9)));
(bek)=((bek).concat(toBin_((bej).ql)));
(bek)=((bek).concat(toBin_((bej).qX)));
(bek)=((bek).concat(toBin_((bej).qU)));
(bek)=((bek).concat(toBin_((bej).pY)));
(bek)=((bek).concat(toBin_((bej).q0)));
(bek)=((bek).concat(toBin_((bej).qz)));
(bek)=((bek).concat(toBin_((bej).zr)));
(bek)=((bek).concat(toBin_((bej).r5)));
(bek)=((bek).concat(toBin_((bej).qc)));
return bek;
}
// _fromBin
function bew(bex,bey,bez){
let be0;
(be0)=(new y5());
((be0).y6)=(fromBin_((bey),(bez.$)));
((be0).y9)=(fromBin_((bey),(bez.$)));
((be0).ql)=(fromBin_((bey),(bez.$)));
((be0).qX)=(fromBin_((bey),(bez.$)));
((be0).qU)=(fromBin_((bey),(bez.$)));
((be0).pY)=(fromBin_((bey),(bez.$)));
((be0).q0)=(fromBin_((bey),(bez.$)));
((be0).qz)=(fromBin_((bey),(bez.$)));
((be0).zr)=(fromBin_((bey),(bez.$)));
((be0).r5)=(fromBin_((bey),(bez.$)));
((be0).qc)=(fromBin_((bey),(bez.$)));
return be0;
}
// _dtor
function be1(be2){
((be2).yM)=(null);
((be2).yR)=(null);
}
// _copy
function be3(be4){
let be5;
(be5)=(new yC());
((be5).yM)=(C_([134],((be4).yM)));
((be5).yR)=(C_([134],((be4).yR)));
return be5;
}
// _toBin
function be6(be7){
let be8;
(be8)=(new Array(8).fill(0));
(be8)=((be8).concat(toBin_((be7).yM)));
(be8)=((be8).concat(toBin_((be7).yR)));
return be8;
}
// _fromBin
function beB(beC,beD,beE){
let beF;
(beF)=(new yC());
((beF).yM)=(fromBin_((beD),(beE.$)));
((beF).yR)=(fromBin_((beD),(beE.$)));
return beF;
}
// _dtor
function beG(beH){
((beH).yL)=(null);
((beH).ql)=(null);
((beH).qX)=(null);
((beH).qU)=(null);
((beH).pY)=(null);
((beH).q0)=(null);
((beH).qz)=(null);
((beH).zr)=(null);
}
// _copy
function beI(beJ){
let beK;
(beK)=(new yG());
((beK).yL)=(C_([134],((beJ).yL)));
((beK).yH)=((beJ).yH);
((beK).ql)=(C_([134],((beJ).ql)));
((beK).qX)=(C_([129,2],((beJ).qX)));
((beK).qU)=(C_([134],((beJ).qU)));
((beK).pY)=(C_([133,129,2,134],((beJ).pY)));
((beK).q0)=(C_([129,2],((beJ).q0)));
((beK).qz)=(C_([134],((beJ).qz)));
((beK).zr)=(C_([134],((beJ).zr)));
((beK).r5)=((beJ).r5);
((beK).qc)=((beJ).qc);
return beK;
}
// _toBin
function beL(beM){
let beN;
(beN)=(new Array(8).fill(0));
(beN)=((beN).concat(toBin_((beM).yL)));
(beN)=((beN).concat(toBin_((beM).yH)));
(beN)=((beN).concat(toBin_((beM).ql)));
(beN)=((beN).concat(toBin_((beM).qX)));
(beN)=((beN).concat(toBin_((beM).qU)));
(beN)=((beN).concat(toBin_((beM).pY)));
(beN)=((beN).concat(toBin_((beM).q0)));
(beN)=((beN).concat(toBin_((beM).qz)));
(beN)=((beN).concat(toBin_((beM).zr)));
(beN)=((beN).concat(toBin_((beM).r5)));
(beN)=((beN).concat(toBin_((beM).qc)));
return beN;
}
// _fromBin
function beZ(bfa,bfb,bfc){
let bfd;
(bfd)=(new yG());
((bfd).yL)=(fromBin_((bfb),(bfc.$)));
((bfd).yH)=(fromBin_((bfb),(bfc.$)));
((bfd).ql)=(fromBin_((bfb),(bfc.$)));
((bfd).qX)=(fromBin_((bfb),(bfc.$)));
((bfd).qU)=(fromBin_((bfb),(bfc.$)));
((bfd).pY)=(fromBin_((bfb),(bfc.$)));
((bfd).q0)=(fromBin_((bfb),(bfc.$)));
((bfd).qz)=(fromBin_((bfb),(bfc.$)));
((bfd).zr)=(fromBin_((bfb),(bfc.$)));
((bfd).r5)=(fromBin_((bfb),(bfc.$)));
((bfd).qc)=(fromBin_((bfb),(bfc.$)));
return bfd;
}
// _dtor
function bfe(bff){
((bff).yL)=(null);
((bff).ql)=(null);
((bff).qX)=(null);
((bff).qU)=(null);
((bff).pY)=(null);
((bff).q0)=(null);
((bff).qz)=(null);
((bff).zr)=(null);
}
// _copy
function bfg(bfh){
let bfi;
(bfi)=(new yF());
((bfi).yI)=((bfh).yI);
((bfi).yL)=(C_([134],((bfh).yL)));
((bfi).yH)=((bfh).yH);
((bfi).ql)=(C_([134],((bfh).ql)));
((bfi).qX)=(C_([129,2],((bfh).qX)));
((bfi).qU)=(C_([134],((bfh).qU)));
((bfi).pY)=(C_([133,129,2,134],((bfh).pY)));
((bfi).q0)=(C_([129,2],((bfh).q0)));
((bfi).qz)=(C_([134],((bfh).qz)));
((bfi).zr)=(C_([134],((bfh).zr)));
((bfi).r5)=((bfh).r5);
((bfi).qc)=((bfh).qc);
return bfi;
}
// _toBin
function bfj(bfk){
let bfl;
(bfl)=(new Array(8).fill(0));
(bfl)=((bfl).concat(toBin_((bfk).yI)));
(bfl)=((bfl).concat(toBin_((bfk).yL)));
(bfl)=((bfl).concat(toBin_((bfk).yH)));
(bfl)=((bfl).concat(toBin_((bfk).ql)));
(bfl)=((bfl).concat(toBin_((bfk).qX)));
(bfl)=((bfl).concat(toBin_((bfk).qU)));
(bfl)=((bfl).concat(toBin_((bfk).pY)));
(bfl)=((bfl).concat(toBin_((bfk).q0)));
(bfl)=((bfl).concat(toBin_((bfk).qz)));
(bfl)=((bfl).concat(toBin_((bfk).zr)));
(bfl)=((bfl).concat(toBin_((bfk).r5)));
(bfl)=((bfl).concat(toBin_((bfk).qc)));
return bfl;
}
// _fromBin
function bfy(bfz,bf0,bf1){
let bf2;
(bf2)=(new yF());
((bf2).yI)=(fromBin_((bf0),(bf1.$)));
((bf2).yL)=(fromBin_((bf0),(bf1.$)));
((bf2).yH)=(fromBin_((bf0),(bf1.$)));
((bf2).ql)=(fromBin_((bf0),(bf1.$)));
((bf2).qX)=(fromBin_((bf0),(bf1.$)));
((bf2).qU)=(fromBin_((bf0),(bf1.$)));
((bf2).pY)=(fromBin_((bf0),(bf1.$)));
((bf2).q0)=(fromBin_((bf0),(bf1.$)));
((bf2).qz)=(fromBin_((bf0),(bf1.$)));
((bf2).zr)=(fromBin_((bf0),(bf1.$)));
((bf2).r5)=(fromBin_((bf0),(bf1.$)));
((bf2).qc)=(fromBin_((bf0),(bf1.$)));
return bf2;
}
// _dtor
function bf3(bf4){
((bf4).zf)=(null);
}
// _copy
function bf5(bf6){
let bf7;
(bf7)=(new za());
((bf7).zf)=(C_([134],((bf6).zf)));
((bf7).zb)=((bf6).zb);
((bf7).zc)=((bf6).zc);
return bf7;
}
// _toBin
function bf8(bf9){
let bfA;
(bfA)=(new Array(8).fill(0));
(bfA)=((bfA).concat(toBin_((bf9).zf)));
(bfA)=((bfA).concat(toBin_((bf9).zb)));
(bfA)=((bfA).concat(toBin_((bf9).zc)));
return bfA;
}
// _fromBin
function bfE(bfF,bfG,bfH){
let bfI;
(bfI)=(new za());
((bfI).zf)=(fromBin_((bfG),(bfH.$)));
((bfI).zb)=(fromBin_((bfG),(bfH.$)));
((bfI).zc)=(fromBin_((bfG),(bfH.$)));
return bfI;
}
// _dtor
function bfJ(bfK){
((bfK).zP)=(null);
((bfK).zQ)=(null);
((bfK).yL)=(null);
((bfK).ql)=(null);
((bfK).qX)=(null);
((bfK).qU)=(null);
((bfK).pY)=(null);
((bfK).q0)=(null);
((bfK).qz)=(null);
((bfK).zr)=(null);
}
// _copy
function bfL(bfM){
let bfN;
(bfN)=(new zL());
((bfN).zM)=((bfM).zM);
((bfN).zP)=(C_([134],((bfM).zP)));
((bfN).zQ)=(C_([134],((bfM).zQ)));
((bfN).yL)=(C_([134],((bfM).yL)));
((bfN).yH)=((bfM).yH);
((bfN).ql)=(C_([134],((bfM).ql)));
((bfN).qX)=(C_([129,2],((bfM).qX)));
((bfN).qU)=(C_([134],((bfM).qU)));
((bfN).pY)=(C_([133,129,2,134],((bfM).pY)));
((bfN).q0)=(C_([129,2],((bfM).q0)));
((bfN).qz)=(C_([134],((bfM).qz)));
((bfN).zr)=(C_([134],((bfM).zr)));
((bfN).r5)=((bfM).r5);
((bfN).qc)=((bfM).qc);
return bfN;
}
// _toBin
function bfO(bfP){
let bfQ;
(bfQ)=(new Array(8).fill(0));
(bfQ)=((bfQ).concat(toBin_((bfP).zM)));
(bfQ)=((bfQ).concat(toBin_((bfP).zP)));
(bfQ)=((bfQ).concat(toBin_((bfP).zQ)));
(bfQ)=((bfQ).concat(toBin_((bfP).yL)));
(bfQ)=((bfQ).concat(toBin_((bfP).yH)));
(bfQ)=((bfQ).concat(toBin_((bfP).ql)));
(bfQ)=((bfQ).concat(toBin_((bfP).qX)));
(bfQ)=((bfQ).concat(toBin_((bfP).qU)));
(bfQ)=((bfQ).concat(toBin_((bfP).pY)));
(bfQ)=((bfQ).concat(toBin_((bfP).q0)));
(bfQ)=((bfQ).concat(toBin_((bfP).qz)));
(bfQ)=((bfQ).concat(toBin_((bfP).zr)));
(bfQ)=((bfQ).concat(toBin_((bfP).r5)));
(bfQ)=((bfQ).concat(toBin_((bfP).qc)));
return bfQ;
}
// _fromBin
function bgf(bgg,bgh,bgi){
let bgj;
(bgj)=(new zL());
((bgj).zM)=(fromBin_((bgh),(bgi.$)));
((bgj).zP)=(fromBin_((bgh),(bgi.$)));
((bgj).zQ)=(fromBin_((bgh),(bgi.$)));
((bgj).yL)=(fromBin_((bgh),(bgi.$)));
((bgj).yH)=(fromBin_((bgh),(bgi.$)));
((bgj).ql)=(fromBin_((bgh),(bgi.$)));
((bgj).qX)=(fromBin_((bgh),(bgi.$)));
((bgj).qU)=(fromBin_((bgh),(bgi.$)));
((bgj).pY)=(fromBin_((bgh),(bgi.$)));
((bgj).q0)=(fromBin_((bgh),(bgi.$)));
((bgj).qz)=(fromBin_((bgh),(bgi.$)));
((bgj).zr)=(fromBin_((bgh),(bgi.$)));
((bgj).r5)=(fromBin_((bgh),(bgi.$)));
((bgj).qc)=(fromBin_((bgh),(bgi.$)));
return bgj;
}
// _dtor
function bgk(bgl){
((bgl).ql)=(null);
((bgl).qX)=(null);
((bgl).qU)=(null);
((bgl).pY)=(null);
((bgl).q0)=(null);
((bgl).qz)=(null);
((bgl).zr)=(null);
}
// _copy
function bgm(bgn){
let bgo;
(bgo)=(new Ay());
((bgo).ql)=(C_([134],((bgn).ql)));
((bgo).qX)=(C_([129,2],((bgn).qX)));
((bgo).qU)=(C_([134],((bgn).qU)));
((bgo).pY)=(C_([133,129,2,134],((bgn).pY)));
((bgo).q0)=(C_([129,2],((bgn).q0)));
((bgo).qz)=(C_([134],((bgn).qz)));
((bgo).zr)=(C_([134],((bgn).zr)));
((bgo).r5)=((bgn).r5);
((bgo).qc)=((bgn).qc);
return bgo;
}
// _toBin
function bgp(bgq){
let bgr;
(bgr)=(new Array(8).fill(0));
(bgr)=((bgr).concat(toBin_((bgq).ql)));
(bgr)=((bgr).concat(toBin_((bgq).qX)));
(bgr)=((bgr).concat(toBin_((bgq).qU)));
(bgr)=((bgr).concat(toBin_((bgq).pY)));
(bgr)=((bgr).concat(toBin_((bgq).q0)));
(bgr)=((bgr).concat(toBin_((bgq).qz)));
(bgr)=((bgr).concat(toBin_((bgq).zr)));
(bgr)=((bgr).concat(toBin_((bgq).r5)));
(bgr)=((bgr).concat(toBin_((bgq).qc)));
return bgr;
}
// _fromBin
function bg1(bg2,bg3,bg4){
let bg5;
(bg5)=(new Ay());
((bg5).ql)=(fromBin_((bg3),(bg4.$)));
((bg5).qX)=(fromBin_((bg3),(bg4.$)));
((bg5).qU)=(fromBin_((bg3),(bg4.$)));
((bg5).pY)=(fromBin_((bg3),(bg4.$)));
((bg5).q0)=(fromBin_((bg3),(bg4.$)));
((bg5).qz)=(fromBin_((bg3),(bg4.$)));
((bg5).zr)=(fromBin_((bg3),(bg4.$)));
((bg5).r5)=(fromBin_((bg3),(bg4.$)));
((bg5).qc)=(fromBin_((bg3),(bg4.$)));
return bg5;
}
// _dtor
function bg6(bg7){
((bg7).Az)=(null);
((bg7).ql)=(null);
((bg7).qX)=(null);
((bg7).qU)=(null);
((bg7).pY)=(null);
((bg7).q0)=(null);
((bg7).qz)=(null);
((bg7).zr)=(null);
}
// _copy
function bg8(bg9){
let bgA;
(bgA)=(new Ax());
((bgA).Az)=(C_([134],((bg9).Az)));
((bgA).ql)=(C_([134],((bg9).ql)));
((bgA).qX)=(C_([129,2],((bg9).qX)));
((bgA).qU)=(C_([134],((bg9).qU)));
((bgA).pY)=(C_([133,129,2,134],((bg9).pY)));
((bgA).q0)=(C_([129,2],((bg9).q0)));
((bgA).qz)=(C_([134],((bg9).qz)));
((bgA).zr)=(C_([134],((bg9).zr)));
((bgA).r5)=((bg9).r5);
((bgA).qc)=((bg9).qc);
return bgA;
}
// _toBin
function bgB(bgC){
let bgD;
(bgD)=(new Array(8).fill(0));
(bgD)=((bgD).concat(toBin_((bgC).Az)));
(bgD)=((bgD).concat(toBin_((bgC).ql)));
(bgD)=((bgD).concat(toBin_((bgC).qX)));
(bgD)=((bgD).concat(toBin_((bgC).qU)));
(bgD)=((bgD).concat(toBin_((bgC).pY)));
(bgD)=((bgD).concat(toBin_((bgC).q0)));
(bgD)=((bgD).concat(toBin_((bgC).qz)));
(bgD)=((bgD).concat(toBin_((bgC).zr)));
(bgD)=((bgD).concat(toBin_((bgC).r5)));
(bgD)=((bgD).concat(toBin_((bgC).qc)));
return bgD;
}
// _fromBin
function bgO(bgP,bgQ,bgR){
let bgS;
(bgS)=(new Ax());
((bgS).Az)=(fromBin_((bgQ),(bgR.$)));
((bgS).ql)=(fromBin_((bgQ),(bgR.$)));
((bgS).qX)=(fromBin_((bgQ),(bgR.$)));
((bgS).qU)=(fromBin_((bgQ),(bgR.$)));
((bgS).pY)=(fromBin_((bgQ),(bgR.$)));
((bgS).q0)=(fromBin_((bgQ),(bgR.$)));
((bgS).qz)=(fromBin_((bgQ),(bgR.$)));
((bgS).zr)=(fromBin_((bgQ),(bgR.$)));
((bgS).r5)=(fromBin_((bgQ),(bgR.$)));
((bgS).qc)=(fromBin_((bgQ),(bgR.$)));
return bgS;
}
// _dtor
function bgT(bgU){
((bgU).ql)=(null);
((bgU).qX)=(null);
((bgU).qU)=(null);
((bgU).pY)=(null);
((bgU).q0)=(null);
((bgU).qz)=(null);
((bgU).zr)=(null);
}
// _copy
function bgV(bgW){
let bgX;
(bgX)=(new A1());
((bgX).A2)=((bgW).A2);
((bgX).ql)=(C_([134],((bgW).ql)));
((bgX).qX)=(C_([129,2],((bgW).qX)));
((bgX).qU)=(C_([134],((bgW).qU)));
((bgX).pY)=(C_([133,129,2,134],((bgW).pY)));
((bgX).q0)=(C_([129,2],((bgW).q0)));
((bgX).qz)=(C_([134],((bgW).qz)));
((bgX).zr)=(C_([134],((bgW).zr)));
((bgX).r5)=((bgW).r5);
((bgX).qc)=((bgW).qc);
return bgX;
}
// _toBin
function bgY(bgZ){
let bha;
(bha)=(new Array(8).fill(0));
(bha)=((bha).concat(toBin_((bgZ).A2)));
(bha)=((bha).concat(toBin_((bgZ).ql)));
(bha)=((bha).concat(toBin_((bgZ).qX)));
(bha)=((bha).concat(toBin_((bgZ).qU)));
(bha)=((bha).concat(toBin_((bgZ).pY)));
(bha)=((bha).concat(toBin_((bgZ).q0)));
(bha)=((bha).concat(toBin_((bgZ).qz)));
(bha)=((bha).concat(toBin_((bgZ).zr)));
(bha)=((bha).concat(toBin_((bgZ).r5)));
(bha)=((bha).concat(toBin_((bgZ).qc)));
return bha;
}
// _fromBin
function bhl(bhm,bhn,bho){
let bhp;
(bhp)=(new A1());
((bhp).A2)=(fromBin_((bhn),(bho.$)));
((bhp).ql)=(fromBin_((bhn),(bho.$)));
((bhp).qX)=(fromBin_((bhn),(bho.$)));
((bhp).qU)=(fromBin_((bhn),(bho.$)));
((bhp).pY)=(fromBin_((bhn),(bho.$)));
((bhp).q0)=(fromBin_((bhn),(bho.$)));
((bhp).qz)=(fromBin_((bhn),(bho.$)));
((bhp).zr)=(fromBin_((bhn),(bho.$)));
((bhp).r5)=(fromBin_((bhn),(bho.$)));
((bhp).qc)=(fromBin_((bhn),(bho.$)));
return bhp;
}
// _dtor
function bhq(bhr){
((bhr).ad8)=(null);
((bhr).AC)=(null);
((bhr).A7)=(null);
((bhr).ql)=(null);
((bhr).qX)=(null);
((bhr).qU)=(null);
((bhr).pY)=(null);
((bhr).q0)=(null);
((bhr).qz)=(null);
((bhr).zr)=(null);
}
// _copy
function bhs(bht){
let bhu;
(bhu)=(new A5());
((bhu).ad7)=((bht).ad7);
((bhu).ad8)=(C_([130,129,2],((bht).ad8)));
((bhu).AC)=(C_([130,134],((bht).AC)));
((bhu).A7)=(C_([134],((bht).A7)));
((bhu).ql)=(C_([134],((bht).ql)));
((bhu).qX)=(C_([129,2],((bht).qX)));
((bhu).qU)=(C_([134],((bht).qU)));
((bhu).pY)=(C_([133,129,2,134],((bht).pY)));
((bhu).q0)=(C_([129,2],((bht).q0)));
((bhu).qz)=(C_([134],((bht).qz)));
((bhu).zr)=(C_([134],((bht).zr)));
((bhu).r5)=((bht).r5);
((bhu).qc)=((bht).qc);
return bhu;
}
// _toBin
function bhv(bhw){
let bhx;
(bhx)=(new Array(8).fill(0));
(bhx)=((bhx).concat(toBin_((bhw).ad7)));
(bhx)=((bhx).concat(toBin_((bhw).ad8)));
(bhx)=((bhx).concat(toBin_((bhw).AC)));
(bhx)=((bhx).concat(toBin_((bhw).A7)));
(bhx)=((bhx).concat(toBin_((bhw).ql)));
(bhx)=((bhx).concat(toBin_((bhw).qX)));
(bhx)=((bhx).concat(toBin_((bhw).qU)));
(bhx)=((bhx).concat(toBin_((bhw).pY)));
(bhx)=((bhx).concat(toBin_((bhw).q0)));
(bhx)=((bhx).concat(toBin_((bhw).qz)));
(bhx)=((bhx).concat(toBin_((bhw).zr)));
(bhx)=((bhx).concat(toBin_((bhw).r5)));
(bhx)=((bhx).concat(toBin_((bhw).qc)));
return bhx;
}
// _fromBin
function bhB(bhC,bhD,bhE){
let bhF;
(bhF)=(new A5());
((bhF).ad7)=(fromBin_((bhD),(bhE.$)));
((bhF).ad8)=(fromBin_((bhD),(bhE.$)));
((bhF).AC)=(fromBin_((bhD),(bhE.$)));
((bhF).A7)=(fromBin_((bhD),(bhE.$)));
((bhF).ql)=(fromBin_((bhD),(bhE.$)));
((bhF).qX)=(fromBin_((bhD),(bhE.$)));
((bhF).qU)=(fromBin_((bhD),(bhE.$)));
((bhF).pY)=(fromBin_((bhD),(bhE.$)));
((bhF).q0)=(fromBin_((bhD),(bhE.$)));
((bhF).qz)=(fromBin_((bhD),(bhE.$)));
((bhF).zr)=(fromBin_((bhD),(bhE.$)));
((bhF).r5)=(fromBin_((bhD),(bhE.$)));
((bhF).qc)=(fromBin_((bhD),(bhE.$)));
return bhF;
}
// _dtor
function bhG(bhH){
((bhH).AL)=(null);
}
// _copy
function bhI(bhJ){
let bhK;
(bhK)=(new AF());
((bhK).AL)=(C_([134],((bhJ).AL)));
((bhK).AN)=((bhJ).AN);
return bhK;
}
// _toBin
function bhL(bhM){
let bhN;
(bhN)=(new Array(8).fill(0));
(bhN)=((bhN).concat(toBin_((bhM).AL)));
(bhN)=((bhN).concat(toBin_((bhM).AN)));
return bhN;
}
// _fromBin
function bhQ(bhR,bhS,bhT){
let bhU;
(bhU)=(new AF());
((bhU).AL)=(fromBin_((bhS),(bhT.$)));
((bhU).AN)=(fromBin_((bhS),(bhT.$)));
return bhU;
}
// _dtor
function bhV(bhW){
((bhW).AX)=(null);
((bhW).ql)=(null);
((bhW).qX)=(null);
((bhW).qU)=(null);
((bhW).pY)=(null);
((bhW).q0)=(null);
((bhW).qz)=(null);
((bhW).zr)=(null);
}
// _copy
function bhX(bhY){
let bhZ;
(bhZ)=(new AS());
((bhZ).AV)=((bhY).AV);
((bhZ).AX)=(C_([134],((bhY).AX)));
((bhZ).ql)=(C_([134],((bhY).ql)));
((bhZ).qX)=(C_([129,2],((bhY).qX)));
((bhZ).qU)=(C_([134],((bhY).qU)));
((bhZ).pY)=(C_([133,129,2,134],((bhY).pY)));
((bhZ).q0)=(C_([129,2],((bhY).q0)));
((bhZ).qz)=(C_([134],((bhY).qz)));
((bhZ).zr)=(C_([134],((bhY).zr)));
((bhZ).r5)=((bhY).r5);
((bhZ).qc)=((bhY).qc);
return bhZ;
}
// _toBin
function bia(bib){
let bic;
(bic)=(new Array(8).fill(0));
(bic)=((bic).concat(toBin_((bib).AV)));
(bic)=((bic).concat(toBin_((bib).AX)));
(bic)=((bic).concat(toBin_((bib).ql)));
(bic)=((bic).concat(toBin_((bib).qX)));
(bic)=((bic).concat(toBin_((bib).qU)));
(bic)=((bic).concat(toBin_((bib).pY)));
(bic)=((bic).concat(toBin_((bib).q0)));
(bic)=((bic).concat(toBin_((bib).qz)));
(bic)=((bic).concat(toBin_((bib).zr)));
(bic)=((bic).concat(toBin_((bib).r5)));
(bic)=((bic).concat(toBin_((bib).qc)));
return bic;
}
// _fromBin
function bio(bip,biq,bir){
let bis;
(bis)=(new AS());
((bis).AV)=(fromBin_((biq),(bir.$)));
((bis).AX)=(fromBin_((biq),(bir.$)));
((bis).ql)=(fromBin_((biq),(bir.$)));
((bis).qX)=(fromBin_((biq),(bir.$)));
((bis).qU)=(fromBin_((biq),(bir.$)));
((bis).pY)=(fromBin_((biq),(bir.$)));
((bis).q0)=(fromBin_((biq),(bir.$)));
((bis).qz)=(fromBin_((biq),(bir.$)));
((bis).zr)=(fromBin_((biq),(bir.$)));
((bis).r5)=(fromBin_((biq),(bir.$)));
((bis).qc)=(fromBin_((biq),(bir.$)));
return bis;
}
// _dtor
function bit(biu){
((biu).Be)=(null);
((biu).Bf)=(null);
((biu).ql)=(null);
((biu).qX)=(null);
((biu).qU)=(null);
((biu).pY)=(null);
((biu).q0)=(null);
((biu).qz)=(null);
((biu).zr)=(null);
}
// _copy
function biv(biw){
let bix;
(bix)=(new Bd());
((bix).Be)=(C_([134],((biw).Be)));
((bix).Bf)=(C_([134],((biw).Bf)));
((bix).ql)=(C_([134],((biw).ql)));
((bix).qX)=(C_([129,2],((biw).qX)));
((bix).qU)=(C_([134],((biw).qU)));
((bix).pY)=(C_([133,129,2,134],((biw).pY)));
((bix).q0)=(C_([129,2],((biw).q0)));
((bix).qz)=(C_([134],((biw).qz)));
((bix).zr)=(C_([134],((biw).zr)));
((bix).r5)=((biw).r5);
((bix).qc)=((biw).qc);
return bix;
}
// _toBin
function biy(biz){
let bi0;
(bi0)=(new Array(8).fill(0));
(bi0)=((bi0).concat(toBin_((biz).Be)));
(bi0)=((bi0).concat(toBin_((biz).Bf)));
(bi0)=((bi0).concat(toBin_((biz).ql)));
(bi0)=((bi0).concat(toBin_((biz).qX)));
(bi0)=((bi0).concat(toBin_((biz).qU)));
(bi0)=((bi0).concat(toBin_((biz).pY)));
(bi0)=((bi0).concat(toBin_((biz).q0)));
(bi0)=((bi0).concat(toBin_((biz).qz)));
(bi0)=((bi0).concat(toBin_((biz).zr)));
(bi0)=((bi0).concat(toBin_((biz).r5)));
(bi0)=((bi0).concat(toBin_((biz).qc)));
return bi0;
}
// _fromBin
function biC(biD,biE,biF){
let biG;
(biG)=(new Bd());
((biG).Be)=(fromBin_((biE),(biF.$)));
((biG).Bf)=(fromBin_((biE),(biF.$)));
((biG).ql)=(fromBin_((biE),(biF.$)));
((biG).qX)=(fromBin_((biE),(biF.$)));
((biG).qU)=(fromBin_((biE),(biF.$)));
((biG).pY)=(fromBin_((biE),(biF.$)));
((biG).q0)=(fromBin_((biE),(biF.$)));
((biG).qz)=(fromBin_((biE),(biF.$)));
((biG).zr)=(fromBin_((biE),(biF.$)));
((biG).r5)=(fromBin_((biE),(biF.$)));
((biG).qc)=(fromBin_((biE),(biF.$)));
return biG;
}
// _dtor
function biH(biI){
((biI).Uy)=(null);
((biI).U0)=(null);
((biI).U6)=(null);
((biI).UD)=(null);
((biI).yc)=(null);
((biI).ql)=(null);
((biI).qX)=(null);
((biI).qU)=(null);
((biI).pY)=(null);
((biI).q0)=(null);
((biI).qz)=(null);
((biI).zr)=(null);
}
// _copy
function biJ(biK){
let biL;
(biL)=(new Fm());
((biL).Uy)=(C_([134],((biK).Uy)));
((biL).U0)=(C_([134],((biK).U0)));
((biL).U6)=(C_([130,134],((biK).U6)));
((biL).UD)=(C_([134],((biK).UD)));
((biL).yc)=(C_([134],((biK).yc)));
((biL).ql)=(C_([134],((biK).ql)));
((biL).qX)=(C_([129,2],((biK).qX)));
((biL).qU)=(C_([134],((biK).qU)));
((biL).pY)=(C_([133,129,2,134],((biK).pY)));
((biL).q0)=(C_([129,2],((biK).q0)));
((biL).qz)=(C_([134],((biK).qz)));
((biL).zr)=(C_([134],((biK).zr)));
((biL).r5)=((biK).r5);
((biL).qc)=((biK).qc);
return biL;
}
// _toBin
function biM(biN){
let biO;
(biO)=(new Array(8).fill(0));
(biO)=((biO).concat(toBin_((biN).Uy)));
(biO)=((biO).concat(toBin_((biN).U0)));
(biO)=((biO).concat(toBin_((biN).U6)));
(biO)=((biO).concat(toBin_((biN).UD)));
(biO)=((biO).concat(toBin_((biN).yc)));
(biO)=((biO).concat(toBin_((biN).ql)));
(biO)=((biO).concat(toBin_((biN).qX)));
(biO)=((biO).concat(toBin_((biN).qU)));
(biO)=((biO).concat(toBin_((biN).pY)));
(biO)=((biO).concat(toBin_((biN).q0)));
(biO)=((biO).concat(toBin_((biN).qz)));
(biO)=((biO).concat(toBin_((biN).zr)));
(biO)=((biO).concat(toBin_((biN).r5)));
(biO)=((biO).concat(toBin_((biN).qc)));
return biO;
}
// _fromBin
function bjd(bje,bjf,bjg){
let bjh;
(bjh)=(new Fm());
((bjh).Uy)=(fromBin_((bjf),(bjg.$)));
((bjh).U0)=(fromBin_((bjf),(bjg.$)));
((bjh).U6)=(fromBin_((bjf),(bjg.$)));
((bjh).UD)=(fromBin_((bjf),(bjg.$)));
((bjh).yc)=(fromBin_((bjf),(bjg.$)));
((bjh).ql)=(fromBin_((bjf),(bjg.$)));
((bjh).qX)=(fromBin_((bjf),(bjg.$)));
((bjh).qU)=(fromBin_((bjf),(bjg.$)));
((bjh).pY)=(fromBin_((bjf),(bjg.$)));
((bjh).q0)=(fromBin_((bjf),(bjg.$)));
((bjh).qz)=(fromBin_((bjf),(bjg.$)));
((bjh).zr)=(fromBin_((bjf),(bjg.$)));
((bjh).r5)=(fromBin_((bjf),(bjg.$)));
((bjh).qc)=(fromBin_((bjf),(bjg.$)));
return bjh;
}
// _dtor
function bji(bjj){
((bjj).UR)=(null);
((bjj).UW)=(null);
((bjj).Vr)=(null);
((bjj).yc)=(null);
((bjj).ql)=(null);
((bjj).qX)=(null);
((bjj).qU)=(null);
((bjj).pY)=(null);
((bjj).q0)=(null);
((bjj).qz)=(null);
((bjj).zr)=(null);
}
// _copy
function bjk(bjl){
let bjm;
(bjm)=(new Fp());
((bjm).UR)=(C_([134],((bjl).UR)));
((bjm).UW)=(C_([130,134],((bjl).UW)));
((bjm).Vr)=(C_([134],((bjl).Vr)));
((bjm).yc)=(C_([134],((bjl).yc)));
((bjm).ql)=(C_([134],((bjl).ql)));
((bjm).qX)=(C_([129,2],((bjl).qX)));
((bjm).qU)=(C_([134],((bjl).qU)));
((bjm).pY)=(C_([133,129,2,134],((bjl).pY)));
((bjm).q0)=(C_([129,2],((bjl).q0)));
((bjm).qz)=(C_([134],((bjl).qz)));
((bjm).zr)=(C_([134],((bjl).zr)));
((bjm).r5)=((bjl).r5);
((bjm).qc)=((bjl).qc);
return bjm;
}
// _toBin
function bjn(bjo){
let bjp;
(bjp)=(new Array(8).fill(0));
(bjp)=((bjp).concat(toBin_((bjo).UR)));
(bjp)=((bjp).concat(toBin_((bjo).UW)));
(bjp)=((bjp).concat(toBin_((bjo).Vr)));
(bjp)=((bjp).concat(toBin_((bjo).yc)));
(bjp)=((bjp).concat(toBin_((bjo).ql)));
(bjp)=((bjp).concat(toBin_((bjo).qX)));
(bjp)=((bjp).concat(toBin_((bjo).qU)));
(bjp)=((bjp).concat(toBin_((bjo).pY)));
(bjp)=((bjp).concat(toBin_((bjo).q0)));
(bjp)=((bjp).concat(toBin_((bjo).qz)));
(bjp)=((bjp).concat(toBin_((bjo).zr)));
(bjp)=((bjp).concat(toBin_((bjo).r5)));
(bjp)=((bjp).concat(toBin_((bjo).qc)));
return bjp;
}
// _fromBin
function bj3(bj4,bj5,bj6){
let bj7;
(bj7)=(new Fp());
((bj7).UR)=(fromBin_((bj5),(bj6.$)));
((bj7).UW)=(fromBin_((bj5),(bj6.$)));
((bj7).Vr)=(fromBin_((bj5),(bj6.$)));
((bj7).yc)=(fromBin_((bj5),(bj6.$)));
((bj7).ql)=(fromBin_((bj5),(bj6.$)));
((bj7).qX)=(fromBin_((bj5),(bj6.$)));
((bj7).qU)=(fromBin_((bj5),(bj6.$)));
((bj7).pY)=(fromBin_((bj5),(bj6.$)));
((bj7).q0)=(fromBin_((bj5),(bj6.$)));
((bj7).qz)=(fromBin_((bj5),(bj6.$)));
((bj7).zr)=(fromBin_((bj5),(bj6.$)));
((bj7).r5)=(fromBin_((bj5),(bj6.$)));
((bj7).qc)=(fromBin_((bj5),(bj6.$)));
return bj7;
}
// _dtor
function bj8(bj9){
((bj9).yc)=(null);
((bj9).ql)=(null);
((bj9).qX)=(null);
((bj9).qU)=(null);
((bj9).pY)=(null);
((bj9).q0)=(null);
((bj9).qz)=(null);
((bj9).zr)=(null);
}
// _copy
function bjA(bjB){
let bjC;
(bjC)=(new Ft());
((bjC).yc)=(C_([134],((bjB).yc)));
((bjC).ql)=(C_([134],((bjB).ql)));
((bjC).qX)=(C_([129,2],((bjB).qX)));
((bjC).qU)=(C_([134],((bjB).qU)));
((bjC).pY)=(C_([133,129,2,134],((bjB).pY)));
((bjC).q0)=(C_([129,2],((bjB).q0)));
((bjC).qz)=(C_([134],((bjB).qz)));
((bjC).zr)=(C_([134],((bjB).zr)));
((bjC).r5)=((bjB).r5);
((bjC).qc)=((bjB).qc);
return bjC;
}
// _toBin
function bjD(bjE){
let bjF;
(bjF)=(new Array(8).fill(0));
(bjF)=((bjF).concat(toBin_((bjE).yc)));
(bjF)=((bjF).concat(toBin_((bjE).ql)));
(bjF)=((bjF).concat(toBin_((bjE).qX)));
(bjF)=((bjF).concat(toBin_((bjE).qU)));
(bjF)=((bjF).concat(toBin_((bjE).pY)));
(bjF)=((bjF).concat(toBin_((bjE).q0)));
(bjF)=((bjF).concat(toBin_((bjE).qz)));
(bjF)=((bjF).concat(toBin_((bjE).zr)));
(bjF)=((bjF).concat(toBin_((bjE).r5)));
(bjF)=((bjF).concat(toBin_((bjE).qc)));
return bjF;
}
// _fromBin
function bjQ(bjR,bjS,bjT){
let bjU;
(bjU)=(new Ft());
((bjU).yc)=(fromBin_((bjS),(bjT.$)));
((bjU).ql)=(fromBin_((bjS),(bjT.$)));
((bjU).qX)=(fromBin_((bjS),(bjT.$)));
((bjU).qU)=(fromBin_((bjS),(bjT.$)));
((bjU).pY)=(fromBin_((bjS),(bjT.$)));
((bjU).q0)=(fromBin_((bjS),(bjT.$)));
((bjU).qz)=(fromBin_((bjS),(bjT.$)));
((bjU).zr)=(fromBin_((bjS),(bjT.$)));
((bjU).r5)=(fromBin_((bjS),(bjT.$)));
((bjU).qc)=(fromBin_((bjS),(bjT.$)));
return bjU;
}
// _dtor
function bjV(bjW){
((bjW).VQ)=(null);
((bjW).VS)=(null);
((bjW).yc)=(null);
((bjW).ql)=(null);
((bjW).qX)=(null);
((bjW).qU)=(null);
((bjW).pY)=(null);
((bjW).q0)=(null);
((bjW).qz)=(null);
((bjW).zr)=(null);
}
// _copy
function bjX(bjY){
let bjZ;
(bjZ)=(new Fs());
((bjZ).VQ)=(C_([134],((bjY).VQ)));
((bjZ).VY)=((bjY).VY);
((bjZ).VS)=(C_([130,134],((bjY).VS)));
((bjZ).yc)=(C_([134],((bjY).yc)));
((bjZ).ql)=(C_([134],((bjY).ql)));
((bjZ).qX)=(C_([129,2],((bjY).qX)));
((bjZ).qU)=(C_([134],((bjY).qU)));
((bjZ).pY)=(C_([133,129,2,134],((bjY).pY)));
((bjZ).q0)=(C_([129,2],((bjY).q0)));
((bjZ).qz)=(C_([134],((bjY).qz)));
((bjZ).zr)=(C_([134],((bjY).zr)));
((bjZ).r5)=((bjY).r5);
((bjZ).qc)=((bjY).qc);
return bjZ;
}
// _toBin
function bka(bkb){
let bkc;
(bkc)=(new Array(8).fill(0));
(bkc)=((bkc).concat(toBin_((bkb).VQ)));
(bkc)=((bkc).concat(toBin_((bkb).VY)));
(bkc)=((bkc).concat(toBin_((bkb).VS)));
(bkc)=((bkc).concat(toBin_((bkb).yc)));
(bkc)=((bkc).concat(toBin_((bkb).ql)));
(bkc)=((bkc).concat(toBin_((bkb).qX)));
(bkc)=((bkc).concat(toBin_((bkb).qU)));
(bkc)=((bkc).concat(toBin_((bkb).pY)));
(bkc)=((bkc).concat(toBin_((bkb).q0)));
(bkc)=((bkc).concat(toBin_((bkb).qz)));
(bkc)=((bkc).concat(toBin_((bkb).zr)));
(bkc)=((bkc).concat(toBin_((bkb).r5)));
(bkc)=((bkc).concat(toBin_((bkb).qc)));
return bkc;
}
// _fromBin
function bkq(bkr,bks,bkt){
let bku;
(bku)=(new Fs());
((bku).VQ)=(fromBin_((bks),(bkt.$)));
((bku).VY)=(fromBin_((bks),(bkt.$)));
((bku).VS)=(fromBin_((bks),(bkt.$)));
((bku).yc)=(fromBin_((bks),(bkt.$)));
((bku).ql)=(fromBin_((bks),(bkt.$)));
((bku).qX)=(fromBin_((bks),(bkt.$)));
((bku).qU)=(fromBin_((bks),(bkt.$)));
((bku).pY)=(fromBin_((bks),(bkt.$)));
((bku).q0)=(fromBin_((bks),(bkt.$)));
((bku).qz)=(fromBin_((bks),(bkt.$)));
((bku).zr)=(fromBin_((bks),(bkt.$)));
((bku).r5)=(fromBin_((bks),(bkt.$)));
((bku).qc)=(fromBin_((bks),(bkt.$)));
return bku;
}
// _dtor
function bkv(bkw){
((bkw).Ws)=(null);
((bkw).Wr)=(null);
((bkw).Wt)=(null);
((bkw).Wy)=(null);
((bkw).yc)=(null);
((bkw).ql)=(null);
((bkw).qX)=(null);
((bkw).qU)=(null);
((bkw).pY)=(null);
((bkw).q0)=(null);
((bkw).qz)=(null);
((bkw).zr)=(null);
}
// _copy
function bkx(bky){
let bkz;
(bkz)=(new Fw());
((bkz).Ws)=(C_([134],((bky).Ws)));
((bkz).Wr)=(C_([134],((bky).Wr)));
((bkz).Wt)=(C_([134],((bky).Wt)));
((bkz).Wy)=(C_([130,134],((bky).Wy)));
((bkz).yc)=(C_([134],((bky).yc)));
((bkz).ql)=(C_([134],((bky).ql)));
((bkz).qX)=(C_([129,2],((bky).qX)));
((bkz).qU)=(C_([134],((bky).qU)));
((bkz).pY)=(C_([133,129,2,134],((bky).pY)));
((bkz).q0)=(C_([129,2],((bky).q0)));
((bkz).qz)=(C_([134],((bky).qz)));
((bkz).zr)=(C_([134],((bky).zr)));
((bkz).r5)=((bky).r5);
((bkz).qc)=((bky).qc);
return bkz;
}
// _toBin
function bk0(bk1){
let bk2;
(bk2)=(new Array(8).fill(0));
(bk2)=((bk2).concat(toBin_((bk1).Ws)));
(bk2)=((bk2).concat(toBin_((bk1).Wr)));
(bk2)=((bk2).concat(toBin_((bk1).Wt)));
(bk2)=((bk2).concat(toBin_((bk1).Wy)));
(bk2)=((bk2).concat(toBin_((bk1).yc)));
(bk2)=((bk2).concat(toBin_((bk1).ql)));
(bk2)=((bk2).concat(toBin_((bk1).qX)));
(bk2)=((bk2).concat(toBin_((bk1).qU)));
(bk2)=((bk2).concat(toBin_((bk1).pY)));
(bk2)=((bk2).concat(toBin_((bk1).q0)));
(bk2)=((bk2).concat(toBin_((bk1).qz)));
(bk2)=((bk2).concat(toBin_((bk1).zr)));
(bk2)=((bk2).concat(toBin_((bk1).r5)));
(bk2)=((bk2).concat(toBin_((bk1).qc)));
return bk2;
}
// _fromBin
function bkH(bkI,bkJ,bkK){
let bkL;
(bkL)=(new Fw());
((bkL).Ws)=(fromBin_((bkJ),(bkK.$)));
((bkL).Wr)=(fromBin_((bkJ),(bkK.$)));
((bkL).Wt)=(fromBin_((bkJ),(bkK.$)));
((bkL).Wy)=(fromBin_((bkJ),(bkK.$)));
((bkL).yc)=(fromBin_((bkJ),(bkK.$)));
((bkL).ql)=(fromBin_((bkJ),(bkK.$)));
((bkL).qX)=(fromBin_((bkJ),(bkK.$)));
((bkL).qU)=(fromBin_((bkJ),(bkK.$)));
((bkL).pY)=(fromBin_((bkJ),(bkK.$)));
((bkL).q0)=(fromBin_((bkJ),(bkK.$)));
((bkL).qz)=(fromBin_((bkJ),(bkK.$)));
((bkL).zr)=(fromBin_((bkJ),(bkK.$)));
((bkL).r5)=(fromBin_((bkJ),(bkK.$)));
((bkL).qc)=(fromBin_((bkJ),(bkK.$)));
return bkL;
}
// _dtor
function bkM(bkN){
((bkN).Xe)=(null);
((bkN).ql)=(null);
((bkN).qX)=(null);
((bkN).qU)=(null);
((bkN).pY)=(null);
((bkN).q0)=(null);
((bkN).qz)=(null);
((bkN).zr)=(null);
}
// _copy
function bkO(bkP){
let bkQ;
(bkQ)=(new F1());
((bkQ).Xe)=(C_([134],((bkP).Xe)));
((bkQ).ql)=(C_([134],((bkP).ql)));
((bkQ).qX)=(C_([129,2],((bkP).qX)));
((bkQ).qU)=(C_([134],((bkP).qU)));
((bkQ).pY)=(C_([133,129,2,134],((bkP).pY)));
((bkQ).q0)=(C_([129,2],((bkP).q0)));
((bkQ).qz)=(C_([134],((bkP).qz)));
((bkQ).zr)=(C_([134],((bkP).zr)));
((bkQ).r5)=((bkP).r5);
((bkQ).qc)=((bkP).qc);
return bkQ;
}
// _toBin
function bkR(bkS){
let bkT;
(bkT)=(new Array(8).fill(0));
(bkT)=((bkT).concat(toBin_((bkS).Xe)));
(bkT)=((bkT).concat(toBin_((bkS).ql)));
(bkT)=((bkT).concat(toBin_((bkS).qX)));
(bkT)=((bkT).concat(toBin_((bkS).qU)));
(bkT)=((bkT).concat(toBin_((bkS).pY)));
(bkT)=((bkT).concat(toBin_((bkS).q0)));
(bkT)=((bkT).concat(toBin_((bkS).qz)));
(bkT)=((bkT).concat(toBin_((bkS).zr)));
(bkT)=((bkT).concat(toBin_((bkS).r5)));
(bkT)=((bkT).concat(toBin_((bkS).qc)));
return bkT;
}
// _fromBin
function ble(blf,blg,blh){
let bli;
(bli)=(new F1());
((bli).Xe)=(fromBin_((blg),(blh.$)));
((bli).ql)=(fromBin_((blg),(blh.$)));
((bli).qX)=(fromBin_((blg),(blh.$)));
((bli).qU)=(fromBin_((blg),(blh.$)));
((bli).pY)=(fromBin_((blg),(blh.$)));
((bli).q0)=(fromBin_((blg),(blh.$)));
((bli).qz)=(fromBin_((blg),(blh.$)));
((bli).zr)=(fromBin_((blg),(blh.$)));
((bli).r5)=(fromBin_((blg),(blh.$)));
((bli).qc)=(fromBin_((blg),(blh.$)));
return bli;
}
// _dtor
function blj(blk){
((blk).Xn)=(null);
((blk).ql)=(null);
((blk).qX)=(null);
((blk).qU)=(null);
((blk).pY)=(null);
((blk).q0)=(null);
((blk).qz)=(null);
((blk).zr)=(null);
}
// _copy
function bll(blm){
let bln;
(bln)=(new F6());
((bln).Xn)=(C_([134],((blm).Xn)));
((bln).ql)=(C_([134],((blm).ql)));
((bln).qX)=(C_([129,2],((blm).qX)));
((bln).qU)=(C_([134],((blm).qU)));
((bln).pY)=(C_([133,129,2,134],((blm).pY)));
((bln).q0)=(C_([129,2],((blm).q0)));
((bln).qz)=(C_([134],((blm).qz)));
((bln).zr)=(C_([134],((blm).zr)));
((bln).r5)=((blm).r5);
((bln).qc)=((blm).qc);
return bln;
}
// _toBin
function blo(blp){
let blq;
(blq)=(new Array(8).fill(0));
(blq)=((blq).concat(toBin_((blp).Xn)));
(blq)=((blq).concat(toBin_((blp).ql)));
(blq)=((blq).concat(toBin_((blp).qX)));
(blq)=((blq).concat(toBin_((blp).qU)));
(blq)=((blq).concat(toBin_((blp).pY)));
(blq)=((blq).concat(toBin_((blp).q0)));
(blq)=((blq).concat(toBin_((blp).qz)));
(blq)=((blq).concat(toBin_((blp).zr)));
(blq)=((blq).concat(toBin_((blp).r5)));
(blq)=((blq).concat(toBin_((blp).qc)));
return blq;
}
// _fromBin
function bl1(bl2,bl3,bl4){
let bl5;
(bl5)=(new F6());
((bl5).Xn)=(fromBin_((bl3),(bl4.$)));
((bl5).ql)=(fromBin_((bl3),(bl4.$)));
((bl5).qX)=(fromBin_((bl3),(bl4.$)));
((bl5).qU)=(fromBin_((bl3),(bl4.$)));
((bl5).pY)=(fromBin_((bl3),(bl4.$)));
((bl5).q0)=(fromBin_((bl3),(bl4.$)));
((bl5).qz)=(fromBin_((bl3),(bl4.$)));
((bl5).zr)=(fromBin_((bl3),(bl4.$)));
((bl5).r5)=(fromBin_((bl3),(bl4.$)));
((bl5).qc)=(fromBin_((bl3),(bl4.$)));
return bl5;
}
// _dtor
function bl6(bl7){
((bl7).X4)=(null);
((bl7).ql)=(null);
((bl7).qX)=(null);
((bl7).qU)=(null);
((bl7).pY)=(null);
((bl7).q0)=(null);
((bl7).qz)=(null);
((bl7).zr)=(null);
}
// _copy
function bl8(bl9){
let blA;
(blA)=(new FF());
((blA).X4)=(C_([134],((bl9).X4)));
((blA).ql)=(C_([134],((bl9).ql)));
((blA).qX)=(C_([129,2],((bl9).qX)));
((blA).qU)=(C_([134],((bl9).qU)));
((blA).pY)=(C_([133,129,2,134],((bl9).pY)));
((blA).q0)=(C_([129,2],((bl9).q0)));
((blA).qz)=(C_([134],((bl9).qz)));
((blA).zr)=(C_([134],((bl9).zr)));
((blA).r5)=((bl9).r5);
((blA).qc)=((bl9).qc);
return blA;
}
// _toBin
function blB(blC){
let blD;
(blD)=(new Array(8).fill(0));
(blD)=((blD).concat(toBin_((blC).X4)));
(blD)=((blD).concat(toBin_((blC).ql)));
(blD)=((blD).concat(toBin_((blC).qX)));
(blD)=((blD).concat(toBin_((blC).qU)));
(blD)=((blD).concat(toBin_((blC).pY)));
(blD)=((blD).concat(toBin_((blC).q0)));
(blD)=((blD).concat(toBin_((blC).qz)));
(blD)=((blD).concat(toBin_((blC).zr)));
(blD)=((blD).concat(toBin_((blC).r5)));
(blD)=((blD).concat(toBin_((blC).qc)));
return blD;
}
// _fromBin
function blO(blP,blQ,blR){
let blS;
(blS)=(new FF());
((blS).X4)=(fromBin_((blQ),(blR.$)));
((blS).ql)=(fromBin_((blQ),(blR.$)));
((blS).qX)=(fromBin_((blQ),(blR.$)));
((blS).qU)=(fromBin_((blQ),(blR.$)));
((blS).pY)=(fromBin_((blQ),(blR.$)));
((blS).q0)=(fromBin_((blQ),(blR.$)));
((blS).qz)=(fromBin_((blQ),(blR.$)));
((blS).zr)=(fromBin_((blQ),(blR.$)));
((blS).r5)=(fromBin_((blQ),(blR.$)));
((blS).qc)=(fromBin_((blQ),(blR.$)));
return blS;
}
// _dtor
function blT(blU){
((blU).ql)=(null);
((blU).qX)=(null);
((blU).qU)=(null);
((blU).pY)=(null);
((blU).q0)=(null);
((blU).qz)=(null);
((blU).zr)=(null);
}
// _copy
function blV(blW){
let blX;
(blX)=(new Oq());
((blX).ql)=(C_([134],((blW).ql)));
((blX).qX)=(C_([129,2],((blW).qX)));
((blX).qU)=(C_([134],((blW).qU)));
((blX).pY)=(C_([133,129,2,134],((blW).pY)));
((blX).q0)=(C_([129,2],((blW).q0)));
((blX).qz)=(C_([134],((blW).qz)));
((blX).zr)=(C_([134],((blW).zr)));
((blX).r5)=((blW).r5);
((blX).qc)=((blW).qc);
return blX;
}
// _toBin
function blY(blZ){
let bma;
(bma)=(new Array(8).fill(0));
(bma)=((bma).concat(toBin_((blZ).ql)));
(bma)=((bma).concat(toBin_((blZ).qX)));
(bma)=((bma).concat(toBin_((blZ).qU)));
(bma)=((bma).concat(toBin_((blZ).pY)));
(bma)=((bma).concat(toBin_((blZ).q0)));
(bma)=((bma).concat(toBin_((blZ).qz)));
(bma)=((bma).concat(toBin_((blZ).zr)));
(bma)=((bma).concat(toBin_((blZ).r5)));
(bma)=((bma).concat(toBin_((blZ).qc)));
return bma;
}
// _fromBin
function bmk(bml,bmm,bmn){
let bmo;
(bmo)=(new Oq());
((bmo).ql)=(fromBin_((bmm),(bmn.$)));
((bmo).qX)=(fromBin_((bmm),(bmn.$)));
((bmo).qU)=(fromBin_((bmm),(bmn.$)));
((bmo).pY)=(fromBin_((bmm),(bmn.$)));
((bmo).q0)=(fromBin_((bmm),(bmn.$)));
((bmo).qz)=(fromBin_((bmm),(bmn.$)));
((bmo).zr)=(fromBin_((bmm),(bmn.$)));
((bmo).r5)=(fromBin_((bmm),(bmn.$)));
((bmo).qc)=(fromBin_((bmm),(bmn.$)));
return bmo;
}
// _dtor
function bmp(bmq){
((bmq).aiF)=(null);
((bmq).yL)=(null);
((bmq).ql)=(null);
((bmq).qX)=(null);
((bmq).qU)=(null);
((bmq).pY)=(null);
((bmq).q0)=(null);
((bmq).qz)=(null);
((bmq).zr)=(null);
}
// _copy
function bmr(bms){
let bmt;
(bmt)=(new RK());
((bmt).aiL)=((bms).aiL);
((bmt).aiF)=(C_([134],((bms).aiF)));
((bmt).yL)=(C_([134],((bms).yL)));
((bmt).yH)=((bms).yH);
((bmt).ql)=(C_([134],((bms).ql)));
((bmt).qX)=(C_([129,2],((bms).qX)));
((bmt).qU)=(C_([134],((bms).qU)));
((bmt).pY)=(C_([133,129,2,134],((bms).pY)));
((bmt).q0)=(C_([129,2],((bms).q0)));
((bmt).qz)=(C_([134],((bms).qz)));
((bmt).zr)=(C_([134],((bms).zr)));
((bmt).r5)=((bms).r5);
((bmt).qc)=((bms).qc);
return bmt;
}
// _toBin
function bmu(bmv){
let bmw;
(bmw)=(new Array(8).fill(0));
(bmw)=((bmw).concat(toBin_((bmv).aiL)));
(bmw)=((bmw).concat(toBin_((bmv).aiF)));
(bmw)=((bmw).concat(toBin_((bmv).yL)));
(bmw)=((bmw).concat(toBin_((bmv).yH)));
(bmw)=((bmw).concat(toBin_((bmv).ql)));
(bmw)=((bmw).concat(toBin_((bmv).qX)));
(bmw)=((bmw).concat(toBin_((bmv).qU)));
(bmw)=((bmw).concat(toBin_((bmv).pY)));
(bmw)=((bmw).concat(toBin_((bmv).q0)));
(bmw)=((bmw).concat(toBin_((bmv).qz)));
(bmw)=((bmw).concat(toBin_((bmv).zr)));
(bmw)=((bmw).concat(toBin_((bmv).r5)));
(bmw)=((bmw).concat(toBin_((bmv).qc)));
return bmw;
}
// _fromBin
function bmA(bmB,bmC,bmD){
let bmE;
(bmE)=(new RK());
((bmE).aiL)=(fromBin_((bmC),(bmD.$)));
((bmE).aiF)=(fromBin_((bmC),(bmD.$)));
((bmE).yL)=(fromBin_((bmC),(bmD.$)));
((bmE).yH)=(fromBin_((bmC),(bmD.$)));
((bmE).ql)=(fromBin_((bmC),(bmD.$)));
((bmE).qX)=(fromBin_((bmC),(bmD.$)));
((bmE).qU)=(fromBin_((bmC),(bmD.$)));
((bmE).pY)=(fromBin_((bmC),(bmD.$)));
((bmE).q0)=(fromBin_((bmC),(bmD.$)));
((bmE).qz)=(fromBin_((bmC),(bmD.$)));
((bmE).zr)=(fromBin_((bmC),(bmD.$)));
((bmE).r5)=(fromBin_((bmC),(bmD.$)));
((bmE).qc)=(fromBin_((bmC),(bmD.$)));
return bmE;
}
// _dtor
function bmF(bmG){
((bmG).and)=(null);
((bmG).ang)=(null);
((bmG).anj)=(null);
((bmG).yL)=(null);
((bmG).ql)=(null);
((bmG).qX)=(null);
((bmG).qU)=(null);
((bmG).pY)=(null);
((bmG).q0)=(null);
((bmG).qz)=(null);
((bmG).zr)=(null);
}
// _copy
function bmH(bmI){
let bmJ;
(bmJ)=(new RP());
((bmJ).and)=(C_([134],((bmI).and)));
((bmJ).ang)=(C_([134],((bmI).ang)));
((bmJ).anj)=(C_([134],((bmI).anj)));
((bmJ).yL)=(C_([134],((bmI).yL)));
((bmJ).yH)=((bmI).yH);
((bmJ).ql)=(C_([134],((bmI).ql)));
((bmJ).qX)=(C_([129,2],((bmI).qX)));
((bmJ).qU)=(C_([134],((bmI).qU)));
((bmJ).pY)=(C_([133,129,2,134],((bmI).pY)));
((bmJ).q0)=(C_([129,2],((bmI).q0)));
((bmJ).qz)=(C_([134],((bmI).qz)));
((bmJ).zr)=(C_([134],((bmI).zr)));
((bmJ).r5)=((bmI).r5);
((bmJ).qc)=((bmI).qc);
return bmJ;
}
// _toBin
function bmK(bmL){
let bmM;
(bmM)=(new Array(8).fill(0));
(bmM)=((bmM).concat(toBin_((bmL).and)));
(bmM)=((bmM).concat(toBin_((bmL).ang)));
(bmM)=((bmM).concat(toBin_((bmL).anj)));
(bmM)=((bmM).concat(toBin_((bmL).yL)));
(bmM)=((bmM).concat(toBin_((bmL).yH)));
(bmM)=((bmM).concat(toBin_((bmL).ql)));
(bmM)=((bmM).concat(toBin_((bmL).qX)));
(bmM)=((bmM).concat(toBin_((bmL).qU)));
(bmM)=((bmM).concat(toBin_((bmL).pY)));
(bmM)=((bmM).concat(toBin_((bmL).q0)));
(bmM)=((bmM).concat(toBin_((bmL).qz)));
(bmM)=((bmM).concat(toBin_((bmL).zr)));
(bmM)=((bmM).concat(toBin_((bmL).r5)));
(bmM)=((bmM).concat(toBin_((bmL).qc)));
return bmM;
}
// _fromBin
function bnb(bnc,bnd,bne){
let bnf;
(bnf)=(new RP());
((bnf).and)=(fromBin_((bnd),(bne.$)));
((bnf).ang)=(fromBin_((bnd),(bne.$)));
((bnf).anj)=(fromBin_((bnd),(bne.$)));
((bnf).yL)=(fromBin_((bnd),(bne.$)));
((bnf).yH)=(fromBin_((bnd),(bne.$)));
((bnf).ql)=(fromBin_((bnd),(bne.$)));
((bnf).qX)=(fromBin_((bnd),(bne.$)));
((bnf).qU)=(fromBin_((bnd),(bne.$)));
((bnf).pY)=(fromBin_((bnd),(bne.$)));
((bnf).q0)=(fromBin_((bnd),(bne.$)));
((bnf).qz)=(fromBin_((bnd),(bne.$)));
((bnf).zr)=(fromBin_((bnd),(bne.$)));
((bnf).r5)=(fromBin_((bnd),(bne.$)));
((bnf).qc)=(fromBin_((bnd),(bne.$)));
return bnf;
}
// _dtor
function bng(bnh){
((bnh).an3)=(null);
((bnh).yL)=(null);
((bnh).ql)=(null);
((bnh).qX)=(null);
((bnh).qU)=(null);
((bnh).pY)=(null);
((bnh).q0)=(null);
((bnh).qz)=(null);
((bnh).zr)=(null);
}
// _copy
function bni(bnj){
let bnk;
(bnk)=(new RS());
((bnk).an3)=(C_([134],((bnj).an3)));
((bnk).yL)=(C_([134],((bnj).yL)));
((bnk).yH)=((bnj).yH);
((bnk).ql)=(C_([134],((bnj).ql)));
((bnk).qX)=(C_([129,2],((bnj).qX)));
((bnk).qU)=(C_([134],((bnj).qU)));
((bnk).pY)=(C_([133,129,2,134],((bnj).pY)));
((bnk).q0)=(C_([129,2],((bnj).q0)));
((bnk).qz)=(C_([134],((bnj).qz)));
((bnk).zr)=(C_([134],((bnj).zr)));
((bnk).r5)=((bnj).r5);
((bnk).qc)=((bnj).qc);
return bnk;
}
// _toBin
function bnl(bnm){
let bnn;
(bnn)=(new Array(8).fill(0));
(bnn)=((bnn).concat(toBin_((bnm).an3)));
(bnn)=((bnn).concat(toBin_((bnm).yL)));
(bnn)=((bnn).concat(toBin_((bnm).yH)));
(bnn)=((bnn).concat(toBin_((bnm).ql)));
(bnn)=((bnn).concat(toBin_((bnm).qX)));
(bnn)=((bnn).concat(toBin_((bnm).qU)));
(bnn)=((bnn).concat(toBin_((bnm).pY)));
(bnn)=((bnn).concat(toBin_((bnm).q0)));
(bnn)=((bnn).concat(toBin_((bnm).qz)));
(bnn)=((bnn).concat(toBin_((bnm).zr)));
(bnn)=((bnn).concat(toBin_((bnm).r5)));
(bnn)=((bnn).concat(toBin_((bnm).qc)));
return bnn;
}
// _fromBin
function bn0(bn1,bn2,bn3){
let bn4;
(bn4)=(new RS());
((bn4).an3)=(fromBin_((bn2),(bn3.$)));
((bn4).yL)=(fromBin_((bn2),(bn3.$)));
((bn4).yH)=(fromBin_((bn2),(bn3.$)));
((bn4).ql)=(fromBin_((bn2),(bn3.$)));
((bn4).qX)=(fromBin_((bn2),(bn3.$)));
((bn4).qU)=(fromBin_((bn2),(bn3.$)));
((bn4).pY)=(fromBin_((bn2),(bn3.$)));
((bn4).q0)=(fromBin_((bn2),(bn3.$)));
((bn4).qz)=(fromBin_((bn2),(bn3.$)));
((bn4).zr)=(fromBin_((bn2),(bn3.$)));
((bn4).r5)=(fromBin_((bn2),(bn3.$)));
((bn4).qc)=(fromBin_((bn2),(bn3.$)));
return bn4;
}
// _dtor
function bn5(bn6){
((bn6).anF)=(null);
((bn6).anN)=(null);
((bn6).yL)=(null);
((bn6).ql)=(null);
((bn6).qX)=(null);
((bn6).qU)=(null);
((bn6).pY)=(null);
((bn6).q0)=(null);
((bn6).qz)=(null);
((bn6).zr)=(null);
}
// _copy
function bn7(bn8){
let bn9;
(bn9)=(new RV());
((bn9).anF)=(C_([130,134],((bn8).anF)));
((bn9).anN)=(C_([134],((bn8).anN)));
((bn9).yL)=(C_([134],((bn8).yL)));
((bn9).yH)=((bn8).yH);
((bn9).ql)=(C_([134],((bn8).ql)));
((bn9).qX)=(C_([129,2],((bn8).qX)));
((bn9).qU)=(C_([134],((bn8).qU)));
((bn9).pY)=(C_([133,129,2,134],((bn8).pY)));
((bn9).q0)=(C_([129,2],((bn8).q0)));
((bn9).qz)=(C_([134],((bn8).qz)));
((bn9).zr)=(C_([134],((bn8).zr)));
((bn9).r5)=((bn8).r5);
((bn9).qc)=((bn8).qc);
return bn9;
}
// _toBin
function bnA(bnB){
let bnC;
(bnC)=(new Array(8).fill(0));
(bnC)=((bnC).concat(toBin_((bnB).anF)));
(bnC)=((bnC).concat(toBin_((bnB).anN)));
(bnC)=((bnC).concat(toBin_((bnB).yL)));
(bnC)=((bnC).concat(toBin_((bnB).yH)));
(bnC)=((bnC).concat(toBin_((bnB).ql)));
(bnC)=((bnC).concat(toBin_((bnB).qX)));
(bnC)=((bnC).concat(toBin_((bnB).qU)));
(bnC)=((bnC).concat(toBin_((bnB).pY)));
(bnC)=((bnC).concat(toBin_((bnB).q0)));
(bnC)=((bnC).concat(toBin_((bnB).qz)));
(bnC)=((bnC).concat(toBin_((bnB).zr)));
(bnC)=((bnC).concat(toBin_((bnB).r5)));
(bnC)=((bnC).concat(toBin_((bnB).qc)));
return bnC;
}
// _fromBin
function bnQ(bnR,bnS,bnT){
let bnU;
(bnU)=(new RV());
((bnU).anF)=(fromBin_((bnS),(bnT.$)));
((bnU).anN)=(fromBin_((bnS),(bnT.$)));
((bnU).yL)=(fromBin_((bnS),(bnT.$)));
((bnU).yH)=(fromBin_((bnS),(bnT.$)));
((bnU).ql)=(fromBin_((bnS),(bnT.$)));
((bnU).qX)=(fromBin_((bnS),(bnT.$)));
((bnU).qU)=(fromBin_((bnS),(bnT.$)));
((bnU).pY)=(fromBin_((bnS),(bnT.$)));
((bnU).q0)=(fromBin_((bnS),(bnT.$)));
((bnU).qz)=(fromBin_((bnS),(bnT.$)));
((bnU).zr)=(fromBin_((bnS),(bnT.$)));
((bnU).r5)=(fromBin_((bnS),(bnT.$)));
((bnU).qc)=(fromBin_((bnS),(bnT.$)));
return bnU;
}
// _dtor
function bnV(bnW){
((bnW).aoa)=(null);
((bnW).aod)=(null);
((bnW).yL)=(null);
((bnW).ql)=(null);
((bnW).qX)=(null);
((bnW).qU)=(null);
((bnW).pY)=(null);
((bnW).q0)=(null);
((bnW).qz)=(null);
((bnW).zr)=(null);
}
// _copy
function bnX(bnY){
let bnZ;
(bnZ)=(new RY());
((bnZ).aoi)=((bnY).aoi);
((bnZ).aoa)=(C_([134],((bnY).aoa)));
((bnZ).aod)=(C_([134],((bnY).aod)));
((bnZ).yL)=(C_([134],((bnY).yL)));
((bnZ).yH)=((bnY).yH);
((bnZ).ql)=(C_([134],((bnY).ql)));
((bnZ).qX)=(C_([129,2],((bnY).qX)));
((bnZ).qU)=(C_([134],((bnY).qU)));
((bnZ).pY)=(C_([133,129,2,134],((bnY).pY)));
((bnZ).q0)=(C_([129,2],((bnY).q0)));
((bnZ).qz)=(C_([134],((bnY).qz)));
((bnZ).zr)=(C_([134],((bnY).zr)));
((bnZ).r5)=((bnY).r5);
((bnZ).qc)=((bnY).qc);
return bnZ;
}
// _toBin
function boa(bob){
let boc;
(boc)=(new Array(8).fill(0));
(boc)=((boc).concat(toBin_((bob).aoi)));
(boc)=((boc).concat(toBin_((bob).aoa)));
(boc)=((boc).concat(toBin_((bob).aod)));
(boc)=((boc).concat(toBin_((bob).yL)));
(boc)=((boc).concat(toBin_((bob).yH)));
(boc)=((boc).concat(toBin_((bob).ql)));
(boc)=((boc).concat(toBin_((bob).qX)));
(boc)=((boc).concat(toBin_((bob).qU)));
(boc)=((boc).concat(toBin_((bob).pY)));
(boc)=((boc).concat(toBin_((bob).q0)));
(boc)=((boc).concat(toBin_((bob).qz)));
(boc)=((boc).concat(toBin_((bob).zr)));
(boc)=((boc).concat(toBin_((bob).r5)));
(boc)=((boc).concat(toBin_((bob).qc)));
return boc;
}
// _fromBin
function bor(bos,bot,bou){
let bov;
(bov)=(new RY());
((bov).aoi)=(fromBin_((bot),(bou.$)));
((bov).aoa)=(fromBin_((bot),(bou.$)));
((bov).aod)=(fromBin_((bot),(bou.$)));
((bov).yL)=(fromBin_((bot),(bou.$)));
((bov).yH)=(fromBin_((bot),(bou.$)));
((bov).ql)=(fromBin_((bot),(bou.$)));
((bov).qX)=(fromBin_((bot),(bou.$)));
((bov).qU)=(fromBin_((bot),(bou.$)));
((bov).pY)=(fromBin_((bot),(bou.$)));
((bov).q0)=(fromBin_((bot),(bou.$)));
((bov).qz)=(fromBin_((bot),(bou.$)));
((bov).zr)=(fromBin_((bot),(bou.$)));
((bov).r5)=(fromBin_((bot),(bou.$)));
((bov).qc)=(fromBin_((bot),(bou.$)));
return bov;
}
// _dtor
function bow(box){
((box).apw)=(null);
((box).ap2)=(null);
((box).yL)=(null);
((box).ql)=(null);
((box).qX)=(null);
((box).qU)=(null);
((box).pY)=(null);
((box).q0)=(null);
((box).qz)=(null);
((box).zr)=(null);
}
// _copy
function boy(boz){
let bo0;
(bo0)=(new Sb());
((bo0).apw)=(C_([134],((boz).apw)));
((bo0).ap2)=(C_([134],((boz).ap2)));
((bo0).yL)=(C_([134],((boz).yL)));
((bo0).yH)=((boz).yH);
((bo0).ql)=(C_([134],((boz).ql)));
((bo0).qX)=(C_([129,2],((boz).qX)));
((bo0).qU)=(C_([134],((boz).qU)));
((bo0).pY)=(C_([133,129,2,134],((boz).pY)));
((bo0).q0)=(C_([129,2],((boz).q0)));
((bo0).qz)=(C_([134],((boz).qz)));
((bo0).zr)=(C_([134],((boz).zr)));
((bo0).r5)=((boz).r5);
((bo0).qc)=((boz).qc);
return bo0;
}
// _toBin
function bo1(bo2){
let bo3;
(bo3)=(new Array(8).fill(0));
(bo3)=((bo3).concat(toBin_((bo2).apw)));
(bo3)=((bo3).concat(toBin_((bo2).ap2)));
(bo3)=((bo3).concat(toBin_((bo2).yL)));
(bo3)=((bo3).concat(toBin_((bo2).yH)));
(bo3)=((bo3).concat(toBin_((bo2).ql)));
(bo3)=((bo3).concat(toBin_((bo2).qX)));
(bo3)=((bo3).concat(toBin_((bo2).qU)));
(bo3)=((bo3).concat(toBin_((bo2).pY)));
(bo3)=((bo3).concat(toBin_((bo2).q0)));
(bo3)=((bo3).concat(toBin_((bo2).qz)));
(bo3)=((bo3).concat(toBin_((bo2).zr)));
(bo3)=((bo3).concat(toBin_((bo2).r5)));
(bo3)=((bo3).concat(toBin_((bo2).qc)));
return bo3;
}
// _fromBin
function boH(boI,boJ,boK){
let boL;
(boL)=(new Sb());
((boL).apw)=(fromBin_((boJ),(boK.$)));
((boL).ap2)=(fromBin_((boJ),(boK.$)));
((boL).yL)=(fromBin_((boJ),(boK.$)));
((boL).yH)=(fromBin_((boJ),(boK.$)));
((boL).ql)=(fromBin_((boJ),(boK.$)));
((boL).qX)=(fromBin_((boJ),(boK.$)));
((boL).qU)=(fromBin_((boJ),(boK.$)));
((boL).pY)=(fromBin_((boJ),(boK.$)));
((boL).q0)=(fromBin_((boJ),(boK.$)));
((boL).qz)=(fromBin_((boJ),(boK.$)));
((boL).zr)=(fromBin_((boJ),(boK.$)));
((boL).r5)=(fromBin_((boJ),(boK.$)));
((boL).qc)=(fromBin_((boJ),(boK.$)));
return boL;
}
// _dtor
function boM(boN){
((boN).ap7)=(null);
((boN).apC)=(null);
((boN).apD)=(null);
((boN).yL)=(null);
((boN).ql)=(null);
((boN).qX)=(null);
((boN).qU)=(null);
((boN).pY)=(null);
((boN).q0)=(null);
((boN).qz)=(null);
((boN).zr)=(null);
}
// _copy
function boO(boP){
let boQ;
(boQ)=(new Se());
((boQ).ap7)=(C_([134],((boP).ap7)));
((boQ).apC)=(C_([134],((boP).apC)));
((boQ).apD)=(C_([134],((boP).apD)));
((boQ).yL)=(C_([134],((boP).yL)));
((boQ).yH)=((boP).yH);
((boQ).ql)=(C_([134],((boP).ql)));
((boQ).qX)=(C_([129,2],((boP).qX)));
((boQ).qU)=(C_([134],((boP).qU)));
((boQ).pY)=(C_([133,129,2,134],((boP).pY)));
((boQ).q0)=(C_([129,2],((boP).q0)));
((boQ).qz)=(C_([134],((boP).qz)));
((boQ).zr)=(C_([134],((boP).zr)));
((boQ).r5)=((boP).r5);
((boQ).qc)=((boP).qc);
return boQ;
}
// _toBin
function boR(boS){
let boT;
(boT)=(new Array(8).fill(0));
(boT)=((boT).concat(toBin_((boS).ap7)));
(boT)=((boT).concat(toBin_((boS).apC)));
(boT)=((boT).concat(toBin_((boS).apD)));
(boT)=((boT).concat(toBin_((boS).yL)));
(boT)=((boT).concat(toBin_((boS).yH)));
(boT)=((boT).concat(toBin_((boS).ql)));
(boT)=((boT).concat(toBin_((boS).qX)));
(boT)=((boT).concat(toBin_((boS).qU)));
(boT)=((boT).concat(toBin_((boS).pY)));
(boT)=((boT).concat(toBin_((boS).q0)));
(boT)=((boT).concat(toBin_((boS).qz)));
(boT)=((boT).concat(toBin_((boS).zr)));
(boT)=((boT).concat(toBin_((boS).r5)));
(boT)=((boT).concat(toBin_((boS).qc)));
return boT;
}
// _fromBin
function bpi(bpj,bpk,bpl){
let bpm;
(bpm)=(new Se());
((bpm).ap7)=(fromBin_((bpk),(bpl.$)));
((bpm).apC)=(fromBin_((bpk),(bpl.$)));
((bpm).apD)=(fromBin_((bpk),(bpl.$)));
((bpm).yL)=(fromBin_((bpk),(bpl.$)));
((bpm).yH)=(fromBin_((bpk),(bpl.$)));
((bpm).ql)=(fromBin_((bpk),(bpl.$)));
((bpm).qX)=(fromBin_((bpk),(bpl.$)));
((bpm).qU)=(fromBin_((bpk),(bpl.$)));
((bpm).pY)=(fromBin_((bpk),(bpl.$)));
((bpm).q0)=(fromBin_((bpk),(bpl.$)));
((bpm).qz)=(fromBin_((bpk),(bpl.$)));
((bpm).zr)=(fromBin_((bpk),(bpl.$)));
((bpm).r5)=(fromBin_((bpk),(bpl.$)));
((bpm).qc)=(fromBin_((bpk),(bpl.$)));
return bpm;
}
// _dtor
function bpn(bpo){
((bpo).aqE)=(null);
((bpo).aqJ)=(null);
((bpo).yL)=(null);
((bpo).ql)=(null);
((bpo).qX)=(null);
((bpo).qU)=(null);
((bpo).pY)=(null);
((bpo).q0)=(null);
((bpo).qz)=(null);
((bpo).zr)=(null);
}
// _copy
function bpp(bpq){
let bpr;
(bpr)=(new Sj());
((bpr).aqE)=(C_([134],((bpq).aqE)));
((bpr).aqJ)=(C_([134],((bpq).aqJ)));
((bpr).yL)=(C_([134],((bpq).yL)));
((bpr).yH)=((bpq).yH);
((bpr).ql)=(C_([134],((bpq).ql)));
((bpr).qX)=(C_([129,2],((bpq).qX)));
((bpr).qU)=(C_([134],((bpq).qU)));
((bpr).pY)=(C_([133,129,2,134],((bpq).pY)));
((bpr).q0)=(C_([129,2],((bpq).q0)));
((bpr).qz)=(C_([134],((bpq).qz)));
((bpr).zr)=(C_([134],((bpq).zr)));
((bpr).r5)=((bpq).r5);
((bpr).qc)=((bpq).qc);
return bpr;
}
// _toBin
function bps(bpt){
let bpu;
(bpu)=(new Array(8).fill(0));
(bpu)=((bpu).concat(toBin_((bpt).aqE)));
(bpu)=((bpu).concat(toBin_((bpt).aqJ)));
(bpu)=((bpu).concat(toBin_((bpt).yL)));
(bpu)=((bpu).concat(toBin_((bpt).yH)));
(bpu)=((bpu).concat(toBin_((bpt).ql)));
(bpu)=((bpu).concat(toBin_((bpt).qX)));
(bpu)=((bpu).concat(toBin_((bpt).qU)));
(bpu)=((bpu).concat(toBin_((bpt).pY)));
(bpu)=((bpu).concat(toBin_((bpt).q0)));
(bpu)=((bpu).concat(toBin_((bpt).qz)));
(bpu)=((bpu).concat(toBin_((bpt).zr)));
(bpu)=((bpu).concat(toBin_((bpt).r5)));
(bpu)=((bpu).concat(toBin_((bpt).qc)));
return bpu;
}
// _fromBin
function bp8(bp9,bpA,bpB){
let bpC;
(bpC)=(new Sj());
((bpC).aqE)=(fromBin_((bpA),(bpB.$)));
((bpC).aqJ)=(fromBin_((bpA),(bpB.$)));
((bpC).yL)=(fromBin_((bpA),(bpB.$)));
((bpC).yH)=(fromBin_((bpA),(bpB.$)));
((bpC).ql)=(fromBin_((bpA),(bpB.$)));
((bpC).qX)=(fromBin_((bpA),(bpB.$)));
((bpC).qU)=(fromBin_((bpA),(bpB.$)));
((bpC).pY)=(fromBin_((bpA),(bpB.$)));
((bpC).q0)=(fromBin_((bpA),(bpB.$)));
((bpC).qz)=(fromBin_((bpA),(bpB.$)));
((bpC).zr)=(fromBin_((bpA),(bpB.$)));
((bpC).r5)=(fromBin_((bpA),(bpB.$)));
((bpC).qc)=(fromBin_((bpA),(bpB.$)));
return bpC;
}
// _dtor
function bpD(bpE){
((bpE).apW)=(null);
((bpE).arc)=(null);
((bpE).arp)=(null);
((bpE).yL)=(null);
((bpE).ql)=(null);
((bpE).qX)=(null);
((bpE).qU)=(null);
((bpE).pY)=(null);
((bpE).q0)=(null);
((bpE).qz)=(null);
((bpE).zr)=(null);
}
// _copy
function bpF(bpG){
let bpH;
(bpH)=(new Sm());
((bpH).apW)=(C_([134],((bpG).apW)));
((bpH).arc)=(C_([129,2],((bpG).arc)));
((bpH).arp)=(C_([134],((bpG).arp)));
((bpH).yL)=(C_([134],((bpG).yL)));
((bpH).yH)=((bpG).yH);
((bpH).ql)=(C_([134],((bpG).ql)));
((bpH).qX)=(C_([129,2],((bpG).qX)));
((bpH).qU)=(C_([134],((bpG).qU)));
((bpH).pY)=(C_([133,129,2,134],((bpG).pY)));
((bpH).q0)=(C_([129,2],((bpG).q0)));
((bpH).qz)=(C_([134],((bpG).qz)));
((bpH).zr)=(C_([134],((bpG).zr)));
((bpH).r5)=((bpG).r5);
((bpH).qc)=((bpG).qc);
return bpH;
}
// _toBin
function bpI(bpJ){
let bpK;
(bpK)=(new Array(8).fill(0));
(bpK)=((bpK).concat(toBin_((bpJ).apW)));
(bpK)=((bpK).concat(toBin_((bpJ).arc)));
(bpK)=((bpK).concat(toBin_((bpJ).arp)));
(bpK)=((bpK).concat(toBin_((bpJ).yL)));
(bpK)=((bpK).concat(toBin_((bpJ).yH)));
(bpK)=((bpK).concat(toBin_((bpJ).ql)));
(bpK)=((bpK).concat(toBin_((bpJ).qX)));
(bpK)=((bpK).concat(toBin_((bpJ).qU)));
(bpK)=((bpK).concat(toBin_((bpJ).pY)));
(bpK)=((bpK).concat(toBin_((bpJ).q0)));
(bpK)=((bpK).concat(toBin_((bpJ).qz)));
(bpK)=((bpK).concat(toBin_((bpJ).zr)));
(bpK)=((bpK).concat(toBin_((bpJ).r5)));
(bpK)=((bpK).concat(toBin_((bpJ).qc)));
return bpK;
}
// _fromBin
function bpZ(bqa,bqb,bqc){
let bqd;
(bqd)=(new Sm());
((bqd).apW)=(fromBin_((bqb),(bqc.$)));
((bqd).arc)=(fromBin_((bqb),(bqc.$)));
((bqd).arp)=(fromBin_((bqb),(bqc.$)));
((bqd).yL)=(fromBin_((bqb),(bqc.$)));
((bqd).yH)=(fromBin_((bqb),(bqc.$)));
((bqd).ql)=(fromBin_((bqb),(bqc.$)));
((bqd).qX)=(fromBin_((bqb),(bqc.$)));
((bqd).qU)=(fromBin_((bqb),(bqc.$)));
((bqd).pY)=(fromBin_((bqb),(bqc.$)));
((bqd).q0)=(fromBin_((bqb),(bqc.$)));
((bqd).qz)=(fromBin_((bqb),(bqc.$)));
((bqd).zr)=(fromBin_((bqb),(bqc.$)));
((bqd).r5)=(fromBin_((bqb),(bqc.$)));
((bqd).qc)=(fromBin_((bqb),(bqc.$)));
return bqd;
}
// _dtor
function bqe(bqf){
((bqf).akF)=(null);
((bqf).yL)=(null);
((bqf).ql)=(null);
((bqf).qX)=(null);
((bqf).qU)=(null);
((bqf).pY)=(null);
((bqf).q0)=(null);
((bqf).qz)=(null);
((bqf).zr)=(null);
}
// _copy
function bqg(bqh){
let bqi;
(bqi)=(new St());
((bqi).akF)=(C_([129,2],((bqh).akF)));
((bqi).yL)=(C_([134],((bqh).yL)));
((bqi).yH)=((bqh).yH);
((bqi).ql)=(C_([134],((bqh).ql)));
((bqi).qX)=(C_([129,2],((bqh).qX)));
((bqi).qU)=(C_([134],((bqh).qU)));
((bqi).pY)=(C_([133,129,2,134],((bqh).pY)));
((bqi).q0)=(C_([129,2],((bqh).q0)));
((bqi).qz)=(C_([134],((bqh).qz)));
((bqi).zr)=(C_([134],((bqh).zr)));
((bqi).r5)=((bqh).r5);
((bqi).qc)=((bqh).qc);
return bqi;
}
// _toBin
function bqj(bqk){
let bql;
(bql)=(new Array(8).fill(0));
(bql)=((bql).concat(toBin_((bqk).akF)));
(bql)=((bql).concat(toBin_((bqk).yL)));
(bql)=((bql).concat(toBin_((bqk).yH)));
(bql)=((bql).concat(toBin_((bqk).ql)));
(bql)=((bql).concat(toBin_((bqk).qX)));
(bql)=((bql).concat(toBin_((bqk).qU)));
(bql)=((bql).concat(toBin_((bqk).pY)));
(bql)=((bql).concat(toBin_((bqk).q0)));
(bql)=((bql).concat(toBin_((bqk).qz)));
(bql)=((bql).concat(toBin_((bqk).zr)));
(bql)=((bql).concat(toBin_((bqk).r5)));
(bql)=((bql).concat(toBin_((bqk).qc)));
return bql;
}
// _fromBin
function bqy(bqz,bq0,bq1){
let bq2;
(bq2)=(new St());
((bq2).akF)=(fromBin_((bq0),(bq1.$)));
((bq2).yL)=(fromBin_((bq0),(bq1.$)));
((bq2).yH)=(fromBin_((bq0),(bq1.$)));
((bq2).ql)=(fromBin_((bq0),(bq1.$)));
((bq2).qX)=(fromBin_((bq0),(bq1.$)));
((bq2).qU)=(fromBin_((bq0),(bq1.$)));
((bq2).pY)=(fromBin_((bq0),(bq1.$)));
((bq2).q0)=(fromBin_((bq0),(bq1.$)));
((bq2).qz)=(fromBin_((bq0),(bq1.$)));
((bq2).zr)=(fromBin_((bq0),(bq1.$)));
((bq2).r5)=(fromBin_((bq0),(bq1.$)));
((bq2).qc)=(fromBin_((bq0),(bq1.$)));
return bq2;
}
// _dtor
function bq3(bq4){
((bq4).akb)=(null);
((bq4).yL)=(null);
((bq4).ql)=(null);
((bq4).qX)=(null);
((bq4).qU)=(null);
((bq4).pY)=(null);
((bq4).q0)=(null);
((bq4).qz)=(null);
((bq4).zr)=(null);
}
// _copy
function bq5(bq6){
let bq7;
(bq7)=(new Sw());
((bq7).akb)=(C_([129,2],((bq6).akb)));
((bq7).yL)=(C_([134],((bq6).yL)));
((bq7).yH)=((bq6).yH);
((bq7).ql)=(C_([134],((bq6).ql)));
((bq7).qX)=(C_([129,2],((bq6).qX)));
((bq7).qU)=(C_([134],((bq6).qU)));
((bq7).pY)=(C_([133,129,2,134],((bq6).pY)));
((bq7).q0)=(C_([129,2],((bq6).q0)));
((bq7).qz)=(C_([134],((bq6).qz)));
((bq7).zr)=(C_([134],((bq6).zr)));
((bq7).r5)=((bq6).r5);
((bq7).qc)=((bq6).qc);
return bq7;
}
// _toBin
function bq8(bq9){
let bqA;
(bqA)=(new Array(8).fill(0));
(bqA)=((bqA).concat(toBin_((bq9).akb)));
(bqA)=((bqA).concat(toBin_((bq9).yL)));
(bqA)=((bqA).concat(toBin_((bq9).yH)));
(bqA)=((bqA).concat(toBin_((bq9).ql)));
(bqA)=((bqA).concat(toBin_((bq9).qX)));
(bqA)=((bqA).concat(toBin_((bq9).qU)));
(bqA)=((bqA).concat(toBin_((bq9).pY)));
(bqA)=((bqA).concat(toBin_((bq9).q0)));
(bqA)=((bqA).concat(toBin_((bq9).qz)));
(bqA)=((bqA).concat(toBin_((bq9).zr)));
(bqA)=((bqA).concat(toBin_((bq9).r5)));
(bqA)=((bqA).concat(toBin_((bq9).qc)));
return bqA;
}
// _fromBin
function bqN(bqO,bqP,bqQ){
let bqR;
(bqR)=(new Sw());
((bqR).akb)=(fromBin_((bqP),(bqQ.$)));
((bqR).yL)=(fromBin_((bqP),(bqQ.$)));
((bqR).yH)=(fromBin_((bqP),(bqQ.$)));
((bqR).ql)=(fromBin_((bqP),(bqQ.$)));
((bqR).qX)=(fromBin_((bqP),(bqQ.$)));
((bqR).qU)=(fromBin_((bqP),(bqQ.$)));
((bqR).pY)=(fromBin_((bqP),(bqQ.$)));
((bqR).q0)=(fromBin_((bqP),(bqQ.$)));
((bqR).qz)=(fromBin_((bqP),(bqQ.$)));
((bqR).zr)=(fromBin_((bqP),(bqQ.$)));
((bqR).r5)=(fromBin_((bqP),(bqQ.$)));
((bqR).qc)=(fromBin_((bqP),(bqQ.$)));
return bqR;
}
// _dtor
function bqS(bqT){
((bqT).yL)=(null);
((bqT).ql)=(null);
((bqT).qX)=(null);
((bqT).qU)=(null);
((bqT).pY)=(null);
((bqT).q0)=(null);
((bqT).qz)=(null);
((bqT).zr)=(null);
}
// _copy
function bqU(bqV){
let bqW;
(bqW)=(new Sz());
((bqW).ajb)=((bqV).ajb);
((bqW).yL)=(C_([134],((bqV).yL)));
((bqW).yH)=((bqV).yH);
((bqW).ql)=(C_([134],((bqV).ql)));
((bqW).qX)=(C_([129,2],((bqV).qX)));
((bqW).qU)=(C_([134],((bqV).qU)));
((bqW).pY)=(C_([133,129,2,134],((bqV).pY)));
((bqW).q0)=(C_([129,2],((bqV).q0)));
((bqW).qz)=(C_([134],((bqV).qz)));
((bqW).zr)=(C_([134],((bqV).zr)));
((bqW).r5)=((bqV).r5);
((bqW).qc)=((bqV).qc);
return bqW;
}
// _toBin
function bqX(bqY){
let bqZ;
(bqZ)=(new Array(8).fill(0));
(bqZ)=((bqZ).concat(toBin_((bqY).ajb)));
(bqZ)=((bqZ).concat(toBin_((bqY).yL)));
(bqZ)=((bqZ).concat(toBin_((bqY).yH)));
(bqZ)=((bqZ).concat(toBin_((bqY).ql)));
(bqZ)=((bqZ).concat(toBin_((bqY).qX)));
(bqZ)=((bqZ).concat(toBin_((bqY).qU)));
(bqZ)=((bqZ).concat(toBin_((bqY).pY)));
(bqZ)=((bqZ).concat(toBin_((bqY).q0)));
(bqZ)=((bqZ).concat(toBin_((bqY).qz)));
(bqZ)=((bqZ).concat(toBin_((bqY).zr)));
(bqZ)=((bqZ).concat(toBin_((bqY).r5)));
(bqZ)=((bqZ).concat(toBin_((bqY).qc)));
return bqZ;
}
// _fromBin
function brm(brn,bro,brp){
let brq;
(brq)=(new Sz());
((brq).ajb)=(fromBin_((bro),(brp.$)));
((brq).yL)=(fromBin_((bro),(brp.$)));
((brq).yH)=(fromBin_((bro),(brp.$)));
((brq).ql)=(fromBin_((bro),(brp.$)));
((brq).qX)=(fromBin_((bro),(brp.$)));
((brq).qU)=(fromBin_((bro),(brp.$)));
((brq).pY)=(fromBin_((bro),(brp.$)));
((brq).q0)=(fromBin_((bro),(brp.$)));
((brq).qz)=(fromBin_((bro),(brp.$)));
((brq).zr)=(fromBin_((bro),(brp.$)));
((brq).r5)=(fromBin_((bro),(brp.$)));
((brq).qc)=(fromBin_((bro),(brp.$)));
return brq;
}
// _dtor
function brr(brs){
((brs).aqf)=(null);
((brs).yL)=(null);
((brs).ql)=(null);
((brs).qX)=(null);
((brs).qU)=(null);
((brs).pY)=(null);
((brs).q0)=(null);
((brs).qz)=(null);
((brs).zr)=(null);
}
// _copy
function brt(bru){
let brv;
(brv)=(new S2());
((brv).aqf)=(C_([130,134],((bru).aqf)));
((brv).yL)=(C_([134],((bru).yL)));
((brv).yH)=((bru).yH);
((brv).ql)=(C_([134],((bru).ql)));
((brv).qX)=(C_([129,2],((bru).qX)));
((brv).qU)=(C_([134],((bru).qU)));
((brv).pY)=(C_([133,129,2,134],((bru).pY)));
((brv).q0)=(C_([129,2],((bru).q0)));
((brv).qz)=(C_([134],((bru).qz)));
((brv).zr)=(C_([134],((bru).zr)));
((brv).r5)=((bru).r5);
((brv).qc)=((bru).qc);
return brv;
}
// _toBin
function brw(brx){
let bry;
(bry)=(new Array(8).fill(0));
(bry)=((bry).concat(toBin_((brx).aqf)));
(bry)=((bry).concat(toBin_((brx).yL)));
(bry)=((bry).concat(toBin_((brx).yH)));
(bry)=((bry).concat(toBin_((brx).ql)));
(bry)=((bry).concat(toBin_((brx).qX)));
(bry)=((bry).concat(toBin_((brx).qU)));
(bry)=((bry).concat(toBin_((brx).pY)));
(bry)=((bry).concat(toBin_((brx).q0)));
(bry)=((bry).concat(toBin_((brx).qz)));
(bry)=((bry).concat(toBin_((brx).zr)));
(bry)=((bry).concat(toBin_((brx).r5)));
(bry)=((bry).concat(toBin_((brx).qc)));
return bry;
}
// _fromBin
function brB(brC,brD,brE){
let brF;
(brF)=(new S2());
((brF).aqf)=(fromBin_((brD),(brE.$)));
((brF).yL)=(fromBin_((brD),(brE.$)));
((brF).yH)=(fromBin_((brD),(brE.$)));
((brF).ql)=(fromBin_((brD),(brE.$)));
((brF).qX)=(fromBin_((brD),(brE.$)));
((brF).qU)=(fromBin_((brD),(brE.$)));
((brF).pY)=(fromBin_((brD),(brE.$)));
((brF).q0)=(fromBin_((brD),(brE.$)));
((brF).qz)=(fromBin_((brD),(brE.$)));
((brF).zr)=(fromBin_((brD),(brE.$)));
((brF).r5)=(fromBin_((brD),(brE.$)));
((brF).qc)=(fromBin_((brD),(brE.$)));
return brF;
}
// _dtor
function brG(brH){
((brH).SK)=(null);
((brH).ql)=(null);
((brH).qX)=(null);
((brH).qU)=(null);
((brH).pY)=(null);
((brH).q0)=(null);
((brH).qz)=(null);
((brH).zr)=(null);
}
// _copy
function brI(brJ){
let brK;
(brK)=(new SI());
((brK).SK)=(C_([134],((brJ).SK)));
((brK).ql)=(C_([134],((brJ).ql)));
((brK).qX)=(C_([129,2],((brJ).qX)));
((brK).qU)=(C_([134],((brJ).qU)));
((brK).pY)=(C_([133,129,2,134],((brJ).pY)));
((brK).q0)=(C_([129,2],((brJ).q0)));
((brK).qz)=(C_([134],((brJ).qz)));
((brK).zr)=(C_([134],((brJ).zr)));
((brK).r5)=((brJ).r5);
((brK).qc)=((brJ).qc);
return brK;
}
// _toBin
function brL(brM){
let brN;
(brN)=(new Array(8).fill(0));
(brN)=((brN).concat(toBin_((brM).SK)));
(brN)=((brN).concat(toBin_((brM).ql)));
(brN)=((brN).concat(toBin_((brM).qX)));
(brN)=((brN).concat(toBin_((brM).qU)));
(brN)=((brN).concat(toBin_((brM).pY)));
(brN)=((brN).concat(toBin_((brM).q0)));
(brN)=((brN).concat(toBin_((brM).qz)));
(brN)=((brN).concat(toBin_((brM).zr)));
(brN)=((brN).concat(toBin_((brM).r5)));
(brN)=((brN).concat(toBin_((brM).qc)));
return brN;
}
// _fromBin
function brY(brZ,bsa,bsb){
let bsc;
(bsc)=(new SI());
((bsc).SK)=(fromBin_((bsa),(bsb.$)));
((bsc).ql)=(fromBin_((bsa),(bsb.$)));
((bsc).qX)=(fromBin_((bsa),(bsb.$)));
((bsc).qU)=(fromBin_((bsa),(bsb.$)));
((bsc).pY)=(fromBin_((bsa),(bsb.$)));
((bsc).q0)=(fromBin_((bsa),(bsb.$)));
((bsc).qz)=(fromBin_((bsa),(bsb.$)));
((bsc).zr)=(fromBin_((bsa),(bsb.$)));
((bsc).r5)=(fromBin_((bsa),(bsb.$)));
((bsc).qc)=(fromBin_((bsa),(bsb.$)));
return bsc;
}
// _dtor
function bsd(bse){
((bse).ql)=(null);
((bse).qX)=(null);
((bse).qU)=(null);
((bse).pY)=(null);
((bse).q0)=(null);
((bse).qz)=(null);
((bse).zr)=(null);
}
// _copy
function bsf(bsg){
let bsh;
(bsh)=(new TE());
((bsh).ql)=(C_([134],((bsg).ql)));
((bsh).qX)=(C_([129,2],((bsg).qX)));
((bsh).qU)=(C_([134],((bsg).qU)));
((bsh).pY)=(C_([133,129,2,134],((bsg).pY)));
((bsh).q0)=(C_([129,2],((bsg).q0)));
((bsh).qz)=(C_([134],((bsg).qz)));
((bsh).zr)=(C_([134],((bsg).zr)));
((bsh).r5)=((bsg).r5);
((bsh).qc)=((bsg).qc);
return bsh;
}
// _toBin
function bsi(bsj){
let bsk;
(bsk)=(new Array(8).fill(0));
(bsk)=((bsk).concat(toBin_((bsj).ql)));
(bsk)=((bsk).concat(toBin_((bsj).qX)));
(bsk)=((bsk).concat(toBin_((bsj).qU)));
(bsk)=((bsk).concat(toBin_((bsj).pY)));
(bsk)=((bsk).concat(toBin_((bsj).q0)));
(bsk)=((bsk).concat(toBin_((bsj).qz)));
(bsk)=((bsk).concat(toBin_((bsj).zr)));
(bsk)=((bsk).concat(toBin_((bsj).r5)));
(bsk)=((bsk).concat(toBin_((bsj).qc)));
return bsk;
}
// _fromBin
function bsu(bsv,bsw,bsx){
let bsy;
(bsy)=(new TE());
((bsy).ql)=(fromBin_((bsw),(bsx.$)));
((bsy).qX)=(fromBin_((bsw),(bsx.$)));
((bsy).qU)=(fromBin_((bsw),(bsx.$)));
((bsy).pY)=(fromBin_((bsw),(bsx.$)));
((bsy).q0)=(fromBin_((bsw),(bsx.$)));
((bsy).qz)=(fromBin_((bsw),(bsx.$)));
((bsy).zr)=(fromBin_((bsw),(bsx.$)));
((bsy).r5)=(fromBin_((bsw),(bsx.$)));
((bsy).qc)=(fromBin_((bsw),(bsx.$)));
return bsy;
}
// _dtor
function bsz(bs0){
((bs0).UA)=(null);
((bs0).UB)=(null);
((bs0).ql)=(null);
((bs0).qX)=(null);
((bs0).qU)=(null);
((bs0).pY)=(null);
((bs0).q0)=(null);
((bs0).qz)=(null);
((bs0).zr)=(null);
}
// _copy
function bs1(bs2){
let bs3;
(bs3)=(new U9());
((bs3).UA)=(C_([134],((bs2).UA)));
((bs3).UB)=(C_([134],((bs2).UB)));
((bs3).ql)=(C_([134],((bs2).ql)));
((bs3).qX)=(C_([129,2],((bs2).qX)));
((bs3).qU)=(C_([134],((bs2).qU)));
((bs3).pY)=(C_([133,129,2,134],((bs2).pY)));
((bs3).q0)=(C_([129,2],((bs2).q0)));
((bs3).qz)=(C_([134],((bs2).qz)));
((bs3).zr)=(C_([134],((bs2).zr)));
((bs3).r5)=((bs2).r5);
((bs3).qc)=((bs2).qc);
return bs3;
}
// _toBin
function bs4(bs5){
let bs6;
(bs6)=(new Array(8).fill(0));
(bs6)=((bs6).concat(toBin_((bs5).UA)));
(bs6)=((bs6).concat(toBin_((bs5).UB)));
(bs6)=((bs6).concat(toBin_((bs5).ql)));
(bs6)=((bs6).concat(toBin_((bs5).qX)));
(bs6)=((bs6).concat(toBin_((bs5).qU)));
(bs6)=((bs6).concat(toBin_((bs5).pY)));
(bs6)=((bs6).concat(toBin_((bs5).q0)));
(bs6)=((bs6).concat(toBin_((bs5).qz)));
(bs6)=((bs6).concat(toBin_((bs5).zr)));
(bs6)=((bs6).concat(toBin_((bs5).r5)));
(bs6)=((bs6).concat(toBin_((bs5).qc)));
return bs6;
}
// _fromBin
function bsI(bsJ,bsK,bsL){
let bsM;
(bsM)=(new U9());
((bsM).UA)=(fromBin_((bsK),(bsL.$)));
((bsM).UB)=(fromBin_((bsK),(bsL.$)));
((bsM).ql)=(fromBin_((bsK),(bsL.$)));
((bsM).qX)=(fromBin_((bsK),(bsL.$)));
((bsM).qU)=(fromBin_((bsK),(bsL.$)));
((bsM).pY)=(fromBin_((bsK),(bsL.$)));
((bsM).q0)=(fromBin_((bsK),(bsL.$)));
((bsM).qz)=(fromBin_((bsK),(bsL.$)));
((bsM).zr)=(fromBin_((bsK),(bsL.$)));
((bsM).r5)=(fromBin_((bsK),(bsL.$)));
((bsM).qc)=(fromBin_((bsK),(bsL.$)));
return bsM;
}
// _dtor
function bsN(bsO){
((bsO).Vb)=(null);
((bsO).Vp)=(null);
((bsO).ql)=(null);
((bsO).qX)=(null);
((bsO).qU)=(null);
((bsO).pY)=(null);
((bsO).q0)=(null);
((bsO).qz)=(null);
((bsO).zr)=(null);
}
// _copy
function bsP(bsQ){
let bsR;
(bsR)=(new UZ());
((bsR).Vb)=(C_([130,134],((bsQ).Vb)));
((bsR).Vp)=(C_([134],((bsQ).Vp)));
((bsR).ql)=(C_([134],((bsQ).ql)));
((bsR).qX)=(C_([129,2],((bsQ).qX)));
((bsR).qU)=(C_([134],((bsQ).qU)));
((bsR).pY)=(C_([133,129,2,134],((bsQ).pY)));
((bsR).q0)=(C_([129,2],((bsQ).q0)));
((bsR).qz)=(C_([134],((bsQ).qz)));
((bsR).zr)=(C_([134],((bsQ).zr)));
((bsR).r5)=((bsQ).r5);
((bsR).qc)=((bsQ).qc);
return bsR;
}
// _toBin
function bsS(bsT){
let bsU;
(bsU)=(new Array(8).fill(0));
(bsU)=((bsU).concat(toBin_((bsT).Vb)));
(bsU)=((bsU).concat(toBin_((bsT).Vp)));
(bsU)=((bsU).concat(toBin_((bsT).ql)));
(bsU)=((bsU).concat(toBin_((bsT).qX)));
(bsU)=((bsU).concat(toBin_((bsT).qU)));
(bsU)=((bsU).concat(toBin_((bsT).pY)));
(bsU)=((bsU).concat(toBin_((bsT).q0)));
(bsU)=((bsU).concat(toBin_((bsT).qz)));
(bsU)=((bsU).concat(toBin_((bsT).zr)));
(bsU)=((bsU).concat(toBin_((bsT).r5)));
(bsU)=((bsU).concat(toBin_((bsT).qc)));
return bsU;
}
// _fromBin
function btg(bth,bti,btj){
let btk;
(btk)=(new UZ());
((btk).Vb)=(fromBin_((bti),(btj.$)));
((btk).Vp)=(fromBin_((bti),(btj.$)));
((btk).ql)=(fromBin_((bti),(btj.$)));
((btk).qX)=(fromBin_((bti),(btj.$)));
((btk).qU)=(fromBin_((bti),(btj.$)));
((btk).pY)=(fromBin_((bti),(btj.$)));
((btk).q0)=(fromBin_((bti),(btj.$)));
((btk).qz)=(fromBin_((bti),(btj.$)));
((btk).zr)=(fromBin_((bti),(btj.$)));
((btk).r5)=(fromBin_((bti),(btj.$)));
((btk).qc)=(fromBin_((bti),(btj.$)));
return btk;
}
// _dtor
function btl(btm){
((btm).az2)=(null);
((btm).ql)=(null);
((btm).qX)=(null);
((btm).qU)=(null);
((btm).pY)=(null);
((btm).q0)=(null);
((btm).qz)=(null);
((btm).zr)=(null);
}
// _copy
function btn(bto){
let btp;
(btp)=(new az1());
((btp).az2)=(C_([134],((bto).az2)));
((btp).ql)=(C_([134],((bto).ql)));
((btp).qX)=(C_([129,2],((bto).qX)));
((btp).qU)=(C_([134],((bto).qU)));
((btp).pY)=(C_([133,129,2,134],((bto).pY)));
((btp).q0)=(C_([129,2],((bto).q0)));
((btp).qz)=(C_([134],((bto).qz)));
((btp).zr)=(C_([134],((bto).zr)));
((btp).r5)=((bto).r5);
((btp).qc)=((bto).qc);
return btp;
}
// _toBin
function btq(btr){
let bts;
(bts)=(new Array(8).fill(0));
(bts)=((bts).concat(toBin_((btr).az2)));
(bts)=((bts).concat(toBin_((btr).ql)));
(bts)=((bts).concat(toBin_((btr).qX)));
(bts)=((bts).concat(toBin_((btr).qU)));
(bts)=((bts).concat(toBin_((btr).pY)));
(bts)=((bts).concat(toBin_((btr).q0)));
(bts)=((bts).concat(toBin_((btr).qz)));
(bts)=((bts).concat(toBin_((btr).zr)));
(bts)=((bts).concat(toBin_((btr).r5)));
(bts)=((bts).concat(toBin_((btr).qc)));
return bts;
}
// _fromBin
function bt3(bt4,bt5,bt6){
let bt7;
(bt7)=(new az1());
((bt7).az2)=(fromBin_((bt5),(bt6.$)));
((bt7).ql)=(fromBin_((bt5),(bt6.$)));
((bt7).qX)=(fromBin_((bt5),(bt6.$)));
((bt7).qU)=(fromBin_((bt5),(bt6.$)));
((bt7).pY)=(fromBin_((bt5),(bt6.$)));
((bt7).q0)=(fromBin_((bt5),(bt6.$)));
((bt7).qz)=(fromBin_((bt5),(bt6.$)));
((bt7).zr)=(fromBin_((bt5),(bt6.$)));
((bt7).r5)=(fromBin_((bt5),(bt6.$)));
((bt7).qc)=(fromBin_((bt5),(bt6.$)));
return bt7;
}
// _dtor
function bt8(bt9){
((bt9).az6)=(null);
((bt9).ql)=(null);
((bt9).qX)=(null);
((bt9).qU)=(null);
((bt9).pY)=(null);
((bt9).q0)=(null);
((bt9).qz)=(null);
((bt9).zr)=(null);
}
// _copy
function btA(btB){
let btC;
(btC)=(new az5());
((btC).az6)=(C_([134],((btB).az6)));
((btC).ql)=(C_([134],((btB).ql)));
((btC).qX)=(C_([129,2],((btB).qX)));
((btC).qU)=(C_([134],((btB).qU)));
((btC).pY)=(C_([133,129,2,134],((btB).pY)));
((btC).q0)=(C_([129,2],((btB).q0)));
((btC).qz)=(C_([134],((btB).qz)));
((btC).zr)=(C_([134],((btB).zr)));
((btC).r5)=((btB).r5);
((btC).qc)=((btB).qc);
return btC;
}
// _toBin
function btD(btE){
let btF;
(btF)=(new Array(8).fill(0));
(btF)=((btF).concat(toBin_((btE).az6)));
(btF)=((btF).concat(toBin_((btE).ql)));
(btF)=((btF).concat(toBin_((btE).qX)));
(btF)=((btF).concat(toBin_((btE).qU)));
(btF)=((btF).concat(toBin_((btE).pY)));
(btF)=((btF).concat(toBin_((btE).q0)));
(btF)=((btF).concat(toBin_((btE).qz)));
(btF)=((btF).concat(toBin_((btE).zr)));
(btF)=((btF).concat(toBin_((btE).r5)));
(btF)=((btF).concat(toBin_((btE).qc)));
return btF;
}
// _fromBin
function btQ(btR,btS,btT){
let btU;
(btU)=(new az5());
((btU).az6)=(fromBin_((btS),(btT.$)));
((btU).ql)=(fromBin_((btS),(btT.$)));
((btU).qX)=(fromBin_((btS),(btT.$)));
((btU).qU)=(fromBin_((btS),(btT.$)));
((btU).pY)=(fromBin_((btS),(btT.$)));
((btU).q0)=(fromBin_((btS),(btT.$)));
((btU).qz)=(fromBin_((btS),(btT.$)));
((btU).zr)=(fromBin_((btS),(btT.$)));
((btU).r5)=(fromBin_((btS),(btT.$)));
((btU).qc)=(fromBin_((btS),(btT.$)));
return btU;
}
// _dtor
function btV(btW){
((btW).az9)=(null);
((btW).ql)=(null);
((btW).qX)=(null);
((btW).qU)=(null);
((btW).pY)=(null);
((btW).q0)=(null);
((btW).qz)=(null);
((btW).zr)=(null);
}
// _copy
function btX(btY){
let btZ;
(btZ)=(new az8());
((btZ).az9)=(C_([134],((btY).az9)));
((btZ).ql)=(C_([134],((btY).ql)));
((btZ).qX)=(C_([129,2],((btY).qX)));
((btZ).qU)=(C_([134],((btY).qU)));
((btZ).pY)=(C_([133,129,2,134],((btY).pY)));
((btZ).q0)=(C_([129,2],((btY).q0)));
((btZ).qz)=(C_([134],((btY).qz)));
((btZ).zr)=(C_([134],((btY).zr)));
((btZ).r5)=((btY).r5);
((btZ).qc)=((btY).qc);
return btZ;
}
// _toBin
function bua(bub){
let buc;
(buc)=(new Array(8).fill(0));
(buc)=((buc).concat(toBin_((bub).az9)));
(buc)=((buc).concat(toBin_((bub).ql)));
(buc)=((buc).concat(toBin_((bub).qX)));
(buc)=((buc).concat(toBin_((bub).qU)));
(buc)=((buc).concat(toBin_((bub).pY)));
(buc)=((buc).concat(toBin_((bub).q0)));
(buc)=((buc).concat(toBin_((bub).qz)));
(buc)=((buc).concat(toBin_((bub).zr)));
(buc)=((buc).concat(toBin_((bub).r5)));
(buc)=((buc).concat(toBin_((bub).qc)));
return buc;
}
// _fromBin
function bun(buo,bup,buq){
let bur;
(bur)=(new az8());
((bur).az9)=(fromBin_((bup),(buq.$)));
((bur).ql)=(fromBin_((bup),(buq.$)));
((bur).qX)=(fromBin_((bup),(buq.$)));
((bur).qU)=(fromBin_((bup),(buq.$)));
((bur).pY)=(fromBin_((bup),(buq.$)));
((bur).q0)=(fromBin_((bup),(buq.$)));
((bur).qz)=(fromBin_((bup),(buq.$)));
((bur).zr)=(fromBin_((bup),(buq.$)));
((bur).r5)=(fromBin_((bup),(buq.$)));
((bur).qc)=(fromBin_((bup),(buq.$)));
return bur;
}
// _dtor
function bus(but){
((but).azC)=(null);
((but).ql)=(null);
((but).qX)=(null);
((but).qU)=(null);
((but).pY)=(null);
((but).q0)=(null);
((but).qz)=(null);
((but).zr)=(null);
}
// _copy
function buu(buv){
let buw;
(buw)=(new azB());
((buw).azC)=(C_([134],((buv).azC)));
((buw).ql)=(C_([134],((buv).ql)));
((buw).qX)=(C_([129,2],((buv).qX)));
((buw).qU)=(C_([134],((buv).qU)));
((buw).pY)=(C_([133,129,2,134],((buv).pY)));
((buw).q0)=(C_([129,2],((buv).q0)));
((buw).qz)=(C_([134],((buv).qz)));
((buw).zr)=(C_([134],((buv).zr)));
((buw).r5)=((buv).r5);
((buw).qc)=((buv).qc);
return buw;
}
// _toBin
function bux(buy){
let buz;
(buz)=(new Array(8).fill(0));
(buz)=((buz).concat(toBin_((buy).azC)));
(buz)=((buz).concat(toBin_((buy).ql)));
(buz)=((buz).concat(toBin_((buy).qX)));
(buz)=((buz).concat(toBin_((buy).qU)));
(buz)=((buz).concat(toBin_((buy).pY)));
(buz)=((buz).concat(toBin_((buy).q0)));
(buz)=((buz).concat(toBin_((buy).qz)));
(buz)=((buz).concat(toBin_((buy).zr)));
(buz)=((buz).concat(toBin_((buy).r5)));
(buz)=((buz).concat(toBin_((buy).qc)));
return buz;
}
// _fromBin
function buA(buB,buC,buD){
let buE;
(buE)=(new azB());
((buE).azC)=(fromBin_((buC),(buD.$)));
((buE).ql)=(fromBin_((buC),(buD.$)));
((buE).qX)=(fromBin_((buC),(buD.$)));
((buE).qU)=(fromBin_((buC),(buD.$)));
((buE).pY)=(fromBin_((buC),(buD.$)));
((buE).q0)=(fromBin_((buC),(buD.$)));
((buE).qz)=(fromBin_((buC),(buD.$)));
((buE).zr)=(fromBin_((buC),(buD.$)));
((buE).r5)=(fromBin_((buC),(buD.$)));
((buE).qc)=(fromBin_((buC),(buD.$)));
return buE;
}
// _dtor
function buF(buG){
((buG).azF)=(null);
((buG).ql)=(null);
((buG).qX)=(null);
((buG).qU)=(null);
((buG).pY)=(null);
((buG).q0)=(null);
((buG).qz)=(null);
((buG).zr)=(null);
}
// _copy
function buH(buI){
let buJ;
(buJ)=(new azE());
((buJ).azF)=(C_([134],((buI).azF)));
((buJ).ql)=(C_([134],((buI).ql)));
((buJ).qX)=(C_([129,2],((buI).qX)));
((buJ).qU)=(C_([134],((buI).qU)));
((buJ).pY)=(C_([133,129,2,134],((buI).pY)));
((buJ).q0)=(C_([129,2],((buI).q0)));
((buJ).qz)=(C_([134],((buI).qz)));
((buJ).zr)=(C_([134],((buI).zr)));
((buJ).r5)=((buI).r5);
((buJ).qc)=((buI).qc);
return buJ;
}
// _toBin
function buK(buL){
let buM;
(buM)=(new Array(8).fill(0));
(buM)=((buM).concat(toBin_((buL).azF)));
(buM)=((buM).concat(toBin_((buL).ql)));
(buM)=((buM).concat(toBin_((buL).qX)));
(buM)=((buM).concat(toBin_((buL).qU)));
(buM)=((buM).concat(toBin_((buL).pY)));
(buM)=((buM).concat(toBin_((buL).q0)));
(buM)=((buM).concat(toBin_((buL).qz)));
(buM)=((buM).concat(toBin_((buL).zr)));
(buM)=((buM).concat(toBin_((buL).r5)));
(buM)=((buM).concat(toBin_((buL).qc)));
return buM;
}
// _fromBin
function buX(buY,buZ,bva){
let bvb;
(bvb)=(new azE());
((bvb).azF)=(fromBin_((buZ),(bva.$)));
((bvb).ql)=(fromBin_((buZ),(bva.$)));
((bvb).qX)=(fromBin_((buZ),(bva.$)));
((bvb).qU)=(fromBin_((buZ),(bva.$)));
((bvb).pY)=(fromBin_((buZ),(bva.$)));
((bvb).q0)=(fromBin_((buZ),(bva.$)));
((bvb).qz)=(fromBin_((buZ),(bva.$)));
((bvb).zr)=(fromBin_((buZ),(bva.$)));
((bvb).r5)=(fromBin_((buZ),(bva.$)));
((bvb).qc)=(fromBin_((buZ),(bva.$)));
return bvb;
}
// _dtor
function bvc(bvd){
((bvd).ql)=(null);
((bvd).qX)=(null);
((bvd).qU)=(null);
((bvd).pY)=(null);
((bvd).q0)=(null);
((bvd).qz)=(null);
((bvd).zr)=(null);
}
// _copy
function bve(bvf){
let bvg;
(bvg)=(new aPI());
((bvg).ql)=(C_([134],((bvf).ql)));
((bvg).qX)=(C_([129,2],((bvf).qX)));
((bvg).qU)=(C_([134],((bvf).qU)));
((bvg).pY)=(C_([133,129,2,134],((bvf).pY)));
((bvg).q0)=(C_([129,2],((bvf).q0)));
((bvg).qz)=(C_([134],((bvf).qz)));
((bvg).zr)=(C_([134],((bvf).zr)));
((bvg).r5)=((bvf).r5);
((bvg).qc)=((bvf).qc);
return bvg;
}
// _toBin
function bvh(bvi){
let bvj;
(bvj)=(new Array(8).fill(0));
(bvj)=((bvj).concat(toBin_((bvi).ql)));
(bvj)=((bvj).concat(toBin_((bvi).qX)));
(bvj)=((bvj).concat(toBin_((bvi).qU)));
(bvj)=((bvj).concat(toBin_((bvi).pY)));
(bvj)=((bvj).concat(toBin_((bvi).q0)));
(bvj)=((bvj).concat(toBin_((bvi).qz)));
(bvj)=((bvj).concat(toBin_((bvi).zr)));
(bvj)=((bvj).concat(toBin_((bvi).r5)));
(bvj)=((bvj).concat(toBin_((bvi).qc)));
return bvj;
}
// _fromBin
function bvt(bvu,bvv,bvw){
let bvx;
(bvx)=(new aPI());
((bvx).ql)=(fromBin_((bvv),(bvw.$)));
((bvx).qX)=(fromBin_((bvv),(bvw.$)));
((bvx).qU)=(fromBin_((bvv),(bvw.$)));
((bvx).pY)=(fromBin_((bvv),(bvw.$)));
((bvx).q0)=(fromBin_((bvv),(bvw.$)));
((bvx).qz)=(fromBin_((bvv),(bvw.$)));
((bvx).zr)=(fromBin_((bvv),(bvw.$)));
((bvx).r5)=(fromBin_((bvv),(bvw.$)));
((bvx).qc)=(fromBin_((bvv),(bvw.$)));
return bvx;
}
// addr
function aTc(bvy /*class_*/){
}
// _signInt
function aUy(bvz /*me_*/){
return ((bvz)>(0))?(1):(((bvz)<(0))?(-1):(0));
}
function C_(t,v){
switch(t[0]){
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
return v;
case 129:
if(t[1]===2)
return v===null?null:{S:v.S};
else{
let a=new Array(v.length);
for(let i=0;i<v.length;i++)a[i]=C_(t.slice(1),v[i]);
return a;
}
case 130:
case 131:
case 132:
case 133:
case 134:
}
}
function F_(p,f){
if(p==="res/")
return f?null:true;
else if(p==="res/analyze.kn")
return f?"var asts: dict<[]char, \\ast@Ast>\n\n+func analyze(asts: dict<[]char, \\ast@Ast>): \\ast@AstFunc\n\u0009do @asts :: asts\n\u0009\n\u0009var mainFunc: \\ast@AstFunc :: @searchMain()\n\u0009if(mainFunc =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009do asts.forEach(@resolveIdentifier, null)\n\u0009ret @rebuild(mainFunc)\nend func\n\n+func searchMain(): \\ast@AstFunc\n\u0009var ast: \\ast@Ast :: @asts.get(\"\\\\\" ~ \\option@inputName, &)\n\u0009if(ast =& null)\n\u0009\u0009do \\err@err(%noMainFunc, null, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009var mainFunc: \\ast@Ast :: ast.scopeChildren.get(\"main\", &)\n\u0009if(mainFunc =& null | mainFunc.typeId <> %func_)\n\u0009\u0009do \\err@err(%noMainFunc, null, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009var mainFunc2: \\ast@AstFunc :: mainFunc $ \\ast@AstFunc\n\u0009if(^mainFunc2.args <> 0 | mainFunc2.ret_ <>& null | mainFunc2.funcOption <> %none | ^mainFunc2.funcAttr <> 0)\n\u0009\u0009do \\err@err(%wrongMainFunc, mainFunc2.pos, null)\n\u0009end if\n\u0009ret mainFunc2\nend func\n\nfunc resolveIdentifier(key: []char, value: \\ast@Ast, data: kuin@Class): bool\n\u0009assert value =$ \\ast@AstRoot\n\u0009var scopeRefedItems: list<\\ast@ScopeRefedItem> :: (value $ \\ast@AstRoot).scopeRefedItems\n\u0009\n\u0009; Search scopes for identifiers and resolve references.\n\u0009do scopeRefedItems.head()\n\u0009while(!scopeRefedItems.term())\n\u0009\u0009var item: \\ast@ScopeRefedItem :: scopeRefedItems.get()\n\u0009\u0009var ast: \\ast@Ast :: item.def\n\u0009\u0009assert ast.refItem =& null {Must not resolve references that have been already resolved.}\n\u0009\u0009assert ast.refName <>& null\n\u0009\u0009var otherFile: bool :: false\n\u0009\u0009var ptrAt: int :: ast.refName.find(\'@\', -1)\n\u0009\u0009var ptrName: []char :: ptrAt = -1 ?(ast.refName, ast.refName.sub(ptrAt + 1, -1))\n\u0009\u0009var foundAst: \\ast@Ast :: null\n\u0009\u0009if(ptrAt <> -1)\n\u0009\u0009\u0009; Search the root of the source.\n\u0009\u0009\u0009var ptrSrc: []char {The source name before \'@\'.}\n\u0009\u0009\u0009if(ptrAt = 0)\n\u0009\u0009\u0009\u0009do ptrSrc :: key\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do ptrSrc :: ast.refName.sub(0, ptrAt)\n\u0009\u0009\u0009\u0009if(ptrSrc = key)\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%nonOmittingAt, ast.pos, [ptrSrc])\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do otherFile :: true\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009var ast2: \\ast@Ast :: @asts.get(ptrSrc, &)\n\u0009\u0009\u0009if(ast2 <>& null)\n\u0009\u0009\u0009\u0009do foundAst :: ast2.scopeChildren.get(ptrName, &)\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009; Search from the current scope toward its parent\'s scope.\n\u0009\u0009\u0009var scope: \\ast@Ast :: item.scope\n\u0009\u0009\u0009var overFunc: bool :: false\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009if(scope.scopeParent =& null)\n\u0009\u0009\u0009\u0009\u0009break loop {No more parent scope exists.}\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(scope.name <>& null & scope.name = ptrName)\n\u0009\u0009\u0009\u0009\u0009if(scope.typeId = %func_ & scope.refName <>& null)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%accessMemberWithoutMe, ast.pos, [ptrName])\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009; The compiler also looks at the current scope\'s name.\n\u0009\u0009\u0009\u0009\u0009\u0009do foundAst :: scope\n\u0009\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009var ast2: \\ast@Ast :: scope.scopeChildren.get(ptrName, &)\n\u0009\u0009\u0009\u0009if(ast2 <>& null)\n\u0009\u0009\u0009\u0009\u0009var err: bool :: false\n\u0009\u0009\u0009\u0009\u0009if(overFunc)\n\u0009\u0009\u0009\u0009\u0009\u0009if(ast2.typeId = %arg)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var kind: \\ast@AstArgKind :: (ast2 $ \\ast@AstArg).kind\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(kind = %member | kind = %localVar | kind = %localArg)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do err :: true\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009if(!err & ast2.typeId.and(%statBreakable) = %statBreakable)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do err :: true\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(!err & ast2.typeId = %func_ & ast2.refName <>& null)\n\u0009\u0009\u0009\u0009\u0009\u0009do err :: true\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(err)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%accessMemberWithoutMe, ast.pos, [ptrName])\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do foundAst :: ast2\n\u0009\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(scope.typeId = %func_)\n\u0009\u0009\u0009\u0009\u0009do overFunc :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do scope :: scope.scopeParent\n\u0009\u0009\u0009end while\n\u0009\u0009end if\n\u0009\u0009if(foundAst <>& null)\n\u0009\u0009\u0009if(otherFile & !foundAst.publicInSrc)\n\u0009\u0009\u0009\u0009do \\err@err(%accessUnpublishedElement, ast.pos, [ast.refName])\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.refItem :: foundAst\n\u0009\u0009else\n\u0009\u0009\u0009do \\err@err(%identifierNotFound, ast.pos, [ast.refName])\n\u0009\u0009\u0009do ast.refItem :: null\n\u0009\u0009end if\n\u0009\u0009do scopeRefedItems.next()\n\u0009end while\n\u0009ret true\nend func\n\nfunc rebuild(mainFunc: \\ast@AstFunc): \\ast@AstFunc\n\u0009var entry: \\ast@AstFunc\n\u0009\n\u0009; Build the entry point and register it in the root.\n\u0009block\n\u0009\u0009do entry :: @makeEntryPoint(mainFunc)\n\u0009\u0009do @rebuildFunc(entry)\n\u0009\u0009var root: \\ast@Ast :: @asts.get(\"\\\\\" ~ \\option@inputName, &)\n\u0009\u0009assert root =$ \\ast@AstRoot\n\u0009\u0009do(root $ \\ast@AstRoot).items.add(entry)\n\u0009end block\n\u0009\n\u0009do @asts.forEach(@rebuildRoot, null)\n\u0009\n\u0009ret entry\nend func\n\nfunc makeEntryPoint(mainFunc: \\ast@AstFunc): \\ast@AstFunc\n\u0009var pos: \\pos@Pos :: \\pos@make(\"kuin\", 1, 1)\n\u0009var entry: \\ast@AstFunc :: #\\ast@AstFunc\n\u0009do @initAst(entry, %func_, pos)\n\u0009do entry.name :: \"$\"\n\u0009do entry.funcOption :: %none\n\u0009do entry.funcAttr :: #list<[]char>\n\u0009do entry.args :: #list<\\ast@AstArg>\n\u0009do entry.ret_ :: null\n\u0009do entry.stats :: #list<\\ast@AstStat>\n\u0009block\n\u0009\u0009var try_: \\ast@AstStatTry :: #\\ast@AstStatTry\n\u0009\u0009do @initAst(try_, %statTry, pos)\n\u0009\u0009block\n\u0009\u0009\u0009var var_: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009do @initAst(var_, %arg, pos)\n\u0009\u0009\u0009do var_.name :: \"$\"\n\u0009\u0009\u0009do var_.kind :: %localVar\n\u0009\u0009\u0009do var_.refVar :: false\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, pos)\n\u0009\u0009\u0009\u0009do type.kind :: %int_\n\u0009\u0009\u0009\u0009do var_.type :: type\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do var_.expr :: null\n\u0009\u0009\u0009do try_.blockVar :: var_\n\u0009\u0009end block\n\u0009\u0009block\n\u0009\u0009\u0009var block_: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009\u0009\u0009do @initAst(block_, %statBlock, pos)\n\u0009\u0009\u0009do block_.name :: \"$\"\n\u0009\u0009\u0009do block_.blockVar :: null\n\u0009\u0009\u0009do block_.stats :: #list<\\ast@AstStat>\n\u0009\u0009\u0009do try_.statBlock :: block_\n\u0009\u0009end block\n\u0009\u0009do try_.catches :: #list<\\ast@AstStatCatch>\n\u0009\u0009block\n\u0009\u0009\u0009var block_: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009\u0009\u0009do @initAst(block_, %statBlock, pos)\n\u0009\u0009\u0009do block_.name :: \"$\"\n\u0009\u0009\u0009do block_.blockVar :: null\n\u0009\u0009\u0009do block_.stats :: #list<\\ast@AstStat>\n\u0009\u0009\u0009do try_.finallyStatBlock :: block_\n\u0009\u0009end block\n\u0009\u0009block\n\u0009\u0009\u0009; Make the program to call \'init\' and \'main\'.\n\u0009\u0009\u0009var funcs: list<\\ast@Ast> :: #list<\\ast@Ast>\n\u0009\u0009\u0009do funcs.add(@searchStdItem(\"kuin\", \"_init\", false))\n\u0009\u0009\u0009do funcs.add(@searchStdItem(\"kuin\", \"_initVars\", false))\n\u0009\u0009\u0009do funcs.add(mainFunc)\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009do funcs.head()\n\u0009\u0009\u0009\u0009while(!funcs.term())\n\u0009\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, pos)\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var call: \\ast@AstExprCall :: #\\ast@AstExprCall\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(call, %exprCall, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do call.args :: #list<\\ast@AstExprCallArg>\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref, %exprRef, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ref.refItem :: funcs.get()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do call.func_ :: ref\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do do_.expr :: call\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do try_.statBlock.stats.add(do_)\n\u0009\u0009\u0009\u0009\u0009do funcs.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end block\n\u0009\u0009end block\n\u0009\u0009block\n\u0009\u0009\u0009var catch_: \\ast@AstStatCatch :: #\\ast@AstStatCatch\n\u0009\u0009\u0009do @initAst(catch_, %statCatch, pos)\n\u0009\u0009\u0009do catch_.conds :: #list<\\ast@ExprPair>\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var block_: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009\u0009\u0009\u0009do @initAst(block_, %statBlock, pos)\n\u0009\u0009\u0009\u0009do block_.name :: \"$\"\n\u0009\u0009\u0009\u0009do block_.blockVar :: null\n\u0009\u0009\u0009\u0009do block_.stats :: #list<\\ast@AstStat>\n\u0009\u0009\u0009\u0009do catch_.statBlock :: block_\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: #\\ast@ExprPair\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, pos)\n\u0009\u0009\u0009\u0009\u0009do expr.varKind :: %value\n\u0009\u0009\u0009\u0009\u0009do expr.value :: 0b64\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.kind :: %int_\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do exprs.expr0 :: expr\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, pos)\n\u0009\u0009\u0009\u0009\u0009do expr.varKind :: %value\n\u0009\u0009\u0009\u0009\u0009do expr.value :: 0xFFFFFFFFb64\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.kind :: %int_\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do exprs.expr1 :: expr\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do catch_.conds.add(exprs)\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009; Make the program to call \'err\'.\n\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var call: \\ast@AstExprCall :: #\\ast@AstExprCall\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(call, %exprCall, pos)\n\u0009\u0009\u0009\u0009\u0009do call.args :: #list<\\ast@AstExprCallArg>\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var ref_: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref_, %exprRef, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do ref_.refItem :: @searchStdItem(\"kuin\", \"_err\", false)\n\u0009\u0009\u0009\u0009\u0009\u0009do call.func_ :: ref_\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var excpt: \\ast@AstExprCallArg :: #\\ast@AstExprCallArg\n\u0009\u0009\u0009\u0009\u0009\u0009do excpt.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009do excpt.skipVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var ref_: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref_, %exprRef, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ref_.refItem :: try_.blockVar\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do excpt.arg :: ref_\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do call.args.add(excpt)\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do do_.expr :: call\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do catch_.statBlock.stats.add(do_)\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do try_.catches.add(catch_)\n\u0009\u0009end block\n\u0009\u0009block\n\u0009\u0009\u0009; Make the program to call \'fin\'.\n\u0009\u0009\u0009var funcs: list<\\ast@Ast> :: #list<\\ast@Ast>\n\u0009\u0009\u0009do funcs.add(@searchStdItem(\"kuin\", \"_finVars\", false))\n\u0009\u0009\u0009do funcs.add(@searchStdItem(\"kuin\", \"_fin\", false))\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009do funcs.head()\n\u0009\u0009\u0009\u0009while(!funcs.term())\n\u0009\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, pos)\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var call: \\ast@AstExprCall :: #\\ast@AstExprCall\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(call, %exprCall, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do call.args :: #list<\\ast@AstExprCallArg>\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref, %exprRef, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ref.refItem :: funcs.get()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do call.func_ :: ref\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do do_.expr :: call\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do try_.finallyStatBlock.stats.add(do_)\n\u0009\u0009\u0009\u0009\u0009do funcs.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end block\n\u0009\u0009end block\n\u0009\u0009do entry.stats.add(try_)\n\u0009end block\n\u0009ret entry\nend func\n\nfunc rebuildRoot(key: []char, value: \\ast@Ast, data: kuin@Class): bool\n\u0009var ast: \\ast@AstRoot :: value $ \\ast@AstRoot\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret true\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009; Initialize and finalize global variables of each source file.\n\u0009var initVarsFunc: \\ast@AstFunc :: @searchStdItem(\"kuin\", \"_initVars\", false) $ \\ast@AstFunc\n\u0009var finVarsFunc: \\ast@AstFunc :: @searchStdItem(\"kuin\", \"_finVars\", false) $ \\ast@AstFunc\n\u0009var items: list<\\ast@Ast> :: ast.items\n\u0009do items.head()\n\u0009while(!items.term())\n\u0009\u0009var item: \\ast@Ast :: items.get()\n\u0009\u0009if(item.typeId = %func_)\n\u0009\u0009\u0009do @rebuildFunc(item $ \\ast@AstFunc)\n\u0009\u0009elif(item.typeId = %var_)\n\u0009\u0009\u0009var var_: \\ast@AstVar :: item $ \\ast@AstVar\n\u0009\u0009\u0009assert var_.arg.kind = %global\n\u0009\u0009\u0009if(var_.arg.expr <>& null)\n\u0009\u0009\u0009\u0009; Add initialization processing of global variables to \'_initVars\'.\n\u0009\u0009\u0009\u0009do var_.arg.expr :: @rebuildExpr(var_.arg.expr, false)\n\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var assign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(assign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do assign.kind :: %assign\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do ref.type :: var_.arg.type\n\u0009\u0009\u0009\u0009\u0009\u0009do ref.refItem :: var_.arg\n\u0009\u0009\u0009\u0009\u0009\u0009do assign.children0 :: ref\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do assign.children1 :: var_.arg.expr\n\u0009\u0009\u0009\u0009\u0009do do_.expr :: assign\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do initVarsFunc.stats.add(@rebuildStat(do_, null, null))\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(var_.arg.type <>& null & \\ast@isRef(var_.arg.type))\n\u0009\u0009\u0009\u0009; Add finalization processing of global variables to \'_finVars\'.\n\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var assign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(assign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do assign.kind :: %assign\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do ref.type :: var_.arg.type\n\u0009\u0009\u0009\u0009\u0009\u0009do ref.refItem :: var_.arg\n\u0009\u0009\u0009\u0009\u0009\u0009do assign.children0 :: ref\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do assign.children1 :: @makeExprNull(ast.pos)\n\u0009\u0009\u0009\u0009\u0009do do_.expr :: assign\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do finVarsFunc.stats.add(@rebuildStat(do_, null, null))\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009assert item.typeId = %const_ | item.typeId = %alias_ | item.typeId = %class_ | item.typeId = %enum_\n\u0009\u0009end if\n\u0009\u0009do items.next()\n\u0009end while\n\u0009ret true\nend func\n\nfunc rebuildFunc(ast: \\ast@AstFunc)\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009var items: list<\\ast@AstArg> :: ast.args\n\u0009do items.head()\n\u0009while(!items.term())\n\u0009\u0009do @rebuildArg(items.get())\n\u0009\u0009do items.next()\n\u0009end while\n\u0009\n\u0009if(ast.ret_ <>& null)\n\u0009\u0009do ast.ret_ :: @rebuildType(ast.ret_, null)\n\u0009end if\n\u0009do ast.stats :: @refreshStats(ast.stats, ast.ret_, ast)\nend func\n\nfunc rebuildVar(ast: \\ast@AstVar)\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do @rebuildArg(ast.arg)\nend func\n\nfunc rebuildAlias(ast: \\ast@AstAlias, parent: \\ast@AstAlias)\n\u0009; Make sure that the enum references do not circulate.\n\u0009if(ast =& parent)\n\u0009\u0009do \\err@err(%circulatingAlias, parent.pos, [parent.name])\n\u0009\u0009do ast.type :: null\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.type :: @rebuildType(ast.type, ast)\nend func\n\nfunc rebuildClass(ast: \\ast@AstClass)\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009var dtor: \\ast@AstFunc :: null\n\u0009var copy: \\ast@AstFunc :: null\n\u0009var toBin: \\ast@AstFunc :: null\n\u0009var fromBin: \\ast@AstFunc :: null\n\u0009do process1(ast, &dtor, &copy, &toBin, &fromBin)\n\u0009do process2(ast, dtor, copy, toBin, fromBin)\n\u0009do @rebuildFunc(dtor)\n\u0009do @rebuildFunc(copy)\n\u0009do @rebuildFunc(toBin)\n\u0009do @rebuildFunc(fromBin)\n\u0009\n\u0009func process1(ast: \\ast@AstClass, dtor: &\\ast@AstFunc, copy: &\\ast@AstFunc, toBin: &\\ast@AstFunc, fromBin: &\\ast@AstFunc)\n\u0009\u0009if(ast.refItem <>& null)\n\u0009\u0009\u0009var parent: \\ast@Ast :: ast.refItem\n\u0009\u0009\u0009if(parent.typeId = %alias_)\n\u0009\u0009\u0009\u0009do @rebuildAlias(parent $ \\ast@AstAlias, null)\n\u0009\u0009\u0009\u0009do ast.refItem :: (parent $ \\ast@AstAlias).type.refItem\n\u0009\u0009\u0009\u0009assert ast.refItem.typeId = %class_\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009assert parent.typeId = %class_\n\u0009\u0009\u0009\u0009do @rebuildClass(parent $ \\ast@AstClass)\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009block\n\u0009\u0009\u0009; Make sure that the class references do not circulate.\n\u0009\u0009\u0009var parent: \\ast@AstClass :: ast\n\u0009\u0009\u0009var chk: dict<\\ast@AstClass, bool> :: #dict<\\ast@AstClass, bool>\n\u0009\u0009\u0009while(parent <>& null)\n\u0009\u0009\u0009\u0009if(chk.get(parent, &))\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%circulatingClass, ast.pos, [ast.name])\n\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do chk.add(parent, true)\n\u0009\u0009\u0009\u0009do parent :: parent.refItem $ \\ast@AstClass\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009\n\u0009\u0009block\n\u0009\u0009\u0009var astItems: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009\u0009do astItems.head()\n\u0009\u0009\u0009while(!astItems.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: astItems.get()\n\u0009\u0009\u0009\u0009var memberName: []char\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var def: \\ast@Ast :: item.def\n\u0009\u0009\u0009\u0009\u0009if(def.typeId = %var_)\n\u0009\u0009\u0009\u0009\u0009\u0009do memberName :: (def $ \\ast@AstVar).arg.name\n\u0009\u0009\u0009\u0009\u0009elif(def.typeId = %const_)\n\u0009\u0009\u0009\u0009\u0009\u0009do memberName :: (def $ \\ast@AstConst).arg.name\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do memberName :: def.name\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009; Check whether functions are overriding another.\n\u0009\u0009\u0009\u0009var parentItem: \\ast@AstClassItem :: null\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var parent: \\ast@AstClass :: ast.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009\u0009while(parentItem =& null & parent <>& null)\n\u0009\u0009\u0009\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: parent.items\n\u0009\u0009\u0009\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var parentName: []char\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var item2: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var def: \\ast@Ast :: item2.def\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(def.typeId = %var_)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do parentName :: (def $ \\ast@AstVar).arg.name\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009elif(def.typeId = %const_)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do parentName :: (def $ \\ast@AstConst).arg.name\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do parentName :: def.name\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(memberName = parentName)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do parentItem :: item2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009\u0009do parent :: parent.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009if(parentItem =& null)\n\u0009\u0009\u0009\u0009\u0009if(item.override)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%overridedMemberNotFound, item.def.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009if(!item.override)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%memberDuplicatedWithParentClass, item.def.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(!(item.def.typeId = %func_ & parentItem.def.typeId = %func_))\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%overridingNonFunc, item.def.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(item.public <> parentItem.public)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%overriddenMemberNotMatchAccessModifier, item.def.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009var func1: \\ast@AstFunc :: item.def $ \\ast@AstFunc\n\u0009\u0009\u0009\u0009\u0009var func2: \\ast@AstFunc :: parentItem.def $ \\ast@AstFunc\n\u0009\u0009\u0009\u0009\u0009if(func1.ret_ =& null & func2.ret_ <>& null |\n\u0009\u0009\u0009\u0009\u0009\u0009|func1.ret_ <>& null & func2.ret_ =& null |\n\u0009\u0009\u0009\u0009\u0009\u0009|func1.ret_ <>& null & func2.ret_ <>& null & !@cmpType(func1.ret_, func2.ret_, false) |\n\u0009\u0009\u0009\u0009\u0009\u0009|^func1.args <> ^func2.args)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%overriddenMemberNotMatchTypeOrArg, item.def.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009var items1: list<\\ast@AstArg> :: func1.args\n\u0009\u0009\u0009\u0009\u0009var items2: list<\\ast@AstArg> :: func2.args\n\u0009\u0009\u0009\u0009\u0009do items1.head()\n\u0009\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009\u0009for i(0, ^items1 - 1)\n\u0009\u0009\u0009\u0009\u0009\u0009var arg1: \\ast@AstArg :: items1.get()\n\u0009\u0009\u0009\u0009\u0009\u0009var arg2: \\ast@AstArg :: items2.get()\n\u0009\u0009\u0009\u0009\u0009\u0009if(arg1.type.typeId = %typeUser & arg1.type.refItem =& null |\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009|arg2.type.typeId = %typeUser & arg2.type.refItem =& null |\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009|!@cmpType(arg1.type, arg2.type, false) |\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009|arg1.name <>& null & arg2.name <>& null & arg1.name <> arg2.name |\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009|arg1.refVar <> arg2.refVar)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%overriddenMemberNotMatchTypeOrArg, item.def.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do items1.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009\u0009end for\n\u0009\u0009\u0009\u0009\u0009do item.parentItem :: parentItem\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009switch(memberName)\n\u0009\u0009\u0009\u0009case \"_dtor\", \"_copy\", \"_toBin\", \"_fromBin\"\n\u0009\u0009\u0009\u0009\u0009assert item.def.typeId = %func_\n\u0009\u0009\u0009\u0009\u0009var func_: \\ast@AstFunc :: item.def $ \\ast@AstFunc\n\u0009\u0009\u0009\u0009\u0009if(item.override & (item.def $ \\ast@AstFunc).funcOption.and(%frc) = %none)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%notAllowedToBeOverridden, func_.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009switch(memberName[1])\n\u0009\u0009\u0009\u0009\u0009case \'d\'\n\u0009\u0009\u0009\u0009\u0009\u0009do dtor :: func_\n\u0009\u0009\u0009\u0009\u0009case \'c\'\n\u0009\u0009\u0009\u0009\u0009\u0009do copy :: func_\n\u0009\u0009\u0009\u0009\u0009case \'t\'\n\u0009\u0009\u0009\u0009\u0009\u0009do toBin :: func_\n\u0009\u0009\u0009\u0009\u0009case \'f\'\n\u0009\u0009\u0009\u0009\u0009\u0009do fromBin :: func_\n\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009; Skip \'RebuildFunc\' to add the contents later.\n\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009; Analyze functions and variables in classes because they can be referred to as instances.\n\u0009\u0009\u0009\u0009\u0009var def: \\ast@Ast :: item.def\n\u0009\u0009\u0009\u0009\u0009if(def.typeId = %func_)\n\u0009\u0009\u0009\u0009\u0009\u0009var idx: int :: astItems.idx()\n\u0009\u0009\u0009\u0009\u0009\u0009assert idx <> -1\n\u0009\u0009\u0009\u0009\u0009\u0009do @rebuildFunc(def $ \\ast@AstFunc)\n\u0009\u0009\u0009\u0009\u0009\u0009do astItems.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do astItems.moveOffset(idx)\n\u0009\u0009\u0009\u0009\u0009elif(def.typeId = %var_)\n\u0009\u0009\u0009\u0009\u0009\u0009do @rebuildVar(def $ \\ast@AstVar)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009do astItems.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009\n\u0009\u0009\u0009; Get \'me\' of special functions.\n\u0009\u0009\u0009if(dtor =& null)\n\u0009\u0009\u0009\u0009do dtor :: @addSpecialFunc(ast, \"_dtor\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(copy =& null)\n\u0009\u0009\u0009\u0009do copy :: @addSpecialFunc(ast, \"_copy\")\n\u0009\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009\u0009do @initAst(type, %typeUser, ast.pos)\n\u0009\u0009\u0009\u0009do type.refItem :: ast\n\u0009\u0009\u0009\u0009do copy.ret_ :: type\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(toBin =& null)\n\u0009\u0009\u0009\u0009do toBin :: @addSpecialFunc(ast, \"_toBin\")\n\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var type2: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009\u0009\u0009\u0009do @initAst(type2, %typeBit, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do type2.size :: 1\n\u0009\u0009\u0009\u0009\u0009do type.itemType :: type2\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do toBin.ret_ :: type\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(fromBin =& null)\n\u0009\u0009\u0009\u0009do fromBin :: @addSpecialFunc(ast, \"_fromBin\")\n\u0009\u0009\u0009\u0009; \'bin\'.\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009\u0009\u0009do @initAst(arg, %arg, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do arg.kind :: %localArg\n\u0009\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009\u0009do arg.expr :: null\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var type2: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type2, %typeBit, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type2.size :: 1\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type.itemType :: type2\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do fromBin.args.add(arg)\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009; \'idx\'.\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009\u0009\u0009do @initAst(arg, %arg, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do arg.kind :: %localArg\n\u0009\u0009\u0009\u0009\u0009do arg.refVar :: true\n\u0009\u0009\u0009\u0009\u0009do arg.expr :: null\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.kind :: %int_\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do fromBin.args.add(arg)\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do fromBin.args.head()\n\u0009\u0009\u0009\u0009do fromBin.ret_ :: fromBin.args.get().type\n\u0009\u0009\u0009end if\n\u0009\u0009end block\n\u0009end func\n\u0009\n\u0009func process2(ast: \\ast@AstClass, dtor: \\ast@AstFunc, copy: \\ast@AstFunc, toBin: \\ast@AstFunc, fromBin: \\ast@AstFunc)\n\u0009\u0009; The \'_dtor\' function.\n\u0009\u0009block\n\u0009\u0009\u0009var ptr: \\ast@AstClass :: ast\n\u0009\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: ptr.items\n\u0009\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009\u0009if(item.def.typeId = %var_ & \\ast@isRef((item.def $ \\ast@AstVar).arg.type))\n\u0009\u0009\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var assign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(assign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.kind :: %assign\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dtor.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children0 :: @makeMeDot(ast, dtor.args.get(), (item.def $ \\ast@AstVar).arg.name)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children1 :: @makeExprNull(ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do do_.expr :: assign\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do dtor.stats.add(@rebuildStat(do_, dtor.ret_, dtor))\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009\n\u0009\u0009; The \'_copy\' function.\n\u0009\u0009block\n\u0009\u0009\u0009var result: \\ast@AstExpr\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var var_: \\ast@AstStatVar :: #\\ast@AstStatVar\n\u0009\u0009\u0009\u0009do @initAst(var_, %statVar, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var var2: \\ast@AstVar :: #\\ast@AstVar\n\u0009\u0009\u0009\u0009\u0009do @initAst(var2, %var_, ast.pos)\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(arg, %arg, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.kind :: %localVar\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeUser, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type.refItem :: ast\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.type :: type\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var new_: \\ast@AstExprNew :: #\\ast@AstExprNew\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(new_, %exprNew, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do new_.itemType :: arg.type\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.expr :: new_\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do var2.arg :: arg\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do var_.def :: var2\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do copy.stats.add(@rebuildStat(var_, copy.ret_, copy))\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009do result :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(result, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do result.refName :: \"me\"\n\u0009\u0009\u0009\u0009\u0009do result.refItem :: var_.def.arg\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeUser, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.refItem :: ast\n\u0009\u0009\u0009\u0009\u0009\u0009do result.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var ptr: \\ast@AstClass :: ast\n\u0009\u0009\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: ptr.items\n\u0009\u0009\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009\u0009\u0009if(item.def.typeId = %var_)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var member: \\ast@AstArg :: (item.def $ \\ast@AstVar).arg\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var assign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(assign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.kind :: %assign\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var dot: \\ast@AstExprDot :: #\\ast@AstExprDot\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(dot, %exprDot, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.var_ :: result\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.member :: member.name\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.classItem :: null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children0 :: dot\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(\\ast@isRef(member.type))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var copy2: \\ast@AstExpr1 :: #\\ast@AstExpr1\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(copy2, %expr1, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do copy2.kind :: %copy\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do copy.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do copy2.child :: @makeMeDot(ast, copy.args.get(), member.name)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children1 :: copy2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do copy.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children1 :: @makeMeDot(ast, copy.args.get(), member.name)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do do_.expr :: assign\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do copy.stats.add(@rebuildStat(do_, copy.ret_, copy))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var ret_: \\ast@AstStatRet :: #\\ast@AstStatRet\n\u0009\u0009\u0009\u0009do @initAst(ret_, %statRet, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var as: \\ast@AstExprAs :: #\\ast@AstExprAs\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(as, %exprAs, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do as.kind :: %as\n\u0009\u0009\u0009\u0009\u0009do as.child :: result\n\u0009\u0009\u0009\u0009\u0009do as.childType :: copy.ret_\n\u0009\u0009\u0009\u0009\u0009do ret_.value :: as\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do copy.stats.add(@rebuildStat(ret_, copy.ret_, copy))\n\u0009\u0009\u0009end block\n\u0009\u0009end block\n\u0009\u0009\n\u0009\u0009; The \'_toBin\' function.\n\u0009\u0009block\n\u0009\u0009\u0009var result: \\ast@AstExpr\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var var_: \\ast@AstStatVar :: #\\ast@AstStatVar\n\u0009\u0009\u0009\u0009do @initAst(var_, %statVar, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var var2: \\ast@AstVar :: #\\ast@AstVar\n\u0009\u0009\u0009\u0009\u0009do @initAst(var2, %var_, ast.pos)\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(arg, %arg, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.kind :: %localVar\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var new_: \\ast@AstExprNewArray :: #\\ast@AstExprNewArray\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(new_, %exprNewArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do new_.idces :: #list<\\ast@AstExpr>\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var value: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(value, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value.value :: 8b64\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var prim: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(prim, %typePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do prim.kind :: %int_\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value.type :: prim\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do new_.idces.add(value)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeBit, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type.size :: 1\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do new_.itemType :: type\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.expr :: new_\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var type2: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type2, %typeBit, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type2.size :: 1\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type.itemType :: type2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.type :: type\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do var2.arg :: arg\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do var_.def :: var2\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do toBin.stats.add(@rebuildStat(var_, toBin.ret_, toBin))\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009do result :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(result, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do result.refItem :: var_.def.arg\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeUser, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.refItem :: ast\n\u0009\u0009\u0009\u0009\u0009\u0009do result.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var ptr: \\ast@AstClass :: ast\n\u0009\u0009\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: ptr.items\n\u0009\u0009\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009\u0009\u0009if(item.def.typeId = %var_)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var member: \\ast@AstArg :: (item.def $ \\ast@AstVar).arg\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var assign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(assign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.kind :: %assignCat\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children0 :: result\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprToBin :: #\\ast@AstExprToBin\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprToBin, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do toBin.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.child :: @makeMeDot(ast, toBin.args.get(), member.name)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var array_: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(array_, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var bit: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(bit, %typeBit, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do bit.size :: 1\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do array_.itemType :: bit\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.childType :: array_\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children1 :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do do_.expr :: assign\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do toBin.stats.add(@rebuildStat(do_, toBin.ret_, toBin))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var ret_: \\ast@AstStatRet :: #\\ast@AstStatRet\n\u0009\u0009\u0009\u0009do @initAst(ret_, %statRet, ast.pos)\n\u0009\u0009\u0009\u0009do ret_.value :: result\n\u0009\u0009\u0009\u0009do toBin.stats.add(@rebuildStat(ret_, toBin.ret_, toBin))\n\u0009\u0009\u0009end block\n\u0009\u0009end block\n\u0009\u0009\n\u0009\u0009; The \'_fromBin\' function.\n\u0009\u0009block\n\u0009\u0009\u0009var result: \\ast@AstExpr\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var var_: \\ast@AstStatVar :: #\\ast@AstStatVar\n\u0009\u0009\u0009\u0009do @initAst(var_, %statVar, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var var2: \\ast@AstVar :: #\\ast@AstVar\n\u0009\u0009\u0009\u0009\u0009do @initAst(var2, %var_, ast.pos)\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(arg, %arg, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.kind :: %localVar\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.type :: fromBin.args.get().type\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var new_: \\ast@AstExprNew :: #\\ast@AstExprNew\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(new_, %exprNew, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do new_.itemType :: arg.type\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.expr :: new_\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do var2.arg :: arg\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do var_.def :: var2\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do fromBin.stats.add(@rebuildStat(var_, fromBin.ret_, fromBin))\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009do result :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(result, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do result.refItem :: var_.def.arg\n\u0009\u0009\u0009\u0009\u0009do result.refName :: \"me\" {In fact, the referenced member name is not \'me\', but it needs to be set to \'me\' to access private members.}\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeUser, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.refItem :: ast\n\u0009\u0009\u0009\u0009\u0009\u0009do result.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var ptr: \\ast@AstClass :: ast\n\u0009\u0009\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: ptr.items\n\u0009\u0009\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009\u0009\u0009if(item.def.typeId = %var_)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var member: \\ast@AstArg :: (item.def $ \\ast@AstVar).arg\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var assign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(assign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.kind :: %assign\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var dot: \\ast@AstExprDot :: #\\ast@AstExprDot\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(dot, %exprDot, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.classItem :: null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.var_ :: result\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.member :: member.name\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children0 :: dot\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprFromBin :: #\\ast@AstExprFromBin\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprFromBin, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ref.refItem :: fromBin.args.get()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert ref.refItem <>& null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.child :: ref\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.childType :: member.type\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ref.refItem :: fromBin.args.get()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert ref.refItem <>& null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.offset :: ref\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children1 :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do do_.expr :: assign\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.stats.add(@rebuildStat(do_, fromBin.ret_, fromBin))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var ret_: \\ast@AstStatRet :: #\\ast@AstStatRet\n\u0009\u0009\u0009\u0009do @initAst(ret_, %statRet, ast.pos)\n\u0009\u0009\u0009\u0009do ret_.value :: result\n\u0009\u0009\u0009\u0009do fromBin.stats.add(@rebuildStat(ret_, fromBin.ret_, fromBin))\n\u0009\u0009\u0009end block\n\u0009\u0009end block\n\u0009end func\nend func\n\nfunc rebuildEnum(ast: \\ast@AstEnum)\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009do @initAst(type, %typeUser, ast.pos)\n\u0009do type.extra :: type\n\u0009do type.refItem :: ast\n\u0009\n\u0009; Assign values to items.\n\u0009var defaultNum: int :: -1\n\u0009var enumValues: dict<int, bool> :: #dict<int, bool>\n\u0009var items: list<\\ast@AstExpr> :: ast.items\n\u0009do items.head()\n\u0009while loop(!items.term())\n\u0009\u0009var item: \\ast@AstExpr :: items.get()\n\u0009\u0009var itemName: []char :: item.name\n\u0009\u0009do item :: @rebuildExpr(item, item.type =& null)\n\u0009\u0009if(item =& null)\n\u0009\u0009\u0009skip loop\n\u0009\u0009end if\n\u0009\u0009do item.name :: itemName\n\u0009\u0009do items.ins(item)\n\u0009\u0009do items.del()\n\u0009\u0009if(item.typeId <> %exprValuePrim | item.type <>& null & !\\ast@isInt(item.type))\n\u0009\u0009\u0009do \\err@err(%enumValueMustBeInt, ast.pos, [ast.name, item.name])\n\u0009\u0009\u0009ret\n\u0009\u0009end if\n\u0009\u0009var item2: \\ast@AstExprValuePrim :: item $ \\ast@AstExprValuePrim\n\u0009\u0009if(item.type =& null)\n\u0009\u0009\u0009; \'type\' is \'null\' when the value is not set.\n\u0009\u0009\u0009if(defaultNum = lib@intMax)\n\u0009\u0009\u0009\u0009do \\err@err(%enumValueExceedIntRange, ast.pos, [ast.name, item.name])\n\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do defaultNum :+ 1\n\u0009\u0009\u0009do item2.value :: defaultNum $ bit64\n\u0009\u0009else\n\u0009\u0009\u0009do defaultNum :: item2.value $ int\n\u0009\u0009end if\n\u0009\u0009block\n\u0009\u0009\u0009var value: int :: item2.value $ int\n\u0009\u0009\u0009if(enumValues.get(value, &))\n\u0009\u0009\u0009\u0009do \\err@err(%enumValueDuplicated, ast.pos, [ast.name, item.name, value.toStr()])\n\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do enumValues.add(value, true)\n\u0009\u0009end block\n\u0009\u0009do item.type :: type {Cast values of \'int\' to \'enum\' so as not to being treated as \'int\'.}\n\u0009\u0009; The item was already deleted so do not do \'do items.next()\'.\n\u0009end while\nend func\n\nfunc rebuildEnumElement(enumElement: \\ast@AstExpr, type: \\ast@AstType): \\ast@AstExprValuePrim\n\u0009assert enumElement.typeId = %exprValueEnumElement\n\u0009assert \\ast@isEnum(type)\n\u0009var enumElement2: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009do @initAstExpr(enumElement2, %exprValuePrim, enumElement.pos)\n\u0009do enumElement2.value :: @searchEnumElementValue(enumElement $ \\ast@AstExprValueEnumElement, type.refItem $ \\ast@AstEnum)\n\u0009do enumElement2.type :: type\n\u0009do enumElement2 :: @rebuildExprValuePrim(enumElement2) $ \\ast@AstExprValuePrim\n\u0009ret enumElement2\nend func\n\nfunc rebuildArg(ast: \\ast@AstArg)\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.type :: @rebuildType(ast.type, null)\n\u0009if(ast.expr <>& null)\n\u0009\u0009do ast.expr :: @rebuildExpr(ast.expr, false)\n\u0009\u0009if(ast.expr =& null)\n\u0009\u0009\u0009ret\n\u0009\u0009end if\n\u0009\u0009if(ast.kind = %global & ast.expr.typeId.and(%exprValue) <> %exprValue)\n\u0009\u0009\u0009do \\err@err(%valueOfGlobalVarMustBeConst, ast.pos, [ast.name])\n\u0009\u0009end if\n\u0009\u0009if(ast.kind = %const_ & ast.expr.typeId.and(%exprValue) <> %exprValue)\n\u0009\u0009\u0009do \\err@err(%valueOfConstMustBeConst, ast.pos, [ast.name])\n\u0009\u0009end if\n\u0009\u0009if(!@cmpType(ast.expr.type, ast.type, false))\n\u0009\u0009\u0009do \\err@err(%varAndValueTypeNotMatch, ast.pos, [ast.name])\n\u0009\u0009elif(ast.expr.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009do ast.expr :: @rebuildEnumElement(ast.expr, ast.type)\n\u0009\u0009end if\n\u0009end if\nend func\n\nfunc rebuildStat(ast: \\ast@AstStat, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009switch(ast.typeId)\n\u0009case %statFunc, %statConst, %statAlias, %statClass, %statEnum\n\u0009\u0009ret null\n\u0009case %statVar\n\u0009\u0009var ast2: \\ast@AstStatVar :: ast $ \\ast@AstStatVar\n\u0009\u0009do @rebuildVar(ast2.def)\n\u0009\u0009var arg: \\ast@AstArg :: ast2.def.arg\n\u0009\u0009if(arg.name <>& null & arg.name = \"super\")\n\u0009\u0009\u0009assert parentFunc <>& null & parentFunc.name <>& null\n\u0009\u0009\u0009assert arg.type.typeId = %typeFunc\n\u0009\u0009\u0009var args: list<\\ast@AstTypeFuncArg> :: (arg.type $ \\ast@AstTypeFunc).args\n\u0009\u0009\u0009do args.head()\n\u0009\u0009\u0009var refClass: \\ast@AstClass :: args.get().arg.refItem $ \\ast@AstClass\n\u0009\u0009\u0009assert refClass.typeId = %class_\n\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: refClass.items\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while loop(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009if(item.def.name <>& null & item.def.name = parentFunc.name)\n\u0009\u0009\u0009\u0009\u0009assert item.override\n\u0009\u0009\u0009\u0009\u0009var astRef: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(astRef, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do astRef.refItem :: item.parentItem.def\n\u0009\u0009\u0009\u0009\u0009do arg.expr :: astRef\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009assert !items.term()\n\u0009\u0009end if\n\u0009\u0009if(arg.expr =& null)\n\u0009\u0009\u0009do arg.expr :: @makeExprDefaultValue(arg.type, arg.pos) $ \\ast@AstExpr\n\u0009\u0009end if\n\u0009\u0009block\n\u0009\u0009\u0009; Replace initializers with assignment operators.\n\u0009\u0009\u0009var astDo: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009do @initAst(astDo, %statDo, ast.pos)\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var astAssign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009do @initAstExpr(astAssign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009do astAssign.kind :: %assign\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var astRef: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(astRef, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do astRef.refItem :: arg\n\u0009\u0009\u0009\u0009\u0009do astAssign.children0 :: astRef\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do astAssign.children1 :: arg.expr\n\u0009\u0009\u0009\u0009do astDo.expr :: astAssign\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do arg.expr :: null\n\u0009\u0009\u0009do ast :: @rebuildStat(astDo, retType, parentFunc)\n\u0009\u0009end block\n\u0009case %statIf\n\u0009\u0009do ast :: @rebuildIf(ast $ \\ast@AstStatIf, retType, parentFunc)\n\u0009case %statSwitch\n\u0009\u0009do ast :: @rebuildSwitch(ast $ \\ast@AstStatSwitch, retType, parentFunc)\n\u0009case %statWhile\n\u0009\u0009do ast :: @rebuildWhile(ast $ \\ast@AstStatWhile, retType, parentFunc)\n\u0009case %statFor\n\u0009\u0009do ast :: @rebuildFor(ast $ \\ast@AstStatFor, retType, parentFunc)\n\u0009case %statTry\n\u0009\u0009do ast :: @rebuildTry(ast $ \\ast@AstStatTry, retType, parentFunc)\n\u0009case %statThrow\n\u0009\u0009do ast :: @rebuildThrow(ast $ \\ast@AstStatThrow)\n\u0009case %statBlock\n\u0009\u0009do ast :: @rebuildBlock(ast $ \\ast@AstStatBlock, retType, parentFunc)\n\u0009case %statRet\n\u0009\u0009do ast :: @rebuildRet(ast $ \\ast@AstStatRet, retType)\n\u0009case %statDo\n\u0009\u0009do ast :: @rebuildDo(ast $ \\ast@AstStatDo)\n\u0009case %statBreak\n\u0009\u0009do ast :: @rebuildBreak(ast $ \\ast@AstStat, retType, parentFunc)\n\u0009case %statSkip\n\u0009\u0009do ast :: @rebuildSkip(ast $ \\ast@AstStat, retType, parentFunc)\n\u0009case %statAssert\n\u0009\u0009do ast :: @rebuildAssert(ast $ \\ast@AstStatAssert)\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\n\u0009if(ast =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009assert ast.extra <>& null\n\u0009ret ast\nend func\n\nfunc rebuildIf(ast: \\ast@AstStatIf, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.cond :: @rebuildExpr(ast.cond, false)\n\u0009if(ast.cond <>& null & !\\ast@isBool(ast.cond.type))\n\u0009\u0009do \\err@err(%ifCondMustBeBool, ast.cond.pos, null)\n\u0009end if\n\u0009do ast.statBlock :: @rebuildBlock(ast.statBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009block\n\u0009\u0009var items: list<\\ast@AstStatElIf> :: ast.elIfs\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var elIf: \\ast@AstStatElIf :: items.get()\n\u0009\u0009\u0009do elIf.cond :: @rebuildExpr(elIf.cond, false)\n\u0009\u0009\u0009if(elIf.cond <>& null & !\\ast@isBool(elIf.cond.type))\n\u0009\u0009\u0009\u0009do \\err@err(%elIfCondMustBeBool, elIf.cond.pos, null)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do elIf.statBlock :: @rebuildBlock(elIf.statBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009if(ast.elseStatBlock <>& null)\n\u0009\u0009do ast.elseStatBlock :: @rebuildBlock(ast.elseStatBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009end if\n\u0009if(ast.cond <>& null)\n\u0009\u0009; Optimize the code.\n\u0009\u0009var stats: \\ast@AstStatBlock :: null\n\u0009\u0009if(ast.cond.typeId <> %exprValuePrim)\n\u0009\u0009\u0009ret ast\n\u0009\u0009end if\n\u0009\u0009if((ast.cond $ \\ast@AstExprValuePrim).value <> 0b64)\n\u0009\u0009\u0009do stats :: ast.statBlock\n\u0009\u0009end if\n\u0009\u0009if(stats <>& null)\n\u0009\u0009\u0009var items: list<\\ast@AstStatElIf> :: ast.elIfs\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while loop(!items.term())\n\u0009\u0009\u0009\u0009var elIf: \\ast@AstStatElIf :: items.get()\n\u0009\u0009\u0009\u0009if(elIf.cond.typeId <> %exprValuePrim)\n\u0009\u0009\u0009\u0009\u0009ret ast\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if((elIf.cond $ \\ast@AstExprValuePrim).value <> 0b64)\n\u0009\u0009\u0009\u0009\u0009do stats :: elIf.statBlock\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009if(stats =& null)\n\u0009\u0009\u0009\u0009if(ast.elseStatBlock =& null)\n\u0009\u0009\u0009\u0009\u0009var block_: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009\u0009\u0009\u0009\u0009do @initAst(block_, %statBlock, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do block_.name :: \"$\"\n\u0009\u0009\u0009\u0009\u0009do block_.stats :: #list<\\ast@AstStat>\n\u0009\u0009\u0009\u0009\u0009do stats :: block_\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do stats :: ast.elseStatBlock\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009do ast.cond :: null\n\u0009\u0009do ast.statBlock :: stats\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildSwitch(ast: \\ast@AstStatSwitch, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.cond :: @rebuildExpr(ast.cond, false)\n\u0009if(ast.cond <>& null)\n\u0009\u0009if(!@isComparable(ast.cond.type, true))\n\u0009\u0009\u0009do \\err@err(%switchCondMustBeComparable, ast.cond.pos, null)\n\u0009\u0009end if\n\u0009\u0009do ast.blockVar.type :: ast.cond.type\n\u0009end if\n\u0009block\n\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var case_: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: case_.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009do exprs.expr0 :: @rebuildExpr(exprs.expr0, false)\n\u0009\u0009\u0009\u0009if(ast.cond <>& null & exprs.expr0 <>& null)\n\u0009\u0009\u0009\u0009\u0009if(!@cmpType(ast.cond.type, exprs.expr0.type, false))\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%caseCondNotMatchSwitch, exprs.expr0.pos, null)\n\u0009\u0009\u0009\u0009\u0009elif(exprs.expr0.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009do exprs.expr0 :: @rebuildEnumElement(exprs.expr0, ast.cond.type)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(exprs.expr1 <>& null)\n\u0009\u0009\u0009\u0009\u0009do exprs.expr1 :: @rebuildExpr(exprs.expr1, false)\n\u0009\u0009\u0009\u0009\u0009if(ast.cond <>& null & exprs.expr1 <>& null)\n\u0009\u0009\u0009\u0009\u0009\u0009if(!@cmpType(ast.cond.type, exprs.expr1.type, false))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%caseCondNotMatchSwitch, exprs.expr1.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009elif(exprs.expr1.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do exprs.expr1 :: @rebuildEnumElement(exprs.expr1, ast.cond.type)\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do case_.statBlock :: @rebuildBlock(case_.statBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009if(ast.defaultStatBlock <>& null)\n\u0009\u0009do ast.defaultStatBlock :: @rebuildBlock(ast.defaultStatBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildWhile(ast: \\ast@AstStatWhile, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009if(ast.cond <>& null)\n\u0009\u0009do ast.cond :: @rebuildExpr(ast.cond, false)\n\u0009\u0009if(ast.cond <>& null & !\\ast@isBool(ast.cond.type))\n\u0009\u0009\u0009do \\err@err(%whileCondMustBeBool, ast.cond.pos, null)\n\u0009\u0009end if\n\u0009end if\n\u0009do ast.stats :: @refreshStats(ast.stats, retType, parentFunc)\n\u0009ret ast\nend func\n\nfunc rebuildFor(ast: \\ast@AstStatFor, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.start :: @rebuildExpr(ast.start, false)\n\u0009if(ast.start <>& null)\n\u0009\u0009if(!\\ast@isInt(ast.start.type))\n\u0009\u0009\u0009do \\err@err(%forBeginValueMustBeInt, ast.start.pos, null)\n\u0009\u0009end if\n\u0009\u0009do ast.blockVar.type :: ast.start.type\n\u0009end if\n\u0009do ast.cond :: @rebuildExpr(ast.cond, false)\n\u0009if(ast.cond <>& null & !\\ast@isInt(ast.cond.type))\n\u0009\u0009do \\err@err(%forEndValueMustBeInt, ast.cond.pos, null)\n\u0009end if\n\u0009do ast.step :: @rebuildExpr(ast.step, false)\n\u0009if(ast.step <>& null)\n\u0009\u0009if(!\\ast@isInt(ast.step.type))\n\u0009\u0009\u0009do \\err@err(%forIncreaseDecreaseValueMustBeInt, ast.step.pos, null)\n\u0009\u0009end if\n\u0009\u0009if(ast.step.typeId <> %exprValuePrim)\n\u0009\u0009\u0009do \\err@err(%forIncreaseDecreaseValueMustBeConst, ast.step.pos, null)\n\u0009\u0009end if\n\u0009\u0009if((ast.step $ \\ast@AstExprValuePrim).value = 0b64)\n\u0009\u0009\u0009do \\err@err(%forIncreaseDecreaseValueMustBeOtherThanZero, ast.step.pos, null)\n\u0009\u0009end if\n\u0009end if\n\u0009do ast.stats :: @refreshStats(ast.stats, retType, parentFunc)\n\u0009ret ast\nend func\n\nfunc rebuildTry(ast: \\ast@AstStatTry, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do @rebuildArg(ast.blockVar)\n\u0009do ast.statBlock :: @rebuildBlock(ast.statBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009if(^ast.catches <> 0)\n\u0009\u0009var items: list<\\ast@AstStatCatch> :: ast.catches\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var catch_: \\ast@AstStatCatch :: items.get()\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: catch_.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009do exprs.expr0 :: @rebuildExpr(exprs.expr0, false)\n\u0009\u0009\u0009\u0009if(exprs.expr0 <>& null & (!\\ast@isInt(exprs.expr0.type) | exprs.expr0.typeId <> %exprValuePrim))\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%catchCondMustBeConstInt, exprs.expr0.pos, null)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(exprs.expr1 <>& null)\n\u0009\u0009\u0009\u0009\u0009do exprs.expr1 :: @rebuildExpr(exprs.expr1, false)\n\u0009\u0009\u0009\u0009\u0009if(exprs.expr1 <>& null & (!\\ast@isInt(exprs.expr1.type) | exprs.expr1.typeId <> %exprValuePrim))\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%catchCondMustBeConstInt, exprs.expr1.pos, null)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do catch_.statBlock :: @rebuildBlock(catch_.statBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end if\n\u0009if(ast.finallyStatBlock <>& null)\n\u0009\u0009do ast.finallyStatBlock :: @rebuildBlock(ast.finallyStatBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildThrow(ast: \\ast@AstStatThrow): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.code :: @rebuildExpr(ast.code, false)\n\u0009if(ast.code <>& null & !\\ast@isInt(ast.code.type))\n\u0009\u0009do \\err@err(%excptCodeMustBeInt, ast.code.pos, null)\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildBlock(ast: \\ast@AstStatBlock, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.stats :: @refreshStats(ast.stats, retType, parentFunc)\n\u0009ret ast\nend func\n\nfunc rebuildRet(ast: \\ast@AstStatRet, retType: \\ast@AstType): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009if(ast.value =& null)\n\u0009\u0009if(retType <>& null)\n\u0009\u0009\u0009do \\err@err(%mustRetValue, ast.pos, null)\n\u0009\u0009end if\n\u0009else\n\u0009\u0009do ast.value :: @rebuildExpr(ast.value, false)\n\u0009\u0009if(ast.value <>& null)\n\u0009\u0009\u0009if(retType =& null | !@cmpType(ast.value.type, retType, false))\n\u0009\u0009\u0009\u0009do \\err@err(%retTypeNotMatchFunc, ast.pos, null)\n\u0009\u0009\u0009elif(ast.value.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009do ast.value :: @rebuildEnumElement(ast.value, retType)\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildDo(ast: \\ast@AstStatDo): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009if(ast.expr <>& null & ast.expr.typeId = %expr2)\n\u0009\u0009; Replace all assignment operators that are not \'::\' with \'::\'\n\u0009\u0009var expr: \\ast@AstExpr2 :: ast.expr $ \\ast@AstExpr2\n\u0009\u0009var kind: \\ast@AstExpr2Kind :: %assign\n\u0009\u0009switch(expr.kind)\n\u0009\u0009case %assignAdd\n\u0009\u0009\u0009do kind :: %add\n\u0009\u0009case %assignSub\n\u0009\u0009\u0009do kind :: %sub\n\u0009\u0009case %assignMul\n\u0009\u0009\u0009do kind :: %mul\n\u0009\u0009case %assignDiv\n\u0009\u0009\u0009do kind :: %div\n\u0009\u0009case %assignMod\n\u0009\u0009\u0009do kind :: %mod\n\u0009\u0009case %assignPow\n\u0009\u0009\u0009do kind :: %pow\n\u0009\u0009case %assignCat\n\u0009\u0009\u0009do kind :: %cat\n\u0009\u0009end switch\n\u0009\u0009if(kind <> %assign)\n\u0009\u0009\u0009var block_: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009\u0009\u0009do @initAst(block_, %statBlock, ast.pos)\n\u0009\u0009\u0009do block_.extra :: block_\n\u0009\u0009\u0009do block_.name :: \"$\"\n\u0009\u0009\u0009do block_.blockVar :: null\n\u0009\u0009\u0009do block_.stats :: #list<\\ast@AstStat>\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var lhs: \\ast@AstExpr :: @rebuildExpr(expr.children0, false)\n\u0009\u0009\u0009\u0009if(lhs =& null)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(lhs.typeId = %exprDot)\n\u0009\u0009\u0009\u0009\u0009var lhs2: \\ast@AstExprDot :: lhs $ \\ast@AstExprDot\n\u0009\u0009\u0009\u0009\u0009do lhs2.var_ :: @cacheSubExpr(block_.stats, lhs2.var_, ast.pos)\n\u0009\u0009\u0009\u0009elif(lhs.typeId = %exprArray)\n\u0009\u0009\u0009\u0009\u0009var lhs2: \\ast@AstExprArray :: lhs $ \\ast@AstExprArray\n\u0009\u0009\u0009\u0009\u0009do lhs2.var_ :: @cacheSubExpr(block_.stats, lhs2.var_, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do lhs2.idx :: @cacheSubExpr(block_.stats, lhs2.idx, ast.pos)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009var exprAssign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009do @initAstExpr(exprAssign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009do exprAssign.kind :: %assign\n\u0009\u0009\u0009\u0009do exprAssign.children0 :: lhs\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var exprOne: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(exprOne, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do exprOne.kind :: kind\n\u0009\u0009\u0009\u0009\u0009do exprOne.children0 :: lhs\n\u0009\u0009\u0009\u0009\u0009do exprOne.children1 :: expr.children1\n\u0009\u0009\u0009\u0009\u0009do exprAssign.children1 :: exprOne\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do ast.expr :: @rebuildExpr(exprAssign, true)\n\u0009\u0009\u0009\u0009do block_.stats.add(ast)\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009ret block_\n\u0009\u0009end if\n\u0009end if\n\u0009do ast.expr :: @rebuildExpr(ast.expr, true)\n\u0009if(ast.expr =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009; \'do\' needs to end with side effects.\n\u0009if(!(ast.expr.typeId = %expr2 & ((ast.expr $ \\ast@AstExpr2).kind = %assign | (ast.expr $ \\ast@AstExpr2).kind = %swap) | ast.expr.typeId = %exprCall))\n\u0009\u0009do \\err@err(%noSideEffectDo, ast.expr.pos, null)\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildBreak(ast: \\ast@AstStat, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009if(ast.refItem =& null | ast.refItem.typeId.and(%statBreakable) <> %statBreakable)\n\u0009\u0009do \\err@err(%mustSpecifyBlockName, ast.pos, [\"break\"])\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.refItem :: @rebuildStat(ast.refItem $ \\ast@AstStat, retType, parentFunc)\n\u0009ret ast\nend func\n\nfunc rebuildSkip(ast: \\ast@AstStat, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009if(ast.refItem =& null | ast.refItem.typeId.and(%statBreakable) <> %statBreakable)\n\u0009\u0009do \\err@err(%mustSpecifyBlockName, ast.pos, [\"skip\"])\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.refItem :: @rebuildStat(ast.refItem $ \\ast@AstStat, retType, parentFunc)\n\u0009ret ast\nend func\n\nfunc rebuildAssert(ast: \\ast@AstStatAssert): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009\n\u0009if(\\option@rls)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009do ast.cond :: @rebuildExpr(ast.cond, false)\n\u0009if(ast.cond <>& null & !\\ast@isBool(ast.cond.type))\n\u0009\u0009do \\err@err(%assertCondMustBeBool, ast.cond.pos, null)\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildType(ast: \\ast@AstType, parentAlias: \\ast@AstAlias): \\ast@AstType\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstType\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009var type: \\ast@TypeId :: ast.typeId\n\u0009switch(type)\n\u0009case %typeUser\n\u0009\u0009var refItem: \\ast@Ast :: ast.refItem\n\u0009\u0009if(refItem =& null)\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009switch(refItem.typeId)\n\u0009\u0009case %class_\n\u0009\u0009\u0009do @rebuildClass(refItem $ \\ast@AstClass)\n\u0009\u0009case %enum_\n\u0009\u0009\u0009do @rebuildEnum(refItem $ \\ast@AstEnum)\n\u0009\u0009case %alias_\n\u0009\u0009\u0009do @rebuildAlias(refItem $ \\ast@AstAlias, parentAlias)\n\u0009\u0009\u0009do ast.extra :: (refItem $ \\ast@AstAlias).type\n\u0009\u0009\u0009do ast :: (refItem $ \\ast@AstAlias).type\n\u0009\u0009default\n\u0009\u0009\u0009do \\err@err(%nonTypeWritten, ast.pos, null)\n\u0009\u0009\u0009ret null\n\u0009\u0009end switch\n\u0009case %typeArray\n\u0009\u0009do(ast $ \\ast@AstTypeArray).itemType :: @rebuildType((ast $ \\ast@AstTypeArray).itemType, parentAlias)\n\u0009case %typeFunc\n\u0009\u0009var ast2: \\ast@AstTypeFunc :: ast $ \\ast@AstTypeFunc\n\u0009\u0009var items: list<\\ast@AstTypeFuncArg> :: ast2.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var arg: \\ast@AstTypeFuncArg :: items.get()\n\u0009\u0009\u0009do arg.arg :: @rebuildType(arg.arg, parentAlias)\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009if(ast2.ret_ <>& null)\n\u0009\u0009\u0009do ast2.ret_ :: @rebuildType(ast2.ret_, parentAlias)\n\u0009\u0009end if\n\u0009case %typeGen\n\u0009\u0009do(ast $ \\ast@AstTypeGen).itemType :: @rebuildType((ast $ \\ast@AstTypeGen).itemType, parentAlias)\n\u0009case %typeDict\n\u0009\u0009var ast2: \\ast@AstTypeDict :: ast $ \\ast@AstTypeDict\n\u0009\u0009do ast2.itemTypeKey :: @rebuildType(ast2.itemTypeKey, parentAlias)\n\u0009\u0009do ast2.itemTypeValue :: @rebuildType(ast2.itemTypeValue, parentAlias)\n\u0009default\n\u0009\u0009assert type = %none {Error}|type = %typeBit | type = %typePrim | type = %typeNull\n\u0009end switch\n\u0009ret ast\nend func\n\nfunc rebuildExpr(ast: \\ast@AstExpr, nullable: bool): \\ast@AstExpr\n\u0009if(ast =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009switch(ast.typeId)\n\u0009case %none\n\u0009\u0009ret null\n\u0009case %expr1\n\u0009\u0009do ast :: @rebuildExpr1(ast $ \\ast@AstExpr1)\n\u0009case %expr2\n\u0009\u0009do ast :: @rebuildExpr2(ast $ \\ast@AstExpr2)\n\u0009case %expr3\n\u0009\u0009do ast :: @rebuildExpr3(ast $ \\ast@AstExpr3)\n\u0009case %exprNew\n\u0009\u0009do ast :: @rebuildExprNew(ast $ \\ast@AstExprNew)\n\u0009case %exprNewArray\n\u0009\u0009do ast :: @rebuildExprNewArray(ast $ \\ast@AstExprNewArray)\n\u0009case %exprAs\n\u0009\u0009do ast :: @rebuildExprAs(ast $ \\ast@AstExprAs)\n\u0009case %exprToBin\n\u0009\u0009do ast :: @rebuildExprToBin(ast $ \\ast@AstExprToBin)\n\u0009case %exprFromBin\n\u0009\u0009do ast :: @rebuildExprFromBin(ast $ \\ast@AstExprFromBin)\n\u0009case %exprCall\n\u0009\u0009do ast :: @rebuildExprCall(ast $ \\ast@AstExprCall)\n\u0009case %exprArray\n\u0009\u0009do ast :: @rebuildExprArray(ast $ \\ast@AstExprArray)\n\u0009case %exprDot\n\u0009\u0009do ast :: @rebuildExprDot(ast $ \\ast@AstExprDot)\n\u0009case %exprValue\n\u0009\u0009do ast :: @rebuildExprValue(ast $ \\ast@AstExprValue)\n\u0009case %exprValuePrim\n\u0009\u0009do ast :: @rebuildExprValuePrim(ast $ \\ast@AstExprValuePrim)\n\u0009case %exprValueStr\n\u0009\u0009do ast :: @rebuildExprValueStr(ast $ \\ast@AstExprValueStr)\n\u0009case %exprValueEnumElement\n\u0009\u0009do ast :: @rebuildExprValueEnumElement(ast $ \\ast@AstExprValueEnumElement)\n\u0009case %exprValueFloat\n\u0009\u0009do ast :: @rebuildExprValueFloat(ast $ \\ast@AstExprValueFloat)\n\u0009case %exprValueArray\n\u0009\u0009do ast :: @rebuildExprValueArray(ast $ \\ast@AstExprValueArray)\n\u0009case %exprRef\n\u0009\u0009do ast :: @rebuildExprRef(ast)\n\u0009end switch\n\u0009if(ast =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(!nullable & ast.type =& null)\n\u0009\u0009; \'type\' is null, for example, when calling a function whose return value is \'void\'.\n\u0009\u0009do \\err@err(%noValuePassed, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildExpr1(ast: \\ast@AstExpr1): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.child :: @rebuildExpr(ast.child, false)\n\u0009if(ast.child =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009assert ast.type =& null\n\u0009var childType: \\ast@AstType :: ast.child.type\n\u0009switch(ast.kind)\n\u0009case %plus\n\u0009\u0009if(\\ast@isInt(childType) | \\ast@isFloat(childType) | childType.typeId = %typeBit)\n\u0009\u0009\u0009if(ast.child.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009do ast.extra :: ast.child\n\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.type :: childType\n\u0009\u0009end if\n\u0009case %minus\n\u0009\u0009if(\\ast@isInt(childType) | \\ast@isFloat(childType))\n\u0009\u0009\u0009if(ast.child.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009if(\\ast@isInt(childType))\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do expr.type :: childType\n\u0009\u0009\u0009\u0009\u0009do expr.value :: (-((ast.child $ \\ast@AstExprValuePrim).value $ int)) $ bit64\n\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009assert \\ast@isFloat(childType)\n\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValueFloat :: #\\ast@AstExprValueFloat\n\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValueFloat, ast.pos)\n\u0009\u0009\u0009\u0009do expr.type :: childType\n\u0009\u0009\u0009\u0009do expr.value :: -(ast.child $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009do expr :: @rebuildExprValueFloat(expr) $ \\ast@AstExprValueFloat\n\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.type :: childType\n\u0009\u0009end if\n\u0009case %not\n\u0009\u0009if(\\ast@isBool(childType))\n\u0009\u0009\u0009if(ast.child.typeId = %exprValuePrim)\n\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009do expr.type :: childType\n\u0009\u0009\u0009\u0009do expr.value :: (ast.child $ \\ast@AstExprValuePrim).value <> 0b64 ?(0b64, 1b64)\n\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.type :: childType\n\u0009\u0009end if\n\u0009case %copy\n\u0009\u0009if(\\ast@isClass(childType) | childType.typeId = %typeArray | childType.typeId = %typeGen | childType.typeId = %typeDict)\n\u0009\u0009\u0009do ast.type :: childType\n\u0009\u0009end if\n\u0009case %len\n\u0009\u0009if(childType.typeId = %typeArray | childType.typeId = %typeGen | childType.typeId = %typeDict)\n\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009do @initAst(type, %typePrim, ast.pos)\n\u0009\u0009\u0009do type.kind :: %int_\n\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009end if\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\n\u0009if(ast.type =& null)\n\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExpr2(ast: \\ast@AstExpr2): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.children0 :: @rebuildExpr(ast.children0, false)\n\u0009if(ast.children0 =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.children1 :: @rebuildExpr(ast.children1, false)\n\u0009if(ast.children1 =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(!@cmpType(ast.children1.type, ast.children0.type, false))\n\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009block\n\u0009\u0009var correct: bool :: false\n\u0009\u0009switch(ast.kind)\n\u0009\u0009case %assign\n\u0009\u0009\u0009if(ast.children0.varKind = %value)\n\u0009\u0009\u0009\u0009do \\err@err(%wrongLeftValueOfAssignOperator, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(\\ast@isClass(ast.children0.type) & \\ast@isClass(ast.children1.type))\n\u0009\u0009\u0009\u0009var ptr: \\ast@AstClass :: ast.children1.type.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009while(ast.children0.type.refItem <>& ptr)\n\u0009\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009\u0009if(ptr =& null)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(ast.children1.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009do ast.children1 :: @rebuildEnumElement(ast.children1, ast.children0.type)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.type :: null\n\u0009\u0009\u0009do correct :: true\n\u0009\u0009case %or, %and\n\u0009\u0009\u0009if(\\ast@isBool(ast.children0.type))\n\u0009\u0009\u0009\u0009if(ast.children0.typeId = %exprValuePrim)\n\u0009\u0009\u0009\u0009\u0009var value: bool :: (ast.children0 $ \\ast@AstExprValuePrim).value <> 0b64\n\u0009\u0009\u0009\u0009\u0009; \'true | x\' becomes \'true\'. \'false & x\' becomes \'false\'.\n\u0009\u0009\u0009\u0009\u0009if(ast.kind = %or)\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: value ?(ast.children0, ast.children1)\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert ast.kind = %and\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: !value ?(ast.children0, ast.children1)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: ast.children0.type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %lt, %gt, %le, %ge\n\u0009\u0009\u0009if(ast.children0.type.typeId = %typeNull | ast.children1.type.typeId = %typeNull)\n\u0009\u0009\u0009\u0009do \\err@err(%comparingNullByValue, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(@isComparable(ast.children0.type, true))\n\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, ast.pos)\n\u0009\u0009\u0009\u0009do type.kind :: %bool_\n\u0009\u0009\u0009\u0009if(ast.children0.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009if(ast.children1.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009assert(ast.children0.typeId = %exprValueEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%enumTypeNotInferred, ast.pos, [(ast.children0 $ \\ast@AstExprValueEnumElement).identifier])\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do ast.children0 :: @rebuildEnumElement(ast.children0, ast.children1.type)\n\u0009\u0009\u0009\u0009elif(ast.children1.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009do ast.children1 :: @rebuildEnumElement(ast.children1, ast.children0.type)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(ast.children0.typeId.and(%exprValue) = %exprValue & ast.children1.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009\u0009var value: bool :: false\n\u0009\u0009\u0009\u0009\u0009var children0Type: \\ast@AstType :: ast.children0.type\n\u0009\u0009\u0009\u0009\u0009if(children0Type.typeId = %typeBit | \\ast@isChar(children0Type))\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: bit64 :: (ast.children0 $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: bit64 :: (ast.children1 $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %lt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 < n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %gt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 > n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %le\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 <= n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %ge\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 >= n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isInt(children0Type) | \\ast@isEnum(children0Type))\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: int :: (ast.children0 $ \\ast@AstExprValuePrim).value $ int\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: int :: (ast.children1 $ \\ast@AstExprValuePrim).value $ int\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %lt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 < n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %gt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 > n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %le\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 <= n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %ge\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 >= n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isFloat(children0Type))\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: float :: (ast.children0 $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: float :: (ast.children1 $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %lt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 < n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %gt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 > n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %le\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 <= n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %ge\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 >= n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isStr(children0Type)\n\u0009\u0009\u0009\u0009\u0009\u0009var cmp: int :: lib@cmp((ast.children0 $ \\ast@AstExprValueStr).value, (ast.children1 $ \\ast@AstExprValueStr).value)\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %lt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: cmp < 0\n\u0009\u0009\u0009\u0009\u0009\u0009case %gt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: cmp > 0\n\u0009\u0009\u0009\u0009\u0009\u0009case %le\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: cmp <= 0\n\u0009\u0009\u0009\u0009\u0009\u0009case %ge\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: cmp >= 0\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do expr.type :: type\n\u0009\u0009\u0009\u0009\u0009do expr.value :: value ?(1b64, 0b64)\n\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %eq, %nEq\n\u0009\u0009\u0009if(ast.children0.type.typeId = %typeNull | ast.children1.type.typeId = %typeNull)\n\u0009\u0009\u0009\u0009do \\err@err(%comparingNullByValue, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(@isComparable(ast.children0.type, false))\n\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, ast.pos)\n\u0009\u0009\u0009\u0009do type.kind :: %bool_\n\u0009\u0009\u0009\u0009if(ast.children0.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009if(ast.children1.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009assert(ast.children0.typeId = %exprValueEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%enumTypeNotInferred, ast.pos, [(ast.children0 $ \\ast@AstExprValueEnumElement).identifier])\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do ast.children0 :: @rebuildEnumElement(ast.children0, ast.children1.type)\n\u0009\u0009\u0009\u0009elif(ast.children1.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009do ast.children1 :: @rebuildEnumElement(ast.children1, ast.children0.type)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(ast.children0.typeId.and(%exprValue) = %exprValue & ast.children1.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009\u0009var value: bool :: false\n\u0009\u0009\u0009\u0009\u0009var children0Type: \\ast@AstType :: ast.children0.type\n\u0009\u0009\u0009\u0009\u0009if(children0Type.typeId = %typeBit | \\ast@isInt(children0Type) | \\ast@isChar(children0Type) | \\ast@isBool(children0Type) | \\ast@isEnum(children0Type))\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: bit64 :: (ast.children0 $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: bit64 :: (ast.children1 $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %eq\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 = n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %nEq\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 <> n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isFloat(children0Type))\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: float :: (ast.children0 $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: float :: (ast.children1 $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %eq\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 = n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %nEq\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 <> n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isStr(children0Type)\n\u0009\u0009\u0009\u0009\u0009\u0009var cmp: int :: lib@cmp((ast.children0 $ \\ast@AstExprValueStr).value, (ast.children1 $ \\ast@AstExprValueStr).value)\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %eq\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: cmp = 0\n\u0009\u0009\u0009\u0009\u0009\u0009case %nEq\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: cmp <> 0\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do expr.type :: type\n\u0009\u0009\u0009\u0009\u0009do expr.value :: value ?(1b64, 0b64)\n\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %eqRef, %nEqRef\n\u0009\u0009\u0009if(\\ast@isNullable(ast.children0.type) | ast.children0.type.typeId = %typeNull)\n\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, ast.pos)\n\u0009\u0009\u0009\u0009do type.kind :: %bool_\n\u0009\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %cat\n\u0009\u0009\u0009if(ast.children0.type.typeId = %typeNull | ast.children1.type.typeId = %typeNull)\n\u0009\u0009\u0009\u0009do \\err@err(%concatNull, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(ast.children0.type.typeId = %typeArray)\n\u0009\u0009\u0009\u0009if(ast.children0.typeId.and(%exprValue) = %exprValue & ast.children1.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009\u0009if(\\ast@isStr(ast.children0.type))\n\u0009\u0009\u0009\u0009\u0009\u0009var s1: []char :: (ast.children0 $ \\ast@AstExprValueStr).value\n\u0009\u0009\u0009\u0009\u0009\u0009var s2: []char :: (ast.children1 $ \\ast@AstExprValueStr).value\n\u0009\u0009\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValueStr :: #\\ast@AstExprValueStr\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValueStr, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.children0.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: s1 ~ s2\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValueStr(expr) $ \\ast@AstExprValueStr\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: ast.children0.type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %add, %sub, %mul, %div, %mod\n\u0009\u0009\u0009if(ast.children0.type.typeId = %typeBit | \\ast@isInt(ast.children0.type) | \\ast@isFloat(ast.children0.type))\n\u0009\u0009\u0009\u0009if(ast.children0.typeId.and(%exprValue) = %exprValue & ast.children1.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009\u0009if(ast.children0.type.typeId = %typeBit)\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: bit64 :: (ast.children0 $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: bit64 :: (ast.children1 $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %add\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :+ n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %sub\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :- n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %mul\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :* n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %div\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(n2 = 0b64)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%dividedBy0, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :/ n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %mod\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(n2 = 0b64)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%dividedBy0, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :% n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.children0.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: @bitCast((ast.children0.type $ \\ast@AstTypeBit).size, n1)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isInt(ast.children0.type))\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: int :: (ast.children0 $ \\ast@AstExprValuePrim).value $ int\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: int :: (ast.children1 $ \\ast@AstExprValuePrim).value $ int\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %add\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :+ n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %sub\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :- n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %mul\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :* n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %div\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(n2 = 0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%dividedBy0, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :/ n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %mod\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(n2 = 0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%dividedBy0, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :% n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.children0.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n1 $ bit64\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isFloat(ast.children0.type)\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: float :: (ast.children0 $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: float :: (ast.children1 $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %add\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :+ n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %sub\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :- n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %mul\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :* n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %div\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(n1 = 0.0 & n2 = 0.0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%dividedBy0, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :/ n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %mod\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(n1 = 0.0 & n2 = 0.0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%dividedBy0, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :% n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValueFloat :: #\\ast@AstExprValueFloat\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValueFloat, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.children0.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n1\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValueFloat(expr) $ \\ast@AstExprValueFloat\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: ast.children0.type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %pow\n\u0009\u0009\u0009if(\\ast@isInt(ast.children0.type) | \\ast@isFloat(ast.children0.type))\n\u0009\u0009\u0009\u0009do ast.type :: ast.children0.type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %swap\n\u0009\u0009\u0009if(ast.children0.varKind = %value | ast.children1.varKind = %value)\n\u0009\u0009\u0009\u0009do \\err@err(%wrongLeftOrRightValueOfSwapOperator, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!(\\ast@isClass(ast.children0.type) & ast.children0.type.refItem <>& ast.children1.type.refItem))\n\u0009\u0009\u0009\u0009do ast.type :: ast.children0.type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009end switch\n\u0009\u0009if(!correct)\n\u0009\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009end block\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExpr3(ast: \\ast@AstExpr3): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.children0 :: @rebuildExpr(ast.children0, false)\n\u0009if(ast.children0 =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.children1 :: @rebuildExpr(ast.children1, false)\n\u0009if(ast.children1 =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.children2 :: @rebuildExpr(ast.children2, false)\n\u0009if(ast.children2 =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(!\\ast@isBool(ast.children0.type))\n\u0009\u0009do \\err@err(%condForCondOperatorMustBeBool, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(!@cmpType(ast.children1.type, ast.children2.type, false) & !@cmpType(ast.children2.type, ast.children1.type, false))\n\u0009\u0009do \\err@err(%twoValueForCondOperatorMustSameType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(ast.children0.typeId = %exprValuePrim)\n\u0009\u0009do ast.extra :: (ast.children0 $ \\ast@AstExprValuePrim).value <> 0b64 ?(ast.children1, ast.children2)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009if(ast.children1.type.typeId = %typeEnumElement)\n\u0009\u0009if(ast.children2.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009assert ast.children1.typeId = %exprValueEnumElement\n\u0009\u0009\u0009do \\err@err(%enumTypeNotInferred, ast.pos, [(ast.children1 $ \\ast@AstExprValueEnumElement).identifier])\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009do ast.children1 :: @rebuildEnumElement(ast.children1, ast.children2.type)\n\u0009elif(ast.children2.type.typeId = %typeEnumElement)\n\u0009\u0009do ast.children2 :: @rebuildEnumElement(ast.children2, ast.children1.type)\n\u0009end if\n\u0009if(@cmpType(ast.children1.type, ast.children2.type, false))\n\u0009\u0009do ast.type :: ast.children2.type.typeId = %typeNull ?(ast.children1.type, ast.children2.type)\n\u0009else\n\u0009\u0009do ast.type :: ast.children1.type.typeId = %typeNull ?(ast.children2.type, ast.children1.type)\n\u0009end if\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprNew(ast: \\ast@AstExprNew): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.itemType :: @rebuildType(ast.itemType, null)\n\u0009if(ast.itemType =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009if(\\ast@isClass(ast.itemType) & ast.itemType.refItem =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009if(!(\\ast@isClass(ast.itemType) | ast.itemType.typeId = %typeGen | ast.itemType.typeId = %typeDict))\n\u0009\u0009do \\err@err(%wrongTypeForNewOperator, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.type :: ast.itemType\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprNewArray(ast: \\ast@AstExprNewArray): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009block\n\u0009\u0009var items: list<\\ast@AstExpr> :: ast.idces\n\u0009\u0009do items.head()\n\u0009\u0009while loop(!items.term())\n\u0009\u0009\u0009var data: \\ast@AstExpr :: items.get()\n\u0009\u0009\u0009do data :: @rebuildExpr(data, false)\n\u0009\u0009\u0009if(data =& null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!\\ast@isInt(data.type))\n\u0009\u0009\u0009\u0009do \\err@err(%numOfElementsMustBeInt, data.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.ins(data)\n\u0009\u0009\u0009do items.del()\n\u0009\u0009end while\n\u0009end block\n\u0009\n\u0009do ast.itemType :: @rebuildType(ast.itemType, null)\n\u0009if(ast.itemType =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009block\n\u0009\u0009; Make a type of \'[][]...[]type\'.\n\u0009\u0009var type: \\ast@AstType :: ast.itemType\n\u0009\u0009for i(0, ^ast.idces - 1)\n\u0009\u0009\u0009var type2: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009do @initAst(type2, %typeArray, ast.pos)\n\u0009\u0009\u0009do type2.itemType :: type\n\u0009\u0009\u0009do type :: type2\n\u0009\u0009end for\n\u0009\u0009do ast.type :: type\n\u0009end block\n\u0009\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprAs(ast: \\ast@AstExprAs): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.child :: @rebuildExpr(ast.child, false)\n\u0009if(ast.child =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.childType :: @rebuildType(ast.childType, null)\n\u0009if(ast.childType =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009assert ast.type =& null\n\u0009switch(ast.kind)\n\u0009case %as\n\u0009\u0009var t1: \\ast@AstType :: ast.child.type\n\u0009\u0009var t2: \\ast@AstType :: ast.childType\n\u0009\u0009if(t1.typeId = %typeBit | \\ast@isInt(t1))\n\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2) | \\ast@isFloat(t2) | \\ast@isChar(t2) | \\ast@isBool(t2) | \\ast@isEnum(t2))\n\u0009\u0009\u0009\u0009if(@cmpType(t1, t2, false))\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: ast.child\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009elif(\\ast@isFloat(t1))\n\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2) | \\ast@isFloat(t2))\n\u0009\u0009\u0009\u0009if(@cmpType(t1, t2, false))\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: ast.child\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009elif(\\ast@isChar(t1))\n\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2) | \\ast@isChar(t2))\n\u0009\u0009\u0009\u0009if(@cmpType(t1, t2, false))\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: ast.child\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009elif(\\ast@isBool(t1))\n\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2) | \\ast@isBool(t2))\n\u0009\u0009\u0009\u0009if(@cmpType(t1, t2, false))\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: ast.child\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009elif(\\ast@isClass(t1))\n\u0009\u0009\u0009if(\\ast@isClass(t2))\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009elif(\\ast@isEnum(t1))\n\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2) | \\ast@isEnum(t2))\n\u0009\u0009\u0009\u0009if(@cmpType(t1, t2, false))\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: ast.child\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009elif(t1.typeId = %typeEnumElement)\n\u0009\u0009\u0009if(\\ast@isEnum(t2))\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(ast.type <>& null)\n\u0009\u0009\u0009if(ast.child.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009if(t1.typeId = %typeBit | \\ast@isChar(t1) | \\ast@isBool(t1) | \\ast@isInt(t1) | \\ast@isEnum(t1))\n\u0009\u0009\u0009\u0009\u0009var n: bit64 :: (ast.child $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009if(t2.typeId = %typeBit)\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: @bitCast((t2 $ \\ast@AstTypeBit).size, n)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isInt(t2) | \\ast@isEnum(t2))\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isFloat(t2))\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValueFloat :: #\\ast@AstExprValueFloat\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValueFloat, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009if(\\ast@isInt(t1) | \\ast@isEnum(t1))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n $ int $ float\n\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n $ float\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValueFloat(expr) $ \\ast@AstExprValueFloat\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isChar(t2))\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: @bitCast(2, n)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isBool(t2)\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n <> 0b64 ?(1b64, 0b64)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009elif(t1.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009assert t2.refItem.typeId = %enum_\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009do expr.value :: @searchEnumElementValue(ast.child $ \\ast@AstExprValueEnumElement, t2.refItem $ \\ast@AstEnum)\n\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert \\ast@isFloat(t1)\n\u0009\u0009\u0009\u0009\u0009var n: float :: (ast.child $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009\u0009if(t2.typeId = %typeBit)\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: @bitCast((t2 $ \\ast@AstTypeBit).size, n $ bit64)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(t2)\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n $ bit64\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009case %is, %nIs\n\u0009\u0009if(\\ast@isClass(ast.child.type) & \\ast@isClass(ast.childType))\n\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009do @initAst(type, %typePrim, ast.pos)\n\u0009\u0009\u0009do type.kind :: %bool_\n\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009end if\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\n\u0009if(ast.type =& null)\n\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprToBin(ast: \\ast@AstExprToBin): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.child :: @rebuildExpr(ast.child, false)\n\u0009if(ast.child =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(ast.child.type.typeId = %typeNull | ast.child.type.typeId = %typeEnumElement)\n\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(ast.childType.typeId <> %typeArray | (ast.childType $ \\ast@AstTypeArray).itemType.typeId <> %typeBit | ((ast.childType $ \\ast@AstTypeArray).itemType $ \\ast@AstTypeBit).size <> 1)\n\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.type :: ast.childType\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprFromBin(ast: \\ast@AstExprFromBin): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.child :: @rebuildExpr(ast.child, false)\n\u0009if(ast.child =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(ast.child.type.typeId <> %typeArray | ((ast.child.type) $ \\ast@AstTypeArray).itemType.typeId <> %typeBit | ((ast.child.type $ \\ast@AstTypeArray).itemType $ \\ast@AstTypeBit).size <> 1)\n\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.type :: ast.childType\n\u0009do ast.varKind :: %value\n\u0009do ast.offset :: @rebuildExpr(ast.offset, false)\n\u0009ret ast\nend func\n\nfunc rebuildExprCall(ast: \\ast@AstExprCall): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.func_ :: @rebuildExpr(ast.func_, false)\n\u0009if(ast.func_ =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009block\n\u0009\u0009var type: \\ast@AstTypeFunc :: ast.func_.type $ \\ast@AstTypeFunc\n\u0009\u0009if(type.funcOption.and(%mki) <> %none)\n\u0009\u0009\u0009; Make an instance and add it to the second argument when \'__mki\' is specified.\n\u0009\u0009\u0009var valueType: \\ast@AstExprCallArg :: #\\ast@AstExprCallArg\n\u0009\u0009\u0009assert type.ret_ <>& null\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var expr: \\ast@AstExprNew :: #\\ast@AstExprNew\n\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprNew, ast.pos)\n\u0009\u0009\u0009\u0009do expr.itemType :: type.ret_\n\u0009\u0009\u0009\u0009do valueType.arg :: @rebuildExpr(expr, false)\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do valueType.refVar :: false\n\u0009\u0009\u0009do valueType.skipVar :: false\n\u0009\u0009\u0009if(^ast.args = 0)\n\u0009\u0009\u0009\u0009do ast.args.add(valueType)\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do ast.args.head()\n\u0009\u0009\u0009\u0009do ast.args.ins(valueType)\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(ast.func_.typeId = %exprDot & ast.func_.type.typeId = %typeFunc)\n\u0009\u0009\u0009var me_: \\ast@AstExprCallArg :: #\\ast@AstExprCallArg\n\u0009\u0009\u0009do me_.arg :: (ast.func_ $ \\ast@AstExprDot).var_\n\u0009\u0009\u0009do me_.refVar :: false\n\u0009\u0009\u0009do me_.skipVar :: false\n\u0009\u0009\u0009if(^ast.args = 0)\n\u0009\u0009\u0009\u0009do ast.args.add(me_)\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do ast.args.head()\n\u0009\u0009\u0009\u0009do ast.args.ins(me_)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(type.funcOption.and(%any) <> %none)\n\u0009\u0009\u0009\u0009; Add the type of \'me\' to the second argument when \'_any_type\' is specified.\n\u0009\u0009\u0009\u0009var meType: \\ast@AstExprCallArg :: #\\ast@AstExprCallArg\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValueArray :: #\\ast@AstExprValueArray\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValueArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do expr.values :: #list<\\ast@AstExpr>\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var value: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(value, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do value.value :: 0b64\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var prim: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(prim, %typePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do prim.kind :: %int_\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value.type :: prim\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.values.add(value)\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do meType.arg :: @rebuildExpr(expr, false)\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do meType.refVar :: false\n\u0009\u0009\u0009\u0009do meType.skipVar :: false\n\u0009\u0009\u0009\u0009if(^ast.args = 1)\n\u0009\u0009\u0009\u0009\u0009do ast.args.add(meType)\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert ^ ast.args >= 2\n\u0009\u0009\u0009\u0009\u0009do ast.args.head()\n\u0009\u0009\u0009\u0009\u0009do ast.args.next()\n\u0009\u0009\u0009\u0009\u0009do ast.args.ins(meType)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009if(type.typeId <> %typeFunc)\n\u0009\u0009\u0009\u0009do \\err@err(%callNonFunction, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do type :: ast.func_.type $ \\ast@AstTypeFunc\n\u0009\u0009end if\n\u0009\u0009do ast.type :: type.ret_\n\u0009\u0009if(^ast.args <> ^type.args)\n\u0009\u0009\u0009do \\err@err(%wrongArgNumInFunc, ast.pos, [(^type.args).toStr(), (^ast.args).toStr(), @getTypeName(type)])\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009block\n\u0009\u0009\u0009var n: int :: 0\n\u0009\u0009\u0009var itemsExpr: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009\u0009var itemsType: list<\\ast@AstTypeFuncArg> :: type.args\n\u0009\u0009\u0009do itemsExpr.head()\n\u0009\u0009\u0009do itemsType.head()\n\u0009\u0009\u0009while(!itemsExpr.term())\n\u0009\u0009\u0009\u0009var argExpr: \\ast@AstExprCallArg :: itemsExpr.get()\n\u0009\u0009\u0009\u0009var argType: \\ast@AstTypeFuncArg :: itemsType.get()\n\u0009\u0009\u0009\u0009if(argExpr.skipVar)\n\u0009\u0009\u0009\u0009\u0009do(argExpr.arg.refItem $ \\ast@AstArg).type :: argType.arg\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do argExpr.arg :: @rebuildExpr(argExpr.arg, false)\n\u0009\u0009\u0009\u0009if(argExpr.arg <>& null)\n\u0009\u0009\u0009\u0009\u0009if(argExpr.refVar & !argExpr.skipVar & argExpr.arg.varKind = %value)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%nonRefArgPassed, ast.pos, [(n + 1).toStr()])\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(argExpr.refVar <> argType.refVar | !@cmpType(argExpr.arg.type, argType.arg, false))\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%wrongArgTypeInFunc, ast.pos, [(n + 1).toStr(), (argType.refVar ?(\"&\", \"\")) ~ @getTypeName(argType.arg), (argExpr.refVar ?(\"&\", \"\")) ~ @getTypeName(argExpr.arg.type)])\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(argExpr.arg.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009do argExpr.arg :: @rebuildEnumElement(argExpr.arg, argType.arg)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do itemsExpr.next()\n\u0009\u0009\u0009\u0009do itemsType.next()\n\u0009\u0009\u0009\u0009do n :+ 1\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009end block\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprArray(ast: \\ast@AstExprArray): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.var_ :: @rebuildExpr(ast.var_, false)\n\u0009if(ast.var_ =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(ast.var_.type.typeId <> %typeArray)\n\u0009\u0009do \\err@err(%nonArrayAccess, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.idx :: @rebuildExpr(ast.idx, false)\n\u0009if(ast.idx =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(!\\ast@isInt(ast.idx.type))\n\u0009\u0009do \\err@err(%arrayIdxMustBeInt, ast.idx.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.type :: (ast.var_.type $ \\ast@AstTypeArray).itemType\n\u0009do ast.varKind :: %globalVar {An array can be an left value.}\n\u0009ret ast\nend func\n\nfunc rebuildExprDot(ast: \\ast@AstExprDot): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.var_ :: @rebuildExpr(ast.var_, false)\n\u0009if(ast.var_ =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(\\ast@isClass(ast.var_.type))\n\u0009\u0009var found: bool :: false\n\u0009\u0009var ptr: \\ast@AstClass :: ast.var_.type.refItem $ \\ast@AstClass\n\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: ptr.items\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009if(item.def.typeId = %var_ & ast.member = (item.def $ \\ast@AstVar).arg.name)\n\u0009\u0009\u0009\u0009\u0009do ast.type :: (item.def $ \\ast@AstVar).arg.type\n\u0009\u0009\u0009\u0009\u0009do ast.varKind :: %globalVar {The addresses of properties are treated as those of global variables. They can be left values.}\n\u0009\u0009\u0009\u0009\u0009do found :: true\n\u0009\u0009\u0009\u0009elif(item.def.typeId = %func_ & ast.member = item.def.name)\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeFunc :: #\\ast@AstTypeFunc\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeFunc, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do type.funcOption :: (item.def $ \\ast@AstFunc).funcOption\n\u0009\u0009\u0009\u0009\u0009do type.funcAttr :: (item.def $ \\ast@AstFunc).funcAttr\n\u0009\u0009\u0009\u0009\u0009do type.args :: #list<\\ast@AstTypeFuncArg>\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var items2: list<\\ast@AstArg> :: (item.def $ \\ast@AstFunc).args\n\u0009\u0009\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: items2.get()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var arg2: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg2.arg :: arg.type\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg2.refVar :: arg.refVar\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type.args.add(arg2)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do type.ret_ :: (item.def $ \\ast@AstFunc).ret_\n\u0009\u0009\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009\u0009\u0009\u0009do ast.varKind :: %value\n\u0009\u0009\u0009\u0009\u0009do found :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(found)\n\u0009\u0009\u0009\u0009\u0009; \'me\' and automatically generated arguments can be accessed even though they are private.\n\u0009\u0009\u0009\u0009\u0009if(!item.public & (ast.var_.refName =& null | ast.var_.refName <> \"me\"))\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%refUnpublishedMember, ast.pos, [ast.member])\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do ast.classItem :: item\n\u0009\u0009\u0009\u0009\u0009ret ast\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009end while\n\u0009else\n\u0009\u0009; Built-in methods.\n\u0009\u0009var varType: \\ast@AstType :: ast.var_.type\n\u0009\u0009if(varType.typeId = %typeEnumElement)\n\u0009\u0009\u0009assert ast.var_.typeId = %exprValueEnumElement\n\u0009\u0009\u0009do \\err@err(%enumTypeNotInferred, ast.pos, [(ast.var_ $ \\ast@AstExprValueEnumElement).identifier])\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009var member: []char :: ast.member\n\u0009\u0009if(\\builtin_func@chkBuiltinFuncType(&member, varType))\n\u0009\u0009\u0009var expr: \\ast@AstExpr :: @searchStdItem(\"kuin\", \"_\" ~ member, true) $ \\ast@AstExpr\n\u0009\u0009\u0009if(expr =& null)\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var func_: \\ast@AstTypeFunc :: expr.type $ \\ast@AstTypeFunc\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%any) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert ^ func_.args >= 2\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.args.get().arg)\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009var argType: \\ast@AstType :: func_.args.get().arg\n\u0009\u0009\u0009\u0009\u0009\u0009assert argType.typeId = %typeArray & \\ast@isInt((argType $ \\ast@AstTypeArray).itemType)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: varType\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%tme) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tkv) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%kvf) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert ^ func_.args >= 3\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.args.get().arg)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: varType\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%tch) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tkv) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%kvf) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert ^ func_.args >= 3\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.args.get().arg)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009if(varType.typeId = %typeArray)\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: (varType $ \\ast@AstTypeArray).itemType\n\u0009\u0009\u0009\u0009\u0009elif(varType.typeId = %typeGen)\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: (varType $ \\ast@AstTypeGen).itemType\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: (varType $ \\ast@AstTypeDict).itemTypeKey\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%tkv) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%kvf) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert ^ func_.args >= 4\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.args.get().arg)\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.args.get().arg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: (varType $ \\ast@AstTypeDict).itemTypeKey\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: (varType $ \\ast@AstTypeDict).itemTypeValue\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%kvf) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tkv) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert ^ func_.args >= 3\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.args.get().arg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeFunc :: #\\ast@AstTypeFunc\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeFunc, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do type.funcOption :: %none\n\u0009\u0009\u0009\u0009\u0009do type.funcAttr :: #list<[]char>\n\u0009\u0009\u0009\u0009\u0009do type.args :: #list<\\ast@AstTypeFuncArg>\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009\u0009do item.arg :: (varType $ \\ast@AstTypeDict).itemTypeKey\n\u0009\u0009\u0009\u0009\u0009\u0009do item.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009do type.args.add(item)\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009\u0009do item.arg :: (varType $ \\ast@AstTypeDict).itemTypeValue\n\u0009\u0009\u0009\u0009\u0009\u0009do item.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009do type.args.add(item)\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do item.arg :: func_.args.get().arg\n\u0009\u0009\u0009\u0009\u0009\u0009do item.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009do type.args.add(item)\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do type.ret_ :: func_.ret_\n\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: type\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%rme) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rac) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rak) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rav) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.ret_)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: varType\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%rch) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rac) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rak) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rav) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.ret_)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(varType.typeId = %typeArray)\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: (varType $ \\ast@AstTypeArray).itemType\n\u0009\u0009\u0009\u0009\u0009elif(varType.typeId = %typeGen)\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: (varType $ \\ast@AstTypeGen).itemType\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: (varType $ \\ast@AstTypeDict).itemTypeValue\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%rac) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rak) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rav) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.ret_)\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeGen\n\u0009\u0009\u0009\u0009\u0009\u0009assert(varType $ \\ast@AstTypeGen).kind = %list_\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do type.itemType :: (varType $ \\ast@AstTypeGen).itemType\n\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: type\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%rak) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rac) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rav) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.ret_)\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do type.itemType :: (varType $ \\ast@AstTypeDict).itemTypeKey\n\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: type\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%rav) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rac) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rak) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.ret_)\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do type.itemType :: (varType $ \\ast@AstTypeDict).itemTypeValue\n\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: type\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009\n\u0009\u0009\u0009do ast.refItem :: expr\n\u0009\u0009\u0009do ast.type :: expr.type\n\u0009\u0009\u0009do ast.varKind :: %value\n\u0009\u0009\u0009ret ast\n\u0009\u0009end if\n\u0009end if\n\u0009do \\err@err(%memberNotExist, ast.pos, [ast.member])\n\u0009ret null\nend func\n\nfunc rebuildExprValue(ast: \\ast@AstExprValue): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009assert ast.typeId = %exprValue\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprValuePrim(ast: \\ast@AstExprValuePrim): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprValueStr(ast: \\ast@AstExprValueStr): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprValueEnumElement(ast: \\ast@AstExprValueEnumElement): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprValueFloat(ast: \\ast@AstExprValueFloat): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprValueArray(ast: \\ast@AstExprValueArray): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009assert ast.type =& null\n\u0009\n\u0009block\n\u0009\u0009var nullSet: bool :: false\n\u0009\u0009var enumSet: bool :: false\n\u0009\u0009var items: list<\\ast@AstExpr> :: ast.values\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var data: \\ast@AstExpr :: items.get()\n\u0009\u0009\u0009do data :: @rebuildExpr(data, false)\n\u0009\u0009\u0009if(data =& null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var dataType: \\ast@AstType :: data.type\n\u0009\u0009\u0009\u0009if(ast.type =& null)\n\u0009\u0009\u0009\u0009\u0009if(dataType.typeId = %typeNull)\n\u0009\u0009\u0009\u0009\u0009\u0009if(enumSet)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%elementTypesOfArrayInitNotMatch, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do nullSet :: true\n\u0009\u0009\u0009\u0009\u0009elif(dataType.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009if(nullSet)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%nullForValueTypeArrayInit, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do enumSet :: true\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009; Determine the type of the array initializer when a value other than \'null\' is specified.\n\u0009\u0009\u0009\u0009\u0009\u0009if(nullSet & !\\ast@isNullable(dataType))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%nullForValueTypeArrayInit, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009if(enumSet & !\\ast@isEnum(dataType))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%elementTypesOfArrayInitNotMatch, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, dataType.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.itemType :: dataType\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009elif(!@cmpType((ast.type $ \\ast@AstTypeArray).itemType, dataType, false))\n\u0009\u0009\u0009\u0009\u0009; The types of the second and subsequent elements of the array initializer do not match the type of the first element.\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%elementTypesOfArrayInitNotMatch, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do items.ins(data)\n\u0009\u0009\u0009do items.del()\n\u0009\u0009end while\n\u0009\u0009if(ast.type =& null)\n\u0009\u0009\u0009if(enumSet)\n\u0009\u0009\u0009\u0009do \\err@err(%allElementsAreEnum, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do \\err@err(%allElementsAreNull, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009if(\\ast@isEnum((ast.type $ \\ast@AstTypeArray).itemType))\n\u0009\u0009var items: list<\\ast@AstExpr> :: ast.values\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstExpr :: items.get()\n\u0009\u0009\u0009if(item.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009do item :: @rebuildEnumElement(item, (ast.type $ \\ast@AstTypeArray).itemType)\n\u0009\u0009\u0009\u0009do items.ins(item)\n\u0009\u0009\u0009\u0009do items.del()\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end if\n\u0009\u0009end while\n\u0009end if\n\u0009\n\u0009if(\\ast@isStr(ast.type))\n\u0009\u0009; Replace constants consisting only of characters with string literals.\n\u0009\u0009var isConst: bool :: true\n\u0009\u0009block\n\u0009\u0009\u0009var items: list<\\ast@AstExpr> :: ast.values\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while loop(!items.term())\n\u0009\u0009\u0009\u0009if(items.get().typeId <> %exprValue)\n\u0009\u0009\u0009\u0009\u0009do isConst :: false\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009if(isConst)\n\u0009\u0009\u0009var ast2: \\ast@AstExprValueStr :: #\\ast@AstExprValueStr\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprValueStr, ast.pos)\n\u0009\u0009\u0009do ast2.type :: ast.type\n\u0009\u0009\u0009var s: []char :: #[^ast.values]char\n\u0009\u0009\u0009var idx: int :: 0\n\u0009\u0009\u0009var items: list<\\ast@AstExpr> :: ast.values\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009do s[idx] :: (items.get() $ \\ast@AstExprValuePrim).value $ char\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do ast2.value :: s\n\u0009\u0009\u0009do ast2 :: @rebuildExprValueStr(ast2) $ \\ast@AstExprValueStr\n\u0009\u0009\u0009do ast.extra :: ast\n\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009end if\n\u0009end if\n\u0009\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprRef(ast: \\ast@AstExpr): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009assert ast.typeId = %exprRef\n\u0009var refItem: \\ast@Ast :: ast.refItem\n\u0009if(refItem =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009switch(refItem.typeId)\n\u0009case %func_\n\u0009\u0009var func_: \\ast@AstFunc :: ast.refItem $ \\ast@AstFunc\n\u0009\u0009do @rebuildFunc(func_)\n\u0009\u0009block\n\u0009\u0009\u0009var type: \\ast@AstTypeFunc :: #\\ast@AstTypeFunc\n\u0009\u0009\u0009do @initAst(type, %typeFunc, ast.pos)\n\u0009\u0009\u0009do type.funcOption :: func_.funcOption\n\u0009\u0009\u0009do type.funcAttr :: func_.funcAttr\n\u0009\u0009\u0009do type.args :: #list<\\ast@AstTypeFuncArg>\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var items: list<\\ast@AstArg> :: func_.args\n\u0009\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: items.get()\n\u0009\u0009\u0009\u0009\u0009var arg2: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009do arg2.refVar :: arg.refVar\n\u0009\u0009\u0009\u0009\u0009do arg2.arg :: arg.type\n\u0009\u0009\u0009\u0009\u0009do type.args.add(arg2)\n\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do type.ret_ :: func_.ret_\n\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009end block\n\u0009\u0009do ast.varKind :: %value\n\u0009case %arg\n\u0009\u0009var arg: \\ast@AstArg :: ast.refItem $ \\ast@AstArg\n\u0009\u0009do @rebuildArg(arg)\n\u0009\u0009switch(arg.kind)\n\u0009\u0009case %global\n\u0009\u0009\u0009do ast.type :: arg.type\n\u0009\u0009\u0009do ast.varKind :: %globalVar\n\u0009\u0009case %localArg\n\u0009\u0009\u0009do ast.type :: arg.type\n\u0009\u0009\u0009do ast.varKind :: arg.refVar ?(%refVar $ \\ast@AstExprVarKind, %localVar)\n\u0009\u0009case %localVar\n\u0009\u0009\u0009do ast.type :: arg.type\n\u0009\u0009\u0009do ast.varKind :: %localVar\n\u0009\u0009case %const_\n\u0009\u0009\u0009if(arg.expr =& null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009assert arg.expr.typeId.and(%exprValue) = %exprValue\n\u0009\u0009\u0009do ast.extra :: arg.expr\n\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009case %member\n\u0009\u0009\u0009do \\err@err(%accessMemberWithoutMe, ast.pos, [ast.refName])\n\u0009\u0009\u0009ret null\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009case %statSwitch, %statFor, %statTry\n\u0009\u0009assert refItem.extra <>& null\n\u0009\u0009do ast.refItem :: (refItem $ \\ast@AstStatBreakable).blockVar\n\u0009\u0009do ast.type :: (refItem $ \\ast@AstStatBreakable).blockVar.type\n\u0009\u0009do ast.varKind :: %localVar\n\u0009default\n\u0009\u0009if(refItem.typeId.and(%expr) = %expr & refItem.extra <>& null & \\ast@isEnum((refItem.extra $ \\ast@AstExpr).type))\n\u0009\u0009\u0009do ast.extra :: refItem.extra\n\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009do \\err@err(%inaccessibleElement, ast.pos, [ast.refName])\n\u0009\u0009ret null\n\u0009end switch\n\u0009ret ast\nend func\n\nfunc searchStdItem(src: []char, identifier: []char, makeExprRef: bool): \\ast@Ast\n\u0009var ast: \\ast@Ast :: @asts.get(src, &)\n\u0009if(ast =& null)\n\u0009\u0009do \\err@err(%sysFileOpenFailed, null, [src])\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009var ast2: \\ast@Ast :: ast.scopeChildren.get(identifier, &)\n\u0009if(ast =& null)\n\u0009\u0009do \\err@err(%sysFileBroken, null, [src])\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009if(makeExprRef)\n\u0009\u0009var expr: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009do @initAstExpr(expr, %exprRef, \\pos@make(\"kuin\", 1, 1))\n\u0009\u0009do expr.refItem :: ast2\n\u0009\u0009ret @rebuildExprRef(expr)\n\u0009end if\n\u0009ret ast2\nend func\n\nfunc initAst(ast: \\ast@Ast, typeId: \\ast@TypeId, pos: \\pos@Pos)\n\u0009assert ast <>$ \\ast@AstExpr\n\u0009do @initAstImpl(ast, typeId, pos)\nend func\n\nfunc initAstExpr(ast: \\ast@AstExpr, typeId: \\ast@TypeId, pos: \\pos@Pos)\n\u0009assert ast =$ \\ast@AstExpr\n\u0009do @initAstImpl(ast, typeId, pos)\n\u0009do ast.type :: null\n\u0009do ast.varKind :: %unknown\nend func\n\nfunc initAstImpl(ast: \\ast@Ast, typeId: \\ast@TypeId, pos: \\pos@Pos)\n\u0009do ast.typeId :: typeId\n\u0009do ast.pos :: pos\n\u0009do ast.name :: null\n\u0009do ast.scopeParent :: null\n\u0009do ast.scopeChildren :: null\n\u0009do ast.refName :: null\n\u0009do ast.refItem :: null\n\u0009do ast.extra :: null\n\u0009do ast.publicInSrc :: false\nend func\n\nfunc makeExprNull(pos: \\pos@Pos): \\ast@AstExprValue\n\u0009var value: \\ast@AstExprValue :: #\\ast@AstExprValue\n\u0009do @initAstExpr(value, %exprValue, pos)\n\u0009block\n\u0009\u0009var type: \\ast@AstTypeNull :: #\\ast@AstTypeNull\n\u0009\u0009do @initAst(type, %typeNull, pos)\n\u0009\u0009do value.type :: type\n\u0009end block\n\u0009ret value\nend func\n\nfunc makeExprDefaultValue(type: \\ast@AstType, pos: \\pos@Pos): \\ast@AstExprValue\n\u0009if(\\ast@isEnum(type))\n\u0009\u0009var value: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009do @initAstExpr(value, %exprValuePrim, pos)\n\u0009\u0009do value.type :: type\n\u0009\u0009do value.value :: 0b64\n\u0009\u0009ret value\n\u0009end if\n\u0009if(\\ast@isNullable(type))\n\u0009\u0009ret @makeExprNull(pos)\n\u0009end if\n\u0009if(\\ast@isFloat(type))\n\u0009\u0009var value: \\ast@AstExprValueFloat :: #\\ast@AstExprValueFloat\n\u0009\u0009do @initAstExpr(value, %exprValueFloat, pos)\n\u0009\u0009do value.type :: type\n\u0009\u0009do value.value :: 0.0\n\u0009\u0009ret value\n\u0009end if\n\u0009switch(type.typeId)\n\u0009case %typeBit, %typePrim\n\u0009\u0009var value: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009do @initAstExpr(value, %exprValuePrim, pos)\n\u0009\u0009do value.type :: type\n\u0009\u0009do value.value :: 0b64\n\u0009\u0009ret value\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc refreshStats(stats: list<\\ast@AstStat>, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): list<\\ast@AstStat>\n\u0009var stats2: list<\\ast@AstStat> :: #list<\\ast@AstStat>\n\u0009do stats.head()\n\u0009while(!stats.term())\n\u0009\u0009var stat: \\ast@AstStat :: @rebuildStat(stats.get(), retType, parentFunc)\n\u0009\u0009if(stat <>& null)\n\u0009\u0009\u0009do stats2.add(stat)\n\u0009\u0009end if\n\u0009\u0009do stats.next()\n\u0009end while\n\u0009ret stats2\nend func\n\nfunc addSpecialFunc(class_: \\ast@AstClass, name: []char): \\ast@AstFunc\n\u0009; Make frameworks for \'_dtor\', \'_copy\', \'_toBin\', and \'_fromBin\'.\n\u0009var ast: \\ast@AstFunc :: #\\ast@AstFunc\n\u0009do @initAst(ast, %func_, class_.pos)\n\u0009do ast.name :: name\n\u0009do ast.funcOption :: %none\n\u0009do ast.funcAttr :: #list<[]char>\n\u0009do ast.args :: #list<\\ast@AstArg>\n\u0009do ast.ret_ :: null\n\u0009do ast.stats :: #list<\\ast@AstStat>\n\u0009block\n\u0009\u0009var me_: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009do @initAst(me_, %arg, class_.pos)\n\u0009\u0009do me_.kind :: %localArg\n\u0009\u0009do me_.refVar :: false\n\u0009\u0009do me_.expr :: null\n\u0009\u0009block\n\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009do @initAst(type, %typeUser, class_.pos)\n\u0009\u0009\u0009do type.refItem :: class_\n\u0009\u0009\u0009do me_.type :: type\n\u0009\u0009end block\n\u0009\u0009do ast.args.add(me_)\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009; These functions override functions of the root class.\n\u0009\u0009var item: \\ast@AstClassItem :: #\\ast@AstClassItem\n\u0009\u0009do item.override :: true\n\u0009\u0009do item.def :: ast\n\u0009\u0009do item.parentItem :: null\n\u0009\u0009var ptr: \\ast@AstClass :: class_.refItem $ \\ast@AstClass\n\u0009\u0009while(ptr.refItem <>& null)\n\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009end while\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ptr.items\n\u0009\u0009do items.head()\n\u0009\u0009while loop(!items.term())\n\u0009\u0009\u0009var item2: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item2.def.name = name)\n\u0009\u0009\u0009\u0009do item.parentItem :: item2\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009assert item.parentItem <>& null\n\u0009\u0009do item.public :: item.parentItem.public\n\u0009\u0009do class_.items.add(item)\n\u0009end block\n\u0009\n\u0009ret ast\nend func\n\nfunc cmpType(type1: \\ast@AstType, type2: \\ast@AstType, strict: bool): bool\n\u0009if(type1 =& null | type2 =& null)\n\u0009\u0009ret false\n\u0009end if\n\u0009var typeId1: \\ast@TypeId :: type1.typeId\n\u0009var typeId2: \\ast@TypeId :: type2.typeId\n\u0009block\n\u0009\u0009; Comparing \'null\' and \'nullable\' should be true.\n\u0009\u0009var nullable1: bool :: typeId1 = %typeUser & type1.refItem.typeId = %enum_ ?(false, typeId1.and(%typeNullable) = %typeNullable)\n\u0009\u0009var nullable2: bool :: typeId2 = %typeUser & type2.refItem.typeId = %enum_ ?(false, typeId2.and(%typeNullable) = %typeNullable)\n\u0009\u0009if(nullable1 & typeId2 = %typeNull | typeId1 = %typeNull & nullable2 | typeId1 = %typeNull & typeId2 = %typeNull)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009end block\n\u0009if(typeId1 = %typeArray & typeId2 = %typeArray)\n\u0009\u0009ret @cmpType((type1 $ \\ast@AstTypeArray).itemType, (type2 $ \\ast@AstTypeArray).itemType, true)\n\u0009end if\n\u0009if(typeId1 = %typeBit & typeId2 = %typeBit)\n\u0009\u0009ret(type1 $ \\ast@AstTypeBit).size = (type2 $ \\ast@AstTypeBit).size\n\u0009end if\n\u0009if(typeId1 = %typeFunc & typeId2 = %typeFunc)\n\u0009\u0009var func1: \\ast@AstTypeFunc :: type1 $ \\ast@AstTypeFunc\n\u0009\u0009var func2: \\ast@AstTypeFunc :: type2 $ \\ast@AstTypeFunc\n\u0009\u0009; TODO:\n\u0009\u0009{\n\u0009\u0009if(func1.funcOption <> func2.funcOption)\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009var attrs1: list<[]char> :: func1.funcAttr\n\u0009\u0009var attrs2: list<[]char> :: func2.funcAttr\n\u0009\u0009do attrs1.head()\n\u0009\u0009do attrs2.head()\n\u0009\u0009while(!attrs1.term() & !attrs2.term())\n\u0009\u0009\u0009if(attrs1.get() <> attrs2.get())\n\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do attrs1.next()\n\u0009\u0009\u0009do attrs2.next()\n\u0009\u0009end while\n\u0009\u0009if(!(attrs1.term() & attrs2.term()))\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009}\n\u0009\u0009var args1: list<\\ast@AstTypeFuncArg> :: func1.args\n\u0009\u0009var args2: list<\\ast@AstTypeFuncArg> :: func2.args\n\u0009\u0009do args1.head()\n\u0009\u0009do args2.head()\n\u0009\u0009while(!args1.term() & !args2.term())\n\u0009\u0009\u0009var arg1: \\ast@AstTypeFuncArg :: args1.get()\n\u0009\u0009\u0009var arg2: \\ast@AstTypeFuncArg :: args2.get()\n\u0009\u0009\u0009if(arg1.refVar <> arg2.refVar | !@cmpType(arg1.arg, arg2.arg, true))\n\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do args1.next()\n\u0009\u0009\u0009do args2.next()\n\u0009\u0009end while\n\u0009\u0009if(!(args1.term() & args2.term()))\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009if(func1.ret_ =& null & func2.ret_ =& null)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009\u0009if(func1.ret_ =& null | func2.ret_ =& null)\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009ret @cmpType(func1.ret_, func2.ret_, true)\n\u0009end if\n\u0009if(typeId1 = %typeGen & typeId2 = %typeGen)\n\u0009\u0009if((type1 $ \\ast@AstTypeGen).kind <> (type2 $ \\ast@AstTypeGen).kind)\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009ret @cmpType((type1 $ \\ast@AstTypeGen).itemType, (type2 $ \\ast@AstTypeGen).itemType, true)\n\u0009end if\n\u0009if(typeId1 = %typeDict & typeId2 = %typeDict)\n\u0009\u0009var dict1: \\ast@AstTypeDict :: type1 $ \\ast@AstTypeDict\n\u0009\u0009var dict2: \\ast@AstTypeDict :: type2 $ \\ast@AstTypeDict\n\u0009\u0009ret @cmpType(dict1.itemTypeKey, dict2.itemTypeKey, true) & @cmpType(dict1.itemTypeValue, dict2.itemTypeValue, true)\n\u0009end if\n\u0009if(typeId1 = %typePrim & typeId2 = %typePrim)\n\u0009\u0009ret(type1 $ \\ast@AstTypePrim).kind = (type2 $ \\ast@AstTypePrim).kind\n\u0009end if\n\u0009if(typeId1 = %typeUser & typeId2 = %typeUser)\n\u0009\u0009assert type1.refItem.typeId <> %alias_ & type2.refItem.typeId <> %alias_\n\u0009\u0009if(type1.refItem.typeId = %class_ & type2.refItem.typeId = %class_)\n\u0009\u0009\u0009if(strict)\n\u0009\u0009\u0009\u0009ret type1.refItem $ \\ast@AstClass =& type2.refItem $ \\ast@AstClass\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009; Check whether they are parent-child relationship.\n\u0009\u0009\u0009\u0009var class1: \\ast@AstClass :: type1.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009var class2: \\ast@AstClass :: type2.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009var ptr: \\ast@AstClass\n\u0009\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009\u0009{\n\u0009\u0009\u0009\u0009do ptr :: class2\n\u0009\u0009\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009\u0009\u0009if(ptr =& class1)\n\u0009\u0009\u0009\u0009\u0009\u0009ret true\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009}\n\u0009\u0009\u0009\u0009do ptr :: class1\n\u0009\u0009\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009\u0009\u0009if(ptr =& class2)\n\u0009\u0009\u0009\u0009\u0009\u0009ret true\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009ret type1.refItem =& type2.refItem\n\u0009end if\n\u0009if((typeId1 = %typeUser & type1.refItem.typeId = %enum_ | typeId1 = %typeEnumElement) &\n\u0009\u0009|(typeId2 = %typeUser & type2.refItem.typeId = %enum_ | typeId2 = %typeEnumElement) &\n\u0009\u0009|!(typeId1 = %typeEnumElement & typeId2 = %typeEnumElement))\n\u0009\u0009ret true\n\u0009end if\n\u0009ret false\nend func\n\nfunc makeMeDot(class_: \\ast@AstClass, arg: \\ast@AstArg, name: []char): \\ast@AstExprDot\n\u0009var ast: \\ast@AstExprDot :: #\\ast@AstExprDot\n\u0009do @initAstExpr(ast, %exprDot, class_.pos)\n\u0009do ast.member :: name\n\u0009do ast.classItem :: null\n\u0009block\n\u0009\u0009var me_: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009do @initAstExpr(me_, %exprRef, class_.pos)\n\u0009\u0009do me_.refName :: \"me\"\n\u0009\u0009do me_.refItem :: arg\n\u0009\u0009block\n\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009do @initAst(type, %typeUser, class_.pos)\n\u0009\u0009\u0009do type.refItem :: class_\n\u0009\u0009\u0009do me_.type :: type\n\u0009\u0009end block\n\u0009\u0009do ast.var_ :: me_\n\u0009end block\n\u0009ret ast\nend func\n\nfunc isComparable(type: \\ast@AstType, lessOrGreater: bool): bool\n\u0009; Note: \'null\' itself is an incomparable type.\n\u0009; The following types can be compared.\n\u0009if(type.typeId = %typeBit | \\ast@isInt(type) | \\ast@isFloat(type) | \\ast@isChar(type) | \\ast@isEnum(type) | \\ast@isClass(type) | \\ast@isStr(type) | type.typeId = %typeEnumElement)\n\u0009\u0009ret true\n\u0009end if\n\u0009\n\u0009; \'bool\' can be just determined whether the values match.\n\u0009if(!lessOrGreater & \\ast@isBool(type))\n\u0009\u0009ret true\n\u0009end if\n\u0009ret false\nend func\n\nfunc searchEnumElementValue(ast: \\ast@AstExprValueEnumElement, enum_: \\ast@AstEnum): bit64\n\u0009assert ast.type.typeId = %typeEnumElement\n\u0009do @rebuildEnum(enum_)\n\u0009var name: []char :: ast.identifier\n\u0009var items: list<\\ast@AstExpr> :: enum_.items\n\u0009do items.head()\n\u0009while(!items.term())\n\u0009\u0009var item: \\ast@AstExpr :: items.get()\n\u0009\u0009if(name = item.name)\n\u0009\u0009\u0009if(item.typeId <> %exprValuePrim)\n\u0009\u0009\u0009\u0009ret 0b64\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009ret(item $ \\ast@AstExprValuePrim).value\n\u0009\u0009end if\n\u0009\u0009do items.next()\n\u0009end while\n\u0009do \\err@err(%notExistedElementName, ast.pos, [name])\n\u0009ret 0b64\nend func\n\nfunc cacheSubExpr(stats: list<\\ast@AstStat>, ast: \\ast@AstExpr, pos: \\pos@Pos): \\ast@AstExpr\n\u0009if(ast =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(ast.typeId = %exprRef | ast.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009ret ast\n\u0009end if\n\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009do @initAstExpr(ref, %exprRef, pos)\n\u0009do ref.refName :: \"$\"\n\u0009do ref.varKind :: %localVar\n\u0009do ref.extra :: ref\n\u0009block\n\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009do @initAst(arg, %arg, pos)\n\u0009\u0009do arg.kind :: %localVar\n\u0009\u0009do arg.refVar :: false\n\u0009\u0009do arg.type :: ast.type\n\u0009\u0009do arg.expr :: null\n\u0009\u0009do arg.extra :: arg\n\u0009\u0009do ref.refItem :: arg\n\u0009\u0009do ref.type :: arg.type\n\u0009end block\n\u0009block\n\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009do @initAst(do_, %statDo, pos)\n\u0009\u0009block\n\u0009\u0009\u0009var exprAssign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(exprAssign, %expr2, pos)\n\u0009\u0009\u0009do exprAssign.kind :: %assign\n\u0009\u0009\u0009do exprAssign.children0 :: ref\n\u0009\u0009\u0009do exprAssign.children1 :: ast\n\u0009\u0009\u0009do do_.expr :: exprAssign\n\u0009\u0009end block\n\u0009\u0009do stats.add(@rebuildDo(do_))\n\u0009end block\n\u0009ret ref\nend func\n\nfunc bitCast(size: int, n: bit64): bit64\n\u0009switch(size)\n\u0009case 1\n\u0009\u0009ret n $ bit8 $ bit64\n\u0009case 2\n\u0009\u0009ret n $ bit16 $ bit64\n\u0009case 4\n\u0009\u0009ret n $ bit32 $ bit64\n\u0009case 8\n\u0009\u0009ret n\n\u0009\u0009assert false\n\u0009end switch\n\u0009ret 0b64\nend func\n\nfunc getTypeName(type: \\ast@AstType): []char\n\u0009if(type =& null)\n\u0009\u0009ret \"\"\n\u0009end if\n\u0009switch(type.typeId)\n\u0009case %typeArray\n\u0009\u0009ret \"[]\" ~ @getTypeName((type $ \\ast@AstTypeArray).itemType)\n\u0009case %typeBit\n\u0009\u0009ret \"bit\" ~ ((type $ \\ast@AstTypeBit).size * 8).toStr()\n\u0009case %typeFunc\n\u0009\u0009var type2: \\ast@AstTypeFunc :: type $ \\ast@AstTypeFunc\n\u0009\u0009var s: []char :: \"func<(\"\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstTypeFuncArg> :: type2.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var arg: \\ast@AstTypeFuncArg :: items.get()\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do s :~ \", \"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(arg.refVar)\n\u0009\u0009\u0009\u0009do s :~ \"&\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do s :~ @getTypeName(arg.arg)\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009if(type2.ret_ =& null)\n\u0009\u0009\u0009do s :~ \")>\"\n\u0009\u0009else\n\u0009\u0009\u0009do s :~ \"): \" ~ @getTypeName(type2.ret_) ~ \">\"\n\u0009\u0009end if\n\u0009\u0009ret s\n\u0009case %typeGen\n\u0009\u0009var type2: \\ast@AstTypeGen :: type $ \\ast@AstTypeGen\n\u0009\u0009var s: []char\n\u0009\u0009switch(type2.kind)\n\u0009\u0009case %list_\n\u0009\u0009\u0009do s :: \"list<\"\n\u0009\u0009case %stack_\n\u0009\u0009\u0009do s :: \"stack<\"\n\u0009\u0009case %queue_\n\u0009\u0009\u0009do s :: \"queue<\"\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009ret s ~ @getTypeName(type2.itemType) ~ \">\"\n\u0009case %typeDict\n\u0009\u0009var type2: \\ast@AstTypeDict :: type $ \\ast@AstTypeDict\n\u0009\u0009ret \"dict<\" ~ @getTypeName(type2.itemTypeKey) ~ \", \" ~ @getTypeName(type2.itemTypeValue) ~ \">\"\n\u0009case %typePrim\n\u0009\u0009var type2: \\ast@AstTypePrim :: type $ \\ast@AstTypePrim\n\u0009\u0009switch(type2.kind)\n\u0009\u0009case %int_\n\u0009\u0009\u0009ret \"int\"\n\u0009\u0009case %float_\n\u0009\u0009\u0009ret \"float\"\n\u0009\u0009case %char_\n\u0009\u0009\u0009ret \"char\"\n\u0009\u0009case %bool_\n\u0009\u0009\u0009ret \"bool\"\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009case %typeUser\n\u0009\u0009ret(type.refName = \"@\" ?(type.pos.srcName, \"\")) ~ type.refName\n\u0009case %typeEnumElement\n\u0009\u0009ret \"(UNKNOWN)\"\n\u0009default\n\u0009\u0009assert false\n\u0009\u0009ret \"\"\n\u0009end switch\nend func\n":true;
else if(p==="res/ast.kn")
return f?"+enum TypeId\n\u0009none :: 0x00\n\u0009root :: 0x01\n\u0009func_ :: 0x0100\n\u0009var_ :: 0x02\n\u0009const_ :: 0x03\n\u0009alias_ :: 0x04\n\u0009class_ :: 0x05\n\u0009enum_ :: 0x06\n\u0009arg :: 0x07\n\u0009stat :: 0x0200\n\u0009statBreakable :: 0x00010200\n\u0009statSkipable :: 0x01010200\n\u0009statEnd :: 0x0201\n\u0009statFunc :: 0x0202\n\u0009statVar :: 0x0203\n\u0009statConst :: 0x0204\n\u0009statAlias :: 0x0205\n\u0009statClass :: 0x0206\n\u0009statEnum :: 0x0207\n\u0009statIf :: 0x00010201\n\u0009statElIf :: 0x0208\n\u0009statElse :: 0x0209\n\u0009statSwitch :: 0x00010202\n\u0009statCase :: 0x020A\n\u0009statDefault :: 0x020B\n\u0009statWhile :: 0x01010201\n\u0009statFor :: 0x01010202\n\u0009statTry :: 0x00010203\n\u0009statCatch :: 0x020C\n\u0009statFinally :: 0x020D\n\u0009statThrow :: 0x020E\n\u0009statBlock :: 0x00010204\n\u0009statRet :: 0x020F\n\u0009statDo :: 0x0210\n\u0009statBreak :: 0x0211\n\u0009statSkip :: 0x0212\n\u0009statAssert :: 0x0213\n\u0009type :: 0x0400\n\u0009typeNullable :: 0x00010400\n\u0009typeArray :: 0x00010401\n\u0009typeBit :: 0x0401\n\u0009typeFunc :: 0x00010402\n\u0009typeGen :: 0x00010403\n\u0009typeDict :: 0x00010404\n\u0009typePrim :: 0x0402\n\u0009typeUser :: 0x00010405\n\u0009typeNull :: 0x0403\n\u0009typeEnumElement :: 0x0404\n\u0009expr :: 0x0800\n\u0009expr1 :: 0x0801\n\u0009expr2 :: 0x0802\n\u0009expr3 :: 0x0803\n\u0009exprNew :: 0x0804\n\u0009exprNewArray :: 0x0805\n\u0009exprAs :: 0x0806\n\u0009exprToBin :: 0x0807\n\u0009exprFromBin :: 0x0808\n\u0009exprCall :: 0x0809\n\u0009exprArray :: 0x080A\n\u0009exprDot :: 0x080B\n\u0009exprValue :: 0x00010800\n\u0009exprValuePrim :: 0x00010801\n\u0009exprValueStr :: 0x00010802\n\u0009exprValueEnumElement :: 0x00010803\n\u0009exprValueFloat :: 0x00010804\n\u0009exprValueArray :: 0x080C\n\u0009exprRef :: 0x080E\n\u0009info :: 0x10000000\nend enum\n\n+class HasType()\n\u0009+var typeId: @TypeId\nend class\n\n+class Ast(@HasType)\n\u0009+*func cmp(t: @Ast): int\n\u0009\u0009var meAddr: bit64 :: lib@addr(me)\n\u0009\u0009var tAddr: bit64 :: lib@addr(t)\n\u0009\u0009ret meAddr > tAddr ?(1, meAddr < tAddr ?(-1, 0))\n\u0009end func\n\u0009\n\u0009+var pos: \\pos@Pos\n\u0009+var name: []char\n\u0009+var scopeParent: @Ast\n\u0009+var scopeChildren: dict<[]char, @Ast>\n\u0009+var refName: []char\n\u0009+var refItem: @Ast\n\u0009+var extra: @HasType {\'AnalyzedCache\' etc.}\n\u0009+var publicInSrc: bool\nend class\n\n+class ScopeRefedItem()\n\u0009+var def: @Ast\n\u0009+var scope: @Ast\nend class\n\n+class AstRoot(@Ast)\n\u0009+var items: list<@Ast>\n\u0009+var scopeRefedItems: list<@ScopeRefedItem>\nend class\n\n+enum AstFuncOption\n\u0009none :: 0x00\n\u0009any :: 0x01 {Ignore type checking of \'me\' and the add the type of it to the second argument.}\n\u0009tme :: 0x02 {The function receives a value of the same type as \'me\' in the third argument.}\n\u0009rme :: 0x04 {The function returns a value of the same type as \'me\'.}\n\u0009tch :: 0x08 {The function receives a value of the type of elements of \'me\' in the third argument.}\n\u0009rch :: 0x10 {The function returns a value of the type of elements of \'me\'.}\n\u0009tkv :: 0x20 {The function receives a value of the type of \'key\' in the third argument and a value of the type of \'value\' in the fourth.}\n\u0009rac :: 0x40 {The function returns an array of the type of list elements of \'me\'.}\n\u0009frc :: 0x0080 {Force to define a method that cannot be overridden.}\n\u0009kvf :: 0x0100 {The function receives a callback function that receives key-value pairs.}\n\u0009rak :: 0x0200 {Return array of dictionary key.}\n\u0009rav :: 0x0400 {Return array of dictionary value.}\n\u0009mki :: 0x0800 {Make an instance automatically.}\n\u0009raw :: 0x1000 {Raw function.}\nend enum\n\n+class AstFunc(@Ast)\n\u0009+var funcOption: @AstFuncOption\n\u0009+var funcAttr: list<[]char>\n\u0009+var args: list<@AstArg>\n\u0009+var ret_: @AstType\n\u0009+var stats: list<@AstStat>\nend class\n\n+class AstVar(@Ast)\n\u0009+var arg: @AstArg\nend class\n\n+class AstConst(@Ast)\n\u0009+var arg: @AstArg\nend class\n\n+class AstAlias(@Ast)\n\u0009+var type: @AstType\nend class\n\n+class AstClassItem()\n\u0009+var public: bool\n\u0009+var override: bool\n\u0009+var def: @Ast\n\u0009+var parentItem: @AstClassItem\nend class\n\n+class AstClass(@Ast)\n\u0009+var items: list<@AstClassItem>\nend class\n\n+class AstEnum(@Ast)\n\u0009+var items: list<@AstExpr>\nend class\n\n+enum AstArgKind\n\u0009unknown\n\u0009global\n\u0009localArg\n\u0009localVar\n\u0009const_\n\u0009member\nend enum\n\n+class AstArg(@Ast)\n\u0009+var kind: @AstArgKind\n\u0009+var refVar: bool\n\u0009+var type: @AstType\n\u0009+var expr: @AstExpr\nend class\n\n+class AstStat(@Ast)\nend class\n\n+class AstStatBreakable(@AstStat)\n\u0009+var blockVar: @AstArg\nend class\n\n+class AstStatSkipable(@AstStatBreakable)\nend class\n\n+class AstStatFunc(@AstStat)\n\u0009+var def: @AstFunc\nend class\n\n+class AstStatVar(@AstStat)\n\u0009+var def: @AstVar\nend class\n\n+class AstStatConst(@AstStat)\n\u0009+var def: @AstConst\nend class\n\n+class AstStatAlias(@AstStat)\n\u0009+var def: @AstAlias\nend class\n\n+class AstStatClass(@AstStat)\n\u0009+var def: @AstClass\nend class\n\n+class AstStatEnum(@AstStat)\n\u0009+var def: @AstEnum\nend class\n\n+class AstStatIf(@AstStatBreakable)\n\u0009+var cond: @AstExpr\n\u0009+var statBlock: @AstStatBlock\n\u0009+var elIfs: list<@AstStatElIf>\n\u0009+var elseStatBlock: @AstStatBlock\nend class\n\n+class AstStatElIf(@AstStat)\n\u0009+var cond: @AstExpr\n\u0009+var statBlock: @AstStatBlock\nend class\n\n+class AstStatSwitch(@AstStatBreakable)\n\u0009+var cond: @AstExpr\n\u0009+var cases: list<@AstStatCase>\n\u0009+var defaultStatBlock: @AstStatBlock\nend class\n\n+class ExprPair()\n\u0009+var expr0: @AstExpr\n\u0009+var expr1: @AstExpr\nend class\n\n+class AstStatCase(@AstStat)\n\u0009+var conds: list<@ExprPair>\n\u0009+var statBlock: @AstStatBlock\nend class\n\n+class AstStatWhile(@AstStatSkipable)\n\u0009+var cond: @AstExpr\n\u0009+var skip_: bool\n\u0009+var stats: list<@AstStat>\nend class\n\n+class AstStatFor(@AstStatSkipable)\n\u0009+var start: @AstExpr\n\u0009+var cond: @AstExpr\n\u0009+var step: @AstExpr\n\u0009+var stats: list<@AstStat>\nend class\n\n+class AstStatTry(@AstStatBreakable)\n\u0009+var statBlock: @AstStatBlock\n\u0009+var catches: list<@AstStatCatch>\n\u0009+var finallyStatBlock: @AstStatBlock\nend class\n\n+class AstStatCatch(@AstStat)\n\u0009+var conds: list<@ExprPair>\n\u0009+var statBlock: @AstStatBlock\nend class\n\n+class AstStatThrow(@AstStat)\n\u0009+var code: @AstExpr\nend class\n\n+class AstStatBlock(@AstStatBreakable)\n\u0009+var stats: list<@AstStat>\nend class\n\n+class AstStatRet(@AstStat)\n\u0009+var value: @AstExpr\nend class\n\n+class AstStatDo(@AstStat)\n\u0009+var expr: @AstExpr\nend class\n\n+class AstStatAssert(@AstStat)\n\u0009+var cond: @AstExpr\nend class\n\n+class AstType(@Ast)\nend class\n\n+class AstTypeNullable(@AstType)\nend class\n\n+class AstTypeArray(@AstTypeNullable)\n\u0009+var itemType: @AstType\nend class\n\n+class AstTypeBit(@AstType)\n\u0009+var size: int\nend class\n\n+class AstTypeFuncArg()\n\u0009+var arg: @AstType\n\u0009+var refVar: bool\nend class\n\n+class AstTypeFunc(@AstTypeNullable)\n\u0009+var funcOption: @AstFuncOption\n\u0009+var funcAttr: list<[]char>\n\u0009+var args: list<@AstTypeFuncArg>\n\u0009+var ret_: @AstType\nend class\n\n+enum AstTypeGenKind\n\u0009list_\n\u0009stack_\n\u0009queue_\nend enum\n\n+class AstTypeGen(@AstTypeNullable)\n\u0009+var kind: @AstTypeGenKind\n\u0009+var itemType: @AstType\nend class\n\n+class AstTypeDict(@AstTypeNullable)\n\u0009+var itemTypeKey: @AstType\n\u0009+var itemTypeValue: @AstType\nend class\n\n+enum AstTypePrimKind\n\u0009int_\n\u0009float_\n\u0009char_\n\u0009bool_\nend enum\n\n+class AstTypePrim(@AstType)\n\u0009+var kind: @AstTypePrimKind\nend class\n\n+class AstTypeUser(@AstTypeNullable)\nend class\n\n+class AstTypeNull(@AstType)\nend class\n\n+class AstTypeEnumElement(@AstType)\nend class\n\n+enum AstExprVarKind\n\u0009unknown\n\u0009value\n\u0009localVar\n\u0009globalVar\n\u0009refVar\nend enum\n\n+class AstExpr(@Ast)\n\u0009+var type: @AstType\n\u0009+var varKind: @AstExprVarKind\nend class\n\n+enum AstExpr1Kind\n\u0009plus\n\u0009minus\n\u0009not\n\u0009copy\n\u0009len\nend enum\n\n+class AstExpr1(@AstExpr)\n\u0009+var kind: @AstExpr1Kind\n\u0009+var child: @AstExpr\nend class\n\n+enum AstExpr2Kind\n\u0009assign\n\u0009assignAdd\n\u0009assignSub\n\u0009assignMul\n\u0009assignDiv\n\u0009assignMod\n\u0009assignPow\n\u0009assignCat\n\u0009or\n\u0009and\n\u0009lt\n\u0009gt\n\u0009le\n\u0009ge\n\u0009eq\n\u0009nEq\n\u0009eqRef\n\u0009nEqRef\n\u0009cat\n\u0009add\n\u0009sub\n\u0009mul\n\u0009div\n\u0009mod\n\u0009pow\n\u0009swap\nend enum\n\n+class AstExpr2(@AstExpr)\n\u0009+var kind: @AstExpr2Kind\n\u0009+var children0: @AstExpr\n\u0009+var children1: @AstExpr\nend class\n\n+class AstExpr3(@AstExpr)\n\u0009+var children0: @AstExpr\n\u0009+var children1: @AstExpr\n\u0009+var children2: @AstExpr\nend class\n\n+class AstExprNew(@AstExpr)\n\u0009+var itemType: @AstType\nend class\n\n+class AstExprNewArray(@AstExpr)\n\u0009+var idces: list<@AstExpr>\n\u0009+var itemType: @AstType\nend class\n\n+enum AstExprAsKind\n\u0009as\n\u0009is\n\u0009nIs\nend enum\n\n+class AstExprAs(@AstExpr)\n\u0009+var kind: @AstExprAsKind\n\u0009+var child: @AstExpr\n\u0009+var childType: @AstType\nend class\n\n+class AstExprToBin(@AstExpr)\n\u0009+var child: @AstExpr\n\u0009+var childType: @AstType\nend class\n\n+class AstExprFromBin(@AstExpr)\n\u0009+var child: @AstExpr\n\u0009+var childType: @AstType\n\u0009+var offset: @AstExpr\nend class\n\n+class AstExprCallArg()\n\u0009+var arg: @AstExpr\n\u0009+var refVar: bool\n\u0009+var skipVar: bool\nend class\n\n+class AstExprCall(@AstExpr)\n\u0009+var func_: @AstExpr\n\u0009+var args: list<@AstExprCallArg>\nend class\n\n+class AstExprArray(@AstExpr)\n\u0009+var var_: @AstExpr\n\u0009+var idx: @AstExpr\nend class\n\n+class AstExprDot(@AstExpr)\n\u0009+var var_: @AstExpr\n\u0009+var member: []char\n\u0009+var classItem: @AstClassItem {For caching to store class references.}\nend class\n\n+class AstExprValue(@AstExpr)\nend class\n\n+class AstExprValuePrim(@AstExprValue)\n\u0009+var value: bit64\nend class\n\n+class AstExprValueStr(@AstExprValue)\n\u0009+var value: []char\nend class\n\n+class AstExprValueEnumElement(@AstExprValue)\n\u0009+var identifier: []char\nend class\n\n+class AstExprValueFloat(@AstExprValue)\n\u0009+var value: float\nend class\n\n+class AstExprValueArray(@AstExpr)\n\u0009+var values: list<@AstExpr>\nend class\n\n+func isInt(type: @AstType): bool\n\u0009ret type.typeId = %typePrim & (type $ @AstTypePrim).kind = %int_\nend func\n\n+func isFloat(type: @AstType): bool\n\u0009ret type.typeId = %typePrim & (type $ @AstTypePrim).kind = %float_\nend func\n\n+func isChar(type: @AstType): bool\n\u0009ret type.typeId = %typePrim & (type $ @AstTypePrim).kind = %char_\nend func\n\n+func isBool(type: @AstType): bool\n\u0009ret type.typeId = %typePrim & (type $ @AstTypePrim).kind = %bool_\nend func\n\n+func isRef(type: @AstType): bool\n\u0009var typeId: @TypeId :: type.typeId\n\u0009ret typeId = %typeArray | typeId = %typeGen | typeId = %typeDict | @isClass(type)\nend func\n\n+func isNullable(type: @AstType): bool\n\u0009ret type.typeId.and(%typeNullable) = %typeNullable & !@isEnum(type)\nend func\n\n+func isClass(type: @AstType): bool\n\u0009ret type.typeId = %typeUser & type.refItem.typeId = %class_\nend func\n\n+func isEnum(type: @AstType): bool\n\u0009ret type.typeId = %typeUser & type.refItem.typeId = %enum_\nend func\n\n+func isStr(type: @AstType): bool\n\u0009if(type.typeId = %typeArray)\n\u0009\u0009var itemType: @AstType :: (type $ @AstTypeArray).itemType\n\u0009\u0009if(itemType.typeId = %typePrim & (itemType $ @AstTypePrim).kind = %char_)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009end if\n\u0009ret false\nend func\n":true;
else if(p==="res/builtin_func.kn")
return f?"enum BuiltinFuncKind\n\u0009toStr\n\u0009bitEnum\n\u0009char_\n\u0009bit\n\u0009array\n\u0009str\n\u0009addGenDict\n\u0009getGenDict\n\u0009list_\n\u0009peekStackQueue\n\u0009intFloat\n\u0009arrayOfStr\n\u0009dict_\n\u0009arrayList\n\u0009delListDict\nend enum\n\nvar builtinFuncs: dict<[]char, @BuiltinFuncKind>\n\n+func chkBuiltinFuncType(member: &[]char, type: \\ast@AstType): bool\n\u0009if(@builtinFuncs =& null)\n\u0009\u0009do @builtinFuncs :: #dict<[]char, @BuiltinFuncKind>\n\u0009\u0009do @builtinFuncs.add(\"abs\", %intFloat)\n\u0009\u0009do @builtinFuncs.add(\"add\", %addGenDict)\n\u0009\u0009do @builtinFuncs.add(\"and\", %bitEnum)\n\u0009\u0009do @builtinFuncs.add(\"clamp\", %intFloat)\n\u0009\u0009do @builtinFuncs.add(\"clampMax\", %intFloat)\n\u0009\u0009do @builtinFuncs.add(\"clampMin\", %intFloat)\n\u0009\u0009do @builtinFuncs.add(\"del\", %delListDict)\n\u0009\u0009do @builtinFuncs.add(\"delNext\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"endian\", %bit)\n\u0009\u0009do @builtinFuncs.add(\"exist\", %dict_)\n\u0009\u0009do @builtinFuncs.add(\"fill\", %array)\n\u0009\u0009do @builtinFuncs.add(\"find\", %arrayList)\n\u0009\u0009do @builtinFuncs.add(\"findBin\", %array)\n\u0009\u0009do @builtinFuncs.add(\"findLast\", %arrayList)\n\u0009\u0009do @builtinFuncs.add(\"findStr\", %str)\n\u0009\u0009do @builtinFuncs.add(\"findStrEx\", %str)\n\u0009\u0009do @builtinFuncs.add(\"findStrLast\", %str)\n\u0009\u0009do @builtinFuncs.add(\"forEach\", %dict_)\n\u0009\u0009do @builtinFuncs.add(\"get\", %getGenDict)\n\u0009\u0009do @builtinFuncs.add(\"getOffset\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"head\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"idx\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"ins\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"join\", %arrayOfStr)\n\u0009\u0009do @builtinFuncs.add(\"lower\", %str)\n\u0009\u0009do @builtinFuncs.add(\"max\", %array)\n\u0009\u0009do @builtinFuncs.add(\"min\", %array)\n\u0009\u0009do @builtinFuncs.add(\"moveOffset\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"next\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"not\", %bitEnum)\n\u0009\u0009do @builtinFuncs.add(\"offset\", %char_)\n\u0009\u0009do @builtinFuncs.add(\"or\", %bitEnum)\n\u0009\u0009do @builtinFuncs.add(\"peek\", %peekStackQueue)\n\u0009\u0009do @builtinFuncs.add(\"prev\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"repeat\", %array)\n\u0009\u0009do @builtinFuncs.add(\"replace\", %str)\n\u0009\u0009do @builtinFuncs.add(\"reverse\", %array)\n\u0009\u0009do @builtinFuncs.add(\"sar\", %bit)\n\u0009\u0009do @builtinFuncs.add(\"shl\", %bit)\n\u0009\u0009do @builtinFuncs.add(\"shr\", %bit)\n\u0009\u0009do @builtinFuncs.add(\"shuffle\", %array)\n\u0009\u0009do @builtinFuncs.add(\"sign\", %intFloat)\n\u0009\u0009do @builtinFuncs.add(\"sort\", %arrayList)\n\u0009\u0009do @builtinFuncs.add(\"sortDesc\", %arrayList)\n\u0009\u0009do @builtinFuncs.add(\"split\", %str)\n\u0009\u0009do @builtinFuncs.add(\"sub\", %array)\n\u0009\u0009do @builtinFuncs.add(\"tail\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"term\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"termOffset\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"toArray\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"toArrayKey\", %dict_)\n\u0009\u0009do @builtinFuncs.add(\"toArrayValue\", %dict_)\n\u0009\u0009do @builtinFuncs.add(\"toBit64\", %str)\n\u0009\u0009do @builtinFuncs.add(\"toFloat\", %str)\n\u0009\u0009do @builtinFuncs.add(\"toInt\", %str)\n\u0009\u0009do @builtinFuncs.add(\"toStr\", %toStr)\n\u0009\u0009do @builtinFuncs.add(\"toStrFmt\", %intFloat)\n\u0009\u0009do @builtinFuncs.add(\"trim\", %str)\n\u0009\u0009do @builtinFuncs.add(\"trimLeft\", %str)\n\u0009\u0009do @builtinFuncs.add(\"trimRight\", %str)\n\u0009\u0009do @builtinFuncs.add(\"upper\", %str)\n\u0009\u0009do @builtinFuncs.add(\"xor\", %bitEnum)\n\u0009end if\n\u0009\n\u0009var found: bool\n\u0009var kind: @BuiltinFuncKind :: @builtinFuncs.get(member, &found)\n\u0009if(!found)\n\u0009\u0009ret false\n\u0009end if\n\u0009\n\u0009switch(kind)\n\u0009case %toStr\n\u0009\u0009if(\\ast@isInt(type) | \\ast@isFloat(type) | \\ast@isChar(type) | \\ast@isBool(type) | type.typeId = %typeBit | \\ast@isStr(type))\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %bitEnum\n\u0009\u0009if(type.typeId = %typeBit | \\ast@isEnum(type))\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %char_\n\u0009\u0009if(\\ast@isChar(type))\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %bit\n\u0009\u0009if(type.typeId = %typeBit)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %array\n\u0009\u0009if(type.typeId = %typeArray)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %str\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %addGenDict\n\u0009\u0009if(type.typeId = %typeGen)\n\u0009\u0009\u0009switch((type $ \\ast@AstTypeGen).kind)\n\u0009\u0009\u0009case %list_\n\u0009\u0009\u0009\u0009do member :: \"addList\"\n\u0009\u0009\u0009case %stack_\n\u0009\u0009\u0009\u0009do member :: \"addStack\"\n\u0009\u0009\u0009case %queue_\n\u0009\u0009\u0009\u0009do member :: \"addQueue\"\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009\u0009if(type.typeId = %typeDict)\n\u0009\u0009\u0009do member :: \"addDict\"\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %getGenDict\n\u0009\u0009if(type.typeId = %typeGen)\n\u0009\u0009\u0009switch((type $ \\ast@AstTypeGen).kind)\n\u0009\u0009\u0009case %list_\n\u0009\u0009\u0009\u0009do member :: \"getList\"\n\u0009\u0009\u0009case %stack_\n\u0009\u0009\u0009\u0009do member :: \"getStack\"\n\u0009\u0009\u0009case %queue_\n\u0009\u0009\u0009\u0009do member :: \"getQueue\"\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009\u0009if(type.typeId = %typeDict)\n\u0009\u0009\u0009do member :: \"getDict\"\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %list_\n\u0009\u0009if(type.typeId = %typeGen & (type $ \\ast@AstTypeGen).kind = %list_)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %peekStackQueue\n\u0009\u0009if(type.typeId = %typeGen)\n\u0009\u0009\u0009if((type $ \\ast@AstTypeGen).kind = %stack_)\n\u0009\u0009\u0009\u0009do member :: \"peekStack\"\n\u0009\u0009\u0009\u0009ret true\n\u0009\u0009\u0009elif((type $ \\ast@AstTypeGen).kind = %queue_)\n\u0009\u0009\u0009\u0009do member :: \"peekQueue\"\n\u0009\u0009\u0009\u0009ret true\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009case %intFloat\n\u0009\u0009if(\\ast@isInt(type))\n\u0009\u0009\u0009switch(member)\n\u0009\u0009\u0009case \"abs\"\n\u0009\u0009\u0009\u0009do member :: \"absInt\"\n\u0009\u0009\u0009case \"clamp\"\n\u0009\u0009\u0009\u0009do member :: \"clampInt\"\n\u0009\u0009\u0009case \"clampMin\"\n\u0009\u0009\u0009\u0009do member :: \"clampMinInt\"\n\u0009\u0009\u0009case \"clampMax\"\n\u0009\u0009\u0009\u0009do member :: \"clampMaxInt\"\n\u0009\u0009\u0009case \"sign\"\n\u0009\u0009\u0009\u0009do member :: \"signInt\"\n\u0009\u0009\u0009case \"toStrFmt\"\n\u0009\u0009\u0009\u0009do member :: \"toStrFmtInt\"\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009\u0009if(\\ast@isFloat(type))\n\u0009\u0009\u0009switch(member)\n\u0009\u0009\u0009case \"abs\"\n\u0009\u0009\u0009\u0009do member :: \"absFloat\"\n\u0009\u0009\u0009case \"clamp\"\n\u0009\u0009\u0009\u0009do member :: \"clampFloat\"\n\u0009\u0009\u0009case \"clampMin\"\n\u0009\u0009\u0009\u0009do member :: \"clampMinFloat\"\n\u0009\u0009\u0009case \"clampMax\"\n\u0009\u0009\u0009\u0009do member :: \"clampMaxFloat\"\n\u0009\u0009\u0009case \"sign\"\n\u0009\u0009\u0009\u0009do member :: \"signFloat\"\n\u0009\u0009\u0009case \"toStrFmt\"\n\u0009\u0009\u0009\u0009do member :: \"toStrFmtFloat\"\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %arrayOfStr\n\u0009\u0009if(type.typeId = %typeArray & \\ast@isStr((type $ \\ast@AstTypeArray).itemType))\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %dict_\n\u0009\u0009if(type.typeId = %typeDict)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %arrayList\n\u0009\u0009if(type.typeId = %typeArray)\n\u0009\u0009\u0009switch(member)\n\u0009\u0009\u0009case \"sort\"\n\u0009\u0009\u0009\u0009do member :: \"sortArray\"\n\u0009\u0009\u0009case \"sortDesc\"\n\u0009\u0009\u0009\u0009do member :: \"sortDescArray\"\n\u0009\u0009\u0009case \"find\"\n\u0009\u0009\u0009\u0009do member :: \"findArray\"\n\u0009\u0009\u0009case \"findLast\"\n\u0009\u0009\u0009\u0009do member :: \"findLastArray\"\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009\u0009if(type.typeId = %typeGen & (type $ \\ast@AstTypeGen).kind = %list_)\n\u0009\u0009\u0009switch(member)\n\u0009\u0009\u0009case \"sort\"\n\u0009\u0009\u0009\u0009do member :: \"sortList\"\n\u0009\u0009\u0009case \"sortDesc\"\n\u0009\u0009\u0009\u0009do member :: \"sortDescList\"\n\u0009\u0009\u0009case \"find\"\n\u0009\u0009\u0009\u0009do member :: \"findList\"\n\u0009\u0009\u0009case \"findLast\"\n\u0009\u0009\u0009\u0009do member :: \"findLastList\"\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %delListDict\n\u0009\u0009if(type.typeId = %typeGen & (type $ \\ast@AstTypeGen).kind = %list_)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009\u0009if(type.typeId = %typeDict)\n\u0009\u0009\u0009do member :: \"delDict\"\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009end switch\n\u0009\n\u0009ret false\nend func\n":true;
else if(p==="res/convert.kn")
return f?"+enum runtimeTypeId\n\u0009int_\n\u0009float_\n\u0009char_\n\u0009bool_\n\u0009bit8_\n\u0009bit16_\n\u0009bit32_\n\u0009bit64_\n\u0009func_\n\u0009enum_\n\u0009ref :: 0x80\n\u0009array\n\u0009list_\n\u0009stack_\n\u0009queue_\n\u0009dict_\n\u0009class_\nend enum\n\n+func getTypeId(type: \\ast@AstType): list<int>\n\u0009var result: list<int> :: #list<int>\n\u0009do @makeTypeIdRecursion(type, result)\n\u0009ret result\nend func\n\nfunc makeTypeIdRecursion(type: \\ast@AstType, output: list<int>)\n\u0009if(\\ast@isInt(type))\n\u0009\u0009do output.add(%int_ $ @runtimeTypeId $ int)\n\u0009\u0009ret\n\u0009end if\n\u0009if(\\ast@isFloat(type))\n\u0009\u0009do output.add(%float_ $ @runtimeTypeId $ int)\n\u0009\u0009ret\n\u0009end if\n\u0009if(\\ast@isChar(type))\n\u0009\u0009do output.add(%char_ $ @runtimeTypeId $ int)\n\u0009\u0009ret\n\u0009end if\n\u0009if(\\ast@isBool(type))\n\u0009\u0009do output.add(%bool_ $ @runtimeTypeId $ int)\n\u0009\u0009ret\n\u0009end if\n\u0009if(type.typeId = %typeBit)\n\u0009\u0009switch((type $ \\ast@AstTypeBit).size)\n\u0009\u0009case 1\n\u0009\u0009\u0009do output.add(%bit8_ $ @runtimeTypeId $ int)\n\u0009\u0009case 2\n\u0009\u0009\u0009do output.add(%bit16_ $ @runtimeTypeId $ int)\n\u0009\u0009case 4\n\u0009\u0009\u0009do output.add(%bit32_ $ @runtimeTypeId $ int)\n\u0009\u0009case 8\n\u0009\u0009\u0009do output.add(%bit64_ $ @runtimeTypeId $ int)\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009ret\n\u0009end if\n\u0009if(type.typeId = %typeFunc)\n\u0009\u0009do output.add(%func_ $ @runtimeTypeId $ int)\n\u0009\u0009ret\n\u0009end if\n\u0009if(\\ast@isEnum(type))\n\u0009\u0009do output.add(%enum_ $ @runtimeTypeId $ int)\n\u0009\u0009ret\n\u0009end if\n\u0009if(type.typeId = %typeArray)\n\u0009\u0009do output.add(%array $ @runtimeTypeId $ int)\n\u0009\u0009do @makeTypeIdRecursion((type $ \\ast@AstTypeArray).itemType, output)\n\u0009\u0009ret\n\u0009end if\n\u0009if(type.typeId = %typeGen)\n\u0009\u0009switch((type $ \\ast@AstTypeGen).kind)\n\u0009\u0009case %list_\n\u0009\u0009\u0009do output.add(%list_ $ @runtimeTypeId $ int)\n\u0009\u0009case %stack_\n\u0009\u0009\u0009do output.add(%stack_ $ @runtimeTypeId $ int)\n\u0009\u0009case %queue_\n\u0009\u0009\u0009do output.add(%queue_ $ @runtimeTypeId $ int)\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009do @makeTypeIdRecursion((type $ \\ast@AstTypeGen).itemType, output)\n\u0009\u0009ret\n\u0009end if\n\u0009if(type.typeId = %typeDict)\n\u0009\u0009do output.add(%dict_ $ @runtimeTypeId $ int)\n\u0009\u0009do @makeTypeIdRecursion((type $ \\ast@AstTypeDict).itemTypeKey, output)\n\u0009\u0009do @makeTypeIdRecursion((type $ \\ast@AstTypeDict).itemTypeValue, output)\n\u0009\u0009ret\n\u0009end if\n\u0009assert \\ast@isClass(type)\n\u0009do output.add(%class_ $ @runtimeTypeId $ int)\nend func\n":true;
else if(p==="res/cpp/")
return f?null:true;
else if(p==="res/cpp/output.kn")
return f?"const classTableItemSize: int :: 2\n\nvar funcs: queue<\\ast@AstFunc>\nvar classes: queue<\\ast@AstClass>\n\nvar uniqueId: []char\nvar classDefs: list<[]char>\nvar funcPrototypes: list<[]char>\nvar codes: list<[]char>\nvar classFuncs: list<[]char>\nvar tmpVars: list<@TmpVar>\nvar globalVars: list<\\ast@AstArg>\nvar localVars: list<\\ast@AstArg>\nvar classTableSize: int\nvar classTable: list<[]char>\n\n+class CppInfo(\\ast@HasType)\n\u0009+var id: []char\n\u0009+var breakLabel: []char\n\u0009+var skipLabel: []char\n\u0009+var classTableOffset: int\n\u0009+var alreadyWritten: bool\n\u0009+var breakLabelUsed: bool\n\u0009+var skipLabelUsed: bool\nend class\n\nclass TmpVar()\n\u0009+var identifier: []char\n\u0009+var type: \\ast@AstType\nend class\n\n+func output(entry: \\ast@AstFunc, resFiles: list<[]char>): bool\n\u0009do @funcs :: #queue<\\ast@AstFunc>\n\u0009do @funcs.add(entry)\n\u0009do @classes :: #queue<\\ast@AstClass>\n\u0009\n\u0009do @uniqueId :: \"a\"\n\u0009do @classDefs :: #list<[]char>\n\u0009do @funcPrototypes :: #list<[]char>\n\u0009do @codes :: #list<[]char>\n\u0009do @classFuncs :: #list<[]char>\n\u0009do @tmpVars :: #list<@TmpVar>\n\u0009do @globalVars :: #list<\\ast@AstArg>\n\u0009do @localVars :: #list<\\ast@AstArg>\n\u0009do @classTableSize :: 0\n\u0009do @classTable :: #list<[]char>\n\u0009\n\u0009while(^@funcs > 0 | ^@classes > 0)\n\u0009\u0009while(^@funcs > 0)\n\u0009\u0009\u0009var func_: \\ast@AstFunc :: @funcs.get()\n\u0009\u0009\u0009do @buildFunc(func_)\n\u0009\u0009end while\n\u0009\u0009while(^@classes > 0)\n\u0009\u0009\u0009var class_: \\ast@AstClass :: @classes.get()\n\u0009\u0009\u0009do @buildClass(class_)\n\u0009\u0009end while\n\u0009end while\n\u0009\n\u0009do @write(resFiles)\n\u0009ret true\nend func\n\nfunc buildFunc(ast: \\ast@AstFunc)\n\u0009var info: @CppInfo :: @getInfo(ast)\n\u0009if(info.alreadyWritten)\n\u0009\u0009ret\n\u0009end if\n\u0009do info.alreadyWritten :: true\n\u0009\n\u0009var template: []char :: \"\"\n\u0009if(ast.funcOption.and(%any) = %any)\n\u0009\u0009if(ast.funcOption.and(%tkv) = %tkv)\n\u0009\u0009\u0009do template :: \"template<typename T_, typename K_, typename V_> \"\n\u0009\u0009elif(ast.funcOption.and(%tch) = %tch)\n\u0009\u0009\u0009if(ast.funcOption.and(%rch) = %rch)\n\u0009\u0009\u0009\u0009do template :: \"template<typename T_, typename C_, typename R_> \"\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do template :: \"template<typename T_, typename C_> \"\n\u0009\u0009\u0009end if\n\u0009\u0009elif(ast.funcOption.and(%rch) = %rch)\n\u0009\u0009\u0009do template :: \"template<typename T_, typename R_> \"\n\u0009\u0009elif(ast.funcOption.and(%kvf) = %kvf)\n\u0009\u0009\u0009do template :: \"template<typename T_, typename K_, typename V_> \"\n\u0009\u0009elif(ast.funcOption.and(%rac) = %rac)\n\u0009\u0009\u0009do template :: \"template<typename T_, typename C_> \"\n\u0009\u0009elif(ast.funcOption.and(%rak) = %rak)\n\u0009\u0009\u0009do template :: \"template<typename T_, typename K_> \"\n\u0009\u0009elif(ast.funcOption.and(%rav) = %rav)\n\u0009\u0009\u0009do template :: \"template<typename T_, typename V_> \"\n\u0009\u0009else\n\u0009\u0009\u0009do template :: \"template<typename T_> \"\n\u0009\u0009end if\n\u0009end if\n\u0009\n\u0009var retType: []char\n\u0009if(ast.funcOption.and(%rch) = %rch)\n\u0009\u0009do retType :: \"R_\"\n\u0009elif(ast.funcOption.and(%rme) = %rme)\n\u0009\u0009do retType :: \"T_\"\n\u0009elif(ast.funcOption.and(%rac) = %rac)\n\u0009\u0009do retType :: \"Array_<C_>*\"\n\u0009elif(ast.funcOption.and(%rak) = %rak)\n\u0009\u0009do retType :: \"Array_<K_>*\"\n\u0009elif(ast.funcOption.and(%rav) = %rav)\n\u0009\u0009do retType :: \"Array_<V_>*\"\n\u0009else\n\u0009\u0009do retType :: @getType(ast.ret_)\n\u0009end if\n\u0009\n\u0009var arg: []char :: \"\"\n\u0009block\n\u0009\u0009var idx: int :: 0\n\u0009\u0009var items: list<\\ast@AstArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstArg :: items.get()\n\u0009\u0009\u0009if(idx <> 0)\n\u0009\u0009\u0009\u0009do arg :~ \", \"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009var info2: @CppInfo :: @getInfo(item)\n\u0009\u0009\u0009if(ast.funcOption.and(%any) = %any & idx = 0)\n\u0009\u0009\u0009\u0009assert \\ast@isInt(item.type)\n\u0009\u0009\u0009\u0009do arg :~ \"T_\"\n\u0009\u0009\u0009elif(ast.funcOption.and(%tkv) = %tkv & idx = 2)\n\u0009\u0009\u0009\u0009assert \\ast@isInt(item.type)\n\u0009\u0009\u0009\u0009do arg :~ \"K_\"\n\u0009\u0009\u0009elif(ast.funcOption.and(%tkv) = %tkv & idx = 3)\n\u0009\u0009\u0009\u0009assert \\ast@isInt(item.type)\n\u0009\u0009\u0009\u0009do arg :~ \"V_\"\n\u0009\u0009\u0009elif(ast.funcOption.and(%tch) = %tch & idx = 2)\n\u0009\u0009\u0009\u0009assert \\ast@isInt(item.type)\n\u0009\u0009\u0009\u0009do arg :~ \"C_\"\n\u0009\u0009\u0009elif(ast.funcOption.and(%tme) = %tme & idx = 2)\n\u0009\u0009\u0009\u0009assert \\ast@isInt(item.type)\n\u0009\u0009\u0009\u0009do arg :~ \"T_\"\n\u0009\u0009\u0009elif(ast.funcOption.and(%kvf) = %kvf & idx = 2)\n\u0009\u0009\u0009\u0009assert \\ast@isInt(item.type)\n\u0009\u0009\u0009\u0009do arg :~ \"const void*\"\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do arg :~ \"\\{@getType(item.type)}\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(item.refVar)\n\u0009\u0009\u0009\u0009do arg :~ \"*\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do arg :~ \" \\{info2.id}\"\n\u0009\u0009\u0009if(item.name <>& null)\n\u0009\u0009\u0009\u0009do arg :~ \" /*\\{item.name}*/\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009end while\n\u0009end block\n\u0009\n\u0009if(ast.name <>& null)\n\u0009\u0009do @codes.add(\"// \\{ast.name}\\n\")\n\u0009end if\n\u0009do @funcPrototypes.add(\"\\{template}static \\{retType} \\{info.id}(\\{arg});\\n\")\n\u0009do @codes.add(\"\\{template}static \\{retType} \\{info.id}(\\{arg}){\\n\")\n\u0009\n\u0009if(ast.funcOption.and(%raw) = %raw)\n\u0009\u0009if(^ast.funcAttr = 1)\n\u0009\u0009\u0009do ast.funcAttr.head()\n\u0009\u0009\u0009var hasMembers: bool :: false\n\u0009\u0009\u0009if(^ast.args > 0)\n\u0009\u0009\u0009\u0009do ast.args.head()\n\u0009\u0009\u0009\u0009var arg2: \\ast@AstArg :: ast.args.get()\n\u0009\u0009\u0009\u0009if(arg2.type.refItem <>& null & arg2.type.refItem.typeId = %class_)\n\u0009\u0009\u0009\u0009\u0009var members: list<\\ast@AstClassItem> :: (arg2.type.refItem $ \\ast@AstClass).items\n\u0009\u0009\u0009\u0009\u0009do \\cpp\\raw_funcs@write(@codes, ast.funcAttr.get(), ast.args, members)\n\u0009\u0009\u0009\u0009\u0009do hasMembers :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!hasMembers)\n\u0009\u0009\u0009\u0009do \\cpp\\raw_funcs@write(@codes, ast.funcAttr.get(), ast.args, null)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009end if\n\u0009else\n\u0009\u0009do @codes.tail()\n\u0009\u0009var localVarPos: int :: @codes.idx()\n\u0009\u0009\n\u0009\u0009do @buildStats(ast.stats, null, null)\n\u0009\u0009\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\n\u0009\u0009do @codes.head()\n\u0009\u0009do @codes.moveOffset(localVarPos)\n\u0009\u0009do @codes.next()\n\u0009\u0009do @localVars.head()\n\u0009\u0009while(!@localVars.term())\n\u0009\u0009\u0009var localVar: \\ast@AstArg :: @localVars.get()\n\u0009\u0009\u0009var info2: @CppInfo :: @getInfo(localVar)\n\u0009\u0009\u0009if(localVar.name =& null)\n\u0009\u0009\u0009\u0009do @codes.ins(\"\\{@getType(localVar.type)} \\{info2.id};\\n\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.ins(\"\\{@getType(localVar.type)} \\{info2.id}; // \\{localVar.name}\\n\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @localVars.del()\n\u0009\u0009end while\n\u0009\u0009do @tmpVars.head()\n\u0009\u0009while(!@tmpVars.term())\n\u0009\u0009\u0009var tmpVar: @TmpVar :: @tmpVars.get()\n\u0009\u0009\u0009do @codes.ins(\"\\{@getType(tmpVar.type)} \\{tmpVar.identifier};\\n\")\n\u0009\u0009\u0009do @tmpVars.del()\n\u0009\u0009end while\n\u0009end if\nend func\n\nfunc buildClass(ast: \\ast@AstClass)\n\u0009var parentId: []char :: null\n\u0009if(ast.refItem <>& null)\n\u0009\u0009do parentId :: @refClass(ast.refItem $ \\ast@AstClass)\n\u0009end if\n\u0009if(parentId =& null)\n\u0009\u0009do parentId :: \"Class_\"\n\u0009end if\n\u0009var info: @CppInfo :: @getInfo(ast)\n\u0009block\n\u0009\u0009assert info.classTableOffset <> -1\n\u0009\u0009var parentOffset: int\n\u0009\u0009if(ast.refItem =& null)\n\u0009\u0009\u0009do parentOffset :: 0\n\u0009\u0009else\n\u0009\u0009\u0009var parentInfo: @CppInfo :: @getInfo(ast.refItem)\n\u0009\u0009\u0009assert parentInfo.classTableOffset <> -1\n\u0009\u0009\u0009do parentOffset :: parentInfo.classTableOffset\n\u0009\u0009end if\n\u0009\u0009do @classTable.add(\"classTable_[\\{info.classTableOffset * @classTableItemSize}] = \\{parentOffset * @classTableItemSize};\\n\")\n\u0009end block\n\u0009if(ast.name <>& null)\n\u0009\u0009do @classDefs.add(\"// \\{ast.name}\\n\")\n\u0009end if\n\u0009do @classDefs.add(\"class \\{info.id} : public \\{parentId}{\\npublic:\\n\")\n\u0009do @classDefs.add(\"\\{info.id}();\\n\")\n\u0009do @classFuncs.add(\"\\{info.id}::\\{info.id}(): \\{parentId}()\")\n\u0009block\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item.def.typeId = %var_)\n\u0009\u0009\u0009\u0009var var_: \\ast@AstVar :: item.def $ \\ast@AstVar\n\u0009\u0009\u0009\u0009var info2: @CppInfo :: @getInfo(var_.arg)\n\u0009\u0009\u0009\u0009do @classFuncs.add(\", \\{info2.id}()\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do @classFuncs.add(\"{\\n\")\n\u0009do @classFuncs.add(\"Y = \\{info.classTableOffset * @classTableItemSize};\\n\")\n\u0009block\n\u0009\u0009var ctor: \\ast@AstFunc :: findFunc(ast, \"ctor\")\n\u0009\u0009if(ctor <>& null)\n\u0009\u0009\u0009var ctorInfo: @CppInfo :: @getInfo(ctor)\n\u0009\u0009\u0009do @classFuncs.add(\"\\{ctorInfo.id}(this);\\n\")\n\u0009\u0009end if\n\u0009end block\n\u0009do @classFuncs.add(\"}\\n\")\n\u0009; TODO: Destructor.\n\u0009block\n\u0009\u0009var cmp: \\ast@AstFunc :: findFunc(ast, \"cmp\")\n\u0009\u0009if(cmp <>& null)\n\u0009\u0009\u0009var cmpInfo: @CppInfo :: @getInfo(cmp)\n\u0009\u0009\u0009do @classDefs.add(\"virtual int64_t cmp_(Class_* t) override;\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"int64_t \\{info.id}::cmp_(Class_* t){\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"\\{info.id}* u = reinterpret_cast<\\{info.id}*>(t);\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"return \\{cmpInfo.id}(this, u);\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"}\\n\")\n\u0009\u0009end if\n\u0009\u0009var copy: \\ast@AstFunc :: findFunc(ast, \"_copy\")\n\u0009\u0009block\n\u0009\u0009\u0009assert copy <>& null\n\u0009\u0009\u0009var copyInfo: @CppInfo :: @getInfo(copy)\n\u0009\u0009\u0009do @classDefs.add(\"virtual Class_* copy_(Class_* t) override;\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"Class_* \\{info.id}::copy_(Class_* t){\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"return \\{copyInfo.id}(this);\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"}\\n\")\n\u0009\u0009end block\n\u0009end block\n\u0009block\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item.def.typeId = %var_)\n\u0009\u0009\u0009\u0009var var_: \\ast@AstVar :: item.def $ \\ast@AstVar\n\u0009\u0009\u0009\u0009var info2: @CppInfo :: @getInfo(var_.arg)\n\u0009\u0009\u0009\u0009if(var_.arg.name =& null)\n\u0009\u0009\u0009\u0009\u0009do @classDefs.add(\"\\{@getType(var_.arg.type)} \\{info2.id};\\n\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @classDefs.add(\"\\{@getType(var_.arg.type)} \\{info2.id}; // \\{var_.arg.name}\\n\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do @classDefs.add(\"};\\n\")\n\u0009\n\u0009func findFunc(ast: \\ast@AstClass, name: []char): \\ast@AstFunc\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item.def.typeId = %func_ & item.def.name = name)\n\u0009\u0009\u0009\u0009ret item.def $ \\ast@AstFunc\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009ret null\n\u0009end func\nend func\n\nfunc buildStats(stats: list<\\ast@AstStat>, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009do stats.head()\n\u0009while(!stats.term())\n\u0009\u0009var stat: \\ast@AstStat :: stats.get()\n\u0009\u0009switch(stat.typeId)\n\u0009\u0009case %statIf\n\u0009\u0009\u0009do @buildIf(stat $ \\ast@AstStatIf, breakStat, skipStat)\n\u0009\u0009case %statSwitch\n\u0009\u0009\u0009do @buildSwitch(stat $ \\ast@AstStatSwitch, breakStat, skipStat)\n\u0009\u0009case %statWhile\n\u0009\u0009\u0009do @buildWhile(stat $ \\ast@AstStatWhile, breakStat, skipStat)\n\u0009\u0009case %statFor\n\u0009\u0009\u0009do @buildFor(stat $ \\ast@AstStatFor, breakStat, skipStat)\n\u0009\u0009case %statTry\n\u0009\u0009\u0009do @buildTry(stat $ \\ast@AstStatTry, breakStat, skipStat)\n\u0009\u0009case %statThrow\n\u0009\u0009\u0009do @buildThrow(stat $ \\ast@AstStatThrow)\n\u0009\u0009case %statBlock\n\u0009\u0009\u0009do @buildBlock(stat $ \\ast@AstStatBlock, breakStat, skipStat)\n\u0009\u0009case %statRet\n\u0009\u0009\u0009do @buildRet(stat $ \\ast@AstStatRet)\n\u0009\u0009case %statDo\n\u0009\u0009\u0009do @buildDo(stat $ \\ast@AstStatDo)\n\u0009\u0009case %statBreak\n\u0009\u0009\u0009do @buildBreak(stat $ \\ast@AstStat, breakStat)\n\u0009\u0009case %statSkip\n\u0009\u0009\u0009do @buildSkip(stat $ \\ast@AstStat, skipStat)\n\u0009\u0009case %statAssert\n\u0009\u0009\u0009do @buildAssert(stat $ \\ast@AstStatAssert)\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009do stats.next()\n\u0009end while\nend func\n\nfunc buildIf(ast: \\ast@AstStatIf, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009var infoMe: @CppInfo :: @getInfo(ast)\n\u0009if(ast.cond =& null)\n\u0009\u0009; Optimized code.\n\u0009\u0009do @buildBlock(ast.statBlock, breakStat, skipStat)\n\u0009\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009\u0009end if\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009do @codes.add(\"if(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\"){\\n\")\n\u0009do @buildBlock(ast.statBlock, breakStat, skipStat)\n\u0009do @codes.add(\"}\\n\")\n\u0009block\n\u0009\u0009var items: list<\\ast@AstStatElIf> :: ast.elIfs\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatElIf :: items.get()\n\u0009\u0009\u0009do @codes.add(\"else if(\")\n\u0009\u0009\u0009do @buildExpr(item.cond)\n\u0009\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009\u0009do @buildBlock(item.statBlock, breakStat, skipStat)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009if(ast.elseStatBlock <>& null)\n\u0009\u0009do @codes.add(\"else{\\n\")\n\u0009\u0009do @buildBlock(ast.elseStatBlock, breakStat, skipStat)\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009end if\n\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009end if\nend func\n\nfunc buildSwitch(ast: \\ast@AstStatSwitch, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009var infoMe: @CppInfo :: @getInfo(ast)\n\u0009var info: @CppInfo :: @getInfo(ast.blockVar)\n\u0009if(!info.alreadyWritten)\n\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009do @localVars.add(ast.blockVar)\n\u0009end if\n\u0009var useSwitch: bool :: false\n\u0009if chk(\\ast@isInt(ast.cond.type) | \\ast@isChar(ast.cond.type) | \\ast@isEnum(ast.cond.type) | ast.cond.type.typeId = %typeBit)\n\u0009\u0009do useSwitch :: true\n\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009if(exprs.expr0.typeId.and(%exprValue) <> %exprValue | exprs.expr1 <>& null)\n\u0009\u0009\u0009\u0009\u0009do useSwitch :: false\n\u0009\u0009\u0009\u0009\u0009break chk\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end if\n\u0009do @codes.add(\"\\{info.id} = \")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\";\\n\")\n\u0009if(useSwitch)\n\u0009\u0009do @codes.add(\"switch(\\{info.id}){\\n\")\n\u0009\u0009block\n\u0009\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009\u0009assert exprs.expr1 =& null\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"case \")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\":\\n\")\n\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @buildBlock(item.statBlock, ast, skipStat)\n\u0009\u0009\u0009\u0009do @codes.add(\"break;\\n\")\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009if(ast.defaultStatBlock <>& null)\n\u0009\u0009\u0009do @codes.add(\"default:\\n\")\n\u0009\u0009\u0009do @buildBlock(ast.defaultStatBlock, ast, skipStat)\n\u0009\u0009\u0009do @codes.add(\"break;\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009else\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009do @codes.add(\"if(\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"else if(\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009var first2: bool :: true\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009if(first2)\n\u0009\u0009\u0009\u0009\u0009do first2 :: false\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\" || \")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(exprs.expr1 =& null)\n\u0009\u0009\u0009\u0009\u0009if(\\ast@isRef(ast.cond.type))\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"cmp_(\\{info.id}, (\")\n\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\")) == 0\")\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"\\{info.id} == (\")\n\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\") <= \\{info.id} && \\{info.id} <= (\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr1)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009\u0009do @buildBlock(item.statBlock, breakStat, skipStat)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009if(ast.defaultStatBlock <>& null)\n\u0009\u0009\u0009if(^items = 0)\n\u0009\u0009\u0009\u0009do @codes.add(\"{\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"else{\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @buildBlock(ast.defaultStatBlock, breakStat, skipStat)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009end if\n\u0009end if\n\u0009\n\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009end if\nend func\n\nfunc buildWhile(ast: \\ast@AstStatWhile, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009var infoMe: @CppInfo :: @getInfo(ast)\n\u0009if(ast.cond =& null)\n\u0009\u0009do @codes.add(\"for(;;){\\n\")\n\u0009\u0009do @buildStats(ast.stats, ast, ast)\n\u0009\u0009if(infoMe.skipLabel <>& null & infoMe.skipLabelUsed)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.skipLabel}:;\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009\u0009end if\n\u0009\u0009ret\n\u0009end if\n\u0009if(ast.skip_)\n\u0009\u0009do @codes.add(\"do{\\n\")\n\u0009\u0009do @buildStats(ast.stats, ast, ast)\n\u0009\u0009if(infoMe.skipLabel <>& null & infoMe.skipLabelUsed)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.skipLabel}:;\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"}while(\")\n\u0009\u0009do @buildExpr(ast.cond)\n\u0009\u0009do @codes.add(\");\\n\")\n\u0009\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009\u0009end if\n\u0009\u0009ret\n\u0009end if\n\u0009do @codes.add(\"while(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\"){\\n\")\n\u0009do @buildStats(ast.stats, ast, ast)\n\u0009if(infoMe.skipLabel <>& null & infoMe.skipLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.skipLabel}:;\\n\")\n\u0009end if\n\u0009do @codes.add(\"}\\n\")\n\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009end if\nend func\n\nfunc buildFor(ast: \\ast@AstStatFor, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009var infoMe: @CppInfo :: @getInfo(ast)\n\u0009var info: @CppInfo :: @getInfo(ast.blockVar)\n\u0009if(!info.alreadyWritten)\n\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009do @localVars.add(ast.blockVar)\n\u0009end if\n\u0009var endId: []char :: @addTmpVar(ast.cond.type)\n\u0009do @codes.add(\"for(\\{info.id} = (\")\n\u0009do @buildExpr(ast.start)\n\u0009do @codes.add(\"), \\{endId} = (\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\"); \\{info.id} \")\n\u0009assert ast.step.typeId = %exprValuePrim & \\ast@isInt(ast.cond.type)\n\u0009var step: int :: (ast.step $ \\ast@AstExprValuePrim).value $ int\n\u0009if(step > 0)\n\u0009\u0009do @codes.add(\"<=\")\n\u0009else\n\u0009\u0009do @codes.add(\">=\")\n\u0009end if\n\u0009do @codes.add(\" \\{endId}; \\{info.id} += (\")\n\u0009do @buildExpr(ast.step)\n\u0009do @codes.add(\")){\\n\")\n\u0009do @buildStats(ast.stats, ast, ast)\n\u0009if(infoMe.skipLabel <>& null & infoMe.skipLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.skipLabel}:;\\n\")\n\u0009end if\n\u0009do @codes.add(\"}\\n\")\n\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009end if\nend func\n\nfunc buildTry(ast: \\ast@AstStatTry, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009var infoMe: @CppInfo :: @getInfo(ast)\n\u0009var info: @CppInfo :: @getInfo(ast.blockVar)\n\u0009if(!info.alreadyWritten)\n\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009do @localVars.add(ast.blockVar)\n\u0009end if\n\u0009if(ast.finallyStatBlock <>& null)\n\u0009\u0009do @codes.add(\"try{\\n\")\n\u0009end if\n\u0009do @codes.add(\"try{\\n\")\n\u0009do @buildBlock(ast.statBlock, breakStat, skipStat)\n\u0009if(ast.finallyStatBlock <>& null)\n\u0009\u0009do @buildBlock(ast.finallyStatBlock, breakStat, skipStat)\n\u0009end if\n\u0009do @codes.add(\"}catch(int64_t \\{info.id}){\\n\")\n\u0009block\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstStatCatch> :: ast.catches\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatCatch :: items.get()\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009do @codes.add(\"if(\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"else if(\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009var first2: bool :: true\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009if(first2)\n\u0009\u0009\u0009\u0009\u0009do first2 :: false\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\" || \")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(exprs.expr1 =& null)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"\\{info.id} == (\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\") <= \\{info.id} && \\{info.id} <= (\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr1)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009\u0009do @buildBlock(item.statBlock, breakStat, skipStat)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009if(first)\n\u0009\u0009\u0009do @codes.add(\"{\\n\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"else{\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"throw;\\n}\\n\")\n\u0009end block\n\u0009do @codes.add(\"}\\n\")\n\u0009if(ast.finallyStatBlock <>& null)\n\u0009\u0009do @codes.add(\"}\\ncatch(...){\\n\")\n\u0009\u0009do @buildBlock(ast.finallyStatBlock, breakStat, skipStat)\n\u0009\u0009do @codes.add(\"throw;\\n}\\n\")\n\u0009end if\n\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009end if\nend func\n\nfunc buildThrow(ast: \\ast@AstStatThrow)\n\u0009do @codes.add(\"throw \")\n\u0009do @buildExpr(ast.code)\n\u0009do @codes.add(\";\\n\")\nend func\n\nfunc buildBlock(ast: \\ast@AstStatBlock, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009var infoMe: @CppInfo :: @getInfo(ast)\n\u0009do @buildStats(ast.stats, breakStat, skipStat)\n\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009end if\nend func\n\nfunc buildRet(ast: \\ast@AstStatRet)\n\u0009if(ast.value =& null)\n\u0009\u0009do @codes.add(\"return;\\n\")\n\u0009else\n\u0009\u0009do @codes.add(\"return \")\n\u0009\u0009do @buildExpr(ast.value)\n\u0009\u0009do @codes.add(\";\\n\")\n\u0009end if\nend func\n\nfunc buildDo(ast: \\ast@AstStatDo)\n\u0009do @buildExpr(ast.expr)\n\u0009do @codes.add(\";\\n\")\nend func\n\nfunc buildBreak(ast: \\ast@AstStat, breakStat: \\ast@AstStat)\n\u0009assert ast.refItem.typeId.and(%statBreakable) = %statBreakable\n\u0009if(ast.refItem =& breakStat)\n\u0009\u0009do @codes.add(\"break;\\n\")\n\u0009else\n\u0009\u0009var info: @CppInfo :: @getInfo(ast.refItem)\n\u0009\u0009do info.breakLabelUsed :: true\n\u0009\u0009do @codes.add(\"goto \\{info.breakLabel};\\n\")\n\u0009end if\nend func\n\nfunc buildSkip(ast: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009assert ast.refItem.typeId.and(%statSkipable) = %statSkipable\n\u0009if(ast.refItem =& skipStat)\n\u0009\u0009do @codes.add(\"continue;\\n\")\n\u0009else\n\u0009\u0009var info: @CppInfo :: @getInfo(ast.refItem)\n\u0009\u0009do info.skipLabelUsed :: true\n\u0009\u0009do @codes.add(\"goto \\{info.skipLabel};\\n\")\n\u0009end if\nend func\n\nfunc buildAssert(ast: \\ast@AstStatAssert)\n\u0009do @codes.add(\"if(!(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\")){\\nthrow \\{excpt@dbgAssertFailed $ bit32}U;\\n}\\n\")\nend func\n\nfunc buildExpr(ast: \\ast@AstExpr)\n\u0009switch(ast.typeId)\n\u0009case %expr1\n\u0009\u0009do @buildExpr1(ast $ \\ast@AstExpr1)\n\u0009case %expr2\n\u0009\u0009do @buildExpr2(ast $ \\ast@AstExpr2)\n\u0009case %expr3\n\u0009\u0009do @buildExpr3(ast $ \\ast@AstExpr3)\n\u0009case %exprNew\n\u0009\u0009do @buildExprNew(ast $ \\ast@AstExprNew)\n\u0009case %exprNewArray\n\u0009\u0009do @buildExprNewArray(ast $ \\ast@AstExprNewArray)\n\u0009case %exprAs\n\u0009\u0009do @buildExprAs(ast $ \\ast@AstExprAs)\n\u0009case %exprToBin\n\u0009\u0009do @buildExprToBin(ast $ \\ast@AstExprToBin)\n\u0009case %exprFromBin\n\u0009\u0009do @buildExprFromBin(ast $ \\ast@AstExprFromBin)\n\u0009case %exprCall\n\u0009\u0009do @buildExprCall(ast $ \\ast@AstExprCall)\n\u0009case %exprArray\n\u0009\u0009do @buildExprArray(ast $ \\ast@AstExprArray)\n\u0009case %exprDot\n\u0009\u0009do @buildExprDot(ast $ \\ast@AstExprDot)\n\u0009case %exprValue\n\u0009\u0009do @buildExprValue(ast $ \\ast@AstExprValue)\n\u0009case %exprValuePrim\n\u0009\u0009do @buildExprValuePrim(ast $ \\ast@AstExprValuePrim)\n\u0009case %exprValueStr\n\u0009\u0009do @buildExprValueStr(ast $ \\ast@AstExprValueStr)\n\u0009case %exprValueFloat\n\u0009\u0009do @buildExprValueFloat(ast $ \\ast@AstExprValueFloat)\n\u0009case %exprValueArray\n\u0009\u0009do @buildExprValueArray(ast $ \\ast@AstExprValueArray)\n\u0009case %exprRef\n\u0009\u0009do @buildExprRef(ast $ \\ast@AstExpr)\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExpr1(ast: \\ast@AstExpr1)\n\u0009assert ast.varKind <> %unknown\n\u0009switch(ast.kind)\n\u0009case %plus\n\u0009\u0009do @buildExpr(ast.child)\n\u0009case %minus\n\u0009\u0009do @codes.add(\"-(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %not\n\u0009\u0009do @codes.add(\"!(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %copy\n\u0009\u0009do @codes.add(\"copy_(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %len\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")->Len()\")\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExpr2(ast: \\ast@AstExpr2)\n\u0009assert ast.varKind <> %unknown\n\u0009var type: \\ast@AstType :: ast.children0.type\n\u0009switch(ast.kind)\n\u0009case %assign\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") = (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %or\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") || (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %and\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") && (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %lt\n\u0009\u0009if(\\ast@isRef(type))\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")) < 0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") < (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %gt\n\u0009\u0009if(\\ast@isRef(type))\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")) > 0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") > (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %le\n\u0009\u0009if(\\ast@isRef(type))\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")) <= 0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") <= (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %ge\n\u0009\u0009if(\\ast@isRef(type))\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")) >= 0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") >= (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %eq\n\u0009\u0009if(\\ast@isRef(type))\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")) == 0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") == (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %nEq\n\u0009\u0009if(\\ast@isRef(type))\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")) != 0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") != (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %eqRef\n\u0009\u0009do @codes.add(\"eqAddr_((\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\"))\")\n\u0009case %nEqRef\n\u0009\u0009do @codes.add(\"!eqAddr_((\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\"))\")\n\u0009case %cat\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")->Cat(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %add\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") + (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %sub\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") - (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %mul\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") * (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %div\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") / (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %mod\n\u0009\u0009if(\\ast@isInt(type) | type.typeId.and(%typeBit) = %typeBit)\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") % (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009else\n\u0009\u0009\u0009assert \\ast@isFloat(type)\n\u0009\u0009\u0009do @codes.add(\"fmod((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))\")\n\u0009\u0009end if\n\u0009case %pow\n\u0009\u0009if(\\ast@isInt(type) | type.typeId.and(%typeBit) = %typeBit)\n\u0009\u0009\u0009do @codes.add(\"powI_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))\")\n\u0009\u0009else\n\u0009\u0009\u0009assert \\ast@isFloat(type)\n\u0009\u0009\u0009do @codes.add(\"pow((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))\")\n\u0009\u0009end if\n\u0009case %swap\n\u0009\u0009var tmpVar: []char :: @addTmpVar(type)\n\u0009\u0009do @codes.add(\"\\{tmpVar} = (\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") = (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\") = (\\{tmpVar})\")\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExpr3(ast: \\ast@AstExpr3)\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"(\")\n\u0009do @buildExpr(ast.children0)\n\u0009do @codes.add(\") ? (\")\n\u0009do @buildExpr(ast.children1)\n\u0009do @codes.add(\") : (\")\n\u0009do @buildExpr(ast.children2)\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprNew(ast: \\ast@AstExprNew)\n\u0009assert ast.varKind <> %unknown\n\u0009if(\\ast@isClass(ast.itemType))\n\u0009\u0009var class_: \\ast@AstClass :: ast.itemType.refItem $ \\ast@AstClass\n\u0009\u0009var id: []char :: @refClass(class_)\n\u0009\u0009do @codes.add(\"new \\{id}()\")\n\u0009else\n\u0009\u0009if(ast.itemType.typeId = %typeGen)\n\u0009\u0009\u0009var gen: \\ast@AstTypeGen :: ast.itemType $ \\ast@AstTypeGen\n\u0009\u0009\u0009switch(gen.kind)\n\u0009\u0009\u0009case %list_\n\u0009\u0009\u0009\u0009do @codes.add(\"new List_<\\{@getType(gen.itemType)}>()\")\n\u0009\u0009\u0009case %stack_\n\u0009\u0009\u0009\u0009do @codes.add(\"new Stack_<\\{@getType(gen.itemType)}>()\")\n\u0009\u0009\u0009case %queue_\n\u0009\u0009\u0009\u0009do @codes.add(\"new Queue_<\\{@getType(gen.itemType)}>()\")\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009else\n\u0009\u0009\u0009assert ast.itemType.typeId = %typeDict\n\u0009\u0009\u0009var dict_: \\ast@AstTypeDict :: ast.itemType $ \\ast@AstTypeDict\n\u0009\u0009\u0009do @codes.add(\"new Dict_<\\{@getType(dict_.itemTypeKey)}, \\{@getType(dict_.itemTypeValue)}>()\")\n\u0009\u0009end if\n\u0009end if\nend func\n\nfunc buildExprNewArray(ast: \\ast@AstExprNewArray)\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"newArray_<\\{@getType(ast.itemType)}, \\{@getType(ast.type)}>(\\{^ast.idces}\")\n\u0009block\n\u0009\u0009var items: list<\\ast@AstExpr> :: ast.idces\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009do @codes.add(\", (\")\n\u0009\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprAs(ast: \\ast@AstExprAs)\n\u0009assert ast.varKind <> %unknown\n\u0009switch(ast.kind)\n\u0009case %as\n\u0009\u0009var t1: \\ast@AstType :: ast.child.type\n\u0009\u0009var t2: \\ast@AstType :: ast.childType\n\u0009\u0009if(\\ast@isClass(t1))\n\u0009\u0009\u0009assert \\ast@isClass(t2)\n\u0009\u0009\u0009var id: []char :: @refClass(t2.refItem $ \\ast@AstClass)\n\u0009\u0009\u0009var info: @CppInfo :: @getInfo(t2.refItem)\n\u0009\u0009\u0009do @codes.add(\"as_<\\{id}>(classTable_, (\")\n\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009do @codes.add(\"), \\{info.classTableOffset * @classTableItemSize})\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"static_cast<\\{@getType(ast.childType)}>(\")\n\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %is\n\u0009\u0009do @refClass(ast.childType.refItem $ \\ast@AstClass)\n\u0009\u0009var info: @CppInfo :: @getInfo(ast.childType.refItem)\n\u0009\u0009do @codes.add(\"is_(classTable_, (\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\"), \\{info.classTableOffset * @classTableItemSize})\")\n\u0009case %nIs\n\u0009\u0009do @refClass(ast.childType.refItem $ \\ast@AstClass)\n\u0009\u0009var info: @CppInfo :: @getInfo(ast.childType.refItem)\n\u0009\u0009do @codes.add(\"!is_(classTable_, (\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\"), \\{info.classTableOffset * @classTableItemSize})\")\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExprToBin(ast: \\ast@AstExprToBin)\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"toBin_(\")\n\u0009do @buildExpr(ast.child)\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprFromBin(ast: \\ast@AstExprFromBin)\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"fromBin_<\\{@getType(ast.childType)}>((\")\n\u0009do @buildExpr(ast.child)\n\u0009do @codes.add(\"), (\")\n\u0009do @buildExpr(ast.offset)\n\u0009do @codes.add(\"))\")\nend func\n\nfunc buildExprCall(ast: \\ast@AstExprCall)\n\u0009assert ast.varKind <> %unknown\n\u0009var funcType: \\ast@AstTypeFunc :: ast.func_.type $ \\ast@AstTypeFunc\n\u0009var template: []char :: null\n\u0009if(funcType <>& null & funcType.funcOption.and(%any) = %any)\n\u0009\u0009var items: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009var meType: \\ast@AstType :: items.get().arg.type\n\u0009\u0009if(funcType.funcOption.and(%tkv) = %tkv)\n\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}, \\{@getType((meType $ \\ast@AstTypeDict).itemTypeKey)}, \\{@getType((meType $ \\ast@AstTypeDict).itemTypeValue)}>\"\n\u0009\u0009elif(funcType.funcOption.and(%tch) = %tch)\n\u0009\u0009\u0009if(funcType.funcOption.and(%rch) = %rch)\n\u0009\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}, \"\n\u0009\u0009\u0009\u0009if(meType.typeId = %typeGen)\n\u0009\u0009\u0009\u0009\u0009do template :~ \"\\{@getType((meType $ \\ast@AstTypeGen).itemType)}, \"\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert meType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009do template :~ \"\\{@getType((meType $ \\ast@AstTypeDict).itemTypeKey)}, \"\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do template :~ \"\\{@getType(funcType.ret_)}>\"\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}, \"\n\u0009\u0009\u0009\u0009if(meType.typeId = %typeArray)\n\u0009\u0009\u0009\u0009\u0009do template :~ \"\\{@getType((meType $ \\ast@AstTypeArray).itemType)}>\"\n\u0009\u0009\u0009\u0009elif(meType.typeId = %typeGen)\n\u0009\u0009\u0009\u0009\u0009do template :~ \"\\{@getType((meType $ \\ast@AstTypeGen).itemType)}>\"\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert meType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009do template :~ \"\\{@getType((meType $ \\ast@AstTypeDict).itemTypeKey)}>\"\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009elif(funcType.funcOption.and(%rch) = %rch)\n\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}, \\{@getType(funcType.ret_)}>\"\n\u0009\u0009elif(funcType.funcOption.and(%kvf) = %kvf)\n\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}, \\{@getType((meType $ \\ast@AstTypeDict).itemTypeKey)}, \\{@getType((meType $ \\ast@AstTypeDict).itemTypeValue)}>\"\n\u0009\u0009elif(funcType.funcOption.and(%rac) = %rac)\n\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}, \\{@getType((meType $ \\ast@AstTypeGen).itemType)}>\"\n\u0009\u0009elif(funcType.funcOption.and(%rak) = %rak)\n\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}, \\{@getType((meType $ \\ast@AstTypeDict).itemTypeKey)}>\"\n\u0009\u0009elif(funcType.funcOption.and(%rav) = %rav)\n\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}, \\{@getType((meType $ \\ast@AstTypeDict).itemTypeValue)}>\"\n\u0009\u0009else\n\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}>\"\n\u0009\u0009end if\n\u0009end if\n\u0009if(template =& null)\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.func_)\n\u0009\u0009do @codes.add(\")\")\n\u0009else\n\u0009\u0009do @buildExpr(ast.func_)\n\u0009\u0009do @codes.add(template)\n\u0009end if\n\u0009do @codes.add(\"(\")\n\u0009block\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstExprCallArg :: items.get()\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\", (\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(item.refVar)\n\u0009\u0009\u0009\u0009do @codes.add(\"&\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @buildExpr(item.arg)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do @codes.add(\")\")\n\u0009\n\u0009block\n\u0009\u0009var type: \\ast@AstType :: ast.type\n\u0009\u0009if(type <>& null)\n\u0009\u0009\u0009if(\\ast@isClass(type))\n\u0009\u0009\u0009\u0009do @refClass(type.refItem $ \\ast@AstClass)\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009end block\nend func\n\nfunc buildExprArray(ast: \\ast@AstExprArray)\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"(\")\n\u0009do @buildExpr(ast.var_)\n\u0009do @codes.add(\")->At(\")\n\u0009do @buildExpr(ast.idx)\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprDot(ast: \\ast@AstExprDot)\n\u0009assert ast.varKind <> %unknown\n\u0009if(\\ast@isClass(ast.var_.type))\n\u0009\u0009var classItem: \\ast@AstClassItem :: ast.classItem\n\u0009\u0009assert classItem <>& null\n\u0009\u0009do @refClass(ast.var_.type.refItem $ \\ast@AstClass)\n\u0009\u0009var info: @CppInfo\n\u0009\u0009if(classItem.def.typeId = %var_)\n\u0009\u0009\u0009do info :: @getInfo((classItem.def $ \\ast@AstVar).arg)\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.var_)\n\u0009\u0009\u0009do @codes.add(\")->\\{info.id}\")\n\u0009\u0009else\n\u0009\u0009\u0009assert classItem.def.typeId = %func_\n\u0009\u0009\u0009do info :: @getInfo(classItem.def)\n\u0009\u0009\u0009; \'ast.var_\' is calculated elsewhere.\n\u0009\u0009\u0009do @codes.add(\"\\{info.id}\")\n\u0009\u0009end if\n\u0009else\n\u0009\u0009assert ast.refItem.typeId = %exprRef\n\u0009\u0009do @buildExprRef(ast.refItem $ \\ast@AstExpr)\n\u0009end if\nend func\n\nfunc buildExprValue(ast: \\ast@AstExprValue)\n\u0009assert ast.type.typeId = %typeNull\n\u0009do @codes.add(\"nullptr\")\nend func\n\nfunc buildExprValuePrim(ast: \\ast@AstExprValuePrim)\n\u0009var type: \\ast@AstType :: ast.type\n\u0009if(\\ast@isInt(type) | \\ast@isEnum(type))\n\u0009\u0009do @codes.add((ast.value $ int).toStr() ~ \"LL\")\n\u0009elif(\\ast@isChar(type))\n\u0009\u0009do @codes.add(\"u\'\\\\u\\{(ast.value $ bit16).toStr().sub(2, -1)}\'\")\n\u0009elif(\\ast@isBool(type))\n\u0009\u0009do @codes.add(ast.value = 0b64 ?(\"false\", \"true\"))\n\u0009elif(type.typeId = %typeBit)\n\u0009\u0009switch((type $ \\ast@AstTypeBit).size)\n\u0009\u0009case 1\n\u0009\u0009\u0009do @codes.add(\"static_cast<uint8_t>(\\{ast.value $ bit8}U)\")\n\u0009\u0009case 2\n\u0009\u0009\u0009do @codes.add(\"static_cast<uint16_t>(\\{ast.value $ bit16}U)\")\n\u0009\u0009case 4\n\u0009\u0009\u0009do @codes.add(\"\\{ast.value $ bit32}U\")\n\u0009\u0009case 8\n\u0009\u0009\u0009do @codes.add(\"\\{ast.value $ bit64}ULL\")\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009else\n\u0009\u0009assert false\n\u0009end if\nend func\n\nfunc buildExprValueStr(ast: \\ast@AstExprValueStr)\n\u0009var value: []char :: ast.value\n\u0009var s: []char :: \"new Array_<char16_t>(\\{^value}\"\n\u0009for i(0, ^value - 1)\n\u0009\u0009do s :~ \", u\'\\\\u\\{(value[i] $ bit16).toStr().sub(2, -1)}\'\"\n\u0009end for\n\u0009do s :~ \")\"\n\u0009do @codes.add(s)\nend func\n\nfunc buildExprValueFloat(ast: \\ast@AstExprValueFloat)\n\u0009var value: []char :: ast.value.toStr()\n\u0009if(value = \"inf\")\n\u0009\u0009do @codes.add(\"std::numeric_limits<double>::infinity()\")\n\u0009elif(value.find(\'.\', -1) = -1)\n\u0009\u0009do @codes.add(value ~ \".0\")\n\u0009else\n\u0009\u0009do @codes.add(value)\n\u0009end if\nend func\n\nfunc buildExprValueArray(ast: \\ast@AstExprValueArray)\n\u0009; Note that constant string values are handled by \'ExprValueStr\'.\n\u0009do @codes.add(\"new Array_<\\{@getType((ast.type $ \\ast@AstTypeArray).itemType)}>(\\{^ast.values}\")\n\u0009var items: list<\\ast@AstExpr> :: ast.values\n\u0009do items.head()\n\u0009while(!items.term())\n\u0009\u0009do @codes.add(\", (\")\n\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009do @codes.add(\")\")\n\u0009\u0009do items.next()\n\u0009end while\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprRef(ast: \\ast@AstExpr)\n\u0009var ast2: \\ast@Ast :: ast.refItem\n\u0009var info: @CppInfo :: @getInfo(ast2)\n\u0009if(ast2.typeId = %func_)\n\u0009\u0009do @funcs.add(ast2 $ \\ast@AstFunc)\n\u0009else\n\u0009\u0009assert ast2.typeId = %arg\n\u0009\u0009var arg: \\ast@AstArg :: ast2 $ \\ast@AstArg\n\u0009\u0009switch(arg.kind)\n\u0009\u0009case %global\n\u0009\u0009\u0009if(!info.alreadyWritten)\n\u0009\u0009\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009\u0009\u0009do @globalVars.add(arg)\n\u0009\u0009\u0009end if\n\u0009\u0009case %localArg\n\u0009\u0009\u0009; Do nothing.\n\u0009\u0009case %localVar\n\u0009\u0009\u0009if(!info.alreadyWritten)\n\u0009\u0009\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009\u0009\u0009do @localVars.add(arg)\n\u0009\u0009\u0009end if\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009if(arg.refVar)\n\u0009\u0009\u0009do @codes.add(\"*\")\n\u0009\u0009end if\n\u0009end if\n\u0009do @codes.add(info.id)\nend func\n\nfunc write(resFiles: list<[]char>)\n\u0009if(\\option@extra.get(\"merge\", &))\n\u0009\u0009var writer: file@Writer :: file@makeWriter(\\option@outputFile ~ \".cpp\", false)\n\u0009\u0009var reader: file@Reader :: file@makeReader(\\option@sysDir ~ \"common.h\")\n\u0009\u0009while(!reader.term())\n\u0009\u0009\u0009var s: []char :: reader.readLine()\n\u0009\u0009\u0009do writer.writeStr(s ~ \"\\n\")\n\u0009\u0009end while\n\u0009\u0009do reader.fin()\n\u0009\u0009do writeCpp(writer, resFiles)\n\u0009\u0009do writer.fin()\n\u0009else\n\u0009\u0009do file@copyFile(\\option@outputDir ~ \"common.h\", \\option@sysDir ~ \"common.h\")\n\u0009\u0009\n\u0009\u0009var writer: file@Writer :: file@makeWriter(\\option@outputFile ~ \".cpp\", false)\n\u0009\u0009do writer.writeStr(\"#include \\\"common.h\\\"\\n\")\n\u0009\u0009do writeCpp(writer, resFiles)\n\u0009\u0009do writer.fin()\n\u0009end if\n\u0009\n\u0009func writeCpp(writer: file@Writer, resFiles: list<[]char>)\n\u0009\u0009do writer.writeStr(\"namespace {\\n\")\n\u0009\u0009\n\u0009\u0009do @classDefs.head()\n\u0009\u0009while(!@classDefs.term())\n\u0009\u0009\u0009do writer.writeStr(@classDefs.get())\n\u0009\u0009\u0009do @classDefs.next()\n\u0009\u0009end while\n\u0009\u0009do @funcPrototypes.head()\n\u0009\u0009while(!@funcPrototypes.term())\n\u0009\u0009\u0009do writer.writeStr(@funcPrototypes.get())\n\u0009\u0009\u0009do @funcPrototypes.next()\n\u0009\u0009end while\n\u0009\u0009; TODO: ResFiles\n\u0009\u0009if(@classTableSize <> 0)\n\u0009\u0009\u0009do writer.writeStr(\"static int64_t classTable_[\\{@classTableSize * @classTableItemSize}];\\n\")\n\u0009\u0009end if\n\u0009\u0009do writer.writeStr(\"static int64_t argc_;\\n\")\n\u0009\u0009do writer.writeStr(\"static char** argv_;\\n\")\n\u0009\u0009do @globalVars.head()\n\u0009\u0009while(!@globalVars.term())\n\u0009\u0009\u0009var globalVar: \\ast@AstArg :: @globalVars.get()\n\u0009\u0009\u0009var info: @CppInfo :: @getInfo(globalVar)\n\u0009\u0009\u0009do writer.writeStr(\"static \\{@getType(globalVar.type)} \\{info.id};\\n\")\n\u0009\u0009\u0009do @globalVars.next()\n\u0009\u0009end while\n\u0009\u0009do @classFuncs.head()\n\u0009\u0009while(!@classFuncs.term())\n\u0009\u0009\u0009do writer.writeStr(@classFuncs.get())\n\u0009\u0009\u0009do @classFuncs.next()\n\u0009\u0009end while\n\u0009\u0009do @codes.head()\n\u0009\u0009while(!@codes.term())\n\u0009\u0009\u0009do writer.writeStr(@codes.get())\n\u0009\u0009\u0009do @codes.next()\n\u0009\u0009end while\n\u0009\u0009do writer.writeStr(\"}\\n\")\n\u0009\u0009do writer.writeStr(\"int main(int c_, char** v_){\\n\")\n\u0009\u0009do writer.writeStr(\"argc_ = static_cast<int64_t>(c_) - 1;\\n\")\n\u0009\u0009do writer.writeStr(\"argv_ = v_ + 1;\\n\")\n\u0009\u0009block\n\u0009\u0009\u0009do @classTable.head()\n\u0009\u0009\u0009while(!@classTable.term())\n\u0009\u0009\u0009\u0009var item: []char :: @classTable.get()\n\u0009\u0009\u0009\u0009do writer.writeStr(item)\n\u0009\u0009\u0009\u0009do @classTable.next()\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009do writer.writeStr(\"init_();\\n\")\n\u0009\u0009do writer.writeStr(\"a();\\n\")\n\u0009\u0009do writer.writeStr(\"return 0;\\n\")\n\u0009\u0009do writer.writeStr(\"}\\n\")\n\u0009end func\nend func\n\nfunc getType(type: \\ast@AstType): []char\n\u0009if(type =& null)\n\u0009\u0009ret \"void\"\n\u0009end if\n\u0009switch(type.typeId)\n\u0009case %typeArray\n\u0009\u0009ret \"Array_<\\{@getType((type $ \\ast@AstTypeArray).itemType)}>*\"\n\u0009case %typeBit\n\u0009\u0009ret \"uint\\{(type $ \\ast@AstTypeBit).size * 8}_t\"\n\u0009case %typeFunc\n\u0009\u0009var func_: \\ast@AstTypeFunc :: type $ \\ast@AstTypeFunc\n\u0009\u0009var id: []char :: @getId()\n\u0009\u0009do @funcPrototypes.add(\"typedef \\{@getType(func_.ret_)}(*\\{id})(\")\n\u0009\u0009block\n\u0009\u0009\u0009var arg: []char :: \"\"\n\u0009\u0009\u0009var first: bool :: true\n\u0009\u0009\u0009var items: list<\\ast@AstTypeFuncArg> :: func_.args\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstTypeFuncArg :: items.get()\n\u0009\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do arg :~ \", \"\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do arg :~ \"\\{@getType(item.arg)}\"\n\u0009\u0009\u0009\u0009if(item.refVar)\n\u0009\u0009\u0009\u0009\u0009do arg :~ \"*\"\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do @funcPrototypes.add(\"\\{arg});\\n\")\n\u0009\u0009end block\n\u0009\u0009ret id\n\u0009case %typeGen\n\u0009\u0009var gen: \\ast@AstTypeGen :: type $ \\ast@AstTypeGen\n\u0009\u0009switch(gen.kind)\n\u0009\u0009case %list_\n\u0009\u0009\u0009ret \"List_<\\{@getType(gen.itemType)}>*\"\n\u0009\u0009case %stack_\n\u0009\u0009\u0009ret \"Stack_<\\{@getType(gen.itemType)}>*\"\n\u0009\u0009case %queue_\n\u0009\u0009\u0009ret \"Queue_<\\{@getType(gen.itemType)}>*\"\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009case %typeDict\n\u0009\u0009var dict_: \\ast@AstTypeDict :: type $ \\ast@AstTypeDict\n\u0009\u0009ret \"Dict_<\\{@getType(dict_.itemTypeKey)}, \\{@getType(dict_.itemTypeValue)}>*\"\n\u0009case %typePrim\n\u0009\u0009var prim: \\ast@AstTypePrim :: type $ \\ast@AstTypePrim\n\u0009\u0009switch(prim.kind)\n\u0009\u0009case %int_\n\u0009\u0009\u0009ret \"int64_t\"\n\u0009\u0009case %float_\n\u0009\u0009\u0009ret \"double\"\n\u0009\u0009case %char_\n\u0009\u0009\u0009ret \"char16_t\"\n\u0009\u0009case %bool_\n\u0009\u0009\u0009ret \"bool\"\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009case %typeUser\n\u0009\u0009var ref: \\ast@Ast :: type.refItem\n\u0009\u0009if(ref.typeId = %class_)\n\u0009\u0009\u0009do @refClass(ref $ \\ast@AstClass)\n\u0009\u0009\u0009var info: @CppInfo :: @getInfo(ref)\n\u0009\u0009\u0009ret info.id ~ \"*\"\n\u0009\u0009else\n\u0009\u0009\u0009assert ref.typeId = %enum_\n\u0009\u0009\u0009ret \"int64_t\"\n\u0009\u0009end if\n\u0009case %typeNull\n\u0009\u0009assert false\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc getId(): []char\n\u0009var curId: []char :: @uniqueId\n\u0009var newId: []char :: ##@uniqueId\n\u0009while loop2(true)\n\u0009\u0009var idx: int :: ^newId - 1\n\u0009\u0009while loop(true)\n\u0009\u0009\u0009if(newId[idx] = \'z\')\n\u0009\u0009\u0009\u0009if(idx = 0)\n\u0009\u0009\u0009\u0009\u0009do newId :: #[^newId + 1]char\n\u0009\u0009\u0009\u0009\u0009do newId.fill(\'a\')\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do newId[idx] :: \'a\'\n\u0009\u0009\u0009\u0009\u0009do idx :- 1\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do newId[idx] :: newId[idx].offset(1)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009break loop\n\u0009\u0009end while\n\u0009\u0009switch(^newId)\n\u0009\u0009case 2\n\u0009\u0009\u0009switch(newId)\n\u0009\u0009\u0009case \"do\", \"if\", \"or\"\n\u0009\u0009\u0009\u0009skip loop2\n\u0009\u0009\u0009end switch\n\u0009\u0009case 3\n\u0009\u0009\u0009switch(newId)\n\u0009\u0009\u0009case \"and\", \"asm\", \"for\", \"int\", \"new\", \"not\", \"try\", \"xor\"\n\u0009\u0009\u0009\u0009skip loop2\n\u0009\u0009\u0009end switch\n\u0009\u0009case 4\n\u0009\u0009\u0009switch(newId)\n\u0009\u0009\u0009case \"auto\", \"bool\", \"case\", \"char\", \"else\", \"enum\", \"goto\", \"long\", \"main\", \"this\", \"true\", \"void\"\n\u0009\u0009\u0009\u0009skip loop2\n\u0009\u0009\u0009end switch\n\u0009\u0009end switch\n\u0009\u0009break loop2\n\u0009end while\n\u0009do @uniqueId :: newId\n\u0009ret curId\nend func\n\n+func getInfo(ast: \\ast@Ast): @CppInfo\n\u0009if(ast.extra =& null | ast.extra.typeId <> %info)\n\u0009\u0009var info: @CppInfo :: #@CppInfo\n\u0009\u0009do info.typeId :: %info\n\u0009\u0009do info.id :: @getId()\n\u0009\u0009if(ast.typeId.and(%statBreakable) = %statBreakable & ast.name <>& null & ast.name <> \"$\")\n\u0009\u0009\u0009do info.breakLabel :: @getId()\n\u0009\u0009\u0009if(ast.typeId.and(%statSkipable) = %statSkipable)\n\u0009\u0009\u0009\u0009do info.skipLabel :: @getId()\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do info.skipLabel :: null\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009do info.breakLabel :: null\n\u0009\u0009\u0009do info.skipLabel :: null\n\u0009\u0009end if\n\u0009\u0009do info.classTableOffset :: -1\n\u0009\u0009do info.alreadyWritten :: false\n\u0009\u0009do info.breakLabelUsed :: false\n\u0009\u0009do info.skipLabelUsed :: false\n\u0009\u0009do ast.extra :: info\n\u0009end if\n\u0009ret ast.extra $ @CppInfo\nend func\n\nfunc addTmpVar(type: \\ast@AstType): []char\n\u0009var tmpVar: @TmpVar :: #@TmpVar\n\u0009do tmpVar.identifier :: @getId()\n\u0009do tmpVar.type :: type\n\u0009do @tmpVars.add(tmpVar)\n\u0009ret tmpVar.identifier\nend func\n\nfunc refClass(ast: \\ast@AstClass): []char\n\u0009var info: @CppInfo :: @getInfo(ast)\n\u0009if(info.alreadyWritten)\n\u0009\u0009ret info.id\n\u0009end if\n\u0009do info.alreadyWritten :: true\n\u0009if(ast.refItem <>& null)\n\u0009\u0009do @refClass(ast.refItem $ \\ast@AstClass)\n\u0009end if\n\u0009if(info.classTableOffset = -1)\n\u0009\u0009do info.classTableOffset :: @classTableSize\n\u0009\u0009do @classTableSize :+ 1\n\u0009end if\n\u0009block\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item.def.typeId = %func_)\n\u0009\u0009\u0009\u0009var func_: \\ast@AstFunc :: item.def $ \\ast@AstFunc\n\u0009\u0009\u0009\u0009if(func_.ret_ <>& null)\n\u0009\u0009\u0009\u0009\u0009do @getType(func_.ret_)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009var items2: list<\\ast@AstArg> :: func_.args\n\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: items2.get()\n\u0009\u0009\u0009\u0009\u0009do @getType(arg.type)\n\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @funcs.add(func_)\n\u0009\u0009\u0009elif(item.def.typeId = %var_)\n\u0009\u0009\u0009\u0009var var_: \\ast@AstVar :: item.def $ \\ast@AstVar\n\u0009\u0009\u0009\u0009do @getType(var_.arg.type)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do @classes.add(ast)\n\u0009ret info.id\nend func\n":true;
else if(p==="res/cpp/raw_funcs.kn")
return f?"+func write(codes: list<[]char>, attr: []char, args: list<\\ast@AstArg>, members: list<\\ast@AstClassItem>)\n\u0009switch(attr)\n\u0009case \"acos\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return std::acos(\\{x.id});\\n\")\n\u0009case \"acosh\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return std::acosh(\\{x.id});\\n\")\n\u0009case \"addr\"\n\u0009\u0009do args.head()\n\u0009\u0009var class_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return reinterpret_cast<uint64_t>(\\{class_.id});\\n\")\n\u0009case \"addDict\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var key: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->Add(\\{key.id}, \\{item.id});\\n\")\n\u0009case \"addList\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->B.push_back(\\{item.id});\\n\")\n\u0009case \"addQueue\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->B.push(\\{item.id});\\n\")\n\u0009case \"addStack\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->B.push(\\{item.id});\\n\")\n\u0009case \"and\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id} & \\{n.id};\\n\")\n\u0009case \"asin\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return std::asin(\\{x.id});\\n\")\n\u0009case \"asinh\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return std::asinh(\\{x.id});\\n\")\n\u0009case \"atan\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return std::atan(\\{x.id});\\n\")\n\u0009case \"atanh\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return std::atanh(\\{x.id});\\n\")\n\u0009case \"ceil\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return std::ceil(\\{x.id});\\n\")\n\u0009case \"cmdLine\"\n\u0009\u0009do codes.add(\"Array_<Array_<char16_t>*>* a_ = new Array_<Array_<char16_t>*>();\\n\")\n\u0009\u0009do codes.add(\"a_->L = argc_;\\n\")\n\u0009\u0009do codes.add(\"a_->B = new Array_<char16_t>*[static_cast<size_t>(argc_)];\\n\")\n\u0009\u0009do codes.add(\"for (int64_t i_ = 0; i_ < argc_; i_++){\\n\")\n\u0009\u0009do codes.add(\"std::string s_ = argv_[i_];\\n\")\n\u0009\u0009do codes.add(\"const std::u16string t_ = utf8ToUtf16_(s_);\\n\")\n\u0009\u0009do codes.add(\"a_->B[i_] = new Array_<char16_t>();\\n\")\n\u0009\u0009do codes.add(\"a_->B[i_]->L = static_cast<int64_t>(t_.size());\\n\")\n\u0009\u0009do codes.add(\"a_->B[i_]->B = new char16_t[t_.size() + 1];\\n\")\n\u0009\u0009do codes.add(\"std::memcpy(a_->B[i_]->B, t_.c_str(), sizeof(char16_t) * (t_.size() + 1));\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return a_;\\n\")\n\u0009case \"cos\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return std::cos(\\{x.id});\\n\")\n\u0009case \"cosh\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return std::cosh(\\{x.id});\\n\")\n\u0009case \"del\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"auto& i_ = \\{me_.id}->I++;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}->B.erase(i_);\\n\")\n\u0009case \"dist\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var y: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var centerX: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var centerY: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return std::hypot(\\{x.id} - \\{centerX.id}, \\{y.id} - \\{centerY.id});\\n\")\n\u0009case \"exp\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return std::exp(\\{x.id});\\n\")\n\u0009case \"fill\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var value: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"for(int64_t i_ = 0; i_ < \\{me_.id}->L; i_++) \\{me_.id}->B[i_] = \\{value.id};\\n\")\n\u0009case \"findArray\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var start: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{start.id} == -1) \\{start.id} = 0;\\n\")\n\u0009\u0009do codes.add(\"if(\\{start.id} < 0) return -1;\\n\")\n\u0009\u0009do codes.add(\"for(int64_t i_ = \\{start.id}; i_ < \\{me_.id}->L; i_++){\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}->B[i_] == \\{item.id}) return i_;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return -1;\\n\")\n\u0009case \"findBin\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"int64_t a_ = 0, b_ = \\{me_.id}->L - 1;\\n\")\n\u0009\u0009do codes.add(\"while (a_ <= b_) {\\n\")\n\u0009\u0009do codes.add(\"int64_t c_ = (a_ + b_) / 2;\\n\")\n\u0009\u0009do codes.add(\"int64_t m_ = cmp_(\\{item.id}, \\{me_.id}->B[c_]);\\n\")\n\u0009\u0009do codes.add(\"if(m_ < 0) b_ = c_ - 1;\\n\")\n\u0009\u0009do codes.add(\"else if(m_ > 0) a_ = c_ + 1;\\n\")\n\u0009\u0009do codes.add(\"else return c_;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return -1;\\n\")\n\u0009case \"findLastArray\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var start: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{start.id} == -1) \\{start.id} = \\{me_.id}->L - 1;\\n\")\n\u0009\u0009do codes.add(\"if(\\{start.id} >= \\{me_.id}->L) return -1;\\n\")\n\u0009\u0009do codes.add(\"for(int64_t i_ = \\{start.id}; i_ >= 0; i_--){\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}->B[i_] == \\{item.id}) return i_;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return -1;\\n\")\n\u0009case \"floor\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return std::floor(\\{x.id});\\n\")\n\u0009case \"forEach\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var callback: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var data: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return dictForEach_(\\{me_.id}->B, static_cast<bool(*)(K_, V_, Class_*)>(\\{callback.id}), \\{data.id});\\n\")\n\u0009case \"getDict\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var key: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var existed: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return dictSearch_(\\{me_.id}->B, \\{key.id}, \\{existed.id});\\n\")\n\u0009case \"getList\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return *\\{me_.id}->I;\\n\")\n\u0009case \"getQueue\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"R_ r_ = \\{me_.id}->B.front();\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}->B.pop();\\n\")\n\u0009\u0009do codes.add(\"return r_;\\n\")\n\u0009case \"getStack\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"R_ r_ = \\{me_.id}->B.top();\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}->B.pop();\\n\")\n\u0009\u0009do codes.add(\"return r_;\\n\")\n\u0009case \"head\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->I = \\{me_.id}->B.begin();\\n\")\n\u0009case \"idx\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"int64_t i_ = 0;\\n\")\n\u0009\u0009do codes.add(\"for(auto& t_ = \\{me_.id}->B.begin(); t_ != \\{me_.id}->B.end(); ++t_){\\n\")\n\u0009\u0009do codes.add(\"if(t_ == \\{me_.id}->I) return i_;\\n\")\n\u0009\u0009do codes.add(\"i_++;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return -1;\\n\")\n\u0009case \"ins\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->B.insert(\\{me_.id}->I, \\{item.id});\\n\")\n\u0009case \"invRot\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var y: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var centerX: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var centerY: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"double r_ = std::atan2(\\{y.id} - \\{centerY.id}, \\{x.id} - \\{centerX.id});\\n\")\n\u0009\u0009do codes.add(\"return r_ < 0.0 ? r_ + 2.0 * 3.14159265358979323846 : r_;\\n\")\n\u0009case \"ln\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return std::log(\\{x.id});\\n\")\n\u0009case \"moveOffset\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var offset: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{offset.id} >= 0){\\n\")\n\u0009\u0009do codes.add(\"for(int64_t i_ = 0; i_ < \\{offset.id}; i_++){\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}->I == \\{me_.id}->B.end()) break;\\n\")\n\u0009\u0009do codes.add(\"++\\{me_.id}->I;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"for(int64_t i_ = 0; i_ > \\{offset.id}; i_--){\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}->I == \\{me_.id}->B.end()) break;\\n\")\n\u0009\u0009do codes.add(\"--\\{me_.id}->I;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"next\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"++\\{me_.id}->I;\\n\")\n\u0009case \"not\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return ~\\{me_.id};\\n\")\n\u0009case \"or\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id} | \\{n.id};\\n\")\n\u0009case \"peekQueue\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}->B.front();\\n\")\n\u0009case \"peekStack\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}->B.top();\\n\")\n\u0009case \"prev\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{me_.id}->I == \\{me_.id}->B.begin())\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}->I = \\{me_.id}->B.end();\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"--\\{me_.id}->I;\\n\")\n\u0009case \"rnd\"\n\u0009\u0009do args.head()\n\u0009\u0009var min: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var max: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return rnd_(\\{min.id}, \\{max.id});\\n\")\n\u0009case \"rndFloat\"\n\u0009\u0009do args.head()\n\u0009\u0009var min: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var max: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return rndFloat_(\\{min.id}, \\{max.id});\\n\")\n\u0009case \"sar\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009; TODO: sign\n\u0009\u0009do codes.add(\"return \\{me_.id} >> \\{n.id};\\n\")\n\u0009case \"shl\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id} << \\{n.id};\\n\")\n\u0009case \"shr\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id} >> \\{n.id};\\n\")\n\u0009case \"sin\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return std::sin(\\{x.id});\\n\")\n\u0009case \"sinh\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return std::sinh(\\{x.id});\\n\")\n\u0009case \"sqrt\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return std::sqrt(\\{x.id});\\n\")\n\u0009case \"sub\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var start: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var len: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return sub_(\\{me_.id}, \\{start.id}, \\{len.id});\\n\")\n\u0009case \"sysTime\"\n\u0009\u0009do codes.add(\"return static_cast<int64_t>(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());\\n\")\n\u0009case \"tail\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->I = \\{me_.id}->B.end();\\n\")\n\u0009\u0009do codes.add(\"--\\{me_.id}->I;\\n\")\n\u0009case \"tan\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return std::tan(\\{x.id});\\n\")\n\u0009case \"tanh\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return std::tanh(\\{x.id});\\n\")\n\u0009case \"term\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}->I == \\{me_.id}->B.end();\\n\")\n\u0009case \"toArray\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return toArray_<C_>(\\{me_.id});\")\n\u0009case \"toBit64\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var success: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"std::u16string s_ = \\{me_.id}->B;\\n\")\n\u0009\u0009do codes.add(\"const std::string& t_ = utf16ToUtf8_(s_);\\n\")\n\u0009\u0009do codes.add(\"try{\\n\")\n\u0009\u0009do codes.add(\"size_t s_;\\n\")\n\u0009\u0009do codes.add(\"uint64_t v_ = t_.size() > 2 && t_[0] == \'0\' && t_[1] == \'x\' ? std::stoull(t_, &s_, 16) : std::stoull(t_, &s_);\\n\")\n\u0009\u0009do codes.add(\"if(s_ == t_.size()){\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = true;\\n\")\n\u0009\u0009do codes.add(\"return v_;\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = false;\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}catch(...){\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = false;\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"toFloat\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var success: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"std::u16string s_ = \\{me_.id}->B;\\n\")\n\u0009\u0009do codes.add(\"const std::string& t_ = utf16ToUtf8_(s_);\\n\")\n\u0009\u0009do codes.add(\"try{\\n\")\n\u0009\u0009do codes.add(\"size_t s_;\\n\")\n\u0009\u0009do codes.add(\"double v_ = std::stod(t_, &s_);\\n\")\n\u0009\u0009do codes.add(\"if(s_ == t_.size()){\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = true;\\n\")\n\u0009\u0009do codes.add(\"return v_;\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = false;\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}catch(...){\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = false;\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"toInt\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var success: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"std::u16string s_ = \\{me_.id}->B;\\n\")\n\u0009\u0009do codes.add(\"const std::string& t_ = utf16ToUtf8_(s_);\\n\")\n\u0009\u0009do codes.add(\"try{\\n\")\n\u0009\u0009do codes.add(\"size_t s_;\\n\")\n\u0009\u0009do codes.add(\"int64_t v_ = t_.size() > 2 && t_[0] == \'0\' && t_[1] == \'x\' ? std::stoll(t_, &s_, 16) : std::stoull(t_, &s_);\\n\")\n\u0009\u0009do codes.add(\"if(s_ == t_.size()){\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = true;\\n\")\n\u0009\u0009do codes.add(\"return v_;\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = false;\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}catch(...){\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = false;\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"toStr\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return toStr_(\\{me_.id});\\n\")\n\u0009case \"xor\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id} ^ \\{n.id};\\n\")\n\u0009case \"cui_print\"\n\u0009\u0009do args.head()\n\u0009\u0009var str: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{str.id} == nullptr){\\n\")\n\u0009\u0009do codes.add(\"std::cout << \\\"(null)\\\";\\n\")\n\u0009\u0009do codes.add(\"return;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"std::u16string s_ = \\{str.id}->B;\\n\")\n\u0009\u0009do codes.add(\"const std::string& t_ = utf16ToUtf8_(s_);\\n\")\n\u0009\u0009do codes.add(\"std::cout << t_ << std::flush;\\n\")\n\u0009case \"file_copyFile\"\n\u0009\u0009do args.head()\n\u0009\u0009var dst: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var src: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return copyFile_(\\{dst.id}->B, \\{src.id}->B);\\n\")\n\u0009case \"file_exist\"\n\u0009\u0009do args.head()\n\u0009\u0009var path: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"return false;\\n\")\n\u0009case \"file_forEach\"\n\u0009\u0009do args.head()\n\u0009\u0009var path: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var recursion: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var callback: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var data: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"return false;\\n\")\n\u0009case \"file_makeReader\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var path: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"\\{me_.id}->\\{handle.id} = reinterpret_cast<int64_t>(new reader_());\\n\")\n\u0009\u0009do codes.add(\"std::u16string s_ = \\{path.id}->B;\\n\")\n\u0009\u0009do codes.add(\"const std::string& t_ = utf16ToUtf8_(s_);\\n\")\n\u0009\u0009do codes.add(\"reader_* r_ = reinterpret_cast<reader_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"r_->F = new std::ifstream(t_.c_str(), std::ios::in | std::ios::binary);\\n\")\n\u0009\u0009do codes.add(\"if(!*r_->F) return nullptr;\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id};\\n\")\n\u0009case \"file_makeWriter\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var path: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var append: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"\\{me_.id}->\\{handle.id} = reinterpret_cast<int64_t>(new writer_());\\n\")\n\u0009\u0009do codes.add(\"std::u16string s_ = \\{path.id}->B;\\n\")\n\u0009\u0009do codes.add(\"const std::string& t_ = utf16ToUtf8_(s_);\\n\")\n\u0009\u0009do codes.add(\"writer_* r_ = reinterpret_cast<writer_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"r_->F = new std::ofstream(t_.c_str(), std::ios::out | std::ios::binary | (\\{append.id} ? std::ios::app : std::ios::trunc));\\n\")\n\u0009\u0009do codes.add(\"if(!*r_->F) return nullptr;\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id};\\n\")\n\u0009case \"file_readerFin\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"reader_* r_ = reinterpret_cast<reader_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"r_->F->close();\\n\")\n\u0009case \"file_readerGetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"reader_* r_ = reinterpret_cast<reader_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"return static_cast<int64_t>(r_->F->tellg());\\n\")\n\u0009case \"file_readerReadLetter\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"reader_* r_ = reinterpret_cast<reader_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"return readUtf8_(r_->F);\\n\")\n\u0009case \"file_readerSetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var origin: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var pos: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"reader_* r_ = reinterpret_cast<reader_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"std::ios_base::seekdir o_ = std::ios_base::beg;\\n\")\n\u0009\u0009do codes.add(\"switch(\\{origin.id}){\\n\")\n\u0009\u0009do codes.add(\"case 0: o_ = std::ios_base::beg; break;\\n\")\n\u0009\u0009do codes.add(\"case 1: o_ = std::ios_base::cur; break;\\n\")\n\u0009\u0009do codes.add(\"case 2: o_ = std::ios_base::end; break;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"r_->F->seekg(\\{pos.id}, o_);\\n\")\n\u0009case \"file_readerTerm\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"reader_* r_ = reinterpret_cast<reader_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"char c_;\\n\")\n\u0009\u0009do codes.add(\"if(r_->F->get(c_)) {\\n\")\n\u0009\u0009do codes.add(\"r_->F->seekg(-1, std::ios_base::cur);\\n\")\n\u0009\u0009do codes.add(\"return false;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return true;\\n\")\n\u0009case \"file_writerFin\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"writer_* r_ = reinterpret_cast<writer_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"r_->F->close();\\n\")\n\u0009case \"file_writerGetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"writer_* r_ = reinterpret_cast<writer_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"return static_cast<int64_t>(r_->F->tellp());\\n\")\n\u0009case \"file_writerSetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var origin: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var pos: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"writer_* r_ = reinterpret_cast<writer_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"std::ios_base::seekdir o_ = std::ios_base::beg;\\n\")\n\u0009\u0009do codes.add(\"switch(\\{origin.id}){\\n\")\n\u0009\u0009do codes.add(\"case 0: o_ = std::ios_base::beg; break;\\n\")\n\u0009\u0009do codes.add(\"case 1: o_ = std::ios_base::cur; break;\\n\")\n\u0009\u0009do codes.add(\"case 2: o_ = std::ios_base::end; break;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"r_->F->seekp(\\{pos.id}, o_);\\n\")\n\u0009case \"file_writerWrite\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"writer_* r_ = reinterpret_cast<writer_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"r_->F->write(reinterpret_cast<char*>(\\{n.id}->B), \\{n.id}->L);\\n\")\n\u0009case \"file_writerWriteChar\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"writer_* r_ = reinterpret_cast<writer_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"writeUtf8_(r_->F, \\{n.id});\\n\")\n\u0009case \"wnd_editBaseGetText\"\n\u0009\u0009; TODO:\n\u0009case \"wnd_makeEditMulti\"\n\u0009\u0009; TODO:\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\n\u0009\n\u0009func search(members: list<\\ast@AstClassItem>, name: []char): \\cpp\\output@CppInfo\n\u0009\u0009do members.head()\n\u0009\u0009while(!members.term())\n\u0009\u0009\u0009var def: \\ast@Ast :: members.get().def\n\u0009\u0009\u0009if(def.typeId = %var_ & (def $ \\ast@AstVar).arg.name <>& null & (def $ \\ast@AstVar).arg.name = name)\n\u0009\u0009\u0009\u0009ret \\cpp\\output@getInfo((def $ \\ast@AstVar).arg)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do members.next()\n\u0009\u0009end while\n\u0009\u0009assert false\n\u0009\u0009ret null\n\u0009end func\nend func\n":true;
else if(p==="res/err.kn")
return f?"+var errCnt: int\n\n+func err(id: \\msg@Id, pos: \\pos@Pos, args: [][]char)\n\u0009if(id < %_nonErrs & @errCnt >= 100)\n\u0009\u0009ret {Stop error detection at 100 pieces.}\n\u0009end if\n\u0009\n\u0009var msg: []char :: \\msg@get(id, args)\n\u0009do cui@print((id $ bit32).toStr() ~ \": \")\n\u0009if(pos <>& null)\n\u0009\u0009do cui@print(\"[\\{pos.srcName}: \\{pos.row}, \\{pos.col}]\")\n\u0009end if\n\u0009do cui@print(msg ~ \"\\n\")\n\u0009if(id < %_nonErrs)\n\u0009\u0009do @errCnt :+ 1\n\u0009end if\nend func\n":true;
else if(p==="res/main.kn")
return f?"const major: int :: 2019\nconst minor: int :: 10\nconst micro: int :: 17\n\nfunc main()\n\u0009if(!\\option@acquireOption())\n\u0009\u0009do lib@exitCode(1)\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009if(\\option@version)\n\u0009\u0009do cui@print(\"Kuin Programming Language v.\\{@major}.\\{@minor}.\\{@micro}\\n\")\n\u0009\u0009do cui@print(\"(C)Kuina-chan\\n\")\n\u0009\u0009do lib@exitCode(0)\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009if(\\option@help | \\option@inputFile =& null)\n\u0009\u0009do cui@print(\"Usage: kuincl [-i input.kn] [-o output.kn] [-s \'sys\' directory] [-c icon.ico] [-e environment] [-a appcode] [-r] [-h] [-v] [-q]\\n\")\n\u0009\u0009do lib@exitCode(0)\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009if(@build())\n\u0009\u0009do \\err@err(%success, null, null)\n\u0009\u0009do lib@exitCode(0)\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009if(!\\option@quiet)\n\u0009\u0009do \\err@err(%failure, null, null)\n\u0009end if\n\u0009do lib@exitCode(1)\nend func\n\nfunc build(): bool\n\u0009var asts: dict<[]char, \\ast@Ast>\n\u0009var entry: \\ast@AstFunc\n\u0009\n\u0009do \\err@errCnt :: 0\n\u0009var beginTime: int :: lib@sysTime()\n\u0009do \\err@err(%compilationStarted, null, [((lib@sysTime() - beginTime) $ float / 1000.0).toStr()])\n\u0009\n\u0009; \'Parse\'\n\u0009do asts :: \\parse@parse()\n\u0009do \\err@err(%parsingCompleted, null, [((lib@sysTime() - beginTime) $ float / 1000.0).toStr()])\n\u0009\n\u0009; \'Analyze\'\n\u0009do entry :: \\analyze@analyze(asts)\n\u0009do \\err@err(%semanticAnalysisCompleted, null, [((lib@sysTime() - beginTime) $ float / 1000.0).toStr()])\n\u0009\n\u0009; Stop compilation if some errors occur.\n\u0009if(\\err@errCnt > 0)\n\u0009\u0009ret false\n\u0009end if\n\u0009\n\u0009; \'Res\' files.\n\u0009var resDir: []char :: \\option@inputDir ~ \"res/\"\n\u0009class ResFiles()\n\u0009\u0009+var files: list<[]char>\n\u0009end class\n\u0009var resFiles: ResFiles :: #ResFiles\n\u0009do resFiles.files :: #list<[]char>\n\u0009if(file@exist(resDir))\n\u0009\u0009do file@forEach(resDir, true, searchResFiles, resFiles)\n\u0009end if\n\u0009\n\u0009; \'Output\'\n\u0009switch(\\option@env_)\n\u0009case %cpp\n\u0009\u0009if(!\\cpp\\output@output(entry, resFiles.files))\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009case %web\n\u0009\u0009if(!\\web\\output@output(entry, resFiles.files))\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\n\u0009\n\u0009do \\err@err(%generationProcessCompleted, null, [((lib@sysTime() - beginTime) $ float / 1000.0).toStr()])\n\u0009\n\u0009ret true\n\u0009\n\u0009func searchResFiles(path: []char, isDir: bool, data: kuin@Class): bool\n\u0009\u0009var data2: ResFiles :: data $ ResFiles\n\u0009\u0009do data2.files.add(path)\n\u0009\u0009ret true\n\u0009end func\nend func\n":true;
else if(p==="res/msg.kn")
return f?"+var lang: @Lang :: %ja\n\n+enum Lang\n\u0009ja\n\u0009en\nend enum\n\n+enum Id\n\u0009_generalErrs :: 0x00000000\n\u0009incorrectOption\n\u0009unexpectedOption\n\u0009incorrectExt\n\u0009incorrectSrcName\n\u0009fileOpenFailed\n\u0009sysFileOpenFailed\n\u0009sysFileBroken\n\u0009\n\u0009_parsingErrs :: 0x00010000\n\u0009sameIdentifierInSameScope\n\u0009sameIdentifierInUpperScope\n\u0009noBrace\n\u0009tabInStr\n\u0009lineBreakInStr\n\u0009wrongCharacterInIdentifier\n\u0009wrongAtInIdentifier\n\u0009uppercaseFileName\n\u0009wrongBackslashInIdentifier\n\u0009tooLongIdentifier\n\u0009incorrectBlockOrSentence\n\u0009wrongCharacterInFuncAttr\n\u0009tooLongFuncAttr\n\u0009charShouldBeWritten\n\u0009noEnd\n\u0009overrideNonFunctionMember\n\u0009exposeNonFunctionOrVariableMember\n\u0009wrongEnd\n\u0009wrongMember\n\u0009ampersandInNonArgument\n\u0009initializerInArgument\n\u0009initializerInMember\n\u0009noInitializerInConst\n\u0009noEndUnspecified\n\u0009wrongEndUnspecified\n\u0009nonCorrespondingEnd\n\u0009elifOrElseAfterElse\n\u0009caseOrDefaultAfterDefault\n\u0009catchOrFinallyAfterFinally\n\u0009wrongClause\n\u0009wrongClauseInSwitch\n\u0009wrongWord\n\u0009wrongOperator\n\u0009tooLongStringLiteral\n\u0009wrongEscSequence\n\u0009wrongCharCodeRepresentation\n\u0009nonClosingStrLiteral\n\u0009tooLongCharLiteral\n\u0009emptyCharLiteral\n\u0009noParenthesis\n\u0009wrongNumericLiteral\n\u0009tooLongNumericLiteral\n\u0009wrongHexadecimalLiteral\n\u0009wrongExponentialNotationLiteral\n\u0009wrongFloatingPointLiteral\n\u0009wrongBitTypeLiteral\n\u0009integerLiteralOverflowed\n\u0009\n\u0009_analysisErrs :: 0x00020000\n\u0009noMainFunc\n\u0009wrongMainFunc\n\u0009accessMemberWithoutMe\n\u0009nonOmittingAt\n\u0009accessUnpublishedElement\n\u0009identifierNotFound\n\u0009circulatingAlias\n\u0009circulatingClass\n\u0009overridedMemberNotFound\n\u0009memberDuplicatedWithParentClass\n\u0009overridingNonFunc\n\u0009overriddenMemberNotMatchAccessModifier\n\u0009overriddenMemberNotMatchTypeOrArg\n\u0009notAllowedToBeOverridden\n\u0009enumValueMustBeInt\n\u0009enumValueExceedIntRange\n\u0009enumValueDuplicated\n\u0009notExistedElementName\n\u0009valueOfGlobalVarMustBeConst\n\u0009valueOfConstMustBeConst\n\u0009varAndValueTypeNotMatch\n\u0009ifCondMustBeBool\n\u0009elIfCondMustBeBool\n\u0009switchCondMustBeComparable\n\u0009caseCondNotMatchSwitch\n\u0009whileCondMustBeBool\n\u0009forBeginValueMustBeInt\n\u0009forEndValueMustBeInt\n\u0009forIncreaseDecreaseValueMustBeInt\n\u0009forIncreaseDecreaseValueMustBeConst\n\u0009forIncreaseDecreaseValueMustBeOtherThanZero\n\u0009catchCondMustBeConstInt\n\u0009excptCodeMustBeInt\n\u0009mustRetValue\n\u0009retTypeNotMatchFunc\n\u0009noSideEffectDo\n\u0009mustSpecifyBlockName\n\u0009assertCondMustBeBool\n\u0009nonTypeWritten\n\u0009noValuePassed\n\u0009wrongOperatorType\n\u0009wrongLeftValueOfAssignOperator\n\u0009comparingNullByValue\n\u0009enumTypeNotInferred\n\u0009concatNull\n\u0009dividedBy0\n\u0009wrongLeftOrRightValueOfSwapOperator\n\u0009condForCondOperatorMustBeBool\n\u0009twoValueForCondOperatorMustSameType\n\u0009wrongTypeForNewOperator\n\u0009numOfElementsMustBeInt\n\u0009callNonFunction\n\u0009wrongArgNumInFunc\n\u0009nonRefArgPassed\n\u0009wrongArgTypeInFunc\n\u0009nonArrayAccess\n\u0009arrayIdxMustBeInt\n\u0009memberNotExist\n\u0009refUnpublishedMember\n\u0009elementTypesOfArrayInitNotMatch\n\u0009nullForValueTypeArrayInit\n\u0009allElementsAreEnum\n\u0009allElementsAreNull\n\u0009inaccessibleElement\n\u0009\n\u0009_nonErrs :: 0x00030000\n\u0009success\n\u0009failure\n\u0009compilationStarted\n\u0009parsingCompleted\n\u0009semanticAnalysisCompleted\n\u0009generationProcessCompleted\nend enum\n\n+func get(id: @Id, args: [][]char): []char\n\u0009switch(id)\n\u0009case %incorrectOption\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30AA\u30D7\u30B7\u30E7\u30F3\u300C\\{args[0]}\u300D\u306E\u4F7F\u308F\u308C\u65B9\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The option \'\\{args[0]}\' was used incorrectly.\"\n\u0009\u0009end switch\n\u0009case %unexpectedOption\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u4E0D\u660E\u306A\u30AA\u30D7\u30B7\u30E7\u30F3\u300C\\{args[0]}\u300D\u304C\u6307\u5B9A\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Unexpected option: \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %incorrectExt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5165\u529B\u30D5\u30A1\u30A4\u30EB\u300C\\{args[0]}\u300D\u306E\u62E1\u5F35\u5B50\u306F\u300C.kn\u300D\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The extension of the input file \'\\{args[0]}\' must be \'.kn\'.\"\n\u0009\u0009end switch\n\u0009case %incorrectSrcName\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u540D\u300C\\{args[0]}\u300D\u306B\u4F7F\u3048\u306A\u3044\u6587\u5B57\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The source file name \'\\{args[0]}\' contains characters that cannot be used.\"\n\u0009\u0009end switch\n\u0009case %fileOpenFailed\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u300C\\{args[0]}\u300D\u304C\u958B\u3051\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Cannot open source file \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %sysFileOpenFailed\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30B7\u30B9\u30C6\u30E0\u30D5\u30A1\u30A4\u30EB\u300C\\{args[0]}\u300D\u304C\u958B\u3051\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The system file \'\\{args[0]}\' could not be opened.\"\n\u0009\u0009end switch\n\u0009case %sysFileBroken\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30B7\u30B9\u30C6\u30E0\u30D5\u30A1\u30A4\u30EB\u300C\\{args[0]}\u300D\u304C\u58CA\u308C\u3066\u3044\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The system file \'\\{args[0]}\' is broken.\"\n\u0009\u0009end switch\n\u0009case %sameIdentifierInSameScope\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u540C\u3058\u30B9\u30B3\u30FC\u30D7\u5185\u306B\u65E2\u306B\u540C\u3058\u8B58\u5225\u5B50\u300C\\{args[0]}\u300D\u304C\u5B58\u5728\u3057\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The same identifier \'\\{args[0]}\' already exists in the same scope.\"\n\u0009\u0009end switch\n\u0009case %sameIdentifierInUpperScope\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u4E0A\u4F4D\u306E\u30B9\u30B3\u30FC\u30D7\u5185\u306B\u65E2\u306B\u540C\u3058\u8B58\u5225\u5B50\u300C\\{args[0]}\u300D\u304C\u5B58\u5728\u3057\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The same identifier \'\\{args[0]}\' already exists in the upper scope.\"\n\u0009\u0009end switch\n\u0009case %noBrace\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30B3\u30E1\u30F3\u30C8\u306E\u300C{\u300D\u306B\u5BFE\u5FDC\u3059\u308B\u300C}\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"There is no \'}\' corresponding to \'{\' for comment.\"\n\u0009\u0009end switch\n\u0009case %tabInStr\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3084\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u4E2D\u306B\u30BF\u30D6\u6587\u5B57\u306F\u8A18\u8FF0\u3067\u304D\u307E\u305B\u3093\u3002 \u30A8\u30B9\u30B1\u30FC\u30D7\u30B7\u30FC\u30B1\u30F3\u30B9\u300C\\\\t\u300D\u3092\u4EE3\u7528\u3057\u3066\u304F\u3060\u3055\u3044\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Tab characters cannot be written in character literals and string literals. Use the escape sequence \'\\\\t\' instead.\"\n\u0009\u0009end switch\n\u0009case %lineBreakInStr\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3084\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u4E2D\u3067\u306F\u6539\u884C\u3067\u304D\u307E\u305B\u3093\u3002 \u30A8\u30B9\u30B1\u30FC\u30D7\u30B7\u30FC\u30B1\u30F3\u30B9\u300C\\\\n\u300D\u3092\u4EE3\u7528\u3057\u3066\u304F\u3060\u3055\u3044\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Line breaks are not allowed in character literals and string literals. Use the escape sequence \'\\\\n\' instead.\"\n\u0009\u0009end switch\n\u0009case %wrongCharacterInIdentifier\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u8B58\u5225\u5B50\u306B\u306F\u4F7F\u3048\u306A\u3044\u6587\u5B57\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The character \'\\{args[0]}\' that cannot be used in identifiers was written.\"\n\u0009\u0009end switch\n\u0009case %wrongAtInIdentifier\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u8B58\u5225\u5B50\u306B\u6B63\u3057\u304F\u306A\u3044\u5F62\u5F0F\u3067\u300C@\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Incorrect \'@\' was written in an identifier.\"\n\u0009\u0009end switch\n\u0009case %uppercaseFileName\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u540D\u306E\u6307\u5B9A\u300C\\{args[0]}\u300D\u306B\u5927\u6587\u5B57\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A source file name description \'\\{args[0]}\' contains uppercase letters.\"\n\u0009\u0009end switch\n\u0009case %wrongBackslashInIdentifier\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u8B58\u5225\u5B50\u306B\u6B63\u3057\u304F\u306A\u3044\u5F62\u5F0F\u3067\u300C\\\\\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Incorrect \'\\\\\' was written in an identifier.\"\n\u0009\u0009end switch\n\u0009case %tooLongIdentifier\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u8B58\u5225\u5B50\u300C\\{args[0]}...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 128\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The identifier \'\\{args[0]}...\' is too long. Must be 128 characters or less.\"\n\u0009\u0009end switch\n\u0009case %incorrectBlockOrSentence\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u30D6\u30ED\u30C3\u30AF\u3082\u3057\u304F\u306F\u6587\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An incorrect block or sentence \'\\{args[0]}\' was written.\"\n\u0009\u0009end switch\n\u0009case %wrongCharacterInFuncAttr\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u5C5E\u6027\u306B\u306F\u4F7F\u3048\u306A\u3044\u6587\u5B57\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The character \'\\{args[0]}\' that cannot be used in function attributes was written.\"\n\u0009\u0009end switch\n\u0009case %tooLongFuncAttr\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u5C5E\u6027\u300C\\{args[0]}...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 128\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The function attribute \'\\{args[0]}...\' is too long. Must be 128 characters or less.\"\n\u0009\u0009end switch\n\u0009case %charShouldBeWritten\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u308B\u3079\u304D\u7B87\u6240\u306B\u3001\u4E0D\u6B63\u306A\u6587\u5B57\u300C\\{args[1]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An invalid character \'\\{args[1]}\' was written in a place where the character \'\\{args[0]}\' should be written.\"\n\u0009\u0009end switch\n\u0009case %noEnd\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\\{args[0]}\u300D\u306B\u5BFE\u5FDC\u3059\u308B\u300Cend \\{args[0]}\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"There is no \'end \\{args[0]}\' corresponding to \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %overrideNonFunctionMember\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u4EE5\u5916\u306E\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Overridden non-function member \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %exposeNonFunctionOrVariableMember\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u304A\u3088\u3073\u5909\u6570\u4EE5\u5916\u306E\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3092\u516C\u958B\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The member \'\\{args[0]}\' other than functions and variables has been released.\"\n\u0009\u0009end switch\n\u0009case %wrongEnd\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\\{args[0]}\u300D\u304C\u300Cend \\{args[0]}\u300D\u3067\u306F\u306A\u304F\u4E0D\u6B63\u306A\u300Cend \\{args[1]}\u300D\u3067\u9589\u3058\u3089\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'\\{args[0]}\' was closed with invalid \'end \\{args[1]}\' instead of \'end \\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %wrongMember\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6B63\u3057\u304F\u306A\u3044\u5F62\u5F0F\u306E\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Incorrectly formatted member \'\\{args[0]}\' was written.\"\n\u0009\u0009end switch\n\u0009case %ampersandInNonArgument\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5F15\u6570\u4EE5\u5916\u306E\u5909\u6570\u306B\u4E0D\u6B63\u306A\u300C&\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An invalid \'&\' was written in other than an argument.\"\n\u0009\u0009end switch\n\u0009case %initializerInArgument\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5F15\u6570\u306B\u521D\u671F\u5316\u5B50\u300C::\u300D\u3092\u8A18\u8FF0\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The initializer \'::\' cannot be written in arguments.\"\n\u0009\u0009end switch\n\u0009case %initializerInMember\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30E1\u30F3\u30D0\u306B\u521D\u671F\u5316\u5B50\u300C::\u300D\u3092\u8A18\u8FF0\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The initializer \'::\' cannot be written in members.\"\n\u0009\u0009end switch\n\u0009case %noInitializerInConst\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"const\u6587\u306B\u306F\u521D\u671F\u5316\u5B50\u300C::\u300D\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The initializer \'::\' must be written in const statements.\"\n\u0009\u0009end switch\n\u0009case %noEndUnspecified\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30D6\u30ED\u30C3\u30AF\u306B\u5BFE\u5FDC\u3059\u308B\u300Cend\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"There is no \'end\' corresponding to a block.\"\n\u0009\u0009end switch\n\u0009case %wrongEndUnspecified\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cend \\{args[0]}\u300D\u306F\u4E0D\u6B63\u306A\u5F62\u5F0F\u3067\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'end \\{args[0]}\' is incorrectly formatted.\"\n\u0009\u0009end switch\n\u0009case %nonCorrespondingEnd\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30D6\u30ED\u30C3\u30AF\u3068\u5BFE\u5FDC\u3057\u306A\u3044\u4E0D\u6B63\u306A\u300Cend \\{args[0]}\u300D\u3067\u9589\u3058\u3089\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Closed with invalid \'end \\{args[0]}\' that does not correspond to the block.\"\n\u0009\u0009end switch\n\u0009case %elifOrElseAfterElse\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cif\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Celse\u300D\u7BC0\u306E\u5F8C\u306B\u4E0D\u6B63\u306A\u300Celif\u300D\u7BC0\u3084\u300Celse\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"In an \'if\' block, an invalid \'elif\' or \'else\' clauses is written after an \'else\' clause.\"\n\u0009\u0009end switch\n\u0009case %caseOrDefaultAfterDefault\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Cdefault\u300D\u7BC0\u306E\u5F8C\u306B\u4E0D\u6B63\u306A\u300Ccase\u300D\u7BC0\u3084\u300Cdefault\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"In a \'switch\' block, an invalid \'case\' or \'default\' clauses is written after a \'default\' clause.\"\n\u0009\u0009end switch\n\u0009case %catchOrFinallyAfterFinally\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Ctry\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Cfinally\u300D\u7BC0\u306E\u5F8C\u306B\u4E0D\u6B63\u306A\u300Ccatch\u300D\u7BC0\u3084\u300Cfinally\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"In a \'try\' block, an invalid \'catch\' or \'finally\' clauses is written after a \'finally\' clause.\"\n\u0009\u0009end switch\n\u0009case %wrongClause\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\\{args[0]}\u300D\u30D6\u30ED\u30C3\u30AF\u4EE5\u5916\u3067\u4E0D\u6B63\u306A\u300C\\{args[1]}\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A invalid \'\\{args[1]}\' clause was written outside \'\\{args[0]}\' blocks.\"\n\u0009\u0009end switch\n\u0009case %wrongClauseInSwitch\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Ccase\u300D\u300Cdefault\u300D\u300Cend switch\u300D\u306E\u3044\u305A\u308C\u304B\u304C\u8A18\u8FF0\u3055\u308C\u308B\u3079\u304D\u7B87\u6240\u306B\u305D\u308C\u4EE5\u5916\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"In a \'switch\' block, clauses other than \'case\', \'default\' and \'end switch\' were written.\"\n\u0009\u0009end switch\n\u0009case %wrongWord\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u308B\u3079\u304D\u7B87\u6240\u306B\u4E0D\u6B63\u306A\u300C\\{args[1]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An invalid \'\\{args[1]}\' was written where \'\\{args[0]}\' should be written.\"\n\u0009\u0009end switch\n\u0009case %wrongOperator\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u6F14\u7B97\u5B50\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An incorrect operator \'\\{args[0]}\' was written.\"\n\u0009\u0009end switch\n\u0009case %tooLongStringLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u300C\\{args[0]}...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 1024\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The string literal \'\\{args[0]}\' is too long. Must be 1024 characters or less.\"\n\u0009\u0009end switch\n\u0009case %wrongEscSequence\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u30A8\u30B9\u30B1\u30FC\u30D7\u30B7\u30FC\u30B1\u30F3\u30B9\u300C\\\\\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A invalid escape sequence \'\\\\\\{args[0]}\' was written.\"\n\u0009\u0009end switch\n\u0009case %wrongCharCodeRepresentation\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u30B3\u30FC\u30C9\u8868\u8A18\u306F\u300C\\\\u\u300D\u306B\u7D9A\u3044\u3066\u3001\u6570\u5B57\u307E\u305F\u306F\u5927\u6587\u5B57\u30A2\u30EB\u30D5\u30A1\u30D9\u30C3\u30C8\u30674\u6841\u306E16\u9032\u6570\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Character code representations must be \'\\\\u\' followed by a 4-digit hexadecimal number in numbers or capital letters.\"\n\u0009\u0009end switch\n\u0009case %nonClosingStrLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3082\u3057\u304F\u306F\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u304C\u9589\u3058\u3089\u308C\u3066\u3044\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A character literal or string literal is not closed.\"\n\u0009\u0009end switch\n\u0009case %tooLongCharLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u300C\\{args[0]}...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 1\u6587\u5B57\u5206\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The character literal \'\\{args[0]}...\' is too long. A character literal must contain one character.\"\n\u0009\u0009end switch\n\u0009case %emptyCharLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u304C\u7A7A\u3067\u3059\u3002 1\u6587\u5B57\u5206\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"There is an empty character literal. A character literal must contain one character.\"\n\u0009\u0009end switch\n\u0009case %noParenthesis\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u62EC\u5F27\u300C(\u300D\u306B\u5BFE\u5FDC\u3059\u308B\u300C)\u300D\u304C\u3001\u3042\u308B\u3079\u304D\u5834\u6240\u306B\u5B58\u5728\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The \')\' corresponding to the parenthesis \'(\' does not exist where it should be.\"\n\u0009\u0009end switch\n\u0009case %wrongNumericLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6570\u5024\u30EA\u30C6\u30E9\u30EB\u306B\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An invalid \'\\{args[0]}\' was written in a numeric literal.\"\n\u0009\u0009end switch\n\u0009case %tooLongNumericLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6570\u5024\u30EA\u30C6\u30E9\u30EB\u300C\\{args[0]}...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 1024\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The numeric literal \'\\{args[0]}\' is too long. Must be 1024 characters or less.\"\n\u0009\u0009end switch\n\u0009case %wrongHexadecimalLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"16\u9032\u6570\u30EA\u30C6\u30E9\u30EB\u306F\u300C0x\u300D\u304B\u3089\u59CB\u3081\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Hexadecimal literals must start with \'0x\'.\"\n\u0009\u0009end switch\n\u0009case %wrongExponentialNotationLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6307\u6570\u8868\u8A18\u30EA\u30C6\u30E9\u30EB\u306F\u300Ce+\u300D\u3082\u3057\u304F\u306F\u300Ce-\u300D\u304B\u3089\u59CB\u3081\u3066\u6307\u6570\u90E8\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Exponential notation literals must start with \'e+\' or \'e-\' and write the exponent part.\"\n\u0009\u0009end switch\n\u0009case %wrongFloatingPointLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6D6E\u52D5\u5C0F\u6570\u70B9\u30EA\u30C6\u30E9\u30EB\u300C\\{args[0]}\u300D\u304C\u89E3\u91C8\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002 \u5024\u304C\u5927\u304D\u3059\u304E\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The floating point literal \'\\{args[0]}\' could not be interpreted. The value may be too large.\"\n\u0009\u0009end switch\n\u0009case %wrongBitTypeLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30D3\u30C3\u30C8\u578B\u30EA\u30C6\u30E9\u30EB\u300C\\{args[0]}\u300D\u306E\u63A5\u5C3E\u8F9E\u306F\u300Cb8\u300D\u300Cb16\u300D\u300Cb32\u300D\u300Cb64\u300D\u306E\u3044\u305A\u308C\u304B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The suffix of bit type literal \'\\{args[0]}\' must be either \'b8\', \'b16\', \'b32\' or \'b64\'.\"\n\u0009\u0009end switch\n\u0009case %integerLiteralOverflowed\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6574\u6570\u30EA\u30C6\u30E9\u30EB\u300C\\{args[0]}\u300D\u304C\u30AA\u30FC\u30D0\u30FC\u30D5\u30ED\u30FC\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The integer literal \'\\{args[0]}\' has overflowed.\"\n\u0009\u0009end switch\n\u0009case %noMainFunc\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cmain\u300D\u95A2\u6570\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002 \u30B3\u30F3\u30D1\u30A4\u30EB\u3059\u308B\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u306B\u300Cfunc main()\u300D\u3092\u5B9A\u7FA9\u3057\u3066\u304F\u3060\u3055\u3044\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'main\' function does not exist. Define \'func main()\' in the source files to be compiled.\"\n\u0009\u0009end switch\n\u0009case %wrongMainFunc\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cmain\u300D\u95A2\u6570\u306E\u5B9A\u7FA9\u306F\u300Cfunc main()\u300D\u3068\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The definition of the \'main\' function must be \'func main()\'.\"\n\u0009\u0009end switch\n\u0009case %accessMemberWithoutMe\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30E1\u30F3\u30D0\u3082\u3057\u304F\u306F\u5909\u6570\u300C\\{args[0]}\u300D\u306B\u3001\u300Cme\u300D\u3092\u4ECB\u3055\u305A\u76F4\u63A5\u30A2\u30AF\u30BB\u30B9\u3057\u305F\u304B\u3001\u95A2\u6570\u3092\u8D85\u3048\u3066\u30A2\u30AF\u30BB\u30B9\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The member or variable \'\\{args[0]}\' was accessed directly without \'me\', or accessed beyond the function.\"\n\u0009\u0009end switch\n\u0009case %nonOmittingAt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\\{args[0]}@\u300D\u306B\u3064\u3044\u3066\u3001\u81EA\u8EAB\u306E\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u306E\u30B0\u30ED\u30FC\u30D0\u30EB\u8981\u7D20\u3092\u53C2\u7167\u3059\u308B\u3068\u304D\u306F\u3001\u300C@\u300D\u306E\u524D\u306E\u30BD\u30FC\u30B9\u540D\u3092\u7701\u7565\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"For \'\\{args[0]}@\', when referring to global elements in its own source file, the source name before the \'@\' must be omitted.\"\n\u0009\u0009end switch\n\u0009case %accessUnpublishedElement\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u4ED6\u306E\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u306E\u516C\u958B\u3055\u308C\u3066\u3044\u306A\u3044\u8981\u7D20\u300C\\{args[0]}\u300D\u3092\u53C2\u7167\u3057\u307E\u3057\u305F\u3002\u8981\u7D20\u306E\u5148\u982D\u306B\u300C+\u300D\u304C\u4ED8\u3044\u3066\u3044\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A non-public element \'\\{args[0]}\' in another souce file was referenced. The element must start with a \'+\'.\"\n\u0009\u0009end switch\n\u0009case %identifierNotFound\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u8B58\u5225\u5B50\u300C\\{args[0]}\u300D\u306E\u5B9A\u7FA9\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002\u540D\u524D\u3092\u9593\u9055\u3048\u3066\u3044\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The definition of identifier \'\\{args[0]}\' was not be found. The name may have been written incorrectly.\"\n\u0009\u0009end switch\n\u0009case %circulatingAlias\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Calias \\{args[0]}\u300D\u306E\u5B9A\u7FA9\u304C\u5FAA\u74B0\u3057\u3066\u3044\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The definition of \'alias \\{args[0]}\' is circulating.\"\n\u0009\u0009end switch\n\u0009case %circulatingClass\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cclass \\{args[0]}\u300D\u306E\u7D99\u627F\u304C\u5FAA\u74B0\u3057\u3066\u3044\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The inheritance of \'class \\{args[0]}\' is circulating.\"\n\u0009\u0009end switch\n\u0009case %overridedMemberNotFound\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B\u89AA\u30AF\u30E9\u30B9\u306E\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The member \'\\{args[0]}\' of the parent class to override cannot be found.\"\n\u0009\u0009end switch\n\u0009case %memberDuplicatedWithParentClass\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30E1\u30F3\u30D0\u540D\u300C\\{args[0]}\u300D\u304C\u89AA\u30AF\u30E9\u30B9\u306E\u3082\u306E\u3068\u91CD\u8907\u3057\u3066\u3044\u307E\u3059\u3002 \u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B\u5834\u5408\u306F\u300C*\u300D\u3092\u4ED8\u3051\u3066\u304F\u3060\u3055\u3044\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The member name \'\\{args[0]}\' is duplicated with that of the parent class. Add \'*\' when overriding.\"\n\u0009\u0009end switch\n\u0009case %overridingNonFunc\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u4EE5\u5916\u306E\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Overridden non-function member \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %overriddenMemberNotMatchAccessModifier\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u305F\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3068\u30A2\u30AF\u30BB\u30B9\u4FEE\u98FE\u5B50\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The access modifier does not match that of the overridden member \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %overriddenMemberNotMatchTypeOrArg\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u305F\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3068\u578B\u3082\u3057\u304F\u306F\u5F15\u6570\u540D\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The types or argument names do not match that of the overridden member \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %notAllowedToBeOverridden\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u304C\u8A31\u53EF\u3055\u308C\u3066\u3044\u306A\u3044\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The member \'\\{args[0]}\' that is not allowed to be overridden was overridden.\"\n\u0009\u0009end switch\n\u0009case %enumValueMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5217\u6319\u578B\u300C\\{args[0]}\u300D\u306E\u8981\u7D20\u300C%\\{args[1]}\u300D\u306E\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u300Cint\u300D\u578B\u306E\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The value of the element \'%\\{args[1]}\' of enumeration type \'\\{args[0]}\' must be an \'int\' value that can be made a constant at compile time.\"\n\u0009\u0009end switch\n\u0009case %enumValueExceedIntRange\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5217\u6319\u578B\u300C\\{args[0]}\u300D\u306E\u8981\u7D20\u300C%\\{args[1]}\u300D\u306E\u5024\u304C\u300Cint\u300D\u578B\u306E\u6709\u52B9\u7BC4\u56F2\u3092\u8D85\u3048\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The value of the element \'%\\{args[1]}\' of enumeration type \'\\{args[0]}\' exceeds the valid range of \'int\' type.\"\n\u0009\u0009end switch\n\u0009case %enumValueDuplicated\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5217\u6319\u578B\u300C\\{args[0]}\u300D\u306E\u8981\u7D20\u300C%\\{args[1]}\u300D\u306E\u5024\u300C\\{args[2]}\u300D\u304C\u5225\u306E\u8981\u7D20\u306E\u5024\u3068\u91CD\u8907\u3057\u3066\u3044\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The value \'\\{args[2]}\' of the element \'%\\{args[1]}\' of enumeration type \'\\{args[0]}\' is duplicated with the value of another element.\"\n\u0009\u0009end switch\n\u0009case %notExistedElementName\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5217\u6319\u578B\u5185\u306B\u5B58\u5728\u3057\u306A\u3044\u8981\u7D20\u540D\u300C%\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The element name \'%\\{args[0]}\' that does not exist in the enumeration type was written.\"\n\u0009\u0009end switch\n\u0009case %valueOfGlobalVarMustBeConst\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30B0\u30ED\u30FC\u30D0\u30EB\u5909\u6570\u300C\\{args[0]}\u300D\u306E\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The value of global variable \'\\{args[0]}\' must be a constant at compile time.\"\n\u0009\u0009end switch\n\u0009case %valueOfConstMustBeConst\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cconst\u300D\u6587\u300C\\{args[0]}\u300D\u306E\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The value of \'const\' statement \'\\{args[0]}\' must be a constant at compile time.\"\n\u0009\u0009end switch\n\u0009case %varAndValueTypeNotMatch\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5909\u6570\u300C\\{args[0]}\u300D\u306E\u578B\u3068\u5024\u306E\u578B\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type of the variable \'\\{args[0]}\' does not match the value type.\"\n\u0009\u0009end switch\n\u0009case %ifCondMustBeBool\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cif\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The conditional expression of the \'if\' block must be \'bool\' type.\"\n\u0009\u0009end switch\n\u0009case %elIfCondMustBeBool\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Celif\u300D\u7BC0\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The conditional expression of the \'elif\' clause must be \'bool\' type.\"\n\u0009\u0009end switch\n\u0009case %switchCondMustBeComparable\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306F\u6BD4\u8F03\u53EF\u80FD\u306A\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The conditional expression of the \'switch\' block must be a comparable type.\"\n\u0009\u0009end switch\n\u0009case %caseCondNotMatchSwitch\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Ccase\u300D\u7BC0\u306E\u578B\u304C\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306E\u578B\u3068\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type of the \'case\' clause does not match the type of the conditional expression in the \'switch\' block.\"\n\u0009\u0009end switch\n\u0009case %whileCondMustBeBool\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cwhile\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The conditional expression of the \'while\' block must be \'bool\' type.\"\n\u0009\u0009end switch\n\u0009case %forBeginValueMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u521D\u671F\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The begin value of the \'for\' block must be \'int\' type.\"\n\u0009\u0009end switch\n\u0009case %forEndValueMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u7D42\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The end value of the \'for\' block must be \'int\' type.\"\n\u0009\u0009end switch\n\u0009case %forIncreaseDecreaseValueMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u5897\u6E1B\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The increase / decrease value of the \'for\' block must be \'int\' type.\"\n\u0009\u0009end switch\n\u0009case %forIncreaseDecreaseValueMustBeConst\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u5897\u6E1B\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The increase / decrease value of the \'for\' block must be a constant at compile time.\"\n\u0009\u0009end switch\n\u0009case %forIncreaseDecreaseValueMustBeOtherThanZero\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u5897\u6E1B\u5024\u306F\u300C0\u300D\u4EE5\u5916\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The increase / decrease value of the \'for\' block must be other than \'0\'.\"\n\u0009\u0009end switch\n\u0009case %catchCondMustBeConstInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Ccatch\u300D\u7BC0\u306E\u6761\u4EF6\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u300Cint\u300D\u578B\u306E\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The condition value in the \'catch\' clause must be an \'int\' value that can be a constant at compile time.\"\n\u0009\u0009end switch\n\u0009case %excptCodeMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cthrow\u300D\u6587\u306E\u4F8B\u5916\u30B3\u30FC\u30C9\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The exception code for the \'throw\' statement must be \'int\'.\"\n\u0009\u0009end switch\n\u0009case %mustRetValue\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u623B\u308A\u5024\u3092\u8FD4\u3059\u95A2\u6570\u3067\u306F\u300Cret\u300D\u6587\u306F\u5024\u3092\u8FD4\u3055\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"For functions that return a value, \'ret\' statements must return a value.\"\n\u0009\u0009end switch\n\u0009case %retTypeNotMatchFunc\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cret\u300D\u6587\u306E\u5024\u306E\u578B\u304C\u95A2\u6570\u306E\u623B\u308A\u5024\u306E\u578B\u3068\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type of the \'ret\' statement does not match the return type of the function.\"\n\u0009\u0009end switch\n\u0009case %noSideEffectDo\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cdo\u300D\u6587\u3067\u6700\u5F8C\u306B\u884C\u3046\u6F14\u7B97\u306F\u300C::\u300D\u6F14\u7B97\u5B50\u3084\u95A2\u6570\u547C\u3073\u51FA\u3057\u306A\u3069\u306E\u526F\u4F5C\u7528\u306E\u3042\u308B\u6F14\u7B97\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The last operation in \'do\' statements must be with side effects such as \'::\' operator or function calls.\"\n\u0009\u0009end switch\n\u0009case %mustSpecifyBlockName\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\\{args[0]}\u300D\u6587\u306B\u306F\u30D6\u30ED\u30C3\u30AF\u540D\u3092\u6307\u5B9A\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'\\{args[0]}\' statements must be given block names.\"\n\u0009\u0009end switch\n\u0009case %assertCondMustBeBool\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cassert\u300D\u6587\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The conditional expression of the \'assert\' statement must be \'bool\' type.\"\n\u0009\u0009end switch\n\u0009case %nonTypeWritten\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u578B\u3092\u8A18\u8FF0\u3059\u3079\u304D\u3068\u3053\u308D\u306B\u578B\u4EE5\u5916\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A non-type was written where a type should be written.\"\n\u0009\u0009end switch\n\u0009case %noValuePassed\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5024\u304C\u8A2D\u5B9A\u3055\u308C\u308B\u3079\u304D\u5834\u6240\u306B\u5024\u304C\u6E21\u3055\u308C\u307E\u305B\u3093\u3067\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"No value was passed where some value should be set.\"\n\u0009\u0009end switch\n\u0009case %wrongOperatorType\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6F14\u7B97\u5B50\u306E\u578B\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Incorrect type for operator.\"\n\u0009\u0009end switch\n\u0009case %wrongLeftValueOfAssignOperator\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u4EE3\u5165\u6F14\u7B97\u5B50\u306E\u5DE6\u8FBA\u5024\u304C\u4EE3\u5165\u53EF\u80FD\u306A\u5909\u6570\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The left value of the assignment operator is not an assignable variable.\"\n\u0009\u0009end switch\n\u0009case %comparingNullByValue\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cnull\u300D\u306F\u5024\u6BD4\u8F03\u304C\u3067\u304D\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'null\' cannot be compared by value.\"\n\u0009\u0009end switch\n\u0009case %enumTypeNotInferred\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cenum\u300D\u306E\u8981\u7D20\u540D\u300C\\{args[0]}\u300D\u304B\u3089\u578B\u304C\u63A8\u6E2C\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type could not be inferred from the element name \'\\{args[0]}\' of \'enum\'.\"\n\u0009\u0009end switch\n\u0009case %concatNull\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cnull\u300D\u306F\u300C~\u300D\u6F14\u7B97\u5B50\u3067\u9023\u7D50\u3067\u304D\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'null\' cannot be concatenated with the \'~\' operator.\"\n\u0009\u0009end switch\n\u0009case %dividedBy0\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"0\u3067\u9664\u7B97\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Divided by 0.\"\n\u0009\u0009end switch\n\u0009case %wrongLeftOrRightValueOfSwapOperator\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C:$\u300D\u6F14\u7B97\u5B50\u306E\u5DE6\u8FBA\u5024\u3082\u3057\u304F\u306F\u53F3\u8FBA\u5024\u304C\u4EE3\u5165\u53EF\u80FD\u306A\u5909\u6570\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The left or right value of the \':$\' operator is not an assignable variable.\"\n\u0009\u0009end switch\n\u0009case %condForCondOperatorMustBeBool\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C?(,)\u300D\u6F14\u7B97\u5B50\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The conditional expression for the \'?(,)\' operator must be \'bool\'.\"\n\u0009\u0009end switch\n\u0009case %twoValueForCondOperatorMustSameType\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C?(,)\u300D\u6F14\u7B97\u5B50\u306E\u62EC\u5F27\u5185\u306E2\u3064\u306E\u5024\u306F\u540C\u3058\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The two values in the parenthesis for the \'?(,)\' operator must be the same type.\"\n\u0009\u0009end switch\n\u0009case %wrongTypeForNewOperator\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C#\u300D\u6F14\u7B97\u5B50\u306F\u30AF\u30E9\u30B9\u3084\u300Clist\u300D\u300Cdict\u300D\u306A\u3069\u306E\u53C2\u7167\u578B\u306B\u3057\u304B\u4F7F\u3048\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The \'#\' operator can only be used for reference types such as classes, \'list\' and \'dict\'.\"\n\u0009\u0009end switch\n\u0009case %numOfElementsMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C#\u300D\u6F14\u7B97\u5B50\u306B\u8A18\u8FF0\u3059\u308B\u914D\u5217\u306E\u8981\u7D20\u6570\u306E\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The number of array elements written in the \'#\' operator must be \'int\'.\"\n\u0009\u0009end switch\n\u0009case %callNonFunction\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u3067\u306A\u3044\u3082\u306E\u3092\u95A2\u6570\u547C\u3073\u51FA\u3057\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A non-function was called as if it were a function.\"\n\u0009\u0009end switch\n\u0009case %wrongArgNumInFunc\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\\{args[0]}\u500B\u306E\u5F15\u6570\u3092\u53D7\u3051\u53D6\u308B\u95A2\u6570\u547C\u3073\u51FA\u3057\u306B\\{args[1]}\u500B\u306E\u5F15\u6570\u304C\u6307\u5B9A\u3055\u308C\u307E\u3057\u305F\u3002 \u95A2\u6570\u306E\u578B\u306F\u300C\\{args[2]}\u300D\u3067\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\\{args[1]} arguments were written in the function call that received \\{args[0]} arguments. The function type is \'\\{args[2]}\'\"\n\u0009\u0009end switch\n\u0009case %nonRefArgPassed\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u547C\u3073\u51FA\u3057\u306E\\{args[0]}\u756A\u76EE\u306E\u53C2\u7167\u6E21\u3057\u306E\u5F15\u6570\u306B\u3001\u53C2\u7167\u3092\u53D6\u308C\u306A\u3044\u5024\u304C\u6E21\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A value that cannot be referenced was passed to the \\{args[0]}th/st/nd/rd argument, which is a reference argument, of the function call.\"\n\u0009\u0009end switch\n\u0009case %wrongArgTypeInFunc\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u547C\u3073\u51FA\u3057\u306E\u5F15\u6570\u306E\u578B\u304C\u7570\u306A\u308A\u307E\u3059\u3002 \\{args[0]}\u756A\u76EE\u306E\u5F15\u6570\u3067\u300C\\{args[1]}\u300D\u3092\u6307\u5B9A\u3059\u3079\u304D\u3068\u3053\u308D\u306B\u300C\\{args[2]}\u300D\u304C\u6E21\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type of arguments of the function call is different. \'\\{args[2]}\' has been passed where \'\\{args[1]}\' should be written in the \\{args[0]}th/st/nd/rd argument.\"\n\u0009\u0009end switch\n\u0009case %nonArrayAccess\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u914D\u5217\u3067\u306A\u3044\u3082\u306E\u306B\u914D\u5217\u30A2\u30AF\u30BB\u30B9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A non-array was accessed as an array.\"\n\u0009\u0009end switch\n\u0009case %arrayIdxMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u914D\u5217\u306E\u6DFB\u5B57\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Array indices must be \'int\'.\"\n\u0009\u0009end switch\n\u0009case %memberNotExist\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u53C2\u7167\u5148\u306E\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The referenced member \'\\{args[0]}\' does not exist.\"\n\u0009\u0009end switch\n\u0009case %refUnpublishedMember\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u516C\u958B\u3055\u308C\u3066\u3044\u306A\u3044\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3092\u53C2\u7167\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An unpublished member \'\\{args[0]}\' was referenced.\"\n\u0009\u0009end switch\n\u0009case %elementTypesOfArrayInitNotMatch\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306E\u8981\u7D20\u306E\u578B\u304C\u4E00\u81F4\u3057\u3066\u3044\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The element types of the array initializer \'[]\' do not match.\"\n\u0009\u0009end switch\n\u0009case %nullForValueTypeArrayInit\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5024\u578B\u306E\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306B\u300Cnull\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'null\' was written in the value type array initializer \'[]\'.\"\n\u0009\u0009end switch\n\u0009case %allElementsAreEnum\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306E\u3059\u3079\u3066\u306E\u8981\u7D20\u304C\u300Cenum\u300D\u306E\u8981\u7D20\u540D\u306E\u305F\u3081\u3001\u578B\u304C\u6C7A\u5B9A\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002 \u3044\u305A\u308C\u304B\u306E\u8981\u7D20\u540D\u3092\u30AD\u30E3\u30B9\u30C8\u3057\u3066\u578B\u3092\u793A\u3057\u3066\u304F\u3060\u3055\u3044\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type could not be determined because all elements of the array initializer \'[]\' are element names of \'enum\'. Cast one of the element names to indicate the type.\"\n\u0009\u0009end switch\n\u0009case %allElementsAreNull\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306E\u3059\u3079\u3066\u306E\u8981\u7D20\u304C\u300Cnull\u300D\u306E\u305F\u3081\u3001\u578B\u304C\u6C7A\u5B9A\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002 \u3044\u305A\u308C\u304B\u306E\u300Cnull\u300D\u3092\u30AD\u30E3\u30B9\u30C8\u3057\u3066\u578B\u3092\u793A\u3057\u3066\u304F\u3060\u3055\u3044\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type could not be determined because all elements of the array initializer \'[]\' are \'null\'. Cast one of \'null\' to indicate the type.\"\n\u0009\u0009end switch\n\u0009case %inaccessibleElement\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u306A\u3044\u8981\u7D20\u300C\\{args[0]}\u300D\u306B\u30A2\u30AF\u30BB\u30B9\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Accessed inaccessible element \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %success\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6210\u529F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Success.\"\n\u0009\u0009end switch\n\u0009case %failure\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5931\u6557\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Failure.\"\n\u0009\u0009end switch\n\u0009case %compilationStarted\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30B3\u30F3\u30D1\u30A4\u30EB\u958B\u59CB: \\{args[0]}\u79D2\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Compilation started: \\{args[0]}s.\"\n\u0009\u0009end switch\n\u0009case %parsingCompleted\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5B57\u53E5\u69CB\u6587\u89E3\u6790\u5B8C\u4E86: \\{args[0]}\u79D2\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Parsing is complete: \\{args[0]}s.\"\n\u0009\u0009end switch\n\u0009case %semanticAnalysisCompleted\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u610F\u5473\u89E3\u6790\u5B8C\u4E86: \\{args[0]}\u79D2\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Semantic analysis is complete: \\{args[0]}s.\"\n\u0009\u0009end switch\n\u0009case %generationProcessCompleted\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u751F\u6210\u51E6\u7406\u5B8C\u4E86: \\{args[0]}\u79D2\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Generation process is complete: \\{args[0]}s.\"\n\u0009\u0009end switch\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n":true;
else if(p==="res/option.kn")
return f?"+enum Env\n\u0009cui\n\u0009wnd\n\u0009web\n\u0009cpp\nend enum\n\n+var inputFile: []char\n+var outputFile: []char\n+var sysDir: []char\n+var icon: []char\n+var rls: bool\n+var env_: @Env\n+var help: bool\n+var version: bool\n+var quiet: bool\n+var appCode: int\n+var notDeploy: bool\n+var extra: dict<[]char, bool>\n\n+var inputDir: []char\n+var inputName: []char\n+var outputDir: []char\n\n+func acquireOption(): bool\n\u0009var cmdLines: [][]char :: lib@cmdLine()\n\u0009var envStr: []char\n\u0009var appCodeStr: []char\n\u0009do @extra :: #dict<[]char, bool>\n\u0009\n\u0009for i(0, ^cmdLines - 1)\n\u0009\u0009var cmdLine: []char :: cmdLines[i]\n\u0009\u0009if(^cmdLine = 2 & cmdLine[0] = \'-\')\n\u0009\u0009\u0009switch c(cmdLine[1])\n\u0009\u0009\u0009case \'i\'\n\u0009\u0009\u0009\u0009if(!getArg1(&@inputFile, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'o\'\n\u0009\u0009\u0009\u0009if(!getArg1(&@outputFile, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'s\'\n\u0009\u0009\u0009\u0009if(!getArg1(&@sysDir, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'c\'\n\u0009\u0009\u0009\u0009if(!getArg1(&@icon, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'r\'\n\u0009\u0009\u0009\u0009if(!getArg0(&@rls, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'e\'\n\u0009\u0009\u0009\u0009if(!getArg1(&envStr, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'h\'\n\u0009\u0009\u0009\u0009if(!getArg0(&@help, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'v\'\n\u0009\u0009\u0009\u0009if(!getArg0(&@version, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'q\'\n\u0009\u0009\u0009\u0009if(!getArg0(&@quiet, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'a\'\n\u0009\u0009\u0009\u0009if(!getArg1(&appCodeStr, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'d\' {This option is only used in Kuin Editor builds.}\n\u0009\u0009\u0009\u0009if(!getArg0(&@notDeploy, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'x\'\n\u0009\u0009\u0009\u0009var extra: []char\n\u0009\u0009\u0009\u0009if(!getArg1(&extra, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do @extra.add(extra, true)\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do \\err@err(%unexpectedOption, null, [\"-\\{c}\"])\n\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009end switch\n\u0009\u0009else\n\u0009\u0009\u0009do \\err@err(%unexpectedOption, null, [\"\\{cmdLine}\"])\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009end for\n\u0009\n\u0009if(@inputFile =& null)\n\u0009\u0009ret true\n\u0009end if\n\u0009\n\u0009if(envStr =& null)\n\u0009\u0009do @env_ :: %cui\n\u0009else\n\u0009\u0009switch(envStr)\n\u0009\u0009case \"cui\"\n\u0009\u0009\u0009do @env_ :: %cui\n\u0009\u0009case \"wnd\"\n\u0009\u0009\u0009do @env_ :: %wnd\n\u0009\u0009case \"web\"\n\u0009\u0009\u0009do @env_ :: %web\n\u0009\u0009case \"cpp\"\n\u0009\u0009\u0009do @env_ :: %cpp\n\u0009\u0009default\n\u0009\u0009\u0009do \\err@err(%incorrectOption, null, [\"-e\"])\n\u0009\u0009end switch\n\u0009end if\n\u0009\n\u0009if(appCodeStr =& null)\n\u0009\u0009do @appCode :: lib@rnd(1, 0xFFFFFFFF)\n\u0009else\n\u0009\u0009var success: bool\n\u0009\u0009do @appCode :: appCodeStr.toInt(&success)\n\u0009\u0009if(!success)\n\u0009\u0009\u0009do \\err@err(%incorrectOption, null, [\"-a\"])\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009end if\n\u0009\n\u0009if(@outputFile =& null)\n\u0009\u0009do @outputFile :: file@dir(@inputFile) ~ \"out\"\n\u0009else\n\u0009\u0009do @outputFile :: file@delExt(@outputFile)\n\u0009end if\n\u0009\n\u0009if(@sysDir =& null)\n\u0009\u0009do @sysDir :: \"sys/\"\n\u0009end if\n\u0009\n\u0009if(@icon =& null)\n\u0009\u0009do @icon :: @sysDir ~ \"default.ico\"\n\u0009end if\n\u0009\n\u0009do @inputDir :: file@dir(@inputFile)\n\u0009do @inputName :: file@delExt(file@fileName(@inputFile))\n\u0009do @outputDir :: file@dir(@outputFile)\n\u0009\n\u0009if(file@ext(@inputFile) <> \"kn\")\n\u0009\u0009do \\err@err(%incorrectExt, null, [@inputName])\n\u0009end if\n\u0009\n\u0009ret true\n\u0009\n\u0009func getArg0(out: &bool, option: char): bool\n\u0009\u0009if(out <> false)\n\u0009\u0009\u0009do \\err@err(%incorrectOption, null, [\"-\\{option}\"])\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009do out :: true\n\u0009\u0009ret true\n\u0009end func\n\u0009\n\u0009func getArg1(out: &[]char, cmdLines: [][]char, idx: &int, option: char): bool\n\u0009\u0009if(out <>& null | idx + 1 >= ^cmdLines)\n\u0009\u0009\u0009do \\err@err(%incorrectOption, null, [\"-\\{option}\"])\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009do out :: cmdLines[idx + 1]\n\u0009\u0009do idx :+ 1\n\u0009\u0009ret true\n\u0009end func\nend func\n":true;
else if(p==="res/parse.kn")
return f?"var reserved: [][]char\n\nvar srcesCur: dict<[]char, \\ast@Ast>\nvar srcesNext: dict<[]char, \\ast@Ast>\nvar filePtr: file@Reader\n\nvar srcName: []char\nvar row: int\nvar col: int\n\nvar fileBuf: char\nvar fileBufTmp: char {For single line comments and line breaking.}\nvar fileLast: bool\nvar scope: stack<\\ast@Ast>\nvar uniqueCnt: int\nvar scopeRefedItems: list<\\ast@ScopeRefedItem>\n\n+func parse(): dict<[]char, \\ast@Ast>\n\u0009do @srcesCur :: #dict<[]char, \\ast@Ast>\n\u0009do @srcesCur.add(\"\\\\\" ~ \\option@inputName, null)\n\u0009do @srcesCur.add(\"kuin\", null)\n\u0009\n\u0009var endFlag: lib@Bool :: #lib@Bool\n\u0009do endFlag.value :: false\n\u0009while(!endFlag.value)\n\u0009\u0009do endFlag.value :: true\n\u0009\u0009do @srcesNext :: #dict<[]char, \\ast@Ast>\n\u0009\u0009do @srcesCur.forEach(@parseSrc, endFlag)\n\u0009\u0009do @srcesCur :: @srcesNext\n\u0009end while\n\u0009\n\u0009ret @srcesCur\nend func\n\nfunc parseSrc(key: []char, value: \\ast@Ast, data: kuin@Class): bool\n\u0009if(value <>& null)\n\u0009\u0009do @srcesNext.add(key, value)\n\u0009\u0009ret true\n\u0009end if\n\u0009\n\u0009if(!isCorrectSrcName(key))\n\u0009\u0009do \\err@err(%incorrectSrcName, null, [key])\n\u0009\u0009ret true\n\u0009end if\n\u0009do(data $ lib@Bool).value :: false\n\u0009\n\u0009var truePath: []char\n\u0009if(key[0] = \'\\\\\')\n\u0009\u0009do truePath :: \\option@inputDir ~ replacePath(key.sub(1, -1)) ~ \".kn\"\n\u0009else\n\u0009\u0009do truePath :: \\option@sysDir ~ replacePath(key) ~ \".kn\"\n\u0009end if\n\u0009do @filePtr :: file@makeReader(truePath)\n\u0009if(@filePtr =& null)\n\u0009\u0009do \\err@err(%fileOpenFailed, null, [truePath])\n\u0009\u0009ret true\n\u0009end if\n\u0009\n\u0009do @srcName :: key\n\u0009do @row :: 1\n\u0009do @col :: 0\n\u0009do @fileBuf :: \'\\0\'\n\u0009do @fileBufTmp :: \'\\0\'\n\u0009do @fileLast :: false\n\u0009do @scope :: #stack<\\ast@Ast>\n\u0009do @uniqueCnt :: 0\n\u0009do @scopeRefedItems :: null\n\u0009\n\u0009var ast: \\ast@AstRoot :: @parseRoot()\n\u0009do @filePtr.fin()\n\u0009do @srcesNext.add(key, ast)\n\u0009ret true\n\u0009\n\u0009func isCorrectSrcName(name: []char): bool\n\u0009\u0009var idx: int :: 0\n\u0009\u0009if(idx < ^name & name[idx] = \'\\\\\')\n\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009end if\n\u0009\u0009while(true)\n\u0009\u0009\u0009if(idx >= ^name | !(\'a\' <= name[idx] & name[idx] <= \'z\' | name[idx] = \'_\'))\n\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009\u0009\u0009if(idx >= ^name)\n\u0009\u0009\u0009\u0009\u0009ret true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(\'a\' <= name[idx] & name[idx] <= \'z\' | name[idx] = \'_\' | \'0\' <= name[idx] & name[idx] <= \'9\')\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(name[idx] = \'\\\\\')\n\u0009\u0009\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009end while\n\u0009\u0009end while\n\u0009end func\n\u0009\n\u0009func replacePath(path: []char): []char\n\u0009\u0009var r: []char :: #[^path]char\n\u0009\u0009for i(0, ^path - 1)\n\u0009\u0009\u0009do r[i] :: path[i] = \'\\\\\' ?(\'/\', path[i])\n\u0009\u0009end for\n\u0009\u0009ret r\n\u0009end func\nend func\n\nfunc parseRoot(): \\ast@AstRoot\n\u0009var ast: \\ast@AstRoot :: #\\ast@AstRoot\n\u0009do @initAst(ast, %root, \\pos@make(@srcName, 1, 1), null, false)\n\u0009do ast.scopeRefedItems :: #list<\\ast@ScopeRefedItem>\n\u0009do ast.items :: #list<\\ast@Ast>\n\u0009do @scopeRefedItems :: ast.scopeRefedItems\n\u0009\n\u0009do ast.scopeChildren :: #dict<[]char, \\ast@Ast>\n\u0009do @scope.add(ast)\n\u0009\n\u0009; For the case where there is a single line comment at the beginning of source codes.\n\u0009do @fileBuf :: \'\\n\'\n\u0009do @fileBuf :: @readChar()\n\u0009\n\u0009while loop(true)\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009skip loop\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009var item: \\ast@Ast\n\u0009\u0009var itemPublic: bool :: false\n\u0009\u0009if(c = \'+\')\n\u0009\u0009\u0009do itemPublic :: true\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009block\n\u0009\u0009\u0009var row: int :: @row\n\u0009\u0009\u0009var col: int :: @col\n\u0009\u0009\u0009var id: []char :: @readIdentifier(true, false)\n\u0009\u0009\u0009switch(id)\n\u0009\u0009\u0009case \"func\"\n\u0009\u0009\u0009\u0009do item :: @parseFunc(null, false)\n\u0009\u0009\u0009case \"var\"\n\u0009\u0009\u0009\u0009do item :: @parseVar(%global, null)\n\u0009\u0009\u0009case \"const\"\n\u0009\u0009\u0009\u0009do item :: @parseConst()\n\u0009\u0009\u0009case \"alias\"\n\u0009\u0009\u0009\u0009do item :: @parseAlias()\n\u0009\u0009\u0009case \"include\"\n\u0009\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009case \"class\"\n\u0009\u0009\u0009\u0009do item :: @parseClass()\n\u0009\u0009\u0009case \"enum\"\n\u0009\u0009\u0009\u0009do item :: @parseEnum()\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do \\err@err(%incorrectBlockOrSentence, \\pos@make(@srcName, row, col), [id])\n\u0009\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end switch\n\u0009\u0009end block\n\u0009\u0009\n\u0009\u0009if(item.typeId = %var_)\n\u0009\u0009\u0009do(item $ \\ast@AstVar).arg.publicInSrc :: itemPublic\n\u0009\u0009elif(item.typeId = %const_)\n\u0009\u0009\u0009do(item $ \\ast@AstConst).arg.publicInSrc :: itemPublic\n\u0009\u0009else\n\u0009\u0009\u0009do item.publicInSrc :: itemPublic\n\u0009\u0009end if\n\u0009\u0009do ast.items.add(item)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseFunc(parentClass: []char, overritten: bool): \\ast@AstFunc\n\u0009var ast: \\ast@AstFunc :: #\\ast@AstFunc\n\u0009\n\u0009block\n\u0009\u0009do ast.funcOption :: %none\n\u0009\u0009do ast.funcAttr :: #list<[]char>\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'[\')\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009var row: int :: @row\n\u0009\u0009\u0009\u0009var col: int :: @col\n\u0009\u0009\u0009\u0009var s: []char :: @readFuncAttr()\n\u0009\u0009\u0009\u0009if(^s = 5 & s[0] = \'_\' & s[1] = \'_\')\n\u0009\u0009\u0009\u0009\u0009switch(s[2])\n\u0009\u0009\u0009\u0009\u0009case \'a\'\n\u0009\u0009\u0009\u0009\u0009\u0009if(s[3] = \'n\' & s[4] = \'y\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%any)\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009case \'f\'\n\u0009\u0009\u0009\u0009\u0009\u0009if(s[3] = \'r\' & s[4] = \'c\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%frc)\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009case \'k\'\n\u0009\u0009\u0009\u0009\u0009\u0009if(s[3] = \'v\' & s[4] = \'f\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%kvf)\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009case \'m\'\n\u0009\u0009\u0009\u0009\u0009\u0009if(s[3] = \'k\' & s[4] = \'i\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%mki)\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009case \'r\'\n\u0009\u0009\u0009\u0009\u0009\u0009if(s[3] = \'a\' & s[4] = \'w\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%raw)\n\u0009\u0009\u0009\u0009\u0009\u0009elif(s[3] = \'m\' & s[4] = \'e\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%rme)\n\u0009\u0009\u0009\u0009\u0009\u0009elif(s[3] = \'c\' & s[4] = \'h\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%rch)\n\u0009\u0009\u0009\u0009\u0009\u0009elif(s[3] = \'a\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(s[4] = \'c\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%rac)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009elif(s[4] = \'k\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%rak)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009elif(s[4] = \'v\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%rav)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009case \'t\'\n\u0009\u0009\u0009\u0009\u0009\u0009if(s[3] = \'m\' & s[4] = \'e\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%tme)\n\u0009\u0009\u0009\u0009\u0009\u0009elif(s[3] = \'c\' & s[4] = \'h\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%tch)\n\u0009\u0009\u0009\u0009\u0009\u0009elif(s[3] = \'k\' & s[4] = \'v\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%tkv)\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do ast.funcAttr.add(s)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \']\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009do @initAst(ast, %func_, @makePos(), @readIdentifier(true, false), true)\n\u0009do ast.args :: #list<\\ast@AstArg>\n\u0009do ast.ret_ :: null\n\u0009do ast.stats :: #list<\\ast@AstStat>\n\u0009\n\u0009do ast.scopeChildren :: #dict<[]char, \\ast@Ast>\n\u0009do @scope.add(ast)\n\u0009\n\u0009if(parentClass <>& null)\n\u0009\u0009do @addScopeRefeds(ast, parentClass)\n\u0009end if\n\u0009do @assertNextChar(\'(\', true)\n\u0009if(parentClass <>& null)\n\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009do @initAst(arg, %arg, ast.pos, null, false)\n\u0009\u0009do arg.name :: \"me\"\n\u0009\u0009do arg.kind :: %localArg\n\u0009\u0009do arg.refVar :: false\n\u0009\u0009do arg.expr :: null\n\u0009\u0009do @addScopeName(arg, false)\n\u0009\u0009block\n\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009do @initAst(type, %typeUser, ast.pos, null, false)\n\u0009\u0009\u0009do @addScopeRefeds(type, parentClass)\n\u0009\u0009\u0009do arg.type :: type\n\u0009\u0009end block\n\u0009\u0009do ast.args.add(arg)\n\u0009end if\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c <> \')\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009do ast.args.add(@parseArg(%localArg, null))\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \')\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \':\')\n\u0009\u0009\u0009do ast.ret_ :: @parseType()\n\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009end if\n\u0009\u0009if(c <> \'\\n\')\n\u0009\u0009\u0009do @nextCharErr(\'\\n\', c)\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009; TODO:\n\u0009{\n\u0009if(overritten)\n\u0009\u0009var statVar: \\ast@AstStatVar :: #\\ast@AstStatVar\n\u0009\u0009do @initAst(statVar, %statVar, ast.pos, null, false)\n\u0009\u0009block\n\u0009\u0009\u0009var var_: \\ast@AstVar :: #\\ast@AstVar\n\u0009\u0009\u0009do @initAst(var_, %var_, ast.pos, null, false)\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009\u0009do @initAst(arg, %arg, ast.pos, null, false)\n\u0009\u0009\u0009\u0009do arg.name :: \"super\"\n\u0009\u0009\u0009\u0009do arg.kind :: %localVar\n\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009do arg.expr :: null\n\u0009\u0009\u0009\u0009do @addScopeName(arg, false)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeFunc :: #\\ast@AstTypeFunc\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeFunc, ast.pos, null, false)\n\u0009\u0009\u0009\u0009\u0009do type.funcOption :: ast.funcOption\n\u0009\u0009\u0009\u0009\u0009do type.funcAttr :: ast.funcAttr\n\u0009\u0009\u0009\u0009\u0009do type.args :: #list<\\ast@AstTypeFuncArg>\n\u0009\u0009\u0009\u0009\u0009do type.ret_ :: ast.ret_\n\u0009\u0009\u0009\u0009\u0009var args: list<\\ast@AstArg> :: ast.args\n\u0009\u0009\u0009\u0009\u0009do args.head()\n\u0009\u0009\u0009\u0009\u0009while(!args.term())\n\u0009\u0009\u0009\u0009\u0009\u0009var data: \\ast@AstArg :: args.get()\n\u0009\u0009\u0009\u0009\u0009\u0009var arg2: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009\u0009do arg2.arg :: data.type\n\u0009\u0009\u0009\u0009\u0009\u0009do arg2.refVar :: data.refVar\n\u0009\u0009\u0009\u0009\u0009\u0009do type.args.add(arg2)\n\u0009\u0009\u0009\u0009\u0009\u0009do args.next()\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009do arg.type :: type\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do var_.arg :: arg\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do statVar.def :: var_\n\u0009\u0009end block\n\u0009\u0009do ast.stats.add(statVar)\n\u0009end if\n\u0009}\n\u0009\n\u0009while loop(true)\n\u0009\u0009var stat: \\ast@AstStat :: @parseStat(ast)\n\u0009\u0009if(stat =& null)\n\u0009\u0009\u0009if(@fileLast)\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(stat.typeId = %statEnd)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do ast.stats.add(stat)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseVar(kind: \\ast@AstArgKind, parentClass: []char): \\ast@AstVar\n\u0009var ast: \\ast@AstVar :: #\\ast@AstVar\n\u0009do @initAst(ast, %var_, @makePos(), null, false)\n\u0009do ast.arg :: @parseArg(kind, parentClass)\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseConst(): \\ast@AstConst\n\u0009var ast: \\ast@AstConst :: #\\ast@AstConst\n\u0009do @initAst(ast, %const_, @makePos(), null, false)\n\u0009do ast.arg :: @parseArg(%const_, null)\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseAlias(): \\ast@AstAlias\n\u0009var ast: \\ast@AstAlias :: #\\ast@AstAlias\n\u0009do @initAst(ast, %alias_, @makePos(), @readIdentifier(true, false), true)\n\u0009do @assertNextChar(\':\', true)\n\u0009do ast.type :: @parseType()\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseClass(): \\ast@AstClass\n\u0009var ast: \\ast@AstClass :: #\\ast@AstClass\n\u0009do @initAst(ast, %class_, @makePos(), @readIdentifier(true, false), true)\n\u0009do ast.items :: #list<\\ast@AstClassItem>\n\u0009do @assertNextChar(\'(\', true)\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c <> \')\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009do @addScopeRefeds(ast, @readIdentifier(true, true))\n\u0009\u0009\u0009do @assertNextChar(\')\', true)\n\u0009\u0009else\n\u0009\u0009\u0009var kuinSrc: bool :: @srcName = \"kuin\"\n\u0009\u0009\u0009if(!(kuinSrc & ast.name = \"Class\"))\n\u0009\u0009\u0009\u0009do @addScopeRefeds(ast, kuinSrc ?(\"@Class\", \"kuin@Class\"))\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009\n\u0009do ast.scopeChildren :: #dict<[]char, \\ast@Ast>\n\u0009do @scope.add(ast)\n\u0009\n\u0009while loop(true)\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009do \\err@err(%noEnd, @makePos(), [\"class\"])\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009skip loop\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var item: \\ast@AstClassItem :: #\\ast@AstClassItem\n\u0009\u0009do item.public :: false\n\u0009\u0009do item.override :: false\n\u0009\u0009do item.parentItem :: null\n\u0009\u0009if(c = \'+\')\n\u0009\u0009\u0009do item.public :: true\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009\u0009do c :: @readChar()\n\u0009\u0009if(c = \'*\')\n\u0009\u0009\u0009do item.override :: true\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009var id: []char :: @readIdentifier(true, false)\n\u0009\u0009var className: []char :: ast.scopeParent.typeId = %root ?(\"@\" ~ ast.name, ast.name)\n\u0009\u0009if(id = \"func\")\n\u0009\u0009\u0009do item.def :: @parseFunc(className, item.override)\n\u0009\u0009elif(id = \"var\")\n\u0009\u0009\u0009if(item.override)\n\u0009\u0009\u0009\u0009do \\err@err(%overrideNonFunctionMember, \\pos@make(@srcName, row, col), [id])\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do item.def :: @parseVar(%member, className)\n\u0009\u0009else\n\u0009\u0009\u0009if(item.public)\n\u0009\u0009\u0009\u0009do \\err@err(%exposeNonFunctionOrVariableMember, \\pos@make(@srcName, row, col), [id])\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(item.override)\n\u0009\u0009\u0009\u0009do \\err@err(%overrideNonFunctionMember, \\pos@make(@srcName, row, col), [id])\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009switch(id)\n\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009case \"end\"\n\u0009\u0009\u0009\u0009var id2: []char :: @readIdentifier(true, false)\n\u0009\u0009\u0009\u0009if(id2 <> \"class\")\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%wrongEnd, \\pos@make(@srcName, row, col), [\"class\", id2])\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009var astEndClass: \\ast@Ast :: #\\ast@Ast\n\u0009\u0009\u0009\u0009do @initAst(astEndClass, %none, \\pos@make(@srcName, row, col), null, false)\n\u0009\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009case \"const\"\n\u0009\u0009\u0009\u0009do item.def :: @parseConst()\n\u0009\u0009\u0009case \"alias\"\n\u0009\u0009\u0009\u0009do item.def :: @parseAlias()\n\u0009\u0009\u0009case \"class\"\n\u0009\u0009\u0009\u0009do item.def :: @parseClass()\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do \\err@err(%wrongMember, \\pos@make(@srcName, row, col), [id])\n\u0009\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end switch\n\u0009\u0009end if\n\u0009\u0009do ast.items.add(item)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseEnum(): \\ast@AstEnum\n\u0009var ast: \\ast@AstEnum :: #\\ast@AstEnum\n\u0009do @initAst(ast, %enum_, @makePos(), @readIdentifier(true, false), true)\n\u0009do ast.items :: #list<\\ast@AstExpr>\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009\n\u0009do ast.scopeChildren :: #dict<[]char, \\ast@Ast>\n\u0009do @scope.add(ast)\n\u0009\n\u0009while loop(true)\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009do \\err@err(%noEnd, @makePos(), [\"enum\"])\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009skip loop\n\u0009\u0009end if\n\u0009\u0009do @fileBuf :: c\n\u0009\u0009\n\u0009\u0009var item: \\ast@AstExpr\n\u0009\u0009var id: []char :: @readIdentifier(true, false)\n\u0009\u0009if(id = \"end\")\n\u0009\u0009\u0009var id2: []char :: @readIdentifier(true, false)\n\u0009\u0009\u0009if(id2 <> \"enum\")\n\u0009\u0009\u0009\u0009do \\err@err(%wrongEnd, @makePos(), [\"enum\", id2])\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do c :: @readChar()\n\u0009\u0009if(c = \':\')\n\u0009\u0009\u0009do @assertNextChar(\':\', false)\n\u0009\u0009\u0009do item :: @parseExpr()\n\u0009\u0009\u0009if(item =& null)\n\u0009\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009else\n\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009do expr.type :: null {Set the type to \'null\' when no value is specified.}\n\u0009\u0009\u0009do expr.value :: 0b64\n\u0009\u0009\u0009do item :: expr\n\u0009\u0009end if\n\u0009\u0009do item.name :: id\n\u0009\u0009if(c <> \'\\n\')\n\u0009\u0009\u0009do @nextCharErr(\'\\n\', c)\n\u0009\u0009end if\n\u0009\u0009do ast.items.add(item)\n\u0009\u0009do @addScopeName(item, true)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseArg(kind: \\ast@AstArgKind, parentClass: []char): \\ast@AstArg\n\u0009var ast: \\ast@AstArg :: #\\ast@AstArg\n\u0009do @initAst(ast, %arg, @makePos(), @readIdentifier(true, false), false)\n\u0009do ast.kind :: kind\n\u0009do ast.refVar :: false\n\u0009if(parentClass <>& null)\n\u0009\u0009do @addScopeRefeds(ast, parentClass)\n\u0009end if\n\u0009do @assertNextChar(\':\', true)\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'&\')\n\u0009\u0009\u0009if(kind <> %localArg)\n\u0009\u0009\u0009\u0009do \\err@err(%ampersandInNonArgument, @makePos(), null)\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do ast.refVar :: true\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009do ast.type :: @parseType()\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \':\')\n\u0009\u0009\u0009do @assertNextChar(\':\', false)\n\u0009\u0009\u0009assert kind <> %unknown\n\u0009\u0009\u0009switch(kind)\n\u0009\u0009\u0009case %localArg\n\u0009\u0009\u0009\u0009do \\err@err(%initializerInArgument, @makePos(), null)\n\u0009\u0009\u0009\u0009do ast.expr :: null\n\u0009\u0009\u0009case %member\n\u0009\u0009\u0009\u0009do \\err@err(%initializerInMember, @makePos(), null)\n\u0009\u0009\u0009\u0009do ast.expr :: null\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do ast.expr :: @parseExpr()\n\u0009\u0009\u0009end switch\n\u0009\u0009else\n\u0009\u0009\u0009if(kind = %const_)\n\u0009\u0009\u0009\u0009do \\err@err(%noInitializerInConst, @makePos(), null)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.expr :: null\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009ret ast\nend func\n\nfunc parseStat(block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStat\n\u0009\n\u0009block\n\u0009\u0009var c: char\n\u0009\u0009while(c = \'\\n\', skip)\n\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009do \\err@err(%noEndUnspecified, @makePos(), null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009end while\n\u0009\u0009do @fileBuf :: c\n\u0009end block\n\u0009\n\u0009var row: int :: @row\n\u0009var col: int :: @col\n\u0009var id: []char :: @readIdentifier(true, false)\n\u0009switch(id)\n\u0009case \"end\"\n\u0009\u0009do ast :: @parseStatEnd(row, col, block_)\n\u0009case \"func\"\n\u0009\u0009do ast :: @parseStatFunc()\n\u0009case \"var\"\n\u0009\u0009do ast :: @parseStatVar()\n\u0009case \"const\"\n\u0009\u0009do ast :: @parseStatConst()\n\u0009case \"alias\"\n\u0009\u0009do ast :: @parseStatAlias()\n\u0009case \"class\"\n\u0009\u0009do ast :: @parseStatClass()\n\u0009case \"enum\"\n\u0009\u0009do ast :: @parseStatEnum()\n\u0009case \"if\"\n\u0009\u0009do ast :: @parseStatIf()\n\u0009case \"elif\"\n\u0009\u0009do ast :: @parseStatElIf(row, col, block_)\n\u0009case \"else\"\n\u0009\u0009do ast :: @parseStatElse(row, col, block_)\n\u0009case \"switch\"\n\u0009\u0009do ast :: @parseStatSwitch(row, col)\n\u0009case \"case\"\n\u0009\u0009do ast :: @parseStatCase(row, col, block_)\n\u0009case \"default\"\n\u0009\u0009do ast :: @parseStatDefault(row, col, block_)\n\u0009case \"while\"\n\u0009\u0009do ast :: @parseStatWhile()\n\u0009case \"for\"\n\u0009\u0009do ast :: @parseStatFor(row, col)\n\u0009case \"try\"\n\u0009\u0009do ast :: @parseStatTry(row, col)\n\u0009case \"catch\"\n\u0009\u0009do ast :: @parseStatCatch(row, col, block_)\n\u0009case \"finally\"\n\u0009\u0009do ast :: @parseStatFinally(row, col, block_)\n\u0009case \"throw\"\n\u0009\u0009do ast :: @parseStatThrow()\n\u0009case \"block\"\n\u0009\u0009do ast :: @parseStatBlock()\n\u0009case \"ret\"\n\u0009\u0009do ast :: @parseStatRet()\n\u0009case \"do\"\n\u0009\u0009do ast :: @parseStatDo()\n\u0009case \"break\"\n\u0009\u0009do ast :: @parseStatBreak()\n\u0009case \"skip\"\n\u0009\u0009do ast :: @parseStatSkip()\n\u0009case \"assert\"\n\u0009\u0009do ast :: @parseStatAssert()\n\u0009default\n\u0009\u0009do \\err@err(%incorrectBlockOrSentence, \\pos@make(@srcName, row, col), [id])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end switch\n\u0009\n\u0009if(ast =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.pos :: \\pos@make(@srcName, row, col)\n\u0009ret ast\nend func\n\nfunc parseStatEnd(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStat :: #\\ast@AstStat\n\u0009do @initAst(ast, %statEnd, \\pos@make(@srcName, row, col), null, false)\n\u0009\n\u0009var id: []char :: @readIdentifier(true, false)\n\u0009var err: bool :: false\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009switch(id)\n\u0009case \"func\"\n\u0009\u0009if(block_.typeId <> %func_)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009case \"if\"\n\u0009\u0009if(block_.typeId <> %statIf)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009case \"switch\"\n\u0009\u0009if(block_.typeId <> %statSwitch)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009case \"while\"\n\u0009\u0009if(block_.typeId <> %statWhile)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009case \"for\"\n\u0009\u0009if(block_.typeId <> %statFor)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009case \"try\"\n\u0009\u0009if(block_.typeId <> %statTry)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009case \"block\"\n\u0009\u0009if(block_.typeId <> %statBlock)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009default\n\u0009\u0009do \\err@err(%wrongEndUnspecified, \\pos@make(@srcName, row, col), [id])\n\u0009end switch\n\u0009if(err)\n\u0009\u0009do \\err@err(%nonCorrespondingEnd, \\pos@make(@srcName, row, col), [id])\n\u0009end if\n\u0009ret ast\nend func\n\nfunc parseStatFunc(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatFunc :: #\\ast@AstStatFunc\n\u0009do @initAst(ast, %statFunc, null, null, false)\n\u0009do ast.def :: @parseFunc(null, false)\n\u0009ret ast\nend func\n\nfunc parseStatVar(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatVar :: #\\ast@AstStatVar\n\u0009do @initAst(ast, %statVar, null, null, false)\n\u0009do ast.def :: @parseVar(%localVar, null)\n\u0009ret ast\nend func\n\nfunc parseStatConst(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatConst :: #\\ast@AstStatConst\n\u0009do @initAst(ast, %statConst, null, null, false)\n\u0009do ast.def :: @parseConst()\n\u0009ret ast\nend func\n\nfunc parseStatAlias(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatAlias :: #\\ast@AstStatAlias\n\u0009do @initAst(ast, %statAlias, null, null, false)\n\u0009do ast.def :: @parseAlias()\n\u0009ret ast\nend func\n\nfunc parseStatClass(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatClass :: #\\ast@AstStatClass\n\u0009do @initAst(ast, %statClass, null, null, false)\n\u0009do ast.def :: @parseClass()\n\u0009ret ast\nend func\n\nfunc parseStatEnum(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatEnum :: #\\ast@AstStatEnum\n\u0009do @initAst(ast, %statEnum, null, null, false)\n\u0009do ast.def :: @parseEnum()\n\u0009ret ast\nend func\n\nfunc parseStatIf(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatIf :: #\\ast@AstStatIf\n\u0009do @initAst(ast, %statIf, @makePos(), null, false)\n\u0009do ast.blockVar :: null\n\u0009do ast.elIfs :: #list<\\ast@AstStatElIf>\n\u0009do ast.elseStatBlock :: null\n\u0009do @pushDummyScope(ast)\n\u0009do @obtainBlockName(ast)\n\u0009do ast.cond :: @parseExpr()\n\u0009do @assertNextChar(\')\', true)\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009\n\u0009block\n\u0009\u0009var stat: \\ast@AstStat\n\u0009\u0009var typeId: \\ast@TypeId\n\u0009\u0009do ast.statBlock :: @parseDummyBlock(&stat, &typeId, %statIf, ast)\n\u0009\u0009while(typeId = %statElIf)\n\u0009\u0009\u0009var elIf: \\ast@AstStatElIf :: stat $ \\ast@AstStatElIf\n\u0009\u0009\u0009do elIf.statBlock :: @parseDummyBlock(&stat, &typeId, %statElIf, ast)\n\u0009\u0009\u0009do ast.elIfs.add(elIf)\n\u0009\u0009end while\n\u0009\u0009while(typeId = %statElse)\n\u0009\u0009\u0009do ast.elseStatBlock :: @parseDummyBlock(&stat, &typeId, %statElse, ast)\n\u0009\u0009end while\n\u0009\u0009assert typeId = %statEnd\n\u0009end block\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseStatElIf(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStatElIf :: #\\ast@AstStatElIf\n\u0009do @initAst(ast, %statElIf, null, null, false)\n\u0009do ast.statBlock :: null\n\u0009if(block_.typeId <> %statIf)\n\u0009\u0009do \\err@err(%wrongClause, \\pos@make(@srcName, row, col), [\"if\", \"elif\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009do @assertNextChar(\'(\', true)\n\u0009do ast.cond :: @parseExpr()\n\u0009do @assertNextChar(\')\', true)\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatElse(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStat :: #\\ast@AstStat\n\u0009do @initAst(ast, %statElse, null, null, false)\n\u0009if(block_.typeId <> %statIf)\n\u0009\u0009do \\err@err(%wrongClause, \\pos@make(@srcName, row, col), [\"if\", \"else\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatSwitch(row: int, col: int): \\ast@AstStat\n\u0009var ast: \\ast@AstStatSwitch :: #\\ast@AstStatSwitch\n\u0009do @initAst(ast, %statSwitch, @makePos(), null, false)\n\u0009do ast.blockVar :: @makeBlockVar(ast.pos)\n\u0009do ast.cases :: #list<\\ast@AstStatCase>\n\u0009do ast.defaultStatBlock :: null\n\u0009do @pushDummyScope(ast)\n\u0009do @obtainBlockName(ast)\n\u0009do ast.cond :: @parseExpr()\n\u0009do @assertNextChar(\')\', true)\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009\n\u0009block\n\u0009\u0009var stat: \\ast@AstStat\n\u0009\u0009var typeId: \\ast@TypeId\n\u0009\u0009while loop(true)\n\u0009\u0009\u0009do stat :: @parseStat(ast)\n\u0009\u0009\u0009if(stat =& null)\n\u0009\u0009\u0009\u0009if(@fileLast)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009break loop\n\u0009\u0009end while\n\u0009\u0009do typeId :: stat.typeId\n\u0009\u0009if(!(typeId = %statCase | typeId = %statDefault | typeId = %statEnd))\n\u0009\u0009\u0009do \\err@err(%wrongClauseInSwitch, @makePos(), null)\n\u0009\u0009end if\n\u0009\u0009while(typeId = %statCase)\n\u0009\u0009\u0009var case_: \\ast@AstStatCase :: stat $ \\ast@AstStatCase\n\u0009\u0009\u0009do case_.statBlock :: @parseDummyBlock(&stat, &typeId, %statCase, ast)\n\u0009\u0009\u0009do ast.cases.add(case_)\n\u0009\u0009end while\n\u0009\u0009while(typeId = %statDefault)\n\u0009\u0009\u0009do ast.defaultStatBlock :: @parseDummyBlock(&stat, &typeId, %statDefault, ast)\n\u0009\u0009end while\n\u0009\u0009assert typeId = %statEnd\n\u0009end block\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseStatCase(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStatCase :: #\\ast@AstStatCase\n\u0009do @initAst(ast, %statCase, null, null, false)\n\u0009do ast.conds :: #list<\\ast@ExprPair>\n\u0009do ast.statBlock :: null\n\u0009if(block_.typeId <> %statSwitch)\n\u0009\u0009do \\err@err(%wrongClause, \\pos@make(@srcName, row, col), [\"switch\", \"case\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009while loop(true)\n\u0009\u0009var exprs: \\ast@ExprPair :: #\\ast@ExprPair\n\u0009\u0009do exprs.expr0 :: @parseExpr()\n\u0009\u0009do exprs.expr1 :: null\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(c = \',\')\n\u0009\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009\u0009skip loop\n\u0009\u0009end if\n\u0009\u0009do @fileBuf :: c\n\u0009\u0009var id: []char :: @readIdentifier(true, false)\n\u0009\u0009if(id <> \"to\")\n\u0009\u0009\u0009do \\err@err(%wrongWord, @makePos(), [\"to\", id])\n\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009do exprs.expr1 :: @parseExpr()\n\u0009\u0009do c :: @readChar()\n\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009end if\n\u0009end while\n\u0009\n\u0009ret ast\nend func\n\nfunc parseStatDefault(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStat :: #\\ast@AstStat\n\u0009do @initAst(ast, %statDefault, null, null, false)\n\u0009if(block_.typeId <> %statSwitch)\n\u0009\u0009do \\err@err(%wrongClause, \\pos@make(@srcName, row, col), [\"switch\", \"default\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatWhile(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatWhile :: #\\ast@AstStatWhile\n\u0009do @initAst(ast, %statWhile, @makePos(), null, false)\n\u0009do ast.blockVar :: null\n\u0009do ast.skip_ :: false\n\u0009do ast.stats :: #list<\\ast@AstStat>\n\u0009do @pushDummyScope(ast)\n\u0009do @obtainBlockName(ast)\n\u0009do ast.cond :: @parseExpr()\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \',\')\n\u0009\u0009\u0009var id: []char :: @readIdentifier(true, false)\n\u0009\u0009\u0009if(id <> \"skip\")\n\u0009\u0009\u0009\u0009do \\err@err(%wrongWord, @makePos(), [\"skip\", id])\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.skip_ :: true\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009\u0009do @assertNextChar(\')\', true)\n\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009end block\n\u0009\n\u0009while loop(true)\n\u0009\u0009var stat: \\ast@AstStat :: @parseStat(ast)\n\u0009\u0009if(stat =& null)\n\u0009\u0009\u0009if(@fileLast)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(stat.typeId = %statEnd)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do ast.stats.add(stat)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseStatFor(row: int, col: int): \\ast@AstStat\n\u0009var ast: \\ast@AstStatFor :: #\\ast@AstStatFor\n\u0009do @initAst(ast, %statFor, @makePos(), null, false)\n\u0009do ast.blockVar :: @makeBlockVar(ast.pos)\n\u0009do ast.stats :: #list<\\ast@AstStat>\n\u0009do @pushDummyScope(ast)\n\u0009do @obtainBlockName(ast)\n\u0009do ast.start :: @parseExpr()\n\u0009do @assertNextChar(\',\', true)\n\u0009do ast.cond :: @parseExpr()\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \',\')\n\u0009\u0009\u0009do ast.step :: @parseExpr()\n\u0009\u0009\u0009do @assertNextChar(\')\', true)\n\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009else\n\u0009\u0009\u0009do ast.step :: @makePrimValue(@makePos(), %int_, 1b64)\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009do @assertNextChar(\')\', true)\n\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009while loop(true)\n\u0009\u0009var stat: \\ast@AstStat :: @parseStat(ast)\n\u0009\u0009if(stat =& null)\n\u0009\u0009\u0009if(@fileLast)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(stat.typeId = %statEnd)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do ast.stats.add(stat)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseStatTry(row: int, col: int): \\ast@AstStat\n\u0009var ast: \\ast@AstStatTry :: #\\ast@AstStatTry\n\u0009do @initAst(ast, %statTry, @makePos(), null, false)\n\u0009do ast.blockVar :: @makeBlockVar(ast.pos)\n\u0009do ast.catches :: #list<\\ast@AstStatCatch>\n\u0009do ast.finallyStatBlock :: null\n\u0009do @pushDummyScope(ast)\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c <> \'\\n\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009do ast.name :: @readIdentifier(true, false)\n\u0009\u0009\u0009do @addScopeName(ast, true)\n\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009else\n\u0009\u0009\u0009do ast.name :: \"$\"\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009do @initAst(type, %typePrim, \\pos@make(@srcName, row, col), null, false)\n\u0009\u0009do type.kind :: %int_\n\u0009\u0009do ast.blockVar.type :: type\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var stat: \\ast@AstStat\n\u0009\u0009var typeId: \\ast@TypeId\n\u0009\u0009do ast.statBlock :: @parseDummyBlock(&stat, &typeId, %statTry, ast)\n\u0009\u0009while(typeId = %statCatch)\n\u0009\u0009\u0009var catch_: \\ast@AstStatCatch :: stat $ \\ast@AstStatCatch\n\u0009\u0009\u0009do catch_.statBlock :: @parseDummyBlock(&stat, &typeId, %statCatch, ast)\n\u0009\u0009\u0009do ast.catches.add(catch_)\n\u0009\u0009end while\n\u0009\u0009if(typeId = %statFinally)\n\u0009\u0009\u0009do ast.finallyStatBlock :: @parseDummyBlock(&stat, &typeId, %statFinally, ast)\n\u0009\u0009end if\n\u0009\u0009assert typeId = %statEnd\n\u0009end block\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseStatCatch(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStatCatch :: #\\ast@AstStatCatch\n\u0009do @initAst(ast, %statCatch, null, null, false)\n\u0009do ast.conds :: #list<\\ast@ExprPair>\n\u0009do ast.statBlock :: null\n\u0009if(block_.typeId <> %statTry)\n\u0009\u0009do \\err@err(%wrongClause, \\pos@make(@srcName, row, col), [\"try\", \"catch\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009var exprs: \\ast@ExprPair :: #\\ast@ExprPair\n\u0009\u0009\u0009var pos: \\pos@Pos :: @makePos()\n\u0009\u0009\u0009do exprs.expr0 :: @makePrimValue(pos, %int_, 0b64)\n\u0009\u0009\u0009do exprs.expr1 :: @makePrimValue(pos, %int_, 0xFFFFFFFFb64)\n\u0009\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: #\\ast@ExprPair\n\u0009\u0009\u0009\u0009do exprs.expr0 :: @parseExpr()\n\u0009\u0009\u0009\u0009do exprs.expr1 :: null\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \',\')\n\u0009\u0009\u0009\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009var id: []char :: @readIdentifier(true, false)\n\u0009\u0009\u0009\u0009if(id <> \"to\")\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%wrongWord, @makePos(), [\"to\", id])\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do exprs.expr1 :: @parseExpr()\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009ret ast\nend func\n\nfunc parseStatFinally(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStat :: #\\ast@AstStat\n\u0009do @initAst(ast, %statFinally, null, null, false)\n\u0009if(block_.typeId <> %statTry)\n\u0009\u0009do \\err@err(%wrongClause, \\pos@make(@srcName, row, col), [\"try\", \"finally\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatThrow(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatThrow :: #\\ast@AstStatThrow\n\u0009do @initAst(ast, %statThrow, @makePos(), null, false)\n\u0009do ast.code :: @parseExpr()\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatBlock(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009do @initAst(ast, %statBlock, @makePos(), null, false)\n\u0009do ast.blockVar :: null\n\u0009do ast.stats :: #list<\\ast@AstStat>\n\u0009do @pushDummyScope(ast)\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c <> \'\\n\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009do ast.name :: @readIdentifier(true, false)\n\u0009\u0009\u0009do @addScopeName(ast, true)\n\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009else\n\u0009\u0009\u0009do ast.name :: \"$\"\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009while loop(true)\n\u0009\u0009var stat: \\ast@AstStat :: @parseStat(ast)\n\u0009\u0009if(stat =& null)\n\u0009\u0009\u0009if(@fileLast)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(stat.typeId = %statEnd)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do ast.stats.add(stat)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseStatRet(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatRet :: #\\ast@AstStatRet\n\u0009do @initAst(ast, %statRet, @makePos(), null, false)\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c <> \'\\n\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009do ast.value :: @parseExpr()\n\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009else\n\u0009\u0009\u0009do ast.value :: null\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009ret ast\nend func\n\nfunc parseStatDo(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009do @initAst(ast, %statDo, @makePos(), null, false)\n\u0009do ast.expr :: @parseExpr()\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatBreak(): \\ast@AstStat\n\u0009var ast: \\ast@AstStat :: #\\ast@AstStat\n\u0009do @initAst(ast, %statBreak, @makePos(), null, false)\n\u0009do @addScopeRefeds(ast, @readIdentifier(true, false))\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatSkip(): \\ast@AstStat\n\u0009var ast: \\ast@AstStat :: #\\ast@AstStat\n\u0009do @initAst(ast, %statSkip, @makePos(), null, false)\n\u0009do @addScopeRefeds(ast, @readIdentifier(true, false))\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatAssert(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatAssert :: #\\ast@AstStatAssert\n\u0009do @initAst(ast, %statAssert, @makePos(), null, false)\n\u0009do ast.cond :: @parseExpr()\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseType(): \\ast@AstType\n\u0009var pos: \\pos@Pos :: @makePos()\n\u0009var ast: \\ast@AstType :: null\n\u0009var c: char :: @readChar()\n\u0009if(c = \'[\')\n\u0009\u0009do @assertNextChar(\']\', true)\n\u0009\u0009\n\u0009\u0009var ast2: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009do @initAst(ast2, %typeArray, pos, null, false)\n\u0009\u0009do ast2.itemType :: @parseType()\n\u0009\u0009do ast :: ast2\n\u0009else\n\u0009\u0009do @fileBuf :: c\n\u0009\u0009var id: []char :: @readIdentifier(true, true)\n\u0009\u0009if(^id >= 4 & id[0] = \'b\' & id[1] = \'i\' & id[2] = \'t\')\n\u0009\u0009\u0009var size: []char :: id.sub(3, ^id - 3)\n\u0009\u0009\u0009if(size = \"8\" | size = \"16\" | size = \"32\" | size = \"64\")\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeBit, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.size :: size.toInt(&) / 8\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(ast =& null)\n\u0009\u0009\u0009switch(id)\n\u0009\u0009\u0009case \"func\"\n\u0009\u0009\u0009\u0009do @assertNextChar(\'<\', true)\n\u0009\u0009\u0009\u0009do @assertNextChar(\'(\', true)\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeFunc :: #\\ast@AstTypeFunc\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeFunc, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.funcOption :: %none\n\u0009\u0009\u0009\u0009do ast2.funcAttr :: #list<[]char>\n\u0009\u0009\u0009\u0009do ast2.args :: #list<\\ast@AstTypeFuncArg>\n\u0009\u0009\u0009\u0009do ast2.ret_ :: null\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c <> \')\')\n\u0009\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009if(c = \'&\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: true\n\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.arg :: @parseType()\n\u0009\u0009\u0009\u0009\u0009\u0009do ast2.args.add(arg)\n\u0009\u0009\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009\u0009\u0009if(c = \')\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \':\')\n\u0009\u0009\u0009\u0009\u0009do ast2.ret_ :: @parseType()\n\u0009\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c <> \'>\')\n\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\'>\', c)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"list\"\n\u0009\u0009\u0009\u0009do @assertNextChar(\'<\', true)\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeGen :: #\\ast@AstTypeGen\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeGen, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %list_\n\u0009\u0009\u0009\u0009do ast2.itemType :: @parseType()\n\u0009\u0009\u0009\u0009do @assertNextChar(\'>\', true)\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"stack\"\n\u0009\u0009\u0009\u0009do @assertNextChar(\'<\', true)\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeGen :: #\\ast@AstTypeGen\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeGen, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %stack_\n\u0009\u0009\u0009\u0009do ast2.itemType :: @parseType()\n\u0009\u0009\u0009\u0009do @assertNextChar(\'>\', true)\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"queue\"\n\u0009\u0009\u0009\u0009do @assertNextChar(\'<\', true)\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeGen :: #\\ast@AstTypeGen\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeGen, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %queue_\n\u0009\u0009\u0009\u0009do ast2.itemType :: @parseType()\n\u0009\u0009\u0009\u0009do @assertNextChar(\'>\', true)\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"dict\"\n\u0009\u0009\u0009\u0009do @assertNextChar(\'<\', true)\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeDict :: #\\ast@AstTypeDict\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeDict, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.itemTypeKey :: @parseType()\n\u0009\u0009\u0009\u0009do @assertNextChar(\',\', true)\n\u0009\u0009\u0009\u0009do ast2.itemTypeValue :: @parseType()\n\u0009\u0009\u0009\u0009do @assertNextChar(\'>\', true)\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"int\"\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typePrim, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %int_\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"float\"\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typePrim, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %float_\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"char\"\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typePrim, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %char_\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"bool\"\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typePrim, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %bool_\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeUser, pos, null, false)\n\u0009\u0009\u0009\u0009do @addScopeRefeds(ast2, id)\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009end switch\n\u0009\u0009end if\n\u0009end if\n\u0009ret ast\nend func\n\n; parseExprAssign\nfunc parseExpr(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprThree()\n\u0009var row: int :: @row\n\u0009var col: int :: @col\n\u0009var c: char :: @readChar()\n\u0009if(c = \':\')\n\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009var c2: char :: @read()\n\u0009\u0009switch(c2)\n\u0009\u0009case \':\'\n\u0009\u0009\u0009do ast2.kind :: %assign\n\u0009\u0009case \'+\'\n\u0009\u0009\u0009do ast2.kind :: %assignAdd\n\u0009\u0009case \'-\'\n\u0009\u0009\u0009do ast2.kind :: %assignSub\n\u0009\u0009case \'*\'\n\u0009\u0009\u0009do ast2.kind :: %assignMul\n\u0009\u0009case \'/\'\n\u0009\u0009\u0009do ast2.kind :: %assignDiv\n\u0009\u0009case \'%\'\n\u0009\u0009\u0009do ast2.kind :: %assignMod\n\u0009\u0009case \'^\'\n\u0009\u0009\u0009do ast2.kind :: %assignPow\n\u0009\u0009case \'~\'\n\u0009\u0009\u0009do ast2.kind :: %assignCat\n\u0009\u0009case \'$\'\n\u0009\u0009\u0009do ast2.kind :: %swap\n\u0009\u0009default\n\u0009\u0009\u0009do \\err@err(%wrongOperator, ast2.pos, [@charToStr(c2)])\n\u0009\u0009\u0009do @readUntilRet(c2)\n\u0009\u0009\u0009ret null\n\u0009\u0009end switch\n\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009do ast2.children1 :: @parseExpr()\n\u0009\u0009do ast :: ast2\n\u0009else\n\u0009\u0009do @fileBuf :: c\n\u0009end if\n\u0009ret ast\nend func\n\nfunc parseExprThree(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprOr()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'?\')\n\u0009\u0009\u0009do @assertNextChar(\'(\', false)\n\u0009\u0009\u0009var ast2: \\ast@AstExpr3 :: #\\ast@AstExpr3\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr3, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExpr()\n\u0009\u0009\u0009do @assertNextChar(\',\', true)\n\u0009\u0009\u0009do ast2.children2 :: @parseExpr()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009do @assertNextChar(\')\', true)\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprOr(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprAnd()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'|\')\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %or\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprAnd()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprAnd(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprCmp()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'&\')\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %and\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprCmp()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprCmp(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprCat()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009switch(c)\n\u0009\u0009case \'<\'\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009switch(c)\n\u0009\u0009\u0009case \'=\'\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.kind :: %le\n\u0009\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \'>\'\n\u0009\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009\u0009switch(c)\n\u0009\u0009\u0009\u0009case \'&\'\n\u0009\u0009\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009\u0009do ast2.kind :: %nEqRef\n\u0009\u0009\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009\u0009case \'$\'\n\u0009\u0009\u0009\u0009\u0009var ast2: \\ast@AstExprAs :: #\\ast@AstExprAs\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %exprAs, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009\u0009do ast2.kind :: %nIs\n\u0009\u0009\u0009\u0009\u0009do ast2.child :: ast\n\u0009\u0009\u0009\u0009\u0009do ast2.childType :: @parseType()\n\u0009\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009\u0009do ast2.kind :: %nEq\n\u0009\u0009\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.kind :: %lt\n\u0009\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009end switch\n\u0009\u0009case \'>\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009if(c = \'=\')\n\u0009\u0009\u0009\u0009do ast2.kind :: %ge\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009do ast2.kind :: %gt\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'=\'\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009switch(c)\n\u0009\u0009\u0009case \'&\'\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.kind :: %eqRef\n\u0009\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \'$\'\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExprAs :: #\\ast@AstExprAs\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %exprAs, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.kind :: %is\n\u0009\u0009\u0009\u0009do ast2.child :: ast\n\u0009\u0009\u0009\u0009do ast2.childType :: @parseType()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.kind :: %eq\n\u0009\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009end switch\n\u0009\u0009default\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end switch\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprCat(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprAdd()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'~\')\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %cat\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprAdd()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprAdd(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprMul()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009switch(c)\n\u0009\u0009case \'+\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %add\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprMul()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'-\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %sub\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprMul()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009default\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end switch\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprMul(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprPlus()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009switch(c)\n\u0009\u0009case \'*\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %mul\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprPlus()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'/\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %div\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprPlus()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'%\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %mod\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprPlus()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009default\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end switch\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprPlus(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprPow()\n\u0009if(ast <>& null)\n\u0009\u0009ret ast\n\u0009end if\n\u0009var row: int :: @row\n\u0009var col: int :: @col\n\u0009var c: char :: @readChar()\n\u0009if(c = \'#\')\n\u0009\u0009do c :: @read()\n\u0009\u0009switch(c)\n\u0009\u0009case \'[\'\n\u0009\u0009\u0009var ast2: \\ast@AstExprNewArray :: #\\ast@AstExprNewArray\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprNewArray, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.idces :: #list<\\ast@AstExpr>\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009do ast2.idces.add(@parseExpr())\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \']\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do ast2.itemType :: @parseType()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'#\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr1 :: #\\ast@AstExpr1\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr1, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %copy\n\u0009\u0009\u0009do ast2.child :: @parseExprPlus()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009default\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009var ast2: \\ast@AstExprNew :: #\\ast@AstExprNew\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprNew, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.itemType :: @parseType()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009end switch\n\u0009else\n\u0009\u0009var ast2: \\ast@AstExpr1 :: #\\ast@AstExpr1\n\u0009\u0009do @initAstExpr(ast2, %expr1, \\pos@make(@srcName, row, col))\n\u0009\u0009switch(c)\n\u0009\u0009case \'+\'\n\u0009\u0009\u0009do ast2.kind :: %plus\n\u0009\u0009case \'-\'\n\u0009\u0009\u0009do ast2.kind :: %minus\n\u0009\u0009case \'!\'\n\u0009\u0009\u0009do ast2.kind :: %not\n\u0009\u0009case \'^\'\n\u0009\u0009\u0009do ast2.kind :: %len\n\u0009\u0009default\n\u0009\u0009\u0009do \\err@err(%wrongOperator, ast2.pos, [@charToStr(c)])\n\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009ret null\n\u0009\u0009end switch\n\u0009\u0009do ast2.child :: @parseExprPlus()\n\u0009\u0009do ast :: ast2\n\u0009end if\n\u0009ret ast\nend func\n\nfunc parseExprPow(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprCall()\n\u0009if(ast =& null)\n\u0009\u0009ret ast {Interpret as a unary operator.}\n\u0009end if\n\u0009var row: int :: @row\n\u0009var col: int :: @col\n\u0009var c: char :: @readChar()\n\u0009if(c = \'^\')\n\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009do ast2.kind :: %pow\n\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009do ast2.children1 :: @parseExprPlus()\n\u0009\u0009do ast :: ast2\n\u0009else\n\u0009\u0009do @fileBuf :: c\n\u0009end if\n\u0009ret ast\nend func\n\nfunc parseExprCall(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprValue()\n\u0009if(ast =& null)\n\u0009\u0009ret ast\n\u0009end if\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009switch(c)\n\u0009\u0009case \'(\'\n\u0009\u0009\u0009assert ast <>& null\n\u0009\u0009\u0009var ast2: \\ast@AstExprCall :: #\\ast@AstExprCall\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprCall, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.func_ :: ast\n\u0009\u0009\u0009do ast2.args :: #list<\\ast@AstExprCallArg>\n\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009if(c <> \')\')\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009while loop2(true)\n\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstExprCallArg :: #\\ast@AstExprCallArg\n\u0009\u0009\u0009\u0009\u0009do arg.skipVar :: false\n\u0009\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009\u0009if(c = \'&\')\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: true\n\u0009\u0009\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009\u0009\u0009if(c = \',\' | c = \')\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.skipVar :: true\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009\u0009if(arg.skipVar)\n\u0009\u0009\u0009\u0009\u0009\u0009var ast3: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ast3, %exprRef, ast2.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do ast3.refName :: \"$\"\n\u0009\u0009\u0009\u0009\u0009\u0009do ast3.refItem :: @makeBlockVar(ast3.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.arg :: ast3\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.arg :: @parseExpr()\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do ast2.args.add(arg)\n\u0009\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009\u0009break loop2\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(c = \')\')\n\u0009\u0009\u0009\u0009\u0009\u0009break loop2\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'[\'\n\u0009\u0009\u0009assert ast <>& null\n\u0009\u0009\u0009var ast2: \\ast@AstExprArray :: #\\ast@AstExprArray\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprArray, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.var_ :: ast\n\u0009\u0009\u0009do ast2.idx :: @parseExpr()\n\u0009\u0009\u0009do @assertNextChar(\']\', true)\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'.\'\n\u0009\u0009\u0009assert ast <>& null\n\u0009\u0009\u0009var ast2: \\ast@AstExprDot :: #\\ast@AstExprDot\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprDot, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.var_ :: ast\n\u0009\u0009\u0009do ast2.member :: @readIdentifier(true, false)\n\u0009\u0009\u0009do ast2.classItem :: null\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'$\'\n\u0009\u0009\u0009assert ast <>& null\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009switch(c)\n\u0009\u0009\u0009case \'>\'\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExprToBin :: #\\ast@AstExprToBin\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %exprToBin, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.child :: ast\n\u0009\u0009\u0009\u0009do ast2.childType :: @parseType()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \'<\'\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExprFromBin :: #\\ast@AstExprFromBin\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %exprFromBin, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.child :: ast\n\u0009\u0009\u0009\u0009do ast2.childType :: @parseType()\n\u0009\u0009\u0009\u0009do ast2.offset :: @makePrimValue(ast2.pos, %int_, 0b64)\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExprAs :: #\\ast@AstExprAs\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %exprAs, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.kind :: %as\n\u0009\u0009\u0009\u0009do ast2.child :: ast\n\u0009\u0009\u0009\u0009do ast2.childType :: @parseType()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009end switch\n\u0009\u0009default\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end switch\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprValue(): \\ast@AstExpr\n\u0009var row: int :: @row\n\u0009var col: int :: @col\n\u0009var c: char :: @readChar()\n\u0009var pos: \\pos@Pos :: \\pos@make(@srcName, row, col)\n\u0009switch(c)\n\u0009case \'\"\'\n\u0009\u0009var buf: []char :: #[1024]char\n\u0009\u0009var len: int :: 0\n\u0009\u0009var esc: bool :: false\n\u0009\u0009while loop(true)\n\u0009\u0009\u0009do c :: @readInStr()\n\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009do \\err@err(%nonClosingStrLiteral, pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(esc)\n\u0009\u0009\u0009\u0009if(c = \'{\')\n\u0009\u0009\u0009\u0009\u0009var cat: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(cat, %expr2, pos)\n\u0009\u0009\u0009\u0009\u0009do cat.kind :: %cat\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var cat2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(cat2, %expr2, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do cat2.kind :: %cat\n\u0009\u0009\u0009\u0009\u0009\u0009do cat2.children0 :: @makeStrValue(pos, buf.sub(0, len))\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var call: \\ast@AstExprCall :: #\\ast@AstExprCall\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(call, %exprCall, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do call.args :: #list<\\ast@AstExprCallArg>\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var dot: \\ast@AstExprDot :: #\\ast@AstExprDot\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(dot, %exprDot, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.var_ :: @parseExpr()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.member :: \"toStr\"\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.classItem :: null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do call.func_ :: dot\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do cat2.children1 :: call\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do @assertNextChar(\'}\', false)\n\u0009\u0009\u0009\u0009\u0009\u0009do cat.children0 :: cat2\n\u0009\u0009\u0009\u0009\u0009\u0009do @fileBuf :: \'\"\'\n\u0009\u0009\u0009\u0009\u0009\u0009do cat.children1 :: @parseExprValue()\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009ret cat\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%tooLongStringLiteral, pos, [buf])\n\u0009\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do buf[len] :: @escChar(c)\n\u0009\u0009\u0009\u0009do len :+ 1\n\u0009\u0009\u0009\u0009do esc :: false\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(c = \'\"\')\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(c = \'\\\\\')\n\u0009\u0009\u0009\u0009do esc :: true\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009do \\err@err(%tooLongStringLiteral, pos, [buf])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf[len] :: c\n\u0009\u0009\u0009do len :+ 1\n\u0009\u0009end while\n\u0009\u0009ret @makeStrValue(pos, buf.sub(0, len))\n\u0009case \'\\\'\'\n\u0009\u0009var buf: char :: \'\\0\'\n\u0009\u0009var set: bool :: false\n\u0009\u0009var esc: bool :: false\n\u0009\u0009while loop(true)\n\u0009\u0009\u0009do c :: @readInStr()\n\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009do \\err@err(%nonClosingStrLiteral, pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(esc)\n\u0009\u0009\u0009\u0009if(set)\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%tooLongCharLiteral, pos, [@charToStr(buf)])\n\u0009\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do buf :: @escChar(c)\n\u0009\u0009\u0009\u0009do set :: true\n\u0009\u0009\u0009\u0009do esc :: false\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(c = \'\\\'\')\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(c = \'\\\\\')\n\u0009\u0009\u0009\u0009do esc :: true\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(set)\n\u0009\u0009\u0009\u0009do \\err@err(%tooLongCharLiteral, pos, [@charToStr(buf)])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf :: c\n\u0009\u0009\u0009do set :: true\n\u0009\u0009end while\n\u0009\u0009if(!set)\n\u0009\u0009\u0009do \\err@err(%emptyCharLiteral, pos, null)\n\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009ret @makePrimValue(pos, %char_, buf $ bit64)\n\u0009case \'(\'\n\u0009\u0009var ast: \\ast@AstExpr :: @parseExpr()\n\u0009\u0009do c :: @readChar()\n\u0009\u0009if(c <> \')\')\n\u0009\u0009\u0009do \\err@err(%noParenthesis, pos, null)\n\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009ret ast\n\u0009case \'[\'\n\u0009\u0009var ast: \\ast@AstExprValueArray :: #\\ast@AstExprValueArray\n\u0009\u0009do @initAstExpr(ast, %exprValueArray, pos)\n\u0009\u0009do ast.values :: #list<\\ast@AstExpr>\n\u0009\u0009do c :: @readChar()\n\u0009\u0009if(c <> \']\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009var expr: \\ast@AstExpr :: @parseExpr()\n\u0009\u0009\u0009\u0009if(expr <>& null)\n\u0009\u0009\u0009\u0009\u0009do ast.values.add(expr)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \']\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009end if\n\u0009\u0009ret ast\n\u0009case \'%\'\n\u0009\u0009var id: []char :: @readIdentifier(false, false)\n\u0009\u0009var expr: \\ast@AstExprValueEnumElement :: #\\ast@AstExprValueEnumElement\n\u0009\u0009do @initAstExpr(expr, %exprValueEnumElement, pos)\n\u0009\u0009block\n\u0009\u0009\u0009var type: \\ast@AstTypeEnumElement :: #\\ast@AstTypeEnumElement\n\u0009\u0009\u0009do @initAst(type, %typeEnumElement, pos, null, false)\n\u0009\u0009\u0009do expr.type :: type\n\u0009\u0009end block\n\u0009\u0009do expr.identifier :: id\n\u0009\u0009ret expr\n\u0009default\n\u0009\u0009if(\'0\' <= c & c <= \'9\')\n\u0009\u0009\u0009ret @parseExprNumber(row, col, c)\n\u0009\u0009end if\n\u0009\u0009if(\'a\' <= c & c <= \'z\' | \'A\' <= c & c <= \'Z\' | c = \'_\' | c = \'@\' | c = \'\\\\\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009var id: []char :: @readIdentifier(true, true)\n\u0009\u0009\u0009switch(id)\n\u0009\u0009\u0009case \"false\"\n\u0009\u0009\u0009\u0009ret @makePrimValue(pos, %bool_, 0b64)\n\u0009\u0009\u0009case \"true\"\n\u0009\u0009\u0009\u0009ret @makePrimValue(pos, %bool_, 1b64)\n\u0009\u0009\u0009case \"inf\"\n\u0009\u0009\u0009\u0009ret @makeFloatValue(pos, inf)\n\u0009\u0009\u0009case \"null\"\n\u0009\u0009\u0009\u0009var ast: \\ast@AstExprValue :: #\\ast@AstExprValue\n\u0009\u0009\u0009\u0009do @initAstExpr(ast, %exprValue, pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeNull :: #\\ast@AstTypeNull\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeNull, pos, null, false)\n\u0009\u0009\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009ret ast\n\u0009\u0009\u0009case \"dbg\"\n\u0009\u0009\u0009\u0009ret @makePrimValue(pos, %bool_, \\option@rls ?(0b64, 1b64))\n\u0009\u0009\u0009case \"env\"\n\u0009\u0009\u0009\u0009ret @makePrimValue(pos, %int_, \\option@env_ $ bit64)\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009var ast: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009do @initAstExpr(ast, %exprRef, pos)\n\u0009\u0009\u0009\u0009do @addScopeRefeds(ast, id)\n\u0009\u0009\u0009\u0009ret ast\n\u0009\u0009\u0009end switch\n\u0009\u0009end if\n\u0009end switch\n\u0009do @fileBuf :: c\n\u0009ret null\nend func\n\nfunc parseExprNumber(row: int, col: int, c: char): \\ast@AstExpr\n\u0009var ast: \\ast@AstExprValue\n\u0009var pos: \\pos@Pos :: \\pos@make(@srcName, row, col)\n\u0009var buf: []char :: #[1024]char\n\u0009var len: int :: 0\n\u0009var base: int :: 10\n\u0009var changeBase: bool :: false\n\u0009var floatType: bool :: false\n\u0009var byteSize: int :: 0 {The size for bit types.}\n\u0009while loop(true)\n\u0009\u0009switch(c)\n\u0009\u0009case \'x\'\n\u0009\u0009\u0009if(changeBase | floatType)\n\u0009\u0009\u0009\u0009do \\err@err(%wrongNumericLiteral, pos, [\"x\"])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(len <> 1 | buf[0] <> \'0\')\n\u0009\u0009\u0009\u0009do \\err@err(%wrongHexadecimalLiteral, pos, null)\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do len :: 0\n\u0009\u0009\u0009do base :: 16\n\u0009\u0009\u0009do changeBase :: true\n\u0009\u0009case \'.\'\n\u0009\u0009\u0009if(changeBase | floatType)\n\u0009\u0009\u0009\u0009do \\err@err(%wrongNumericLiteral, pos, [\".\"])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009do \\err@err(%tooLongNumericLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf[len] :: c\n\u0009\u0009\u0009do len :+ 1\n\u0009\u0009\u0009do floatType :: true\n\u0009\u0009case \'0\' to \'9\', \'A\' to \'F\'\n\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009do \\err@err(%tooLongNumericLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf[len] :: c\n\u0009\u0009\u0009do len :+ 1\n\u0009\u0009default\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end switch\n\u0009\u0009do c :: @read()\n\u0009end while\n\u0009if(len = 0 | buf[len - 1] = \'.\')\n\u0009\u0009do \\err@err(%wrongNumericLiteral, pos, [\".\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009if(floatType)\n\u0009\u0009do c :: @read()\n\u0009\u0009if(c = \'e\')\n\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009do \\err@err(%tooLongNumericLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf[len] :: c\n\u0009\u0009\u0009do len :+ 1\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009if(c <> \'+\' & c <> \'-\')\n\u0009\u0009\u0009\u0009do \\err@err(%wrongExponentialNotationLiteral, pos, null)\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009do \\err@err(%tooLongNumericLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf[len] :: c\n\u0009\u0009\u0009do len :+ 1\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009if(!(\'0\' <= c & c <= \'9\'))\n\u0009\u0009\u0009\u0009do \\err@err(%wrongExponentialNotationLiteral, pos, null)\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009while(\'0\' <= c & c <= \'9\', skip)\n\u0009\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%tooLongNumericLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do buf[len] :: c\n\u0009\u0009\u0009\u0009do len :+ 1\n\u0009\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009end while\n\u0009\u0009end if\n\u0009\u0009do @fileBuf :: c\n\u0009\u0009block\n\u0009\u0009\u0009var success: bool\n\u0009\u0009\u0009var value: float :: buf.sub(0, len).toFloat(&success)\n\u0009\u0009\u0009if(!success)\n\u0009\u0009\u0009\u0009do \\err@err(%wrongFloatingPointLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009var ast2: \\ast@AstExprValueFloat :: #\\ast@AstExprValueFloat\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprValueFloat, pos)\n\u0009\u0009\u0009do ast2.value :: value\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009end block\n\u0009else\n\u0009\u0009do c :: @read()\n\u0009\u0009if(c = \'b\')\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009switch(c)\n\u0009\u0009\u0009case \'8\'\n\u0009\u0009\u0009\u0009do byteSize :: 1\n\u0009\u0009\u0009case \'1\'\n\u0009\u0009\u0009\u0009do @assertNextChar(\'6\', false)\n\u0009\u0009\u0009\u0009do byteSize :: 2\n\u0009\u0009\u0009case \'3\'\n\u0009\u0009\u0009\u0009do @assertNextChar(\'2\', false)\n\u0009\u0009\u0009\u0009do byteSize :: 4\n\u0009\u0009\u0009case \'6\'\n\u0009\u0009\u0009\u0009do @assertNextChar(\'4\', false)\n\u0009\u0009\u0009\u0009do byteSize :: 8\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do \\err@err(%wrongBitTypeLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009end switch\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009block\n\u0009\u0009\u0009var value: bit64\n\u0009\u0009\u0009var success: bool\n\u0009\u0009\u0009if(base = 10)\n\u0009\u0009\u0009\u0009do value :: buf.sub(0, len).toBit64(&success)\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009assert base = 16\n\u0009\u0009\u0009\u0009do value :: (\"0x\" ~ buf.sub(0, len)).toBit64(&success)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!success)\n\u0009\u0009\u0009\u0009do \\err@err(%integerLiteralOverflowed, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(byteSize = 1 & value > 0xFFb64 | byteSize = 2 & value > 0xFFFFb64 | byteSize = 4 & value > 0xFFFFFFFFb64 | byteSize = 0 & value > lib@intMax $ bit64)\n\u0009\u0009\u0009\u0009do \\err@err(%integerLiteralOverflowed, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009\n\u0009\u0009\u0009var ast2: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprValuePrim, pos)\n\u0009\u0009\u0009do ast2.value :: value\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009end block\n\u0009end if\n\u0009if(byteSize = 0)\n\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009do @initAst(type, %typePrim, pos, null, false)\n\u0009\u0009if(floatType)\n\u0009\u0009\u0009do type.kind :: %float_\n\u0009\u0009else\n\u0009\u0009\u0009do type.kind :: %int_\n\u0009\u0009end if\n\u0009\u0009do ast.type :: type\n\u0009else\n\u0009\u0009var type: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009do @initAst(type, %typeBit, pos, null, false)\n\u0009\u0009do type.size :: byteSize\n\u0009\u0009do ast.type :: type\n\u0009end if\n\u0009ret ast\nend func\n\nfunc makePos(): \\pos@Pos\n\u0009ret \\pos@make(@srcName, @row, @col)\nend func\n\nfunc initAst(ast: \\ast@Ast, typeId: \\ast@TypeId, pos: \\pos@Pos, name: []char, setParent: bool)\n\u0009assert ast <>$ \\ast@AstExpr\n\u0009do @initAstImpl(ast, typeId, pos, name, setParent)\nend func\n\nfunc initAstExpr(ast: \\ast@AstExpr, typeId: \\ast@TypeId, pos: \\pos@Pos)\n\u0009assert ast =$ \\ast@AstExpr\n\u0009do @initAstImpl(ast, typeId, pos, null, false)\n\u0009do ast.type :: null\n\u0009do ast.varKind :: %unknown\nend func\n\nfunc initAstImpl(ast: \\ast@Ast, typeId: \\ast@TypeId, pos: \\pos@Pos, name: []char, setParent: bool)\n\u0009do ast.typeId :: typeId\n\u0009do ast.pos :: pos\n\u0009do ast.name :: name\n\u0009do ast.scopeParent :: null\n\u0009do ast.scopeChildren :: null\n\u0009do ast.refName :: null\n\u0009do ast.refItem :: null\n\u0009do ast.extra :: null\n\u0009do ast.publicInSrc :: false\n\u0009if(ast.name <>& null)\n\u0009\u0009do @addScopeName(ast, true)\n\u0009end if\n\u0009if(setParent)\n\u0009\u0009do ast.scopeParent :: @scope.peek()\n\u0009end if\nend func\n\nfunc addScopeName(ast: \\ast@Ast, refuseReserved: bool)\n\u0009assert ast.name <>& null\n\u0009if(refuseReserved & @isReserved(ast.name))\n\u0009\u0009do \\err@err(%sameIdentifierInSameScope, @makePos(), [ast.name])\n\u0009\u0009ret\n\u0009end if\n\u0009var scope: \\ast@Ast :: @scope.peek()\n\u0009if(scope.scopeChildren.get(ast.name, &) <>& null)\n\u0009\u0009do \\err@err(%sameIdentifierInSameScope, @makePos(), [ast.name])\n\u0009end if\n\u0009\n\u0009var parent: \\ast@Ast :: scope\n\u0009var overFunc: bool :: false\n\u0009while loop(true)\n\u0009\u0009if(parent.scopeParent =& null)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(parent.name <>& null & parent.name = ast.name & !((parent.typeId = %func_ & parent.refName <>& null)))\n\u0009\u0009\u0009do \\err@err(%sameIdentifierInUpperScope, @makePos(), [ast.name])\n\u0009\u0009\u0009ret\n\u0009\u0009end if\n\u0009\u0009var child: \\ast@Ast :: parent.scopeChildren.get(ast.name, &)\n\u0009\u0009if(child <>& null)\n\u0009\u0009\u0009var flag: bool :: false\n\u0009\u0009\u0009if(overFunc)\n\u0009\u0009\u0009\u0009if(child.typeId = %arg)\n\u0009\u0009\u0009\u0009\u0009var kind: \\ast@AstArgKind :: (child $ \\ast@AstArg).kind\n\u0009\u0009\u0009\u0009\u0009if(kind = %member | kind = %localVar | kind = %localArg)\n\u0009\u0009\u0009\u0009\u0009\u0009do flag :: true\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(!flag & child.typeId.and(%statBreakable) = %statBreakable)\n\u0009\u0009\u0009\u0009\u0009do flag :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!flag & child.typeId = %func_ & child.refName <>& null)\n\u0009\u0009\u0009\u0009do flag :: true\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!flag)\n\u0009\u0009\u0009\u0009do \\err@err(%sameIdentifierInUpperScope, @makePos(), [ast.name])\n\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(parent.typeId = %func_)\n\u0009\u0009\u0009do overFunc :: true\n\u0009\u0009end if\n\u0009\u0009do parent :: parent.scopeParent\n\u0009end while\n\u0009do scope.scopeChildren.add(ast.name, ast)\nend func\n\nfunc isReserved(name: []char): bool\n\u0009if(@reserved =& null)\n\u0009\u0009do @reserved :: [\n\u0009\u0009|\"alias\",\n\u0009\u0009|\"assert\",\n\u0009\u0009|\"bit16\",\n\u0009\u0009|\"bit32\",\n\u0009\u0009|\"bit64\",\n\u0009\u0009|\"bit8\",\n\u0009\u0009|\"block\",\n\u0009\u0009|\"bool\",\n\u0009\u0009|\"break\",\n\u0009\u0009|\"case\",\n\u0009\u0009|\"catch\",\n\u0009\u0009|\"char\",\n\u0009\u0009|\"class\",\n\u0009\u0009|\"const\",\n\u0009\u0009|\"dbg\",\n\u0009\u0009|\"default\",\n\u0009\u0009|\"dict\",\n\u0009\u0009|\"do\",\n\u0009\u0009|\"elif\",\n\u0009\u0009|\"else\",\n\u0009\u0009|\"end\",\n\u0009\u0009|\"enum\",\n\u0009\u0009|\"env\",\n\u0009\u0009|\"false\",\n\u0009\u0009|\"finally\",\n\u0009\u0009|\"float\",\n\u0009\u0009|\"for\",\n\u0009\u0009|\"func\",\n\u0009\u0009|\"if\",\n\u0009\u0009|\"include\",\n\u0009\u0009|\"inf\",\n\u0009\u0009|\"int\",\n\u0009\u0009|\"list\",\n\u0009\u0009|\"me\",\n\u0009\u0009|\"null\",\n\u0009\u0009|\"queue\",\n\u0009\u0009|\"ret\",\n\u0009\u0009|\"skip\",\n\u0009\u0009|\"stack\",\n\u0009\u0009|\"super\",\n\u0009\u0009|\"switch\",\n\u0009\u0009|\"throw\",\n\u0009\u0009|\"to\",\n\u0009\u0009|\"true\",\n\u0009\u0009|\"try\",\n\u0009\u0009|\"var\",\n\u0009\u0009|\"while\"]\n\u0009\u0009\n\u0009\u0009if(dbg)\n\u0009\u0009\u0009for i(0, ^@reserved - 2)\n\u0009\u0009\u0009\u0009assert @reserved[i] < @reserved[i + 1]\n\u0009\u0009\u0009end for\n\u0009\u0009end if\n\u0009end if\n\u0009ret @reserved.findBin(name) <> -1\nend func\n\nfunc readChar(): char\n\u0009while loop(true)\n\u0009\u0009var c: char :: @read()\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009switch(c)\n\u0009\u0009\u0009case \'\\n\'\n\u0009\u0009\u0009\u0009ret \'\\n\'\n\u0009\u0009\u0009case \';\'\n\u0009\u0009\u0009\u0009while(c <> \'\\n\', skip)\n\u0009\u0009\u0009\u0009\u0009do c :: @readBuf()\n\u0009\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009\u0009ret \'\\0\'\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009case \'|\'\n\u0009\u0009\u0009\u0009ret @readChar()\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009do @fileBufTmp :: c\n\u0009\u0009\u0009ret \'\\n\'\n\u0009\u0009end if\n\u0009\u0009if(c <> \' \')\n\u0009\u0009\u0009ret c\n\u0009\u0009end if\n\u0009end while\nend func\n\nfunc read(): char\n\u0009var c: char :: @readBuf()\n\u0009switch(c)\n\u0009case \'{\'\n\u0009\u0009do @readComment()\n\u0009\u0009ret \' \'\n\u0009case \'\\t\'\n\u0009\u0009ret \' \'\n\u0009end switch\n\u0009ret c\nend func\n\nfunc readBuf(): char\n\u0009var c: char\n\u0009if(@fileBuf = \'\\0\')\n\u0009\u0009if(@fileBufTmp = \'\\0\')\n\u0009\u0009\u0009while(c = \'\\u000D\', skip)\n\u0009\u0009\u0009\u0009do c :: @filePtr.term() ?(\'\\0\', @filePtr.readLetter())\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009\u0009do @row :+ 1\n\u0009\u0009\u0009\u0009do @col :: 0\n\u0009\u0009\u0009elif(c = \'\\0\')\n\u0009\u0009\u0009\u0009if(!@fileLast)\n\u0009\u0009\u0009\u0009\u0009do @fileLast :: true\n\u0009\u0009\u0009\u0009\u0009do c :: \'\\n\'\n\u0009\u0009\u0009\u0009\u0009do @row :+ 1\n\u0009\u0009\u0009\u0009\u0009do @col :: 0\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @col :+ 1\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009do c :: @fileBufTmp\n\u0009\u0009\u0009do @fileBufTmp :: \'\\0\'\n\u0009\u0009end if\n\u0009else\n\u0009\u0009do c :: @fileBuf\n\u0009\u0009do @fileBuf :: \'\\0\'\n\u0009end if\n\u0009ret c\nend func\n\nfunc readComment()\n\u0009var row: int :: @row\n\u0009var col: int :: @col\n\u0009var c: char\n\u0009while(c <> \'}\', skip)\n\u0009\u0009do c :: @read()\n\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009do \\err@err(%noBrace, \\pos@make(@srcName, row, col), null)\n\u0009\u0009\u0009ret\n\u0009\u0009end if\n\u0009\u0009if(c = \'\"\')\n\u0009\u0009\u0009var esc: bool :: false\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009do c :: @readInStr()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%noBrace, \\pos@make(@srcName, row, col), null)\n\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(esc)\n\u0009\u0009\u0009\u0009\u0009if(c = \'{\')\n\u0009\u0009\u0009\u0009\u0009\u0009do @readComment()\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do esc :: false\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \'\"\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \'\\\\\')\n\u0009\u0009\u0009\u0009\u0009do esc :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009elif(c = \'\\\'\')\n\u0009\u0009\u0009var esc: bool :: false\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009do c :: @readInStr()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%noBrace, \\pos@make(@srcName, row, col), null)\n\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(esc)\n\u0009\u0009\u0009\u0009\u0009do esc :: false\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \'\\\'\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \'\\\\\')\n\u0009\u0009\u0009\u0009\u0009do esc :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009elif(c = \';\')\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009do c :: @readBuf()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%noBrace, \\pos@make(@srcName, row, col), null)\n\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009end if\n\u0009end while\nend func\n\nfunc readInStr(): char\n\u0009while loop(true)\n\u0009\u0009var c: char :: @readBuf()\n\u0009\u0009switch(c)\n\u0009\u0009case \'\\t\'\n\u0009\u0009\u0009do \\err@err(%tabInStr, @makePos(), null)\n\u0009\u0009\u0009skip loop\n\u0009\u0009case \'\\n\'\n\u0009\u0009\u0009do \\err@err(%lineBreakInStr, @makePos(), null)\n\u0009\u0009end switch\n\u0009\u0009ret c\n\u0009end while\nend func\n\nfunc readIdentifier(skipSpaces: bool, refName: bool): []char\n\u0009var c: char :: skipSpaces ?(@readChar(), @read())\n\u0009if(!(\'a\' <= c & c <= \'z\' | \'A\' <= c & c <= \'Z\' | c = \'_\' | refName & (c = \'@\' | c = \'\\\\\')))\n\u0009\u0009do @fileBuf :: c\n\u0009\u0009do \\err@err(%wrongCharacterInIdentifier, @makePos(), [@charToStr(c)])\n\u0009\u0009ret \"\"\n\u0009end if\n\u0009\n\u0009var buf: []char :: #[128]char\n\u0009var pos: int :: 0\n\u0009var at: bool :: false\n\u0009while(\'a\' <= c & c <= \'z\' | \'A\' <= c & c <= \'Z\' | c = \'_\' | \'0\' <= c & c <= \'9\' | refName & (c = \'@\' | c = \'\\\\\'), skip)\n\u0009\u0009switch(c)\n\u0009\u0009case \'@\'\n\u0009\u0009\u0009if(at)\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009do \\err@err(%wrongAtInIdentifier, @makePos(), null)\n\u0009\u0009\u0009\u0009ret \"\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(pos <> 0)\n\u0009\u0009\u0009\u0009var srcName: []char :: buf.sub(0, pos)\n\u0009\u0009\u0009\u0009for i(0, ^srcName - 1)\n\u0009\u0009\u0009\u0009\u0009var c2: char :: srcName[i]\n\u0009\u0009\u0009\u0009\u0009if(\'A\' <= c2 & c2 <= \'Z\')\n\u0009\u0009\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%uppercaseFileName, @makePos(), [srcName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret \"\"\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end for\n\u0009\u0009\u0009\u0009do @addSrc(srcName)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do at :: true\n\u0009\u0009case \'\\\\\'\n\u0009\u0009\u0009if(at)\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009do \\err@err(%wrongBackslashInIdentifier, @makePos(), null)\n\u0009\u0009\u0009\u0009ret \"\"\n\u0009\u0009\u0009end if\n\u0009\u0009end switch\n\u0009\u0009if(pos = 128)\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009do \\err@err(%tooLongIdentifier, @makePos(), [buf])\n\u0009\u0009\u0009ret \"\"\n\u0009\u0009end if\n\u0009\u0009do buf[pos] :: c\n\u0009\u0009do pos :+ 1\n\u0009\u0009do c :: @read()\n\u0009end while\n\u0009do @fileBuf :: c\n\u0009ret buf.sub(0, pos)\nend func\n\nfunc readUntilRet(c: char)\n\u0009while(c <> \'\\n\' & c <> \'\\0\')\n\u0009\u0009do c :: @read()\n\u0009end while\n\u0009do @fileBuf :: c\nend func\n\nfunc readFuncAttr(): []char\n\u0009var c: char :: @readChar()\n\u0009if(!(\'a\' <= c & c <= \'z\' | \'A\' <= c & c <= \'Z\' | \'0\' <= c & c <= \'9\' | c = \'_\' | c = \'.\'))\n\u0009\u0009do \\err@err(%wrongCharacterInFuncAttr, @makePos(), [@charToStr(c)])\n\u0009\u0009ret \"\"\n\u0009end if\n\u0009\n\u0009var buf: []char :: #[128]char\n\u0009var pos: int :: 0\n\u0009while(\'a\' <= c & c <= \'z\' | \'A\' <= c & c <= \'Z\' | \'0\' <= c & c <= \'9\' | c = \'_\' | c = \'.\', skip)\n\u0009\u0009if(pos = 128)\n\u0009\u0009\u0009do \\err@err(%tooLongFuncAttr, @makePos(), [buf])\n\u0009\u0009\u0009ret \"\"\n\u0009\u0009end if\n\u0009\u0009do buf[pos] :: c\n\u0009\u0009do pos :+ 1\n\u0009\u0009do c :: @read()\n\u0009end while\n\u0009do @fileBuf :: c\n\u0009ret buf.sub(0, pos)\nend func\n\nfunc addSrc(name: []char)\n\u0009if(@srcesNext.get(name, &) =& null)\n\u0009\u0009do @srcesNext.add(name, null)\n\u0009end if\nend func\n\nfunc nextCharErr(c: char, c2: char)\n\u0009do \\err@err(%charShouldBeWritten, @makePos(), [@charToStr(c), @charToStr(c2)])\n\u0009do @readUntilRet(c2)\nend func\n\nfunc assertNextChar(c: char, skipSpaces: bool)\n\u0009var c2: char :: skipSpaces ?(@readChar(), @read())\n\u0009if(c <> c2)\n\u0009\u0009do @nextCharErr(c, c2)\n\u0009\u0009do @fileBuf :: c2\n\u0009end if\nend func\n\nfunc addScopeRefeds(ast: \\ast@Ast, name: []char)\n\u0009; \'RefName\' added here will be resolved later.\n\u0009do ast.refName :: name\n\u0009var scopeRefedItem: \\ast@ScopeRefedItem :: #\\ast@ScopeRefedItem\n\u0009do scopeRefedItem.def :: ast\n\u0009do scopeRefedItem.scope :: @scope.peek()\n\u0009do @scopeRefedItems.add(scopeRefedItem)\nend func\n\nfunc charToStr(c: char): []char\n\u0009switch(c)\n\u0009case \'\\0\'\n\u0009\u0009ret \" \"\n\u0009case \'\\u000D\'\n\u0009\u0009assert false\n\u0009case \'\\n\'\n\u0009\u0009ret \"(RETURN)\"\n\u0009case \'\\t\', \' \'\n\u0009\u0009ret \"(SPACE)\"\n\u0009end switch\n\u0009ret c.toStr()\nend func\n\nfunc obtainBlockName(ast: \\ast@Ast)\n\u0009var c: char :: @readChar()\n\u0009if(c <> \'(\')\n\u0009\u0009do @fileBuf :: c\n\u0009\u0009do ast.name :: @readIdentifier(true, false)\n\u0009\u0009do @addScopeName(ast, true)\n\u0009\u0009do @assertNextChar(\'(\', true)\n\u0009else\n\u0009\u0009do ast.name :: \"$\"\n\u0009end if\nend func\n\nfunc pushDummyScope(ast: \\ast@Ast)\n\u0009var dummy: \\ast@Ast :: #\\ast@Ast\n\u0009do @initAst(dummy, %none, null, null, true)\n\u0009do @scope.peek().scopeChildren.add(\"$\" ~ @uniqueCnt.toStr(), dummy)\n\u0009do @uniqueCnt :+ 1\n\u0009\n\u0009do dummy.scopeChildren :: #dict<[]char, \\ast@Ast>\n\u0009do @scope.add(dummy)\n\u0009\n\u0009do ast.scopeParent :: dummy\nend func\n\nfunc parseDummyBlock(outStat: &\\ast@AstStat, outTypeId: &\\ast@TypeId, typeId: \\ast@TypeId, block_: \\ast@Ast): \\ast@AstStatBlock\n\u0009var ast: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009do @initAst(ast, %statBlock, @makePos(), null, false)\n\u0009do ast.blockVar :: null\n\u0009do ast.stats :: #list<\\ast@AstStat>\n\u0009do @pushDummyScope(ast)\n\u0009do ast.name :: \"$\"\n\u0009\n\u0009while loop(true)\n\u0009\u0009var stat: \\ast@AstStat :: @parseStat(block_)\n\u0009\u0009if(stat =& null)\n\u0009\u0009\u0009if(@fileLast)\n\u0009\u0009\u0009\u0009do outStat :: null\n\u0009\u0009\u0009\u0009do outTypeId :: %statEnd\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009var endFlag: bool :: false\n\u0009\u0009switch(typeId)\n\u0009\u0009case %statIf\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statElIf, %statElse, %statEnd\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statElIf\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statElIf, %statElse, %statEnd\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statElse\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statElIf, %statElse\n\u0009\u0009\u0009\u0009do \\err@err(%elifOrElseAfterElse, @makePos(), null)\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009case %statEnd\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statCase\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statCase, %statDefault, %statEnd\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statDefault\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statCase, %statDefault\n\u0009\u0009\u0009\u0009do \\err@err(%caseOrDefaultAfterDefault, @makePos(), null)\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009case %statEnd\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statTry\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statCatch, %statFinally\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statCatch\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statCatch, %statFinally, %statElIf\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statFinally\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statCatch, %statFinally\n\u0009\u0009\u0009\u0009do \\err@err(%catchOrFinallyAfterFinally, @makePos(), null)\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009case %statEnd\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009if(endFlag)\n\u0009\u0009\u0009do outStat :: stat\n\u0009\u0009\u0009do outTypeId :: stat.typeId\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do ast.stats.add(stat)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc makePrimValue(pos: \\pos@Pos, kind: \\ast@AstTypePrimKind, value: bit64): \\ast@AstExprValuePrim\n\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009do @initAstExpr(expr, %exprValuePrim, pos)\n\u0009block\n\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009do @initAst(type, %typePrim, pos, null, false)\n\u0009\u0009do type.kind :: kind\n\u0009\u0009do expr.type :: type\n\u0009end block\n\u0009do expr.value :: value\n\u0009ret expr\nend func\n\nfunc makeStrValue(pos: \\pos@Pos, value: []char): \\ast@AstExprValueStr\n\u0009var expr: \\ast@AstExprValueStr :: #\\ast@AstExprValueStr\n\u0009do @initAstExpr(expr, %exprValueStr, pos)\n\u0009block\n\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009do @initAst(type, %typeArray, pos, null, false)\n\u0009\u0009block\n\u0009\u0009\u0009var type2: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009do @initAst(type2, %typePrim, pos, null, false)\n\u0009\u0009\u0009do type2.kind :: %char_\n\u0009\u0009\u0009do type.itemType :: type2\n\u0009\u0009end block\n\u0009\u0009do expr.type :: type\n\u0009end block\n\u0009do expr.value :: value\n\u0009ret expr\nend func\n\nfunc makeFloatValue(pos: \\pos@Pos, value: float): \\ast@AstExprValueFloat\n\u0009var expr: \\ast@AstExprValueFloat :: #\\ast@AstExprValueFloat\n\u0009do @initAstExpr(expr, %exprValueFloat, pos)\n\u0009block\n\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009do @initAst(type, %typePrim, pos, null, false)\n\u0009\u0009do type.kind :: %float_\n\u0009\u0009do expr.type :: type\n\u0009end block\n\u0009do expr.value :: value\n\u0009ret expr\nend func\n\nfunc makeBlockVar(pos: \\pos@Pos): \\ast@AstArg\n\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009do @initAst(arg, %arg, pos, null, false)\n\u0009do arg.kind :: %localVar\n\u0009do arg.refVar :: false\n\u0009do arg.type :: null\n\u0009do arg.expr :: null\n\u0009ret arg\nend func\n\nfunc escChar(c: char): char\n\u0009switch(c)\n\u0009case \'\"\', \'\\\'\', \'\\\\\'\n\u0009\u0009ret c\n\u0009case \'0\'\n\u0009\u0009ret \'\\0\'\n\u0009case \'n\'\n\u0009\u0009ret \'\\n\'\n\u0009case \'t\'\n\u0009\u0009ret \'\\t\'\n\u0009case \'u\'\n\u0009\u0009var buf: []char :: #[6]char\n\u0009\u0009do buf[0] :: \'0\'\n\u0009\u0009do buf[1] :: \'x\'\n\u0009\u0009for i(0, 3)\n\u0009\u0009\u0009do c :: @readInStr()\n\u0009\u0009\u0009if(!(\'0\' <= c & c <= \'9\' | \'A\' <= c & c <= \'F\'))\n\u0009\u0009\u0009\u0009do \\err@err(%wrongCharCodeRepresentation, @makePos(), null)\n\u0009\u0009\u0009\u0009ret \'u\'\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf[2 + i] :: c\n\u0009\u0009end for\n\u0009\u0009ret buf.toInt(&) $ char\n\u0009default\n\u0009\u0009do \\err@err(%wrongEscSequence, @makePos(), [@charToStr(c)])\n\u0009\u0009ret c\n\u0009end switch\nend func\n":true;
else if(p==="res/pos.kn")
return f?"+class Pos()\n\u0009+var srcName: []char\n\u0009+var row: int\n\u0009+var col: int\nend class\n\n+func make(srcName: []char, row: int, col: int): @Pos\n\u0009var pos: @Pos :: #@Pos\n\u0009do pos.srcName :: srcName\n\u0009do pos.row :: row\n\u0009do pos.col :: col\n\u0009ret pos\nend func\n":true;
else if(p==="res/sys/")
return f?null:true;
else if(p==="res/sys/common.h")
return f?"#include <chrono>\n#include <codecvt>\n#include <cstdarg>\n#include <cstdint>\n#include <cstring>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <stack>\n#include <type_traits>\n#include <vector>\n\nclass Ref_;\ntemplate<typename T> class Array_;\ntemplate<typename T> class List_;\ntemplate<typename T> class Stack_;\ntemplate<typename T> class Queue_;\ntemplate<typename T1, typename T2> class dictImpl_;\ntemplate<typename T1, typename T2> class Dict_;\nclass Class_;\n\n#if _MSC_VER >= 1900\nstatic std::string utf16ToUtf8_(const std::u16string& s)\n{\n\u0009const int16_t* p = reinterpret_cast<const int16_t*>(s.data());\n\u0009return std::wstring_convert<std::codecvt_utf8_utf16<int16_t>, int16_t>{}.to_bytes(p, p + s.size());\n}\nstatic std::u16string utf8ToUtf16_(const std::string& s)\n{\n\u0009const auto t = std::wstring_convert<std::codecvt_utf8_utf16<int16_t>, int16_t>{}.from_bytes(s);\n\u0009return std::u16string(reinterpret_cast<const char16_t*>(t.data()), t.size());\n}\n#else\nstatic std::string utf16ToUtf8_(const std::u16string& s)\n{\n\u0009return std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t>{}.to_bytes(s);\n}\nstatic std::u16string utf8ToUtf16_(const std::string& s)\n{\n\u0009return std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t>{}.from_bytes(s);\n}\n#endif\n\n#if defined(_WIN32)\n\n#define STRICT\n#define _WIN32_DCOM\n\n#include <Windows.h>\n\n#undef min\n#undef far\n#undef max\n#undef near\n\nconst char newLine_[] = { \'\\r\', \'\\n\' };\n\nstatic bool setCurDir_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::SetCurrentDirectoryA(t.c_str()) != 0;\n}\nstatic bool makeDir_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::CreateDirectoryA(t.c_str(), 0) != 0;\n}\nstatic bool delDir_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::RemoveDirectoryA(t.c_str()) != 0;\n}\nstatic bool delFile_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::DeleteFileA(t.c_str()) != 0;\n}\nstatic bool copyDir_(const char16_t* d, const char16_t* s)\n{\n\u0009std::u16string s1 = d;\n\u0009const std::string& t1 = utf16ToUtf8_(s1);\n\u0009std::u16string s2 = s;\n\u0009const std::string& t2 = utf16ToUtf8_(s2);\n\u0009return ::CreateDirectoryExA(t2.c_str(), t1.c_str(), 0) != 0;\n}\nstatic bool copyFile_(const char16_t* d, const char16_t* s)\n{\n\u0009std::u16string s1 = d;\n\u0009const std::string& t1 = utf16ToUtf8_(s1);\n\u0009std::u16string s2 = s;\n\u0009const std::string& t2 = utf16ToUtf8_(s2);\n\u0009return ::CopyFileA(t2.c_str(), t1.c_str(), false) != 0;\n}\nstatic bool moveFile_(const char16_t* d, const char16_t* s)\n{\n\u0009std::u16string s1 = d;\n\u0009const std::string& t1 = utf16ToUtf8_(s1);\n\u0009std::u16string s2 = s;\n\u0009const std::string& t2 = utf16ToUtf8_(s2);\n\u0009return ::MoveFileExA(t2.c_str(), t1.c_str(), MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED) != 0;\n}\n\n#else\n\nconst char newLine_[] = { \'\\n\' };\n\nstatic bool setCurDir_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::chdir(t.c_str()) == 0;\n}\nstatic bool makeDir_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::mkdir(t.c_str(), S_IRWXU | S_IRWXG | S_IRWXO) == 0;\n}\nstatic bool delDir_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::rmdir(t.c_str()) == 0;\n}\nstatic bool delFile_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::unlink(t.c_str()) == 0;\n}\nstatic bool copyDir_(const char16_t* d, const char16_t* s)\n{\n\u0009std::u16string s1 = d;\n\u0009const std::string& t1 = utf16ToUtf8_(s1);\n\u0009std::u16string s2 = s;\n\u0009const std::string& t2 = utf16ToUtf8_(s2);\n\u0009struct stat f;\n\u0009return !(::stat(t2.c_str(), &f) != 0 || ::mkdir(t1.c_str(), f.st_mode) != 0);\n}\nstatic bool copyFile_(const char16_t* d, const char16_t* s)\n{\n\u0009std::u16string s1 = d;\n\u0009const std::string& t1 = utf16ToUtf8_(s1);\n\u0009std::u16string s2 = s;\n\u0009const std::string& t2 = utf16ToUtf8_(s2);\n\u0009int i = ::open(t2.c_str(), O_RDONLY);\n\u0009if (i < 0)\n\u0009\u0009return false;\n\u0009struct stat f;\n\u0009if (::stat(t2.c_str(), &f) != 0)\n\u0009{\n\u0009\u0009::close(i);\n\u0009\u0009return false;\n\u0009}\n\u0009int o = ::open(t1.c_str(), O_CREAT | O_WRONLY | O_TRUNC, f.st_mode);\n\u0009if (o < 0)\n\u0009{\n\u0009\u0009::close(i);\n\u0009\u0009return false;\n\u0009}\n\u0009size_t r = 1;\n\u0009char* buf = new char[65536];\n\u0009while (r > 0 && (r = ::read(i, buf.get(), 65536)) > 0)\n\u0009{\n\u0009\u0009size_t z, w = 0;\n\u0009\u0009do\n\u0009\u0009{\n\u0009\u0009\u0009if ((z = ::write(o, buf.get() + w, r - w)) < 0)\n\u0009\u0009\u0009{\n\u0009\u0009\u0009\u0009r = z;\n\u0009\u0009\u0009\u0009break;\n\u0009\u0009\u0009}\n\u0009\u0009\u0009w += z;\n\u0009\u0009} while (w < r);\n\u0009}\n\u0009if (::close(i) < 0)\n\u0009\u0009r = -1;\n\u0009if (::close(o) < 0)\n\u0009\u0009r = -1;\n\u0009delete[] buf;\n\u0009return r >= 0;\n}\nstatic bool moveFile_(const char16_t* d, const char16_t* s)\n{\n\u0009std::u16string s1 = d;\n\u0009const std::string& t1 = utf16ToUtf8_(s1);\n\u0009std::u16string s2 = s;\n\u0009const std::string& t2 = utf16ToUtf8_(s2);\n\u0009return ::rename(t2.c_str(), t1.c_str()) == 0;\n}\n\n#   define BOOST_COPY_FILE(F,T,FailIfExistsBool)\n#   define BOOST_MOVE_FILE(OLD,NEW)()\n#endif\n\ntemplate<typename T>\nstatic size_t bufLen_() noexcept { return 0; }\ntemplate<>\nstatic size_t bufLen_<char16_t>() noexcept { return 1; }\n\ntemplate<typename T>\nstatic void* newArrayRec_(int64_t n, int64_t x, const int64_t* b) noexcept\n{\n\u0009if (x == n - 1)\n\u0009{\n\u0009\u0009Array_<T>* r = new Array_<T>();\n\u0009\u0009r->L = b[x];\n\u0009\u0009size_t s = static_cast<size_t>(b[x] + bufLen_<T>());\n\u0009\u0009r->B = new T[s];\n\u0009\u0009memset(r->B, 0, sizeof(T) * s);\n\u0009\u0009return r;\n\u0009}\n\u0009{\n\u0009\u0009Array_<void*>* r = new Array_<void*>();\n\u0009\u0009r->L = b[x];\n\u0009\u0009r->B = reinterpret_cast<void**>(new T[static_cast<size_t>(b[x])]);\n\u0009\u0009for (int64_t i = 0; i < b[x]; i++)\n\u0009\u0009\u0009r->B[i] = newArrayRec_<T>(n, x + 1, b);\n\u0009\u0009return r;\n\u0009}\n}\n\ntemplate<typename T, typename R>\nstatic R newArray_(int64_t n, ...) noexcept\n{\n\u0009if (n > 64)\n\u0009\u0009return nullptr;\n\u0009int64_t b[64];\n\u0009va_list l;\n\u0009va_start(l, n);\n\u0009for (int64_t i = 0; i < n; i++)\n\u0009{\n\u0009\u0009b[i] = va_arg(l, int64_t);\n\u0009}\n\u0009va_end(l);\n\u0009return static_cast<R>(newArrayRec_<T>(n, 0, b));\n}\n\ntemplate<typename T>\nstatic Array_<T>* toArray_(List_<T>* l) noexcept\n{\n\u0009Array_<T>* a = new Array_<T>();\n\u0009a->L = l->Len();\n\u0009a->B = new T[static_cast<size_t>(a->L) + bufLen_<T>()];\n\u0009int64_t i = 0;\n\u0009for (auto& e : l->B)\n\u0009{\n\u0009\u0009a->B[i] = e;\n\u0009\u0009i++;\n\u0009}\n\u0009if (bufLen_<T>() > 0)\n\u0009\u0009a->B[a->L] = 0;\n\u0009return a;\n}\n\ntemplate<typename T>\nstatic Array_<T>* copy_(Array_<T>* t) noexcept\n{\n\u0009if (t == nullptr)\n\u0009\u0009return nullptr;\n\u0009Array_<T>* r = new Array_<T>();\n\u0009r->L = t->L;\n\u0009r->B = new T[static_cast<size_t>(t->L) + bufLen_<T>()];\n\u0009for (int64_t i = 0; i < t->L + static_cast<int64_t>(bufLen_<T>()); i++)\n\u0009\u0009r->B[i] = copy_(t->B[i]);\n\u0009return r;\n}\ntemplate<typename T>\nstatic List_<T>* copy_(List_<T>* t) noexcept\n{\n\u0009if (t == nullptr)\n\u0009\u0009return nullptr;\n\u0009// TODO:\n\u0009return nullptr;\n}\ntemplate<typename T>\nstatic Stack_<T>* copy_(Stack_<T>* t) noexcept\n{\n\u0009if (t == nullptr)\n\u0009\u0009return nullptr;\n\u0009// TODO:\n\u0009return nullptr;\n}\ntemplate<typename T>\nstatic Queue_<T>* copy_(Queue_<T>* t) noexcept\n{\n\u0009if (t == nullptr)\n\u0009\u0009return nullptr;\n\u0009// TODO:\n\u0009return nullptr;\n}\ntemplate<typename T1, typename T2>\nstatic Dict_<T1, T2>* copy_(Dict_<T1, T2>* t) noexcept\n{\n\u0009if (t == nullptr)\n\u0009\u0009return nullptr;\n\u0009// TODO:\n\u0009return nullptr;\n}\ntemplate<typename T>\nstatic T* copy_(T* t) noexcept\n{\n\u0009if (t == nullptr)\n\u0009\u0009return nullptr;\n\u0009return static_cast<T*>((new T())->copy_(t));\n}\nstatic int64_t copy_(int64_t t) noexcept { return t; }\nstatic char16_t copy_(char16_t t) noexcept { return t; }\nstatic bool copy_(bool t) noexcept { return t; }\nstatic double copy_(double t) noexcept { return t; }\nstatic uint8_t copy_(uint8_t t) noexcept { return t; }\nstatic uint16_t copy_(uint16_t t) noexcept { return t; }\nstatic uint32_t copy_(uint32_t t) noexcept { return t; }\nstatic uint64_t copy_(uint64_t t) noexcept { return t; }\n\nclass Ref_\n{\npublic:\n\u0009Ref_() noexcept : R(0LL)\n\u0009{\n\u0009}\n\n\u0009bool EqAddr(const Ref_* t) noexcept\n\u0009{\n\u0009\u0009return this == t;\n\u0009}\n\n\u0009int64_t R;\n};\n\ntemplate<typename T>\nclass Array_ : public Ref_\n{\npublic:\n\u0009Array_() noexcept : Ref_(), L(), B()\n\u0009{\n\u0009}\n\n\u0009explicit Array_(int64_t n, ...) noexcept : Ref_()\n\u0009{\n\u0009\u0009L = n;\n\u0009\u0009B = new T[static_cast<size_t>(n + bufLen_<T>())];\n\u0009\u0009va_list l;\n\u0009\u0009va_start(l, n);\n\u0009\u0009for (int64_t i = 0; i < n; i++)\n\u0009\u0009{\n\u0009\u0009\u0009B[i] = va_arg(l, T);\n\u0009\u0009}\n\u0009\u0009va_end(l);\n\u0009\u0009if (bufLen_<T>() > 0)\n\u0009\u0009\u0009B[n] = 0;\n\u0009}\n\n\u0009Array_<T>* Cat(const Array_<T>* t) noexcept\n\u0009{\n\u0009\u0009Array_<T>* r = new Array_<T>();\n\u0009\u0009r->B = new T[static_cast<size_t>(L + t->L + bufLen_<T>())];\n\u0009\u0009memcpy(r->B, B, sizeof(T) * static_cast<size_t>(L));\n\u0009\u0009memcpy(r->B + L, t->B, sizeof(T) * static_cast<size_t>(t->L + bufLen_<T>()));\n\u0009\u0009r->L = L + t->L;\n\u0009\u0009return r;\n\u0009}\n\n\u0009int64_t Len() noexcept\n\u0009{\n\u0009\u0009return L;\n\u0009}\n\n\u0009T& At(int64_t n) noexcept\n\u0009{\n\u0009\u0009return B[n];\n\u0009}\n\n\u0009bool operator<(const Ref_& t) const\n\u0009{\n\u0009\u0009return cmp_<Array_<T>*>(this, &t);\n\u0009}\n\n\u0009int64_t L;\n\u0009T* B;\n};\n\ntemplate<typename T>\nclass List_ : public Ref_\n{\npublic:\n\u0009List_() noexcept : Ref_(), B(), I(B.end())\n\u0009{\n\u0009}\n\n\u0009int64_t Len() noexcept\n\u0009{\n\u0009\u0009return static_cast<int64_t>(B.size());\n\u0009}\n\n\u0009std::list<T> B;\n\u0009typename std::list<T>::iterator I;\n};\n\ntemplate<typename T>\nclass Stack_ : public Ref_\n{\npublic:\n\u0009Stack_() noexcept : Ref_(), B()\n\u0009{\n\u0009}\n\n\u0009int64_t Len() noexcept\n\u0009{\n\u0009\u0009return static_cast<int64_t>(B.size());\n\u0009}\n\n\u0009std::stack<T> B;\n};\n\ntemplate<typename T>\nclass Queue_ : public Ref_\n{\npublic:\n\u0009Queue_() noexcept : Ref_(), B()\n\u0009{\n\u0009}\n\n\u0009int64_t Len() noexcept\n\u0009{\n\u0009\u0009return static_cast<int64_t>(B.size());\n\u0009}\n\n\u0009std::queue<T> B;\n};\n\ntemplate<typename T1, typename T2>\nclass Dict_ : public Ref_\n{\npublic:\n\u0009Dict_() noexcept : Ref_(), L(0LL), B(nullptr)\n\u0009{\n\u0009}\n\n\u0009int64_t Len() noexcept\n\u0009{\n\u0009\u0009return L;\n\u0009}\n\n\u0009void Add(T1 k, T2 v) noexcept\n\u0009{\n\u0009\u0009bool a;\n\u0009\u0009B = dictAdd_<T1, T2>(B, k, v, &a);\n\u0009\u0009if (a)\n\u0009\u0009\u0009L++;\n\u0009}\n\n\u0009int64_t L;\n\u0009dictImpl_<T1, T2>* B;\n};\n\nclass Class_ : public Ref_\n{\npublic:\n\u0009Class_() noexcept : Ref_(), Y(0LL)\n\u0009{\n\u0009}\n\n\u0009virtual int64_t cmp_(Class_* t) = 0;\n\n\u0009virtual Class_* copy_(Class_* t) = 0;\n\n\u0009int64_t Y;\n};\n\nstatic Array_<char16_t>* toStr_(int64_t v)\n{\n\u0009std::stringstream s;\n\u0009s << v;\n\u0009const std::string& t = s.str();\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(char16_t v)\n{\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(1);\n\u0009r->B = new char16_t[2];\n\u0009r->B[0] = v;\n\u0009r->B[1] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(bool v)\n{\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009if (v)\n\u0009{\n\u0009\u0009r->L = static_cast<int64_t>(4);\n\u0009\u0009r->B = new char16_t[5];\n\u0009\u0009r->B[0] = \'t\';\n\u0009\u0009r->B[1] = \'r\';\n\u0009\u0009r->B[2] = \'u\';\n\u0009\u0009r->B[3] = \'e\';\n\u0009\u0009r->B[4] = 0;\n\u0009}\n\u0009else\n\u0009{\n\u0009\u0009r->L = static_cast<int64_t>(5);\n\u0009\u0009r->B = new char16_t[6];\n\u0009\u0009r->B[0] = \'f\';\n\u0009\u0009r->B[1] = \'a\';\n\u0009\u0009r->B[2] = \'l\';\n\u0009\u0009r->B[3] = \'s\';\n\u0009\u0009r->B[4] = \'e\';\n\u0009\u0009r->B[5] = 0;\n\u0009}\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(double v)\n{\n\u0009std::stringstream s;\n\u0009s << v;\n\u0009const std::string& t = s.str();\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(uint8_t v)\n{\n\u0009std::stringstream s;\n\u0009s << \"0x\" << std::uppercase << std::setfill(\'0\') << std::setw(2) << std::hex << static_cast<uint16_t>(v);\n\u0009const std::string& t = s.str();\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(uint16_t v)\n{\n\u0009std::stringstream s;\n\u0009s << \"0x\" << std::uppercase << std::setfill(\'0\') << std::setw(4) << std::hex << v;\n\u0009const std::string& t = s.str();\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(uint32_t v)\n{\n\u0009std::stringstream s;\n\u0009s << \"0x\" << std::uppercase << std::setfill(\'0\') << std::setw(8) << std::hex << v;\n\u0009const std::string& t = s.str();\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(uint64_t v)\n{\n\u0009std::stringstream s;\n\u0009s << \"0x\" << std::uppercase << std::setfill(\'0\') << std::setw(16) << std::hex << v;\n\u0009const std::string& t = s.str();\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(Array_<char16_t>* v)\n{\n\u0009std::u16string s = v->B;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\n\nstatic int64_t cmp_(Array_<char16_t>* a, Array_<char16_t>* b)\n{\n\u0009int64_t p = 0;\n\u0009while (p < a->L && p < b->L)\n\u0009{\n\u0009\u0009if (a->B[p] != b->B[p])\n\u0009\u0009\u0009return a->B[p] > b->B[p] ? 1 : (a->B[p] < b->B[p] ? -1 : 0);\n\u0009\u0009p++;\n\u0009}\n\u0009return a->L > b->L ? 1 : (a->L < b->L ? -1 : 0);\n}\nstatic int64_t cmp_(Class_* a, Class_* b) noexcept\n{\n\u0009return a->cmp_(b);\n}\nstatic int64_t cmp_(int64_t a, int64_t b) noexcept { return a - b; }\nstatic int64_t cmp_(char16_t a, char16_t b) noexcept { return static_cast<int64_t>(a) - static_cast<int64_t>(b); }\nstatic int64_t cmp_(double a, double b) noexcept { return a > b ? 1LL : (a < b ? -1LL : 0LL); }\nstatic int64_t cmp_(uint8_t a, uint8_t b) noexcept { return static_cast<int64_t>(a) - static_cast<int64_t>(b); }\nstatic int64_t cmp_(uint16_t a, uint16_t b) noexcept { return static_cast<int64_t>(a) - static_cast<int64_t>(b); }\nstatic int64_t cmp_(uint32_t a, uint32_t b) noexcept { return static_cast<int64_t>(a) - static_cast<int64_t>(b); }\nstatic int64_t cmp_(uint64_t a, uint64_t b) noexcept { return a > b ? 1LL : (a < b ? -1LL : 0LL); }\n\ntemplate<typename T>\nstatic Array_<uint8_t>* toBin_(T t)\n{\n\u0009// TODO:\n\u0009return nullptr;\n}\n\ntemplate<typename T>\nstatic T fromBin_(Array_<uint8_t>* t, int64_t o)\n{\n\u0009// TODO:\n\u0009return (T)0;\n}\n\ntemplate<typename T>\nstatic Array_<T>* sub_(Array_<T>* a, int64_t start, int64_t len)\n{\n\u0009if (len == -1)\n\u0009\u0009len = a->L - start;\n\u0009if (start < 0 || len < 0 || start + len > a->L)\n\u0009\u0009return nullptr;\n\u0009Array_<T>* r = new Array_<T>();\n\u0009r->L = len;\n\u0009r->B = new T[static_cast<size_t>(len + bufLen_<T>())];\n\u0009for (int64_t i = 0; i < len; i++)\n\u0009\u0009r->B[i] = a->B[start + i];\n\u0009if (bufLen_<T>() > 0)\n\u0009\u0009r->B[len] = 0;\n\u0009return r;\n}\n\ntemplate<typename T>\nstatic T* as_(const int64_t* y, Class_* c, int64_t o) noexcept\n{\n\u0009if (c == nullptr)\n\u0009\u0009return nullptr;\n\u0009int64_t m = c->Y;\n\u0009for (; ; )\n\u0009{\n\u0009\u0009if (m == o)\n\u0009\u0009\u0009return reinterpret_cast<T*>(c);\n\u0009\u0009if (m == 0)\n\u0009\u0009\u0009return nullptr;\n\u0009\u0009m = y[m];\n\u0009}\n}\n\nstatic bool is_(const int64_t* y, Class_* c, int64_t o) noexcept\n{\n\u0009int64_t m = c->Y;\n\u0009for (; ; )\n\u0009{\n\u0009\u0009if (m == o)\n\u0009\u0009\u0009return true;\n\u0009\u0009if (m == 0)\n\u0009\u0009\u0009return false;\n\u0009\u0009m = y[m];\n\u0009}\n}\n\nstatic bool eqAddr_(const Ref_* a, const Ref_* b) noexcept\n{\n\u0009return a == b;\n}\n\nstatic uint32_t rX_, rY_, rZ_, rW_;\n\nstatic uint32_t xs128_() noexcept\n{\n\u0009uint32_t t = rX_ ^ (rX_ << 11);\n\u0009rX_ = rY_;\n\u0009rY_ = rZ_;\n\u0009rZ_ = rW_;\n\u0009return rW_ = (rW_ ^ (rW_ >> 19)) ^ (t ^ (t >> 8));\n}\n\nstatic int64_t rnd_(int64_t a, int64_t b) noexcept\n{\n\u0009uint64_t n = (uint64_t)(b - a + 1);\n\u0009uint64_t m = 0 - ((0 - n) % n);\n\u0009uint64_t r;\n\u0009if (m == 0)\n\u0009\u0009r = (static_cast<uint64_t>(xs128_()) << 32) | static_cast<uint64_t>(xs128_());\n\u0009else\n\u0009{\n\u0009\u0009do\n\u0009\u0009{\n\u0009\u0009\u0009r = (static_cast<uint64_t>(xs128_()) << 32) | static_cast<uint64_t>(xs128_());\n\u0009\u0009} while (m <= r);\n\u0009}\n\u0009return static_cast<int64_t>(r % n) + a;\n}\n\nstatic double rndFloat_(double a, double b) noexcept\n{\n\u0009return (double)((static_cast<uint64_t>(xs128_()) << 32) | static_cast<uint64_t>(xs128_())) / 18446744073709551616.0 * (b - a) + a;\n}\n\ntemplate<typename T1, typename T2>\nclass dictImpl_\n{\npublic:\n\u0009dictImpl_(T1 k, T2 v) noexcept : K(k), V(v), CL(nullptr), CR(nullptr), R(true)\n\u0009{\n\u0009}\n\n\u0009T1 K;\n\u0009T2 V;\n\u0009dictImpl_* CL;\n\u0009dictImpl_* CR;\n\u0009bool R;\n};\n\ntemplate<typename T1, typename T2>\nstatic dictImpl_<T1, T2>* dictAdd_(dictImpl_<T1, T2>* r, T1 k, T2 v, bool* a) noexcept\n{\n\u0009*a = false;\n\u0009dictImpl_<T1, T2>* n = dictAddRec_(r, k, v, a);\n\u0009n->R = false;\n\u0009return n;\n}\n\ntemplate<typename T1, typename T2>\nstatic T2 dictSearch_(dictImpl_<T1, T2>* r, T1 k, bool* f) noexcept\n{\n\u0009dictImpl_<T1, T2>* n = r;\n\u0009while (n != nullptr)\n\u0009{\n\u0009\u0009int64_t c = cmp_(k, n->K);\n\u0009\u0009if (c == 0)\n\u0009\u0009{\n\u0009\u0009\u0009*f = true;\n\u0009\u0009\u0009return n->V;\n\u0009\u0009}\n\u0009\u0009if (c < 0)\n\u0009\u0009\u0009n = n->CL;\n\u0009\u0009else\n\u0009\u0009\u0009n = n->CR;\n\u0009}\n\u0009*f = false;\n\u0009return (T2)0;\n}\n\ntemplate<typename T1, typename T2>\nstatic bool dictForEach_(dictImpl_<T1, T2>* r, bool(*f)(T1, T2, Class_*), Class_* p)\n{\n\u0009if (r == nullptr)\n\u0009\u0009return true;\n\u0009if (!dictForEach_<T1, T2>(r->CL, f, p))\n\u0009\u0009return false;\n\u0009if (!f(r->K, r->V, p))\n\u0009\u0009return false;\n\u0009if (!dictForEach_<T1, T2>(r->CR, f, p))\n\u0009\u0009return false;\n\u0009return true;\n}\n\ntemplate<typename T1, typename T2>\nstatic dictImpl_<T1, T2>* dictAddRec_(dictImpl_<T1, T2>* n, T1 k, T2 v, bool* a) noexcept\n{\n\u0009if (n == nullptr)\n\u0009{\n\u0009\u0009*a = true;\n\u0009\u0009return new dictImpl_<T1, T2>(k, v);\n\u0009}\n\u0009{\n\u0009\u0009int64_t c = cmp_(k, n->K);\n\u0009\u0009if (c == 0)\n\u0009\u0009{\n\u0009\u0009\u0009n->V = v;\n\u0009\u0009\u0009return n;\n\u0009\u0009}\n\u0009\u0009if (c < 0)\n\u0009\u0009\u0009n->CL = dictAddRec_<T1, T2>(n->CL, k, v, a);\n\u0009\u0009else\n\u0009\u0009\u0009n->CR = dictAddRec_<T1, T2>(n->CR, k, v, a);\n\u0009}\n\u0009if (n->CR != nullptr && n->CR->R)\n\u0009{\n\u0009\u0009dictImpl_<T1, T2>* r = n->CR;\n\u0009\u0009n->CR = r->CL;\n\u0009\u0009r->CL = n;\n\u0009\u0009r->R = n->R;\n\u0009\u0009n->R = true;\n\u0009\u0009n = r;\n\u0009}\n\u0009if (n->CL != nullptr && n->CL->R && n->CL->CL != nullptr && n->CL->CL->R)\n\u0009{\n\u0009\u0009dictImpl_<T1, T2>* l = n->CL;\n\u0009\u0009n->CL = l->CR;\n\u0009\u0009l->CR = n;\n\u0009\u0009l->R = n->R;\n\u0009\u0009n->R = true;\n\u0009\u0009n = l;\n\u0009\u0009n->R = true;\n\u0009\u0009n->CL->R = false;\n\u0009\u0009n->CR->R = false;\n\u0009}\n\u0009return n;\n}\n\nstatic int64_t powI_(int64_t a, int64_t b) noexcept\n{\n\u0009switch (b)\n\u0009{\n\u0009case 0LL:\n\u0009\u0009return 1LL;\n\u0009case 1LL:\n\u0009\u0009return a;\n\u0009case 2LL:\n\u0009\u0009return a * a;\n\u0009}\n\u0009if (a == 1LL)\n\u0009\u0009return 1LL;\n\u0009if (a == -1LL)\n\u0009\u0009return std::abs(b) % 2LL == 0LL ? 1LL : -1LL;\n\u0009if (b < 0LL)\n\u0009\u0009return 0LL;\n\u0009int64_t r = 1LL;\n\u0009for (; ; )\n\u0009{\n\u0009\u0009if ((b & 1LL) == 1LL)\n\u0009\u0009\u0009r *= a;\n\u0009\u0009b >>= 1LL;\n\u0009\u0009if (b == 0LL)\n\u0009\u0009\u0009break;\n\u0009\u0009a *= a;\n\u0009}\n\u0009return r;\n}\n\nclass reader_\n{\npublic:\n\u0009reader_() noexcept : F(new std::ifstream())\n\u0009{\n\u0009}\n\n\u0009std::ifstream* F;\n};\n\nclass writer_\n{\npublic:\n\u0009writer_() noexcept : F(new std::ofstream())\n\u0009{\n\u0009}\n\n\u0009std::ofstream* F;\n};\n\nstatic char16_t readUtf8_(std::ifstream* f)\n{\n\u0009char c;\n\u0009int64_t l;\n\u0009uint64_t u;\n\u0009if (!f->get(c))\n\u0009\u0009return 0xffff;\n\u0009if ((c & 0xc0) == 0x80)\n\u0009\u0009return 0xffff;\n\u0009if ((c & 0x80) == 0x00)\n\u0009\u0009l = 0;\n\u0009else if ((c & 0xe0) == 0xc0)\n\u0009\u0009l = 1, c &= 0x1f;\n\u0009else if ((c & 0xf0) == 0xe0)\n\u0009\u0009l = 2, c &= 0x0f;\n\u0009else if ((c & 0xf8) == 0xf0)\n\u0009\u0009l = 3, c &= 0x07;\n\u0009else if ((c & 0xfc) == 0xf8)\n\u0009\u0009l = 4, c &= 0x03;\n\u0009else if ((c & 0xfe) == 0xfc)\n\u0009\u0009l = 5, c &= 0x01;\n\u0009else\n\u0009\u0009return 0xffff;\n\u0009u = static_cast<uint64_t>(c);\n\u0009for (int64_t i = 0; i < l; i++)\n\u0009{\n\u0009\u0009if (!f->get(c) || (c & 0xc0) != 0x80)\n\u0009\u0009\u0009return 0xffff;\n\u0009\u0009u = (u << 6) | static_cast<uint64_t>(c & 0x3f);\n\u0009}\n\u0009if (0x00010000 <= u && u <= 0x0010ffff)\n\u0009\u0009u = 0x20;\n\u0009return static_cast<char16_t>(u);\n}\n\nstatic void writeUtf8_(std::ofstream* f, char16_t c)\n{\n\u0009uint64_t u;\n\u0009size_t size;\n\u0009if ((c >> 7) == 0)\n\u0009\u0009u = c, size = 1;\n\u0009else\n\u0009{\n\u0009\u0009u = static_cast<uint64_t>(0x80 | (c & 0x3f)) << 8;\n\u0009\u0009c >>= 6;\n\u0009\u0009if ((c >> 5) == 0)\n\u0009\u0009\u0009u |= 0xc0 | c, size = 2;\n\u0009\u0009else\n\u0009\u0009{\n\u0009\u0009\u0009u = (u | 0x80 | (c & 0x3f)) << 8;\n\u0009\u0009\u0009c >>= 6;\n\u0009\u0009\u0009if ((c >> 4) == 0)\n\u0009\u0009\u0009\u0009u |= 0xe0 | c, size = 3;\n\u0009\u0009\u0009else\n\u0009\u0009\u0009{\n\u0009\u0009\u0009\u0009u = (u | 0x80 | (c & 0x3f)) << 8;\n\u0009\u0009\u0009\u0009c >>= 6;\n\u0009\u0009\u0009\u0009if ((c >> 3) == 0)\n\u0009\u0009\u0009\u0009\u0009u |= 0xf0 | c, size = 4;\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009{\n\u0009\u0009\u0009\u0009\u0009u = (u | 0x80 | (c & 0x3f)) << 8;\n\u0009\u0009\u0009\u0009\u0009c >>= 6;\n\u0009\u0009\u0009\u0009\u0009if ((c >> 2) == 0)\n\u0009\u0009\u0009\u0009\u0009\u0009u |= 0xf8 | c, size = 5;\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009{\n\u0009\u0009\u0009\u0009\u0009\u0009u = (u | 0x80 | (c & 0x3f)) << 8;\n\u0009\u0009\u0009\u0009\u0009\u0009c >>= 6;\n\u0009\u0009\u0009\u0009\u0009\u0009if ((c >> 1) == 0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009u |= 0xfc | c, size = 6;\n\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009return;\n\u0009\u0009\u0009\u0009\u0009}\n\u0009\u0009\u0009\u0009}\n\u0009\u0009\u0009}\n\u0009\u0009}\n\u0009}\n\u0009if (size == 1 && u == 0x0a)\n\u0009\u0009f->write(newLine_, static_cast<std::streamsize>(sizeof(newLine_)));\n\u0009else\n\u0009\u0009f->write(reinterpret_cast<char*>(&u), static_cast<std::streamsize>(size));\n}\n\nstatic void init_()\n{\n\u0009uint32_t t = static_cast<uint32_t>(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());\n\u0009rX_ = 123456789;\n\u0009rY_ = 362436069;\n\u0009rZ_ = 521288629 * t;\n\u0009rW_ = 88675123 * (rZ_ >> 1);\n}\n":true;
else if(p==="res/sys/cui.kn")
return f?"func [d0002.knd, _init] _init()\nend func\n\nfunc [d0002.knd] _fin()\nend func\n\n+func [d0002.knd, _delimiter] delimiter(delimiters: []char)\nend func\n\n+func [__raw, cui_print] print(str: []char)\nend func\n\n+func [d0002.knd, _inputLetter] inputLetter(): char\nend func\n\n+func [d0002.knd, _inputInt] inputInt(): int\nend func\n\n+func [d0002.knd, _inputFloat] inputFloat(): float\nend func\n\n+func [d0002.knd, _inputChar] inputChar(): char\nend func\n\n+func [d0002.knd, _inputStr] inputStr(): []char\nend func\n\n+func [d0002.knd, _input] input(): []char\nend func\n":true;
else if(p==="res/sys/dbg.kn")
return f?"+func [d0000.knd, _dbgPrint] print(str: []char)\nend func\n":true;
else if(p==="res/sys/excpt.kn")
return f?"+const userMin: int :: 0x00000001\n+const userMax: int :: 0x0000FFFF\n+const accessViolation: int :: 0xC0000005\n+const noMem: int :: 0xC0000017\n+const floatInvalidOperation: int :: 0xC0000090\n+const intDivideByZero: int :: 0xC0000094\n+const stackOverflow: int :: 0xC00000FD\n+const ctrlCExit: int :: 0xC000013A\n+const dbgAssertFailed: int :: 0xE9170000\n+const classCastFailed: int :: 0xE9170001\n+const dbgArrayIdxOutOfRange: int :: 0xE9170002\n+const dbgIntOverflow: int :: 0xE9170003\n+const invalidCmp: int :: 0xE9170004\n+const dbgArgOutDomain: int :: 0xE9170006\n+const fileReadFailed: int :: 0xE9170007\n+const invalidDataFmt: int :: 0xE9170008\n+const deviceInitFailed: int :: 0xE9170009\n+const dbgInoperableState: int :: 0xE917000A\n":true;
else if(p==="res/sys/file.kn")
return f?"+enum Origin\n\u0009head\n\u0009cur\n\u0009tail\nend enum\n\n+class Reader()\n\u0009*func [d0000.knd, _readerDtor, __frc] _dtor()\n\u0009end func\n\n\u0009+func [__raw, file_readerFin] fin()\n\u0009end func\n\n\u0009+func [__raw, file_readerSetPos] setPos(origin: @Origin, pos: int)\n\u0009end func\n\n\u0009+func [__raw, file_readerGetPos] getPos(): int\n\u0009end func\n\n\u0009+func [d0000.knd, _readerDelimiter] delimiter(delimiters: []char)\n\u0009end func\n\n\u0009+func [d0000.knd, _readerRead] read(size: int): []bit8\n\u0009end func\n\n\u0009+func [__raw, file_readerReadLetter] readLetter(): char\n\u0009end func\n\n\u0009+func [d0000.knd, _readerReadInt] readInt(): int\n\u0009end func\n\n\u0009+func [d0000.knd, _readerReadFloat] readFloat(): float\n\u0009end func\n\n\u0009+func [d0000.knd, _readerReadChar] readChar(): char\n\u0009end func\n\n\u0009+func [d0000.knd, _readerReadStr] readStr(): []char\n\u0009end func\n\n\u0009+func readLine(): []char\n\u0009\u0009var buf: []char :: \"\"\n\u0009\u0009while loop(!me.term())\n\u0009\u0009\u0009var c: char :: me.readLetter()\n\u0009\u0009\u0009if(c = \'\\u000D\')\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf :~ c.toStr()\n\u0009\u0009end while\n\u0009\u0009ret buf\n\u0009end func\n\n\u0009+func [d0000.knd, _readerFileSize] fileSize(): int\n\u0009end func\n\n\u0009+func [__raw, file_readerTerm] term(): bool\n\u0009end func\n\n\u0009var handle: int\n\u0009var delimiterNum: int\n\u0009var delimiters: int\n\u0009var fileSize_: int\nend class\n\n+class Writer()\n\u0009*func [d0000.knd, _writerDtor, __frc] _dtor()\n\u0009end func\n\n\u0009+func [__raw, file_writerFin] fin()\n\u0009end func\n\n\u0009+func [__raw, file_writerSetPos] setPos(origin: @Origin, pos: int)\n\u0009end func\n\n\u0009+func [__raw, file_writerGetPos] getPos(): int\n\u0009end func\n\n\u0009+func [__raw, file_writerWrite] write(bin: []bit8)\n\u0009end func\n\n\u0009+func writeInt(n: int)\n\u0009\u0009var s: []char :: n.toStr()\n\u0009\u0009for i(0, ^s - 1)\n\u0009\u0009\u0009do me.writeChar(s[i])\n\u0009\u0009end for\n\u0009end func\n\n\u0009+func writeFloat(n: float)\n\u0009\u0009var s: []char :: n.toStr()\n\u0009\u0009for i(0, ^s - 1)\n\u0009\u0009\u0009do me.writeChar(s[i])\n\u0009\u0009end for\n\u0009end func\n\n\u0009+func [__raw, file_writerWriteChar] writeChar(n: char)\n\u0009end func\n\n\u0009+func writeStr(n: []char)\n\u0009\u0009for i(0, ^n - 1)\n\u0009\u0009\u0009do me.writeChar(n[i])\n\u0009\u0009end for\n\u0009end func\n\n\u0009var handle: int\nend class\n\n+func [__mki, __raw, file_makeReader] makeReader(me2: @Reader, path: []char): @Reader\nend func\n\n+func [__mki, __raw, file_makeWriter] makeWriter(me2: @Writer, path: []char, append: bool): @Writer\nend func\n\n+enum SysDir\n\u0009desktop :: 0x00\n\u0009fonts :: 0x14\n\u0009appData :: 0x1A\n\u0009windows :: 0x24\n\u0009system32 :: 0x25\n\u0009programFiles :: 0x26\nend enum\n\n+func [d0000.knd, _makeDir] makeDir(path: []char): bool\nend func\n\n+func [__raw, file_forEach] forEach(path: []char, recursion: bool, callback: func<([]char, bool, kuin@Class): bool>, data: kuin@Class): bool\nend func\n\n+func [__raw, file_exist] exist(path: []char): bool\nend func\n\n+func [d0000.knd, _delDir] delDir(path: []char): bool\nend func\n\n+func [d0000.knd, _delFile] delFile(path: []char): bool\nend func\n\n+func [d0000.knd, _copyDir] copyDir(dst: []char, src: []char): bool\nend func\n\n+func [__raw, file_copyFile] copyFile(dst: []char, src: []char): bool\nend func\n\n+func [d0000.knd, _moveDir] moveDir(dst: []char, src: []char): bool\nend func\n\n+func [d0000.knd, _moveFile] moveFile(dst: []char, src: []char): bool\nend func\n\n+func dir(path: []char): []char\n\u0009assert path <>& null\n\u0009var p: int :: ^path - 1\n\u0009while(p >= 0 & path[p] <> \'/\' & path[p] <> \'\\\\\')\n\u0009\u0009do p :- 1\n\u0009end while\n\u0009if(p < 0)\n\u0009\u0009ret \"./\"\n\u0009else\n\u0009\u0009var r: []char :: #[p + 1]char\n\u0009\u0009for i(0, p)\n\u0009\u0009\u0009do r[i] :: path[i] = \'\\\\\' ?(\'/\', path[i])\n\u0009\u0009end for\n\u0009\u0009ret r\n\u0009end if\nend func\n\n+func ext(path: []char): []char\n\u0009assert path <>& null\n\u0009var p: int :: ^path - 1\n\u0009while(p >= 0 & path[p] <> \'/\' & path[p] <> \'\\\\\' & path[p] <> \'.\')\n\u0009\u0009do p :- 1\n\u0009end while\n\u0009if(path[p] <> \'.\')\n\u0009\u0009ret \"\"\n\u0009else\n\u0009\u0009do p :+ 1\n\u0009\u0009var r: []char :: #[^path - p]char\n\u0009\u0009for i(0, ^path - p - 1)\n\u0009\u0009\u0009do r[i] :: path[p + i]\n\u0009\u0009end for\n\u0009\u0009ret r\n\u0009end if\nend func\n\n+func fileName(path: []char): []char\n\u0009assert path <>& null\n\u0009var p: int :: ^path - 1\n\u0009while(p >= 0 & path[p] <> \'/\' & path[p] <> \'\\\\\')\n\u0009\u0009do p :- 1\n\u0009end while\n\u0009if(p < 0)\n\u0009\u0009ret path\n\u0009end if\n\u0009do p :+ 1\n\u0009var r: []char :: #[^path - p]char\n\u0009for i(0, ^path - p - 1)\n\u0009\u0009do r[i] :: path[p + i]\n\u0009end for\n\u0009ret r\nend func\n\n+func [d0000.knd, _fullPath] fullPath(path: []char): []char\nend func\n\n+func delExt(path: []char): []char\n\u0009assert path <>& null\n\u0009var p: int :: ^path - 1\n\u0009while(p >= 0 & path[p] <> \'/\' & path[p] <> \'\\\\\' & path[p] <> \'.\')\n\u0009\u0009do p :- 1\n\u0009end while\n\u0009if(p < 0 | path[p] <> \'.\')\n\u0009\u0009ret path\n\u0009end if\n\u0009var r: []char :: #[p]char\n\u0009for i(0, p - 1)\n\u0009\u0009do r[i] :: path[i] = \'\\\\\' ?(\'/\', path[i])\n\u0009end for\n\u0009ret r\nend func\n\n+func [d0000.knd, _sysDir] sysDir(kind: @SysDir): []char\nend func\n\n+func [d0000.knd, _exeDir] exeDir(): []char\nend func\n\n+func [d0000.knd, _fileSize] fileSize(path: []char): int\nend func\n\n+func [d0000.knd, _setCurDir] setCurDir(path: []char)\nend func\n\n+func [d0000.knd, _getCurDir] getCurDir(): []char\nend func\n":true;
else if(p==="res/sys/kuin.kn")
return f?"+const envCui: bit64 :: 0b64\n+const envWnd: bit64 :: 1b64\n+const envWeb: bit64 :: 2b64\n+const envCpp: bit64 :: 3b64\n\n+class Class()\n\u0009func ctor()\n\u0009end func\n\n\u0009func _dtor()\n\u0009end func\n\n\u0009+func cmp(t: @Class): int\n\u0009\u0009throw 0xE9170004\n\u0009end func\n\n\u0009func _copy(): @Class\n\u0009end func\n\n\u0009func _toBin(): []bit8\n\u0009end func\n\n\u0009func _fromBin(bin: []bit8, idx: &int): @Class\n\u0009end func\n\n\u0009+func toStr(): []char\n\u0009\u0009ret \"\"\n\u0009end func\nend class\n\nfunc _init()\nend func\n\nfunc _fin()\nend func\n\nfunc _err(excpt: int)\nend func\n\nfunc _initVars()\nend func\n\nfunc _finVars()\nend func\n\nfunc [__any, __raw, toStr] _toStr(me_: int, type: []int): []char\nend func\n\nfunc [d0000.knd] _toStrFmtInt(me_: int, fmt: []char): []char\nend func\n\nfunc [d0000.knd] _toStrFmtFloat(me_: float, fmt: []char): []char\nend func\n\nfunc _absInt(me_: int): int\n\u0009ret me_ >= 0 ?(me_, -me_)\nend func\n\nfunc _absFloat(me_: float): float\n\u0009ret me_ >= 0.0 ?(me_, -me_)\nend func\n\nfunc _signInt(me_: int): int\n\u0009ret me_ > 0 ?(1, me_ < 0 ?(-1, 0))\nend func\n\nfunc _signFloat(me_: float): float\n\u0009ret me_ > 0.0 ?(1.0, me_ < 0.0 ?(-1.0, 0.0))\nend func\n\nfunc _clampInt(me_: int, min: int, max: int): int\n\u0009ret me_ > max ?(max, me_ < min ?(min, me_))\nend func\n\nfunc _clampFloat(me_: float, min: float, max: float): float\n\u0009ret me_ > max ?(max, me_ < min ?(min, me_))\nend func\n\nfunc _clampMinInt(me_: int, min: int): int\n\u0009ret me_ < min ?(min, me_)\nend func\n\nfunc _clampMinFloat(me_: float, min: float): float\n\u0009ret me_ < min ?(min, me_)\nend func\n\nfunc _clampMaxInt(me_: int, max: int): int\n\u0009ret me_ > max ?(max, me_)\nend func\n\nfunc _clampMaxFloat(me_: float, max: float): float\n\u0009ret me_ > max ?(max, me_)\nend func\n\nfunc _offset(me_: char, n: int): char\n\u0009ret (me_ $ bit64 + n $ bit64) $ char\nend func\n\nfunc [__any, __tme, __rme, __raw, or] _or(me_: int, type: []int, n: int): int\nend func\n\nfunc [__any, __tme, __rme, __raw, and] _and(me_: int, type: []int, n: int): int\nend func\n\nfunc [__any, __tme, __rme, __raw, xor] _xor(me_: int, type: []int, n: int): int\nend func\n\nfunc [__any, __rme, __raw, not] _not(me_: int, type: []int): int\nend func\n\nfunc [__any, __rme, __raw, shl] _shl(me_: int, type: []int, n: int): int\nend func\n\nfunc [__any, __rme, __raw, shr] _shr(me_: int, type: []int, n: int): int\nend func\n\nfunc [__any, __rme, __raw, sar] _sar(me_: int, type: []int, n: int): int\nend func\n\nfunc [__any, __rme] _endian(me_: int, type: []int): int\nend func\n\nfunc [__any, __rme, __raw, sub] _sub(me_: int, type: []int, start: int, len: int): int\nend func\n\nfunc [__any] _reverse(me_: int, type: []int)\nend func\n\nfunc [__any] _shuffle(me_: int, type: []int)\nend func\n\nfunc [__any] _sortArray(me_: int, type: []int)\nend func\n\nfunc [__any] _sortDescArray(me_: int, type: []int)\nend func\n\nfunc [__any] _sortList(me_: int, type: []int)\nend func\n\nfunc [__any] _sortDescList(me_: int, type: []int)\nend func\n\nfunc [__any, __tch, __raw, findArray] _findArray(me_: int, type: []int, item: int, start: int): int\nend func\n\nfunc [__any, __tch] _findList(me_: int, type: []int, item: int): bool\nend func\n\nfunc [__any, __tch, __raw, findLastArray] _findLastArray(me_: int, type: []int, item: int, start: int): int\nend func\n\nfunc [__any, __tch] _findLastList(me_: int, type: []int, item: int): bool\nend func\n\nfunc [__any, __tch, __raw, findBin] _findBin(me_: int, type: []int, item: int): int\nend func\n\nfunc [__any, __tch, __raw, fill] _fill(me_: int, type: []int, value: int)\nend func\n\nfunc [__any, __rch] _min(me_: int, type: []int): int\nend func\n\nfunc [__any, __rch] _max(me_: int, type: []int): int\nend func\n\nfunc [__any, __rme] _repeat(me_: int, type: []int, len: int): int\nend func\n\nfunc [__raw, toInt] _toInt(me_: []char, success: &bool): int\nend func\n\nfunc [__raw, toFloat] _toFloat(me_: []char, success: &bool): float\nend func\n\nfunc [__raw, toBit64] _toBit64(me_: []char, success: &bool): bit64\nend func\n\nfunc _lower(me_: []char): []char\n\u0009assert me_ <>& null\n\u0009var s: []char :: #[^me_]char\n\u0009for i(0, ^me_ - 1)\n\u0009\u0009if(\'A\' <= me_[i] & me_[i] <= \'Z\')\n\u0009\u0009\u0009do s[i] :: (me_[i] $ bit64 - 0x41b64 + 0x61b64) $ char\n\u0009\u0009else\n\u0009\u0009\u0009do s[i] :: me_[i]\n\u0009\u0009end if\n\u0009end for\n\u0009ret s\nend func\n\nfunc _upper(me_: []char): []char\n\u0009assert me_ <>& null\n\u0009var s: []char :: #[^me_]char\n\u0009for i(0, ^me_ - 1)\n\u0009\u0009if(\'a\' <= me_[i] & me_[i] <= \'z\')\n\u0009\u0009\u0009do s[i] :: (me_[i] $ bit64 - 0x61b64 + 0x41b64) $ char\n\u0009\u0009else\n\u0009\u0009\u0009do s[i] :: me_[i]\n\u0009\u0009end if\n\u0009end for\n\u0009ret s\nend func\n\nfunc _trim(me_: []char): []char\n\u0009assert me_ <>& null\n\u0009var f: int :: -1\n\u0009for i(0, ^me_ - 1)\n\u0009\u0009var c: bit64 :: me_[i] $ bit64\n\u0009\u0009if(!(0x09b64 <= c & c <= 0x0Db64 | c = 0x20b64 | c = 0xA0b64))\n\u0009\u0009\u0009do f :: i\n\u0009\u0009\u0009break i\n\u0009\u0009end if\n\u0009end for\n\u0009if(f = -1)\n\u0009\u0009ret me_\n\u0009end if\n\u0009var l: int :: -1\n\u0009for i(^me_ - 1, 0, -1)\n\u0009\u0009var c: bit64 :: me_[i] $ bit64\n\u0009\u0009if(!(0x09b64 <= c & c <= 0x0Db64 | c = 0x20b64 | c = 0xA0b64))\n\u0009\u0009\u0009do l :: i\n\u0009\u0009\u0009break i\n\u0009\u0009end if\n\u0009end for\n\u0009var r: []char :: #[l - f + 1]char\n\u0009for i(0, l - f)\n\u0009\u0009do r[i] :: me_[f + i]\n\u0009end for\n\u0009ret r\nend func\n\nfunc _trimLeft(me_: []char): []char\n\u0009assert me_ <>& null\n\u0009var f: int :: -1\n\u0009for i(0, ^me_ - 1)\n\u0009\u0009var c: bit64 :: me_[i] $ bit64\n\u0009\u0009if(!(0x09b64 <= c & c <= 0x0Db64 | c = 0x20b64 | c = 0xA0b64))\n\u0009\u0009\u0009do f :: i\n\u0009\u0009\u0009break i\n\u0009\u0009end if\n\u0009end for\n\u0009if(f = -1)\n\u0009\u0009ret me_\n\u0009end if\n\u0009var r: []char :: #[^me_ - f]char\n\u0009for i(0, ^me_ - f - 1)\n\u0009\u0009do r[i] :: me_[f + i]\n\u0009end for\n\u0009ret r\nend func\n\nfunc _trimRight(me_: []char): []char\n\u0009var l: int :: -1\n\u0009for i(^me_ - 1, 0, -1)\n\u0009\u0009var c: bit64 :: me_[i] $ bit64\n\u0009\u0009if(!(0x09b64 <= c & c <= 0x0Db64 | c = 0x20b64 | c = 0xA0b64))\n\u0009\u0009\u0009do l :: i\n\u0009\u0009\u0009break i\n\u0009\u0009end if\n\u0009end for\n\u0009if(l = -1)\n\u0009\u0009ret me_\n\u0009end if\n\u0009var r: []char :: #[l + 1]char\n\u0009for i(0, l)\n\u0009\u0009do r[i] :: me_[i]\n\u0009end for\n\u0009ret r\nend func\n\nfunc _split(me_: []char, delimiter: []char): [][]char\n\u0009var result: list<[]char> :: #list<[]char>\n\u0009var p: int :: 0\n\u0009while(true)\n\u0009\u0009var p2: int :: me_.findStr(delimiter, p)\n\u0009\u0009if(p2 = -1)\n\u0009\u0009\u0009do result.add(me_.sub(p, -1))\n\u0009\u0009\u0009ret result.toArray()\n\u0009\u0009end if\n\u0009\u0009do result.add(me_.sub(p, p2 - p))\n\u0009\u0009do p :: p2 + ^delimiter\n\u0009end while\nend func\n\nfunc _join(me_: [][]char, delimiter: []char): []char\n\u0009var t: int :: ^delimiter * (^me_ - 1)\n\u0009for i(0, ^me_ - 1)\n\u0009\u0009do t :+ ^me_[i]\n\u0009end for\n\u0009var r: []char :: #[t]char\n\u0009var p: int :: 0\n\u0009for i(0, ^me_ - 1)\n\u0009\u0009if(i <> 0)\n\u0009\u0009\u0009for j(0, ^delimiter - 1)\n\u0009\u0009\u0009\u0009do r[p] :: delimiter[j]\n\u0009\u0009\u0009\u0009do p :+ 1\n\u0009\u0009\u0009end for\n\u0009\u0009end if\n\u0009\u0009var s: []char :: me_[i]\n\u0009\u0009for j(0, ^s - 1)\n\u0009\u0009\u0009do r[p] :: s[j]\n\u0009\u0009\u0009do p :+ 1\n\u0009\u0009end for\n\u0009end for\n\u0009ret r\nend func\n\nfunc [d0000.knd] _replace(me_: []char, old: []char, new: []char): []char\nend func\n\nfunc _findStr(me_: []char, pattern: []char, start: int): int\n\u0009for i(0, ^me_ - ^pattern)\n\u0009\u0009for j(0, ^pattern)\n\u0009\u0009\u0009if(me_[i + j] <> pattern[j])\n\u0009\u0009\u0009\u0009skip i\n\u0009\u0009\u0009end if\n\u0009\u0009end for\n\u0009\u0009ret i\n\u0009end for\n\u0009ret -1\nend func\n\nfunc _findStrLast(me_: []char, pattern: []char, start: int): int\n\u0009for i(^me_ - ^pattern, 0, -1)\n\u0009\u0009for j(0, ^pattern)\n\u0009\u0009\u0009if(me_[i + j] <> pattern[j])\n\u0009\u0009\u0009\u0009skip i\n\u0009\u0009\u0009end if\n\u0009\u0009end for\n\u0009\u0009ret i\n\u0009end for\n\u0009ret -1\nend func\n\nfunc [d0000.knd] _findStrEx(me_: []char, pattern: []char, start: int, fromLast: bool, ignoreCase: bool, wholeWord: bool): int\nend func\n\nfunc [__any, __tch, __raw, addList] _addList(me_: int, type: []int, item: int)\nend func\n\nfunc [__any, __tch, __raw, addStack] _addStack(me_: int, type: []int, item: int)\nend func\n\nfunc [__any, __tch, __raw, addQueue] _addQueue(me_: int, type: []int, item: int)\nend func\n\nfunc [__any, __tkv, __raw, addDict] _addDict(me_: int, type: []int, key: int, item: int)\nend func\n\nfunc [__any, __rch, __raw, getList] _getList(me_: int, type: []int): int\nend func\n\nfunc [__any, __rch, __raw, getStack] _getStack(me_: int, type: []int): int\nend func\n\nfunc [__any, __rch, __raw, getQueue] _getQueue(me_: int, type: []int): int\nend func\n\nfunc [__any, __tch, __rch, __raw, getDict] _getDict(me_: int, type: []int, key: int, existed: &bool): int\nend func\n\nfunc [__any, __rch] _getOffset(me_: int, type: []int, offset: int): int\nend func\n\nfunc [__any, __raw, head] _head(me_: int, type: []int)\nend func\n\nfunc [__any, __raw, moveOffset] _moveOffset(me_: int, type: []int, offset: int)\nend func\n\nfunc [__any, __raw, tail] _tail(me_: int, type: []int)\nend func\n\nfunc [__any, __raw, next] _next(me_: int, type: []int)\nend func\n\nfunc [__any, __raw, prev] _prev(me_: int, type: []int)\nend func\n\nfunc [__any, __raw, term] _term(me_: int, type: []int): bool\nend func\n\nfunc [__any] _termOffset(me_: int, type: []int, offset: int): bool\nend func\n\nfunc [__any, __raw, del] _del(me_: int, type: []int)\nend func\n\nfunc [__any] _delNext(me_: int, type: []int)\nend func\n\nfunc [__any, __tch, __raw, ins] _ins(me_: int, type: []int, item: int)\nend func\n\nfunc [__any, __rac, __raw, toArray] _toArray(me_: int, type: []int): int\nend func\n\nfunc [__any, __rak] _toArrayKey(me_: int, type: []int): int\nend func\n\nfunc [__any, __rav] _toArrayValue(me_: int, type: []int): int\nend func\n\nfunc [__any, __rch, __raw, peekQueue] _peekQueue(me_: int, type: []int): int\nend func\n\nfunc [__any, __rch, __raw, peekStack] _peekStack(me_: int, type: []int): int\nend func\n\nfunc [__any, __tch] _exist(me_: int, type: []int, key: int): bool\nend func\n\nfunc [__any, __kvf, __raw, forEach] _forEach(me_: int, type: []int, callback: int, data: @Class): bool\nend func\n\nfunc [__any, __tch] _delDict(me_: int, type: []int, key: int)\nend func\n\nfunc [__any, __raw, idx] _idx(me_: int, type: []int): int\nend func\n":true;
else if(p==="res/sys/lib.kn")
return f?"+const pi: float :: 3.14159265358979323846\n+const e: float :: 2.71828182845904523536\n+const intMin: int :: -9223372036854775807 - 1\n+const intMax: int :: 9223372036854775807\n\n+func [__raw, cmdLine] cmdLine(): [][]char\nend func\n\n+func [_exit_code] exitCode(code: int)\n\u0009if(dbg)\n\u0009\u0009if(code < 0 | 0xFFFFFFFF < code)\n\u0009\u0009\u0009throw excpt@dbgArgOutDomain\n\u0009\u0009end if\n\u0009end if\nend func\n\n+class Rnd()\n\u0009*func [d0000.knd, _rndDtor, __frc] _dtor()\n\u0009end func\n\n\u0009+func [d0000.knd, _rndRnd] rnd(min: int, max: int): int\n\u0009end func\n\n\u0009+func [d0000.knd, _rndRndFloat] rndFloat(min: float, max: float): float\n\u0009end func\n\n\u0009+func [d0000.knd, _rndRndBit64] rndBit64(): bit64\n\u0009end func\n\n\u0009var rndState: int\nend class\n\n+func [d0000.knd, _makeRnd, __mki] makeRnd(me2: @Rnd, seed: int): @Rnd\nend func\n\n+func [__raw, rnd] rnd(min: int, max: int): int\nend func\n\n+func [__raw, rndFloat] rndFloat(min: float, max: float): float\nend func\n\n+func [d0000.knd, _rndBit64] rndBit64(): bit64\nend func\n\n+func [d0000.knd, _rndUuid] rndUuid(): []char\nend func\n\n+func [__raw, cos] cos(x: float): float\nend func\n\n+func [__raw, sin] sin(x: float): float\nend func\n\n+func [__raw, tan] tan(x: float): float\nend func\n\n+func [__raw, acos] acos(x: float): float\nend func\n\n+func [__raw, asin] asin(x: float): float\nend func\n\n+func [__raw, atan] atan(x: float): float\nend func\n\n+func [__raw, cosh] cosh(x: float): float\nend func\n\n+func [__raw, sinh] sinh(x: float): float\nend func\n\n+func [__raw, tanh] tanh(x: float): float\nend func\n\n+func [__raw, acosh] acosh(x: float): float\nend func\n\n+func [__raw, asinh] asinh(x: float): float\nend func\n\n+func [__raw, atanh] atanh(x: float): float\nend func\n\n+func [__raw, sqrt] sqrt(x: float): float\nend func\n\n+func [__raw, exp] exp(x: float): float\nend func\n\n+func [__raw, ln] ln(x: float): float\nend func\n\n+func log(base: float, x: float): float\n\u0009ret @ln(x) / @ln(base)\nend func\n\n+func [__raw, floor] floor(x: float): float\nend func\n\n+func [__raw, ceil] ceil(x: float): float\nend func\n\n+func round(x: float, precision: int): float\n\u0009if(precision = 0)\n\u0009\u0009ret x >= 0.0 ?(@floor(x + 0.5), -@floor(-x + 0.5))\n\u0009else\n\u0009\u0009var p: float :: 10.0 ^ (precision $ float)\n\u0009\u0009ret x >= 0.0 ?(@floor(x * p + 0.5) / p, -@floor(-x * p + 0.5) / p)\n\u0009end if\nend func\n\n+func rot(x: &float, y: &float, centerX: float, centerY: float, angle: float)\n\u0009var x2: float :: x - centerX\n\u0009var y2: float :: y - centerY\n\u0009var cosTheta: float :: @cos(angle)\n\u0009var sinTheta: float :: @sin(angle)\n\u0009var x3: float :: x2 * cosTheta - y2 * sinTheta\n\u0009var y3: float :: x2 * sinTheta + y2 * cosTheta\n\u0009do x :: x3 + centerX\n\u0009do y :: y3 + centerY\nend func\n\n+func [__raw, invRot] invRot(x: float, y: float, centerX: float, centerY: float): float\nend func\n\n+func [__raw, dist] dist(x: float, y: float, centerX: float, centerY: float): float\nend func\n\n+func chase(x: &float, target: float, vel: float): bool\n\u0009if(x = target)\n\u0009\u0009ret true\n\u0009end if\n\u0009if(x < target)\n\u0009\u0009do x :+ vel\n\u0009\u0009if(x >= target)\n\u0009\u0009\u0009do x :: target\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009else\n\u0009\u0009do x :- vel\n\u0009\u0009if(x <= target)\n\u0009\u0009\u0009do x :: target\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009end if\n\u0009ret false\nend func\n\n+func same(n1: float, n2: float): bool\n\u0009var max: float :: 1.0\n\u0009if(max < n1)\n\u0009\u0009do max :: n1\n\u0009end if\n\u0009if(max < n2)\n\u0009\u0009do max :: n2\n\u0009end if\n\u0009ret (n1 - n2).abs() <= 2.220446049250313e-16 * max\nend func\n\n+func toRad(degree: float): float\n\u0009ret degree * @pi / 180.0\nend func\n\n+func toDegree(rad: float): float\n\u0009ret rad * 180.0 / @pi\nend func\n\n+func cmp(s1: []char, s2: []char): int\n\u0009var p: int :: 0\n\u0009while(p < ^s1 & p < ^s2)\n\u0009\u0009if(s1[p] <> s2[p])\n\u0009\u0009\u0009ret s1[p] > s2[p] ?(1, s1[p] < s2[p] ?(-1, 0))\n\u0009\u0009end if\n\u0009\u0009do p :+ 1\n\u0009end while\n\u0009ret ^s1 > ^s2 ?(1, ^s1 < ^s2 ?(-1, 0))\nend func\n\n+func [d0000.knd, _cmpEx] cmpEx(s1: []char, s2: []char, len: int, ignoreCase: bool): int\nend func\n\n+func min(n1: int, n2: int): int\n\u0009ret n1 <= n2 ?(n1, n2)\nend func\n\n+func minFloat(n1: float, n2: float): float\n\u0009ret n1 <= n2 ?(n1, n2)\nend func\n\n+func max(n1: int, n2: int): int\n\u0009ret n1 >= n2 ?(n1, n2)\nend func\n\n+func maxFloat(n1: float, n2: float): float\n\u0009ret n1 >= n2 ?(n1, n2)\nend func\n\n+func [d0000.knd, _levenshtein] levenshtein(s1: []char, s2: []char): int\nend func\n\n+func [d0000.knd, _lerp] lerp(first: float, last: float, rate: float): float\nend func\n\n+func [d0000.knd, _qerp] qerp(first: float, last: float, easeIn: bool, rate: float): float\nend func\n\n+func [d0000.knd, _cerp] cerp(first: float, last: float, rate: float): float\nend func\n\n+func [d0000.knd, _hermite] hermite(pos: []float, rate: float): float\nend func\n\n+class BmSearch()\n\u0009*func [d0000.knd, _bmSearchDtor, __frc] _dtor()\n\u0009end func\n\n\u0009+func [d0000.knd, _bmSearchFind] find(text: []char, start: int): int\n\u0009end func\n\n\u0009var pattern: int\n\u0009var dists: int\n\u0009var len: int\nend class\n\n+func [d0000.knd, _makeBmSearch, __mki] makeBmSearch(me2: @BmSearch, pattern: []char): @BmSearch\nend func\n\n+func [d0000.knd, _hash] hash(data: []bit8): []bit8\nend func\n\n+func [d0000.knd, _encrypt] encrypt(data: []bit8, key: []bit8): []bit8\nend func\n\n+func [d0000.knd, _decrypt] decrypt(data: []bit8, key: []bit8): []bit8\nend func\n\n+func [__raw, sysTime] sysTime(): int\nend func\n\n+func [d0000.knd, _now] now(): int\nend func\n\n+func [d0000.knd, _intToDate] intToDate(time: int, year: &int, month: &int, day: &int, hour: &int, minute: &int, second: &int): int\nend func\n\n+func [d0000.knd, _dateToInt] dateToInt(year: int, month: int, day: int, hour: int, minute: int, second: int): int\nend func\n\n+func [d0000.knd, _intToLocalDate] intToLocalDate(time: int, year: &int, month: &int, day: &int, hour: &int, minute: &int, second: &int): int\nend func\n\n+func [d0000.knd, _localDateToInt] localDateToInt(year: int, month: int, day: int, hour: int, minute: int, second: int): int\nend func\n\n+func [d0000.knd] sleep(ms: int)\nend func\n\n+func [d0000.knd, _countUp] countUp(min: int, max: int): []int\nend func\n\n+func [__raw, addr] addr(class_: kuin@Class): bit64\nend func\n\n+class Int()\n\u0009+*func cmp(t: @Int): int\n\u0009\u0009ret (me.value - t.value).sign()\n\u0009end func\n\n\u0009+*func toStr(): []char\n\u0009\u0009ret me.value.toStr()\n\u0009end func\n\n\u0009+var value: int\nend class\n\n+class Float()\n\u0009+*func cmp(t: @Float): int\n\u0009\u0009ret (me.value - t.value).sign() $ int\n\u0009end func\n\n\u0009+*func toStr(): []char\n\u0009\u0009ret me.value.toStr()\n\u0009end func\n\n\u0009+var value: float\nend class\n\n+class Bool()\n\u0009+*func cmp(t: @Bool): int\n\u0009\u0009ret (me.value $ int - t.value $ int).sign()\n\u0009end func\n\n\u0009+*func toStr(): []char\n\u0009\u0009ret me.value.toStr()\n\u0009end func\n\n\u0009+var value: bool\nend class\n\n+class Char()\n\u0009+*func cmp(t: @Char): int\n\u0009\u0009ret (me.value $ int - t.value $ int).sign()\n\u0009end func\n\n\u0009+*func toStr(): []char\n\u0009\u0009ret me.value.toStr()\n\u0009end func\n\n\u0009+var value: char\nend class\n\n+class Str()\n\u0009+*func cmp(t: @Str): int\n\u0009\u0009ret @cmp(me.value, t.value)\n\u0009end func\n\n\u0009+*func toStr(): []char\n\u0009\u0009ret me.value\n\u0009end func\n\n\u0009+var value: []char\nend class\n":true;
else if(p==="res/sys/preset00_cui.knp")
return f?"func main()\n\u0009do cui@print(\"Hello, world!\")\nend func\n":true;
else if(p==="res/sys/preset00_wnd.knp")
return f?"func main()\n\u0009var wndMain: wnd@Wnd :: wnd@makeWnd(null, %normal, 1024, 768, \"\")\n\u0009var editLog: wnd@EditMulti :: wnd@makeEditMulti(wndMain, 12, 12, 1000, 744, %scale, %scale)\n\u0009do editLog.readonly(true)\n\u0009do editLog.setText(\"Hello, world!\")\n\n\u0009while(wnd@act())\n\u0009end while\nend func\n":true;
else if(p==="res/sys/preset01_cui.knp")
return f?"func main()\n\u0009do cui@print(\"q\")\nend func\n":true;
else if(p==="res/sys/preset01_wnd.knp")
return f?"func main()\n\u0009var wndMain: wnd@Wnd :: wnd@makeWnd(null, %normal, 1024, 768, \"\")\n\u0009var editLog: wnd@EditMulti :: wnd@makeEditMulti(wndMain, 12, 12, 1000, 744, %scale, %scale)\n\u0009do editLog.readonly(true)\n\u0009do editLog.setText(\"q\")\n\n\u0009while(wnd@act())\n\u0009end while\nend func\n":true;
else if(p==="res/sys/preset02_cui.knp")
return f?"func main()\n\u0009for i(1, 100)\n\u0009\u0009if(i % 15 = 0)\n\u0009\u0009\u0009do cui@print(\"FizzBuzz\\n\")\n\u0009\u0009elif(i % 3 = 0)\n\u0009\u0009\u0009do cui@print(\"Fizz\\n\")\n\u0009\u0009elif(i % 5 = 0)\n\u0009\u0009\u0009do cui@print(\"Buzz\\n\")\n\u0009\u0009else\n\u0009\u0009\u0009do cui@print(i.toStr() ~ \"\\n\")\n\u0009\u0009end if\n\u0009end for\nend func\n":true;
else if(p==="res/sys/preset02_wnd.knp")
return f?"func main()\n\u0009var wndMain: wnd@Wnd :: wnd@makeWnd(null, %normal, 1024, 768, \"\")\n\u0009var editLog: wnd@EditMulti :: wnd@makeEditMulti(wndMain, 12, 12, 1000, 744, %scale, %scale)\n\u0009do editLog.readonly(true)\n\u0009do editLog.setText(\"\")\n\u0009for i(1, 100)\n\u0009\u0009if(i % 15 = 0)\n\u0009\u0009\u0009do editLog.setText(editLog.getText() ~ \"FizzBuzz\\n\")\n\u0009\u0009elif(i % 3 = 0)\n\u0009\u0009\u0009do editLog.setText(editLog.getText() ~ \"Fizz\\n\")\n\u0009\u0009elif(i % 5 = 0)\n\u0009\u0009\u0009do editLog.setText(editLog.getText() ~ \"Buzz\\n\")\n\u0009\u0009else\n\u0009\u0009\u0009do editLog.setText(editLog.getText() ~ (i.toStr() ~ \"\\n\"))\n\u0009\u0009end if\n\u0009end for\n\n\u0009while(wnd@act())\n\u0009end while\nend func\n":true;
else if(p==="res/sys/preset03_cui.knp")
return f?"func main()\n\u0009for i(99, 2, -1)\n\u0009\u0009do cui@print(i.toStr() ~ \" bottles of beer on the wall, \" ~ i.toStr() ~ \" bottles of beer.\\n\")\n\u0009\u0009do cui@print(\"Take one down, pass it around, \" ~ (i - 1).toStr() ~ \" bottles of beer on the wall.\\n\")\n\u0009end for\n\u0009do cui@print(\"2 bottles of beer on the wall, 2 bottles of beer.\\n\")\n\u0009do cui@print(\"Take one down, pass it around, 1 bottle of beer on the wall.\\n\")\n\u0009do cui@print(\"1 bottle of beer on the wall, 1 bottle of beer.\\n\")\n\u0009do cui@print(\"Take one down, pass it around, no more bottles of beer on the wall.\\n\")\n\u0009do cui@print(\"No more bottles of beer on the wall, no more bottles of beer.\\n\")\n\u0009do cui@print(\"Go to the store and buy some more, 99 bottles of beer on the wall.\\n\")\nend func\n":true;
else if(p==="res/sys/preset03_wnd.knp")
return f?"func main()\n\u0009var wndMain: wnd@Wnd :: wnd@makeWnd(null, %normal, 1024, 768, \"\")\n\u0009var editLog: wnd@EditMulti :: wnd@makeEditMulti(wndMain, 12, 12, 1000, 744, %scale, %scale)\n\u0009do editLog.readonly(true)\n\u0009do editLog.setText(\"\")\n\u0009for i(99, 2, -1)\n\u0009\u0009do editLog.setText(editLog.getText() ~ (i.toStr() ~ \" bottles of beer on the wall, \" ~ i.toStr() ~ \" bottles of beer.\\n\"))\n\u0009\u0009do editLog.setText(editLog.getText() ~ (\"Take one down, pass it around, \" ~ (i - 1).toStr() ~ \" bottles of beer on the wall.\\n\"))\n\u0009end for\n\u0009do editLog.setText(editLog.getText() ~ \"2 bottles of beer on the wall, 2 bottles of beer.\\n\")\n\u0009do editLog.setText(editLog.getText() ~ \"Take one down, pass it around, 1 bottle of beer on the wall.\\n\")\n\u0009do editLog.setText(editLog.getText() ~ \"1 bottle of beer on the wall, 1 bottle of beer.\\n\")\n\u0009do editLog.setText(editLog.getText() ~ \"Take one down, pass it around, no more bottles of beer on the wall.\\n\")\n\u0009do editLog.setText(editLog.getText() ~ \"No more bottles of beer on the wall, no more bottles of beer.\\n\")\n\u0009do editLog.setText(editLog.getText() ~ \"Go to the store and buy some more, 99 bottles of beer on the wall.\\n\")\n\n\u0009while(wnd@act())\n\u0009end while\nend func\n":true;
else if(p==="res/sys/wnd.kn")
return f?"func [d0001.knd, _init] _init()\nend func\n\nfunc [d0001.knd] _fin()\nend func\n\n+func [d0001.knd, _act] act(): bool\nend func\n\n+enum WndStyle\n\u0009normal\n\u0009fix\n\u0009aspect\n\u0009popup\n\u0009dialog\n\u0009layered :: 0x10000\n\u0009noMinimize :: 0x20000\nend enum\n\n+enum Anchor\n\u0009fix\n\u0009move\n\u0009scale\nend enum\n\n+class WndBase()\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseGetPos] getPos(x: &int, y: &int, width: &int, height: &int)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseGetPosScreen] getPosScreen(x: &int, y: &int, width: &int, height: &int)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseFocus] focus()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseFocused] focused(): bool\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseSetEnabled] setEnabled(isEnabled: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseGetEnabled] getEnabled(): bool\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseSetPos] setPos(x: int, y: int, width: int, height: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseSetRedraw] setRedraw(isEnabled: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseSetVisible] setVisible(isVisible: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseGetVisible] getVisible(): bool\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseClientToScreen] clientToScreen(screenX: &int, screenY: &int, clientX: int, clientY: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseScreenToClient] screenToClient(clientX: &int, clientY: &int, screenX: int, screenY: int)\n\u0009end func\n\n\u0009+func addChild(child: kuin@Class)\n\u0009\u0009do me.children.add(child)\n\u0009end func\n\n\u0009+func find(name: []char): @WndBase\n\u0009\u0009if(dbg)\n\u0009\u0009\u0009if(name =& null)\n\u0009\u0009\u0009\u0009throw 0xE9170006\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009ret findRecursion(me, name)\n\n\u0009\u0009func findRecursion(wnd: @WndBase, name: []char): @WndBase\n\u0009\u0009\u0009if(wnd.name <>& null & wnd.name = name)\n\u0009\u0009\u0009\u0009ret wnd\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do wnd.children.head()\n\u0009\u0009\u0009while(!wnd.children.term())\n\u0009\u0009\u0009\u0009var child: kuin@Class :: wnd.children.get()\n\u0009\u0009\u0009\u0009if(child =$ @WndBase)\n\u0009\u0009\u0009\u0009\u0009var result: @WndBase :: findRecursion(child $ @WndBase, name)\n\u0009\u0009\u0009\u0009\u0009if(result <>& null)\n\u0009\u0009\u0009\u0009\u0009\u0009ret result\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do wnd.children.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009ret null\n\u0009\u0009end func\n\u0009end func\n\n\u0009+var name: []char\n\u0009var kind: int\n\u0009var handle: int\n\u0009var defaultWndProc: int\n\u0009var ctrlFlag: int\n\u0009var defaultRect: int\n\u0009var redrawEnabled: int\n\u0009+var children: list<kuin@Class>\nend class\n\n+class Wnd(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetText] getText(): []char\n\u0009end func\n\n\u0009+func [d0001.knd, _wndClose] close()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndExit] exit()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndMinMax] minMax(minWidth: int, minHeight: int, maxWidth: int, maxHeight: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetMenu] setMenu(menu: @Menu)\n\u0009\u0009if(menu <>& null)\n\u0009\u0009\u0009do me.addChild(menu)\n\u0009\u0009end if\n\u0009end func\n\n\u0009+func [d0001.knd, _wndActivate] activate()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndActivated] activated(): bool\n\u0009end func\n\n\u0009+func [d0001.knd, _wndFocusedWnd] focusedWnd(): bool\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetAlpha] setAlpha(alpha: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetAlpha] getAlpha(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _wndAcceptDraggedFiles] acceptDraggedFiles(isAccepted: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndUpdateMenu] updateMenu()\n\u0009end func\n\n\u0009+func modal()\n\u0009\u0009do me.setModalLock()\n\u0009\u0009while(@act() & me.modalLock)\n\u0009\u0009end while\n\u0009end func\n\n\u0009func [d0001.knd, _wndSetModalLock] setModalLock()\n\u0009end func\n\n\u0009var minMaxRect: int\n\u0009+var onClose: func<(@WndBase): bool>\n\u0009+var onActivate: func<(@WndBase, bool, bool)>\n\u0009+var onPushMenu: func<(@WndBase, int)>\n\u0009+var onDropFiles: func<(@WndBase, [][]char)>\n\u0009+var onResize: func<(@WndBase)>\n\u0009var modalLock: bool\nend class\n\n+enum ShiftCtrl\n\u0009none\n\u0009shift :: 0x01\n\u0009ctrl :: 0x02\nend enum\n\n+class Draw(@WndBase)\n\u0009*func [d0001.knd, _drawDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _drawPaint] paint()\n\u0009end func\n\n\u0009+func [d0001.knd, _drawShowCaret] showCaret(height: int, font: draw@Font)\n\u0009end func\n\n\u0009+func [d0001.knd, _drawHideCaret] hideCaret()\n\u0009end func\n\n\u0009+func [d0001.knd, _drawMoveCaret] moveCaret(x: int, y: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _drawMouseCapture] mouseCapture(enabled: bool)\n\u0009end func\n\n\u0009var equalMagnification: int\n\u0009var drawBuf: int\n\u0009+var onPaint: func<(@WndBase, int, int)>\n\u0009+var onMouseDownL: func<(@WndBase, int, int)>\n\u0009+var onMouseDownR: func<(@WndBase, int, int)>\n\u0009+var onMouseDownM: func<(@WndBase, int, int)>\n\u0009+var onMouseDoubleClick: func<(@WndBase, int, int)>\n\u0009+var onMouseUpL: func<(@WndBase, int, int)>\n\u0009+var onMouseUpR: func<(@WndBase, int, int)>\n\u0009+var onMouseUpM: func<(@WndBase, int, int)>\n\u0009+var onMouseMove: func<(@WndBase, int, int)>\n\u0009+var onMouseEnter: func<(@WndBase, int, int)>\n\u0009+var onMouseLeave: func<(@WndBase)>\n\u0009+var onMouseWheelX: func<(@WndBase, int)>\n\u0009+var onMouseWheelY: func<(@WndBase, int)>\n\u0009+var onFocus: func<(@WndBase, bool)>\n\u0009+var onKeyDown: func<(@WndBase, @Key, @ShiftCtrl)>\n\u0009+var onKeyUp: func<(@WndBase, @Key, @ShiftCtrl)>\n\u0009+var onKeyChar: func<(@WndBase, char)>\n\u0009+var onScrollX: func<(@WndBase, int)>\n\u0009+var onScrollY: func<(@WndBase, int)>\n\u0009+var onSetMouseImg: func<(@WndBase): @MouseImg>\nend class\n\n+class DrawEditable(@Draw)\n\u0009*func [d0001.knd, _drawDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Btn(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetText] getText(): []char\n\u0009end func\n\n\u0009+var onPush: func<(@WndBase)>\nend class\n\n+class Chk(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetText] getText(): []char\n\u0009end func\n\n\u0009+func [d0001.knd, _btnSetChk] setChk(value: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _btnGetChk] getChk(): bool\n\u0009end func\n\n\u0009+var onPush: func<(@WndBase)>\nend class\n\n+class Radio(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetText] getText(): []char\n\u0009end func\n\n\u0009+func [d0001.knd, _btnSetChk] setChk(value: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _btnGetChk] getChk(): bool\n\u0009end func\n\n\u0009+var onPush: func<(@WndBase)>\nend class\n\n+class EditBase(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [__raw,  wnd_editBaseGetText] getText(): []char\n\u0009end func\n\n\u0009+func [d0001.knd, _editReadonly] readonly(enabled: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _editSetSel] setSel(start: int, len: int)\n\u0009end func\n\n\u0009+var onChange: func<(@WndBase)>\n\u0009+var onFocus: func<(@WndBase, bool)>\nend class\n\n+class Edit(@EditBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _editRightAligned] rightAligned(enabled: bool)\n\u0009end func\nend class\n\n+class EditMulti(@EditBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _editMultiAddText] addText(text: []char)\n\u0009end func\nend class\n\n+class List(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _listClear] clear()\n\u0009end func\n\n\u0009+func [d0001.knd, _listAdd] add(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _listIns] ins(idx: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _listDel] del(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listLen] len(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _listSetSel] setSel(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listGetSel] getSel(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _listSetText] setText(idx: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _listGetText] getText(idx: int): []char\n\u0009end func\n\n\u0009+var onSel: func<(@WndBase)>\n\u0009+var onMouseDoubleClick: func<(@WndBase)>\nend class\n\n+class Combo(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _comboClear] clear()\n\u0009end func\n\n\u0009+func [d0001.knd, _comboAdd] add(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _comboIns] ins(idx: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _comboDel] del(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _comboLen] len(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _comboSetSel] setSel(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _comboGetSel] getSel(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _comboSetText] setText(idx: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _comboGetText] getText(idx: int): []char\n\u0009end func\nend class\n\n+class Label(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetText] getText(): []char\n\u0009end func\nend class\n\n+class Group(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetText] getText(): []char\n\u0009end func\nend class\n\n+class Calendar(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Progress(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Rebar(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Status(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Toolbar(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Trackbar(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class LabelLink(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+enum ListViewStyle\n\u0009large\n\u0009report\n\u0009small\n\u0009list_\n\u0009chk\n\u0009hideHeader :: 0x4000\nend enum\n\n+class ListView(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewClear] clear()\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewAdd] add(text: []char, img: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewIns] ins(idx: int, text: []char, img: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewDel] del(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewLen] len(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewAddColumn] addColumn(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewInsColumn] insColumn(column: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewDelColumn] delColumn(column: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewLenColumn] lenColumn(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewClearAll] clearAll()\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewSetText] setText(idx: int, column: int, text: []char, img: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewGetText] getText(img: &int, idx: int, column: int): []char\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewAdjustWidth] adjustWidth()\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewSetSel] setSel(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewGetSel] getSel(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewSetSelMulti] setSelMulti(idx: int, value: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewGetSelMulti] getSelMulti(idx: int): bool\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewStyle] style(listViewStyle: @ListViewStyle)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewDraggable] draggable(enabled: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewSetChk] setChk(idx: int, value: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewGetChk] getChk(idx: int): bool\n\u0009end func\n\n\u0009+var onSel: func<(@WndBase)>\n\u0009+var onMouseDoubleClick: func<(@WndBase)>\n\u0009+var onMouseClick: func<(@WndBase)>\n\u0009+var onMoveNode: func<(@WndBase)>\n\u0009var draggable_: int\n\u0009var draggingImage: int\nend class\n\n+class Pager(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Tab(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _tabAdd] add(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _tabLen] len(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _tabSetSel] setSel(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _tabGetSel] getSel(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _tabGetPosInner] getPosInner(x: &int, y: &int, width: &int, height: &int)\n\u0009end func\n\n\u0009+var onSel: func<(@WndBase)>\nend class\n\n+class Tree(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _treeClear] clear()\n\u0009end func\n\n\u0009+func [d0001.knd, _treeExpand] expand(expand_: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _treeRoot, _make_instance] root(me2: @TreeNode): @TreeNode\n\u0009end func\n\n\u0009+func [d0001.knd, _treeDraggable] draggable(enabled: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _treeAllowDraggingToRoot] allowDraggingToRoot(enabled: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _treeSetSel] setSel(node: @TreeNode)\n\u0009end func\n\n\u0009+func [d0001.knd, _treeGetSel, _make_instance] getSel(me2: @TreeNode): @TreeNode\n\u0009end func\n\n\u0009var draggable_: int\n\u0009var draggingItem: int\n\u0009+var onSel: func<(@WndBase)>\n\u0009+var onMoveNode: func<(@WndBase)>\nend class\n\n+class TreeNode()\n\u0009+*func cmp(t: @TreeNode): int\n\u0009\u0009ret me.item - t.item\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeAddChild, _make_instance] addChild(me2: @TreeNode, name: []char): @TreeNode\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeInsChild, _make_instance] insChild(me2: @TreeNode, node: @TreeNode, name: []char): @TreeNode\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeDelChild] delChild(node: @TreeNode)\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeFirstChild, _make_instance] firstChild(me2: @TreeNode): @TreeNode\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeGetName] getName(): []char\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeNext, _make_instance] next(me2: @TreeNode): @TreeNode\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodePrev, _make_instance] prev(me2: @TreeNode): @TreeNode\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeParent, _make_instance] parent(me2: @TreeNode): @TreeNode\n\u0009end func\n\n\u0009var wndHandle: int\n\u0009+var item: int\nend class\n\nclass SplitBase(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class SplitX(@SplitBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class SplitY(@SplitBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\nclass ScrollBase(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _scrollSetState] setState(min: int, max: int, page: int, pos: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _scrollSetScrollPos] setScrollPos(pos: int)\n\u0009end func\nend class\n\n+class ScrollX(@ScrollBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class ScrollY(@ScrollBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+enum MsgBoxIcon\n\u0009none\n\u0009err :: 0x10\n\u0009question :: 0x20\n\u0009warn :: 0x30\n\u0009info :: 0x40\nend enum\n\n+enum MsgBoxBtn\n\u0009ok\n\u0009okCancel\n\u0009abortRetryIgnore\n\u0009yesNoCancel\n\u0009yesNo\n\u0009retryCancel\n\u0009cancelAgainContinue\nend enum\n\n+enum MsgBoxResult\n\u0009ok :: 1\n\u0009cancel\n\u0009abort\n\u0009retry\n\u0009ignore\n\u0009yes\n\u0009no\n\u0009again :: 10\n\u0009continue\nend enum\n\n+func [d0001.knd, _setOnKeyPress] setOnKeyPress(onKeyPressFunc: func<(@Key, @ShiftCtrl): bool>)\nend func\n\n+func [d0001.knd, _getOnKeyPress] getOnKeyPress(): func<(@Key, @ShiftCtrl): bool>\nend func\n\n+func [d0001.knd, _msgBox] msgBox(parent: @Wnd, text: []char, title: []char, icon: @MsgBoxIcon, btn: @MsgBoxBtn): @MsgBoxResult\nend func\n\n+func [d0001.knd, _openFileDialog] openFileDialog(parent: @Wnd, filter: [][]char, defaultFilter: int): []char\nend func\n\n+func [d0001.knd, _saveFileDialog] saveFileDialog(parent: @Wnd, filter: [][]char, defaultFilter: int, defaultExt: []char): []char\nend func\n\n+func [d0001.knd, _fileDialogDir] fileDialogDir(defaultDir: []char)\nend func\n\n+func [d0001.knd, _colorDialog] colorDialog(parent: @Wnd, defaultColor: int): int\nend func\n\n+func [d0001.knd, _setClipboardStr] setClipboardStr(str: []char)\nend func\n\n+func [d0001.knd, _getClipboardStr] getClipboardStr(): []char\nend func\n\n+func [d0001.knd, _getCaretPos] getCaretPos(x: &int, y: &int)\nend func\n\n+func [d0001.knd, _screenSize] screenSize(width: &int, height: &int)\nend func\n\n+func [d0001.knd, _makeWnd, _make_instance] makeWnd(me2: @Wnd, parent: @Wnd, style: @WndStyle, width: int, height: int, text: []char): @Wnd\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeDraw, _make_instance] makeDraw(me2: @Draw, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, equalMagnification: bool): @Draw\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeDrawReduced, _make_instance] makeDrawReduced(me2: @Draw, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, equalMagnification: bool, split: int): @Draw\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeDrawEditable, _make_instance] makeDrawEditable(me2: @DrawEditable, parent: @WndBase, x: int, y: int, width: int, height: int): @DrawEditable\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeBtn, _make_instance] makeBtn(me2: @Btn, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, text: []char): @Btn\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeChk, _make_instance] makeChk(me2: @Chk, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, text: []char): @Chk\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeRadio, _make_instance] makeRadio(me2: @Radio, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, text: []char): @Radio\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeEdit, _make_instance] makeEdit(me2: @Edit, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Edit\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [__mki, __raw, wnd_makeEditMulti] makeEditMulti(me2: @EditMulti, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @EditMulti\nend func\n\n+func [d0001.knd, _makeList, _make_instance] makeList(me2: @List, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @List\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeCombo, _make_instance] makeCombo(me2: @Combo, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Combo\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeLabel, _make_instance] makeLabel(me2: @Label, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, text: []char): @Label\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeGroup, _make_instance] makeGroup(me2: @Group, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, text: []char): @Group\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeCalendar, _make_instance] makeCalendar(me2: @Calendar, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Calendar\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeProgress, _make_instance] makeProgress(me2: @Progress, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Progress\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeRebar, _make_instance] makeRebar(me2: @Rebar, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Rebar\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeStatus, _make_instance] makeStatus(me2: @Status, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Status\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeToolbar, _make_instance] makeToolbar(me2: @Toolbar, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Toolbar\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeTrackbar, _make_instance] makeTrackbar(me2: @Trackbar, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Trackbar\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeLabelLink, _make_instance] makeLabelLink(me2: @LabelLink, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @LabelLink\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeListView, _make_instance] makeListView(me2: @ListView, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, multiSel: bool, smallImgs: [][]char, largeImgs: [][]char): @ListView\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makePager, _make_instance] makePager(me2: @Pager, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Pager\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeTab, _make_instance] makeTab(me2: @Tab, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Tab\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeTree, _make_instance] makeTree(me2: @Tree, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Tree\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeSplitX, _make_instance] makeSplitX(me2: @SplitX, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @SplitX\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeSplitY, _make_instance] makeSplitY(me2: @SplitY, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @SplitY\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeScrollX, _make_instance] makeScrollX(me2: @ScrollX, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @ScrollX\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeScrollY, _make_instance] makeScrollY(me2: @ScrollY, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @ScrollY\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+class MenuBase()\n\u0009*func [d0001.knd, _menuDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _menuAdd] add(id: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _menuAddLine] addLine()\n\u0009end func\n\n\u0009+func [d0001.knd, _menuAddPopup] addPopup(text: []char, popup: @Popup)\n\u0009\u0009do me.children.add(popup)\n\u0009end func\n\n\u0009+func [d0001.knd, _menuIns] ins(targetId: int, id: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _menuInsPopup] insPopup(target: @Popup, text: []char, popup: @Popup)\n\u0009\u0009do me.children.add(popup)\n\u0009end func\n\n\u0009+func [d0001.knd, _menuDel] del(id: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _menuDelPopup] delPopup(popup: @Popup)\n\u0009end func\n\n\u0009var handle: int\n\u0009var children: list<kuin@Class>\nend class\n\n+class Menu(@MenuBase)\n\u0009*func [d0001.knd, _menuDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Popup(@MenuBase)\n\u0009*func [d0001.knd, _menuDtor, _force] _dtor()\n\u0009end func\nend class\n\n+func [d0001.knd, _makeMenu, _make_instance] makeMenu(me2: @Menu): @Menu\nend func\n\n+func [d0001.knd, _makePopup, _make_instance] makePopup(me2: @Popup): @Popup\nend func\n\n+class TabOrder()\n\u0009*func [_force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _tabOrderChk] chk(key: @Key, shiftCtrl: @ShiftCtrl): bool\n\u0009end func\n\n\u0009var ctrls: []@WndBase\nend class\n\n+func [d0001.knd, _makeTabOrder, _make_instance] makeTabOrder(me2: @TabOrder, ctrls: []@WndBase): @TabOrder\nend func\n\n+func [d0001.knd, _key] key(key_: @Key): bool\nend func\n\n+enum Key\n\u0009mouseL :: 0x01\n\u0009mouseR\n\u0009mouseM :: 0x04\n\u0009bs :: 0x08\n\u0009tab\n\u0009enter :: 0x0D\n\u0009shift :: 0x10\n\u0009ctrl\n\u0009alt\n\u0009pause\n\u0009esc :: 0x1B\n\u0009space :: 0x20\n\u0009pageUp\n\u0009pageDown\n\u0009end_\n\u0009home\n\u0009left\n\u0009up\n\u0009right\n\u0009down\n\u0009ins :: 0x2D\n\u0009del\n\u0009_0 :: 0x30\n\u0009_1\n\u0009_2\n\u0009_3\n\u0009_4\n\u0009_5\n\u0009_6\n\u0009_7\n\u0009_8\n\u0009_9\n\u0009a :: 0x41\n\u0009b\n\u0009c\n\u0009d\n\u0009e\n\u0009f\n\u0009g\n\u0009h\n\u0009i\n\u0009j\n\u0009k\n\u0009l\n\u0009m\n\u0009n\n\u0009o\n\u0009p\n\u0009q\n\u0009r\n\u0009s\n\u0009t\n\u0009u\n\u0009v\n\u0009w\n\u0009x\n\u0009y\n\u0009z\n\u0009f1 :: 0x70\n\u0009f2\n\u0009f3\n\u0009f4\n\u0009f5\n\u0009f6\n\u0009f7\n\u0009f8\n\u0009f9\n\u0009f10\n\u0009f11\n\u0009f12\n\u0009plus :: 0xBB\n\u0009comma\n\u0009minus\n\u0009period\nend enum\n\n+enum MouseImg\n\u0009arrow :: 32512\n\u0009ibeam\n\u0009wait\n\u0009cross\n\u0009upArrow\n\u0009resizeLTRB :: 32642\n\u0009resizeRTLB\n\u0009resizeH\n\u0009resizeV\n\u0009move\n\u0009no :: 32648\n\u0009link\n\u0009arrowWait\n\u0009arrowHelp\nend enum\n":true;
else if(p==="res/test.kn")
return f?"func main()\n\u0009do @test1()\nend func\n\nvar s: []char :: \"abc\" ~ \"def\"\n\nfunc dump(ns: []bit8)\n\u0009var s: []char :: \"\"\n\u0009for i(0, ^ns - 1)\n\u0009\u0009do s :~ \" \" ~ ns[i].toStr()\n\u0009end for\n\u0009do cui@print(s ~ \"\\n\")\nend func\n\n; Single line comment #1.\n; Single line comment #2.\n\nfunc test1()\n\u0009do cui@print(\"Kuin\" ~ \" Test \" ~ \"Program\\n\")\n\u0009\n\u0009block\n\u0009\u0009var a: int :: (7 + 7) / 7 - 7 * 7 + 7 + 7 + 7 + 7 + 7 + 7 + 7 + 7 + 7 + 7 + (+7) + (-7) {23}\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ (23 % 7).toStr() ~ \", \" ~ (7 ^ 7).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: int :: 7\n\u0009\u0009var b: int :: (n + n) / n - n * n + n + n + n + n + n + n + n + n + n + n + (+n) + (-n) {23}\n\u0009\u0009do cui@print(b.toStr() ~ \", \" ~ (b % n).toStr() ~ \", \" ~ (n ^ n).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c: int :: -2\n\u0009\u0009do cui@print((c ^ 0).toStr() ~ \", \" ~ (c ^ 1).toStr() ~ \", \" ~ (c ^ 2).toStr() ~ \", \" ~ (c ^ 3).toStr() ~ \", \" ~ (c ^ 4).toStr() ~ \", \" ~ (c ^ 5).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: float :: (7.0 + 7.0) / 7.0 - 7.0 * 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + (+7.0) + (-7.0) {23.0}\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ (23.00 % 7.0).toStr() ~ \", \" ~ (7 ^ 7).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: float :: 7.0\n\u0009\u0009var b: float :: (n + n) / n - n * n + n + n + n + n + n + n + n + n + n + n + (+n) + (-n) {23.0}\n\u0009\u0009do cui@print(b.toStr() ~ \", \" ~ (b % n).toStr() ~ \", \" ~ (n ^ n).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c: float :: -2.0\n\u0009\u0009do cui@print((c ^ 0.0).toStr() ~ \", \" ~ (c ^ 1.0).toStr() ~ \", \" ~ (c ^ 2.0).toStr() ~ \", \" ~ (c ^ 3.0).toStr() ~ \", \" ~ (c ^ 4.0).toStr() ~ \", \" ~ (c ^ 5.0).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: bit8 :: (7b8 + 7b8) / 7b8 - 7b8 * 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + (+7b8) + ((-7) $ bit8) {23}\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ (23b8 % 7b8).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: bit8 :: 7b8\n\u0009\u0009var b: bit8 :: (n + n) / n - n * n + n + n + n + n + n + n + n + n + n + n + (+n) + (0b8 - n) {23}\n\u0009\u0009do cui@print(b.toStr() ~ \", \" ~ (b % n).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c1: bit8 :: 255b8 + 2b8\n\u0009\u0009var c2: bit8 :: (-1) $ bit8\n\u0009\u0009var d1: bit8 :: 255b8\n\u0009\u0009var d2: bit8 :: 1b8\n\u0009\u0009do d1 :+ 2b8\n\u0009\u0009do d2 :: 0b8 - d2\n\u0009\u0009do cui@print(c1.toStr() ~ \", \" ~ d1.toStr() ~ \", \" ~ c2.toStr() ~ \", \" ~ d2.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: bit16 :: (7b16 + 7b16) / 7b16 - 7b16 * 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + (+7b16) + ((-7) $ bit16) {23}\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ (23b16 % 7b16).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: bit16 :: 7b16\n\u0009\u0009var b: bit16 :: (n + n) / n - n * n + n + n + n + n + n + n + n + n + n + n + (+n) + (0b16 - n) {23}\n\u0009\u0009do cui@print(b.toStr() ~ \", \" ~ (b % n).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c1: bit16 :: 65535b16 + 2b16\n\u0009\u0009var c2: bit16 :: (-1) $ bit16\n\u0009\u0009var d1: bit16 :: 65535b16\n\u0009\u0009var d2: bit16 :: 1b16\n\u0009\u0009do d1 :+ 2b16\n\u0009\u0009do d2 :: 0b16 - d2\n\u0009\u0009do cui@print(c1.toStr() ~ \", \" ~ d1.toStr() ~ \", \" ~ c2.toStr() ~ \", \" ~ d2.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: bit32 :: (7b32 + 7b32) / 7b32 - 7b32 * 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + (+7b32) + ((-7) $ bit32) {23}\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ (23b32 % 7b32).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: bit32 :: 7b32\n\u0009\u0009var b: bit32 :: (n + n) / n - n * n + n + n + n + n + n + n + n + n + n + n + (+n) + (0b32 - n) {23}\n\u0009\u0009do cui@print(b.toStr() ~ \", \" ~ (b % n).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c1: bit32 :: 0xFFFFFFFFb32 + 2b32\n\u0009\u0009var c2: bit32 :: (-1) $ bit32\n\u0009\u0009var d1: bit32 :: 0xFFFFFFFFb32\n\u0009\u0009var d2: bit32 :: 1b32\n\u0009\u0009do d1 :+ 2b32\n\u0009\u0009do d2 :: 0b32 - d2\n\u0009\u0009do cui@print(c1.toStr() ~ \", \" ~ d1.toStr() ~ \", \" ~ c2.toStr() ~ \", \" ~ d2.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: bit64 :: (7b64 + 7b64) / 7b64 - 7b64 * 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + (+7b64) + ((-7) $ bit64) {23}\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ (23b64 % 7b64).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: bit64 :: 7b64\n\u0009\u0009var b: bit64 :: (n + n) / n - n * n + n + n + n + n + n + n + n + n + n + n + (+n) + (0b64 - n) {23}\n\u0009\u0009do cui@print(b.toStr() ~ \", \" ~ (b % n).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c1: bit64 :: 0xFFFFFFFFFFFFFFFFb64 + 2b64\n\u0009\u0009var c2: bit64 :: (-1) $ bit64\n\u0009\u0009var d1: bit64 :: 0xFFFFFFFFFFFFFFFFb64\n\u0009\u0009var d2: bit64 :: 1b64\n\u0009\u0009do d1 :+ 2b64\n\u0009\u0009do d2 :: 0b64 - d2\n\u0009\u0009do cui@print(c1.toStr() ~ \", \" ~ d1.toStr() ~ \", \" ~ c2.toStr() ~ \", \" ~ d2.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print((-3 = 5).toStr() ~ \", \" ~ (-3 <> 5).toStr() ~ \", \" ~ (-3 < 5).toStr() ~ \", \" ~ (-3 <= 5).toStr() ~ \", \" ~ (-3 > 5).toStr() ~ \", \" ~ (-3 >= 5).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var a: int :: -3\n\u0009\u0009var b: int :: 5\n\u0009\u0009do cui@print((a = b).toStr() ~ \", \" ~ (a <> b).toStr() ~ \", \" ~ (a < b).toStr() ~ \", \" ~ (a <= b).toStr() ~ \", \" ~ (a > b).toStr() ~ \", \" ~ (a >= b).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009do cui@print((4 = 4).toStr() ~ \", \" ~ (4 <> 4).toStr() ~ \", \" ~ (4 < 4).toStr() ~ \", \" ~ (4 <= 4).toStr() ~ \", \" ~ (4 > 4).toStr() ~ \", \" ~ (4 >= 4).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c: int :: 4\n\u0009\u0009var d: int :: 4\n\u0009\u0009do cui@print((c = d).toStr() ~ \", \" ~ (c <> d).toStr() ~ \", \" ~ (c < d).toStr() ~ \", \" ~ (c <= d).toStr() ~ \", \" ~ (c > d).toStr() ~ \", \" ~ (c >= d).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print((-3.0 = 5.0).toStr() ~ \", \" ~ (-3.0 <> 5.0).toStr() ~ \", \" ~ (-3.0 < 5.0).toStr() ~ \", \" ~ (-3.0 <= 5.0).toStr() ~ \", \" ~ (-3.0 > 5.0).toStr() ~ \", \" ~ (-3.0 >= 5.0).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var a: float :: -3.0\n\u0009\u0009var b: float :: 5.0\n\u0009\u0009do cui@print((a = b).toStr() ~ \", \" ~ (a <> b).toStr() ~ \", \" ~ (a < b).toStr() ~ \", \" ~ (a <= b).toStr() ~ \", \" ~ (a > b).toStr() ~ \", \" ~ (a >= b).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009do cui@print((4.0 = 4.0).toStr() ~ \", \" ~ (4.0 <> 4.0).toStr() ~ \", \" ~ (4.0 < 4.0).toStr() ~ \", \" ~ (4.0 <= 4.0).toStr() ~ \", \" ~ (4.0 > 4.0).toStr() ~ \", \" ~ (4.0 >= 4.0).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c: float :: 4.0\n\u0009\u0009var d: float :: 4.0\n\u0009\u0009do cui@print((c = d).toStr() ~ \", \" ~ (c <> d).toStr() ~ \", \" ~ (c < d).toStr() ~ \", \" ~ (c <= d).toStr() ~ \", \" ~ (c > d).toStr() ~ \", \" ~ (c >= d).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print((0x79b8 = 0x81b8).toStr() ~ \", \" ~ (0x79b8 <> 0x81b8).toStr() ~ \", \" ~ (0x79b8 < 0x81b8).toStr() ~ \", \" ~ (0x79b8 <= 0x81b8).toStr() ~ \", \" ~ (0x79b8 > 0x81b8).toStr() ~ \", \" ~ (0x79b8 >= 0x81b8).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var a: bit8 :: 0x79b8\n\u0009\u0009var b: bit8 :: 0x81b8\n\u0009\u0009do cui@print((a = b).toStr() ~ \", \" ~ (a <> b).toStr() ~ \", \" ~ (a < b).toStr() ~ \", \" ~ (a <= b).toStr() ~ \", \" ~ (a > b).toStr() ~ \", \" ~ (a >= b).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009do cui@print((0x80b8 = 0x80b8).toStr() ~ \", \" ~ (0x80b8 <> 0x80b8).toStr() ~ \", \" ~ (0x80b8 < 0x80b8).toStr() ~ \", \" ~ (0x80b8 <= 0x80b8).toStr() ~ \", \" ~ (0x80b8 > 0x80b8).toStr() ~ \", \" ~ (0x80b8 >= 0x80b8).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c: bit8 :: 0x80b8\n\u0009\u0009var d: bit8 :: 0x80b8\n\u0009\u0009do cui@print((c = d).toStr() ~ \", \" ~ (c <> d).toStr() ~ \", \" ~ (c < d).toStr() ~ \", \" ~ (c <= d).toStr() ~ \", \" ~ (c > d).toStr() ~ \", \" ~ (c >= d).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print((0x7900b16 = 0x8100b16).toStr() ~ \", \" ~ (0x7900b16 <> 0x8100b16).toStr() ~ \", \" ~ (0x7900b16 < 0x8100b16).toStr() ~ \", \" ~ (0x7900b16 <= 0x8100b16).toStr() ~ \", \" ~ (0x7900b16 > 0x8100b16).toStr() ~ \", \" ~ (0x7900b16 >= 0x8100b16).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var a: bit16 :: 0x7900b16\n\u0009\u0009var b: bit16 :: 0x8100b16\n\u0009\u0009do cui@print((a = b).toStr() ~ \", \" ~ (a <> b).toStr() ~ \", \" ~ (a < b).toStr() ~ \", \" ~ (a <= b).toStr() ~ \", \" ~ (a > b).toStr() ~ \", \" ~ (a >= b).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009do cui@print((0x8000b16 = 0x8000b16).toStr() ~ \", \" ~ (0x8000b16 <> 0x8000b16).toStr() ~ \", \" ~ (0x8000b16 < 0x8000b16).toStr() ~ \", \" ~ (0x8000b16 <= 0x8000b16).toStr() ~ \", \" ~ (0x8000b16 > 0x8000b16).toStr() ~ \", \" ~ (0x8000b16 >= 0x8000b16).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c: bit16 :: 0x8000b16\n\u0009\u0009var d: bit16 :: 0x8000b16\n\u0009\u0009do cui@print((c = d).toStr() ~ \", \" ~ (c <> d).toStr() ~ \", \" ~ (c < d).toStr() ~ \", \" ~ (c <= d).toStr() ~ \", \" ~ (c > d).toStr() ~ \", \" ~ (c >= d).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print((0x79000000b32 = 0x81000000b32).toStr() ~ \", \" ~ (0x79000000b32 <> 0x81000000b32).toStr() ~ \", \" ~ (0x79000000b32 < 0x81000000b32).toStr() ~ \", \" ~ (0x79000000b32 <= 0x81000000b32).toStr() ~ \", \" ~ (0x79000000b32 > 0x81000000b32).toStr() ~ \", \" ~ (0x79000000b32 >= 0x81000000b32).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var a: bit32 :: 0x79000000b32\n\u0009\u0009var b: bit32 :: 0x81000000b32\n\u0009\u0009do cui@print((a = b).toStr() ~ \", \" ~ (a <> b).toStr() ~ \", \" ~ (a < b).toStr() ~ \", \" ~ (a <= b).toStr() ~ \", \" ~ (a > b).toStr() ~ \", \" ~ (a >= b).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009do cui@print((0x80000000b32 = 0x80000000b32).toStr() ~ \", \" ~ (0x80000000b32 <> 0x80000000b32).toStr() ~ \", \" ~ (0x80000000b32 < 0x80000000b32).toStr() ~ \", \" ~ (0x80000000b32 <= 0x80000000b32).toStr() ~ \", \" ~ (0x80000000b32 > 0x80000000b32).toStr() ~ \", \" ~ (0x80000000b32 >= 0x80000000b32).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c: bit32 :: 0x80000000b32\n\u0009\u0009var d: bit32 :: 0x80000000b32\n\u0009\u0009do cui@print((c = d).toStr() ~ \", \" ~ (c <> d).toStr() ~ \", \" ~ (c < d).toStr() ~ \", \" ~ (c <= d).toStr() ~ \", \" ~ (c > d).toStr() ~ \", \" ~ (c >= d).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print((0x7900000000000000b64 = 0x8100000000000000b64).toStr() ~ \", \" ~ (0x7900000000000000b64 <> 0x8100000000000000b64).toStr() ~ \", \" ~ (0x7900000000000000b64 < 0x8100000000000000b64).toStr() ~ \", \" ~ (0x7900000000000000b64 <= 0x8100000000000000b64).toStr() ~ \", \" ~ (0x7900000000000000b64 > 0x8100000000000000b64).toStr() ~ \", \" ~ (0x7900000000000000b64 >= 0x8100000000000000b64).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var a: bit64 :: 0x7900000000000000b64\n\u0009\u0009var b: bit64 :: 0x8100000000000000b64\n\u0009\u0009do cui@print((a = b).toStr() ~ \", \" ~ (a <> b).toStr() ~ \", \" ~ (a < b).toStr() ~ \", \" ~ (a <= b).toStr() ~ \", \" ~ (a > b).toStr() ~ \", \" ~ (a >= b).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009do cui@print((0x8000000000000000b64 = 0x8000000000000000b64).toStr() ~ \", \" ~ (0x8000000000000000b64 <> 0x8000000000000000b64).toStr() ~ \", \" ~ (0x8000000000000000b64 < 0x8000000000000000b64).toStr() ~ \", \" ~ (0x8000000000000000b64 <= 0x8000000000000000b64).toStr() ~ \", \" ~ (0x8000000000000000b64 > 0x8000000000000000b64).toStr() ~ \", \" ~ (0x8000000000000000b64 >= 0x8000000000000000b64).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c: bit64 :: 0x8000000000000000b64\n\u0009\u0009var d: bit64 :: 0x8000000000000000b64\n\u0009\u0009do cui@print((c = d).toStr() ~ \", \" ~ (c <> d).toStr() ~ \", \" ~ (c < d).toStr() ~ \", \" ~ (c <= d).toStr() ~ \", \" ~ (c > d).toStr() ~ \", \" ~ (c >= d).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print((\"ab\" = \"a\" ~ \"c\").toStr() ~ \", \" ~ (\"ab\" <> \"a\" ~ \"c\").toStr() ~ \", \" ~ (\"ab\" < \"a\" ~ \"c\").toStr() ~ \", \" ~ (\"ab\" <= \"a\" ~ \"c\").toStr() ~ \", \" ~ (\"ab\" > \"a\" ~ \"c\").toStr() ~ \", \" ~ (\"ab\" >= \"a\" ~ \"c\").toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var a: []char :: \"ab\"\n\u0009\u0009var b: []char :: \"a\" ~ \"c\"\n\u0009\u0009do cui@print((a = b).toStr() ~ \", \" ~ (a <> b).toStr() ~ \", \" ~ (a < b).toStr() ~ \", \" ~ (a <= b).toStr() ~ \", \" ~ (a > b).toStr() ~ \", \" ~ (a >= b).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009do cui@print((\"ab\" = \"a\" ~ \"b\").toStr() ~ \", \" ~ (\"ab\" <> \"a\" ~ \"b\").toStr() ~ \", \" ~ (\"ab\" < \"a\" ~ \"b\").toStr() ~ \", \" ~ (\"ab\" <= \"a\" ~ \"b\").toStr() ~ \", \" ~ (\"ab\" > \"a\" ~ \"b\").toStr() ~ \", \" ~ (\"ab\" >= \"a\" ~ \"b\").toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((a = \"ab\").toStr() ~ \", \" ~ (a <> \"ab\").toStr() ~ \", \" ~ (a < \"ab\").toStr() ~ \", \" ~ (a <= \"ab\").toStr() ~ \", \" ~ (a > \"ab\").toStr() ~ \", \" ~ (a >= \"ab\").toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: []char :: \"ab\"\n\u0009\u0009var b: []char :: \"ab\"\n\u0009\u0009var c: []char :: a\n\u0009\u0009var d: []char :: null\n\u0009\u0009var e: []char :: null\n\u0009\u0009do cui@print((a =& b).toStr() ~ \", \" ~ (a <>& b).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((a =& c).toStr() ~ \", \" ~ (a <>& c).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((b =& c).toStr() ~ \", \" ~ (b <>& c).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((a =& d).toStr() ~ \", \" ~ (a <>& d).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((d =& e).toStr() ~ \", \" ~ (d <>& e).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((d =& null).toStr() ~ \", \" ~ (d <>& null).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((null =& null).toStr() ~ \", \" ~ (null <>& null).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print((true & true).toStr() ~ \", \" ~ (true | true).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((true & false).toStr() ~ \", \" ~ (true | false).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((false & true).toStr() ~ \", \" ~ (false | true).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((false & false).toStr() ~ \", \" ~ (false | false).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((true ?(\"T\", \"F\")) ~ \"\\n\")\n\u0009\u0009do cui@print((false ?(\"T\", \"F\")) ~ \"\\n\")\n\u0009\u0009do cui@print((!true ?(\"T\", \"F\")) ~ \"\\n\")\n\u0009\u0009do cui@print((!false ?(\"T\", \"F\")) ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var a: bool :: null =& null\n\u0009\u0009var b: bool :: null <>& null\n\u0009\u0009var c: bool :: null =& null\n\u0009\u0009var d: bool :: null <>& null\n\u0009\u0009do cui@print((a & c).toStr() ~ \", \" ~ (a | c).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((a & d).toStr() ~ \", \" ~ (a | d).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((b & c).toStr() ~ \", \" ~ (b | c).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((b & d).toStr() ~ \", \" ~ (b | d).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((a ?(\"T\", \"F\")) ~ \"\\n\")\n\u0009\u0009do cui@print((b ?(\"T\", \"F\")) ~ \"\\n\")\n\u0009\u0009do cui@print((!a ?(\"T\", \"F\")) ~ \"\\n\")\n\u0009\u0009do cui@print((!b ?(\"T\", \"F\")) ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: []char :: (null =& null).toStr()\n\u0009\u0009var b: []char :: (null <>& null).toStr()\n\u0009\u0009do a :~ \", \" ~ b\n\u0009\u0009do cui@print(a ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print((^(\"abcdef\")).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((5).abs().toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((-5).abs().toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((5.0).abs().toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((-5.0).abs().toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: int :: 3\n\u0009\u0009var b: int :: 5\n\u0009\u0009do a :$ b\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ b.toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c: []char :: \"abc\"\n\u0009\u0009var d: []char :: \"def\"\n\u0009\u0009do c :$ d\n\u0009\u0009do cui@print(c ~ \", \" ~ d ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print((65537 $ int).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((65537 $ float).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((65537 $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((65537 $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((65537 $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((65537 $ bit64).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((33 $ char).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((0 $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((5 $ bool).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: int :: 65537\n\u0009\u0009do cui@print((n $ int).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ float).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit64).toStr() ~ \"\\n\")\n\u0009\u0009do n :: 33\n\u0009\u0009do cui@print((n $ char).toStr() ~ \"\\n\")\n\u0009\u0009do n :: 0\n\u0009\u0009do cui@print((n $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do n :: 5\n\u0009\u0009do cui@print((n $ bool).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print((65537.5 $ int).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((65537.5 $ float).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((65537.5 $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((65537.5 $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((65537.5 $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((65537.5 $ bit64).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: float :: 65537.5\n\u0009\u0009do cui@print((n $ int).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ float).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit64).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print((\'A\' $ int).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((\'A\' $ char).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((\'A\' $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((\'A\' $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((\'A\' $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((\'A\' $ bit64).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: char :: \'A\'\n\u0009\u0009do cui@print((n $ int).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ char).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit64).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print((false $ int).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((false $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((false $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((false $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((false $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((false $ bit64).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((true $ int).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((true $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((true $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((true $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((true $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((true $ bit64).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: bool :: false\n\u0009\u0009var m: bool :: true\n\u0009\u0009do cui@print((n $ int).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit64).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((m $ int).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((m $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((m $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((m $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((m $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((m $ bit64).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print((255b8 $ int).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b8 $ float).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((33b8 $ char).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((0b8 $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((5b8 $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b8 $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b8 $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b8 $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b8 $ bit64).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: bit8 :: 255b8\n\u0009\u0009var m: bit8 :: 33b8\n\u0009\u0009var f: bit8 :: 0b8\n\u0009\u0009var t: bit8 :: 5b8\n\u0009\u0009do cui@print((n $ int).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ float).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((m $ char).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((f $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((t $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit64).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print((255b16 $ int).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b16 $ float).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((33b16 $ char).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((0b16 $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((5b16 $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b16 $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b16 $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b16 $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b16 $ bit64).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: bit16 :: 255b16\n\u0009\u0009var m: bit16 :: 33b16\n\u0009\u0009var f: bit16 :: 0b16\n\u0009\u0009var t: bit16 :: 5b16\n\u0009\u0009do cui@print((n $ int).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ float).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((m $ char).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((f $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((t $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit64).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print((255b32 $ int).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b32 $ float).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((33b32 $ char).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((0b32 $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((5b32 $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b32 $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b32 $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b32 $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b32 $ bit64).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: bit32 :: 255b32\n\u0009\u0009var m: bit32 :: 33b32\n\u0009\u0009var f: bit32 :: 0b32\n\u0009\u0009var t: bit32 :: 5b32\n\u0009\u0009do cui@print((n $ int).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ float).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((m $ char).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((f $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((t $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit64).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print((255b64 $ int).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b64 $ float).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((33b64 $ char).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((0b64 $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((5b64 $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b64 $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b64 $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b64 $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((255b64 $ bit64).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: bit64 :: 255b64\n\u0009\u0009var m: bit64 :: 33b64\n\u0009\u0009var f: bit64 :: 0b64\n\u0009\u0009var t: bit64 :: 5b64\n\u0009\u0009do cui@print((n $ int).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ float).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((m $ char).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((f $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((t $ bool).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((n $ bit64).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print(@s ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var a: [][]char :: [\"ab\", \"cd\", \"ef\"]\n\u0009\u0009do cui@print(a[0] ~ \", \" ~ a[1] ~ \", \" ~ a[2] ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009func f(n: int): int\n\u0009\u0009\u0009ret n = 0 ?(1, n * f(n - 1))\n\u0009\u0009end func\n\u0009\u0009\n\u0009\u0009do cui@print(f(5).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009func g(n: [][]char, m: [][]char): [][]char\n\u0009\u0009\u0009ret[n[0], m[0]]\n\u0009\u0009end func\n\u0009\u0009\n\u0009\u0009var s: [][]char :: [\"ab\", \"cd\"]\n\u0009\u0009var t: [][]char :: [\"ef\", \"gh\"]\n\u0009\u0009var u: [][]char :: g(s, t)\n\u0009\u0009do cui@print((^u).toStr() ~ \", \" ~ u[0] ~ \", \" ~ u[1] ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009for i(1, 5, 2)\n\u0009\u0009for j(i, 1, -2)\n\u0009\u0009\u0009do cui@print(i.toStr() ~ \", \" ~ j.toStr() ~ \"\\n\")\n\u0009\u0009end for\n\u0009end for\n\u0009\n\u0009block\n\u0009\u0009var i: int :: 1\n\u0009\u0009while(i <= 5)\n\u0009\u0009\u0009var j: int :: i\n\u0009\u0009\u0009while(j >= 1)\n\u0009\u0009\u0009\u0009do cui@print(i.toStr() ~ \", \" ~ j.toStr() ~ \"\\n\")\n\u0009\u0009\u0009\u0009do j :- 2\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do i :+ 2\n\u0009\u0009end while\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var i: int :: 1\n\u0009\u0009while(i % 2 = 0, skip)\n\u0009\u0009\u0009do cui@print(i.toStr() ~ \"\\n\")\n\u0009\u0009\u0009do i :+ 1\n\u0009\u0009end while\n\u0009end block\n\u0009\n\u0009for i(1, 15)\n\u0009\u0009if(i % 3 = 0 & i % 5 = 0)\n\u0009\u0009\u0009do cui@print(\"FizzBuzz\" ~ \"\\n\")\n\u0009\u0009elif(i % 3 = 0)\n\u0009\u0009\u0009do cui@print(\"Fizz\" ~ \"\\n\")\n\u0009\u0009elif(i % 5 = 0)\n\u0009\u0009\u0009do cui@print(\"Buzz\" ~ \"\\n\")\n\u0009\u0009else\n\u0009\u0009\u0009do cui@print(i.toStr() ~ \"\\n\")\n\u0009\u0009end if\n\u0009end for\n\u0009\n\u0009for i(1, 10)\n\u0009\u0009switch n(i)\n\u0009\u0009case 2, 6 to 7\n\u0009\u0009\u0009do cui@print(\"abc\" ~ \"\\n\")\n\u0009\u0009case 4 to 6, 9\n\u0009\u0009\u0009do cui@print(\"def\" ~ \"\\n\")\n\u0009\u0009default\n\u0009\u0009\u0009do cui@print(n.toStr() ~ \"\\n\")\n\u0009\u0009end switch\n\u0009end for\n\u0009\n\u0009for i(1, 10)\n\u0009\u0009switch n(i $ float)\n\u0009\u0009case 2.0, 6.0 to 7.0\n\u0009\u0009\u0009do cui@print(\"abc\" ~ \"\\n\")\n\u0009\u0009case 4.0 to 6.0, 9.0\n\u0009\u0009\u0009do cui@print(\"def\" ~ \"\\n\")\n\u0009\u0009default\n\u0009\u0009\u0009do cui@print(n.toStr() ~ \"\\n\")\n\u0009\u0009end switch\n\u0009end for\n\u0009\n\u0009for i(1, 10)\n\u0009\u0009switch n(i $ bit8)\n\u0009\u0009case 2b8, 6b8 to 7b8\n\u0009\u0009\u0009do cui@print(\"abc\" ~ \"\\n\")\n\u0009\u0009case 4b8 to 6b8, 9b8\n\u0009\u0009\u0009do cui@print(\"def\" ~ \"\\n\")\n\u0009\u0009default\n\u0009\u0009\u0009do cui@print(n.toStr() ~ \"\\n\")\n\u0009\u0009end switch\n\u0009end for\n\u0009\n\u0009for i(1, 10)\n\u0009\u0009switch n(i $ bit16)\n\u0009\u0009case 2b16, 6b16 to 7b16\n\u0009\u0009\u0009do cui@print(\"abc\" ~ \"\\n\")\n\u0009\u0009case 4b16 to 6b16, 9b16\n\u0009\u0009\u0009do cui@print(\"def\" ~ \"\\n\")\n\u0009\u0009default\n\u0009\u0009\u0009do cui@print(n.toStr() ~ \"\\n\")\n\u0009\u0009end switch\n\u0009end for\n\u0009\n\u0009for i(1, 10)\n\u0009\u0009switch n(i $ bit32)\n\u0009\u0009case 2b32, 6b32 to 7b32\n\u0009\u0009\u0009do cui@print(\"abc\" ~ \"\\n\")\n\u0009\u0009case 4b32 to 6b32, 9b32\n\u0009\u0009\u0009do cui@print(\"def\" ~ \"\\n\")\n\u0009\u0009default\n\u0009\u0009\u0009do cui@print(n.toStr() ~ \"\\n\")\n\u0009\u0009end switch\n\u0009end for\n\u0009\n\u0009for i(1, 10)\n\u0009\u0009switch n(i $ bit64)\n\u0009\u0009case 2b64, 6b64 to 7b64\n\u0009\u0009\u0009do cui@print(\"abc\" ~ \"\\n\")\n\u0009\u0009case 4b64 to 6b64, 9b64\n\u0009\u0009\u0009do cui@print(\"def\" ~ \"\\n\")\n\u0009\u0009default\n\u0009\u0009\u0009do cui@print(n.toStr() ~ \"\\n\")\n\u0009\u0009end switch\n\u0009end for\n\u0009\n\u0009for i(1, 10)\n\u0009\u0009switch n((\'A\' $ int + i) $ char)\n\u0009\u0009case \'C\', \'E\' to \'F\'\n\u0009\u0009\u0009do cui@print(\"abc\" ~ \"\\n\")\n\u0009\u0009case \'F\' to \'H\', \'J\'\n\u0009\u0009\u0009do cui@print(\"def\" ~ \"\\n\")\n\u0009\u0009default\n\u0009\u0009\u0009do cui@print(n.toStr() ~ \"\\n\")\n\u0009\u0009end switch\n\u0009end for\n\u0009\n\u0009for i(1, 10)\n\u0009\u0009switch n(i.toStr())\n\u0009\u0009case \"2\", \"6\" to \"7\"\n\u0009\u0009\u0009do cui@print(\"abc\" ~ \"\\n\")\n\u0009\u0009case \"4\" to \"6\", \"9\"\n\u0009\u0009\u0009do cui@print(\"def\" ~ \"\\n\")\n\u0009\u0009default\n\u0009\u0009\u0009do cui@print(n ~ \"\\n\")\n\u0009\u0009end switch\n\u0009end for\n\u0009\n\u0009block\n\u0009\u0009for i(1, 10)\n\u0009\u0009\u0009for j(1, 10)\n\u0009\u0009\u0009\u0009if(i = 2)\n\u0009\u0009\u0009\u0009\u0009skip i\n\u0009\u0009\u0009\u0009elif(i = 4)\n\u0009\u0009\u0009\u0009\u0009break i\n\u0009\u0009\u0009\u0009elif(j = 3)\n\u0009\u0009\u0009\u0009\u0009skip j\n\u0009\u0009\u0009\u0009elif(j = 5)\n\u0009\u0009\u0009\u0009\u0009break j\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do cui@print(i.toStr() ~ \", \" ~ j.toStr() ~ \"\\n\")\n\u0009\u0009\u0009end for\n\u0009\u0009end for\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009const n: int :: 5\n\u0009\u0009do cui@print(n.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009enum A\n\u0009\u0009\u0009a\n\u0009\u0009\u0009b\n\u0009\u0009\u0009c :: 5\n\u0009\u0009\u0009d\n\u0009\u0009\u0009e :: -2\n\u0009\u0009\u0009f\n\u0009\u0009end enum\n\u0009\u0009enum B\n\u0009\u0009\u0009a :: -1\n\u0009\u0009end enum\n\u0009\u0009block\n\u0009\u0009\u0009do cui@print((%a $ A $ int).toStr() ~ \"\\n\")\n\u0009\u0009\u0009do cui@print((%b $ A $ int).toStr() ~ \"\\n\")\n\u0009\u0009\u0009do cui@print((%c $ A $ int).toStr() ~ \"\\n\")\n\u0009\u0009\u0009do cui@print((%d $ A $ int).toStr() ~ \"\\n\")\n\u0009\u0009\u0009do cui@print((%e $ A $ int).toStr() ~ \"\\n\")\n\u0009\u0009\u0009do cui@print((%f $ A $ int).toStr() ~ \"\\n\")\n\u0009\u0009\u0009do cui@print((%e $ A $ bit8).toStr() ~ \"\\n\")\n\u0009\u0009\u0009do cui@print((%e $ A $ bit16).toStr() ~ \"\\n\")\n\u0009\u0009\u0009do cui@print((%e $ A $ bit32).toStr() ~ \"\\n\")\n\u0009\u0009\u0009do cui@print((%e $ A $ bit64).toStr() ~ \"\\n\")\n\u0009\u0009\u0009var n: A\n\u0009\u0009\u0009do n :: %a $ B $ A\n\u0009\u0009\u0009do cui@print((n $ int).toStr() ~ \", \" ~ (n = %f).toStr() ~ \", \" ~ (n <> %f).toStr() ~ \", \" ~ (n < %e).toStr() ~ \", \" ~ (n > %e).toStr() ~ \"\\n\")\n\u0009\u0009\u0009do n :: 1234 $ A\n\u0009\u0009\u0009do cui@print((n $ int).toStr() ~ \"\\n\")\n\u0009\u0009\u0009do n :: 0xFFb8 $ A\n\u0009\u0009\u0009do cui@print((n $ int).toStr() ~ \"\\n\")\n\u0009\u0009\u0009do n :: 0xFFb16 $ A\n\u0009\u0009\u0009do cui@print((n $ int).toStr() ~ \"\\n\")\n\u0009\u0009\u0009do n :: 0xFFb32 $ A\n\u0009\u0009\u0009do cui@print((n $ int).toStr() ~ \"\\n\")\n\u0009\u0009\u0009do n :: 0xFFb64 $ A\n\u0009\u0009\u0009do cui@print((n $ int).toStr() ~ \"\\n\")\n\u0009\u0009end block\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009class A()\n\u0009\u0009end class\n\u0009\u0009\n\u0009\u0009class B()\n\u0009\u0009end class\n\u0009\u0009\n\u0009\u0009var a: A :: #A\n\u0009\u0009var b: B :: #B\n\u0009\u0009do cui@print((a =$ kuin@Class).toStr() ~ \", \" ~ (b =$ kuin@Class).toStr() ~ \", \" ~ (a =$ A).toStr() ~ \", \" ~ (b =$ B).toStr() ~ \", \" ~ (a =$ B).toStr() ~ \", \" ~ (b =$ A).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((a <>$ kuin@Class).toStr() ~ \", \" ~ (b <>$ kuin@Class).toStr() ~ \", \" ~ (a <>$ A).toStr() ~ \", \" ~ (b <>$ B).toStr() ~ \", \" ~ (a <>$ B).toStr() ~ \", \" ~ (b <>$ A).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009class A()\n\u0009\u0009\u0009var a: int\n\u0009\u0009\u0009\n\u0009\u0009\u0009*func ctor()\n\u0009\u0009\u0009\u0009do me.a :: 5\n\u0009\u0009\u0009end func\n\u0009\u0009\u0009\n\u0009\u0009\u0009+func f(): int\n\u0009\u0009\u0009\u0009ret me.a\n\u0009\u0009\u0009end func\n\u0009\u0009end class\n\u0009\u0009\n\u0009\u0009class B(A)\n\u0009\u0009\u0009+*func f(): int\n\u0009\u0009\u0009\u0009ret 1234\n\u0009\u0009\u0009end func\n\u0009\u0009end class\n\u0009\u0009\n\u0009\u0009do cui@print((#A).f().toStr() ~ \", \" ~ (#B).f().toStr() ~ \"\\n\")\n\u0009\u0009var a: A :: #A\n\u0009\u0009var b: A :: #B\n\u0009\u0009do cui@print(a.f().toStr() ~ \", \" ~ b.f().toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var ns: list<int> :: #list<int>\n\u0009\u0009do ns.add(1)\n\u0009\u0009do ns.add(2)\n\u0009\u0009do ns.add(3)\n\u0009\u0009do ns.head()\n\u0009\u0009do ns.ins(4)\n\u0009\u0009do ns.ins(5)\n\u0009\u0009do ns.tail()\n\u0009\u0009do ns.ins(6)\n\u0009\u0009do ns.ins(7)\n\u0009\u0009do ns.head()\n\u0009\u0009while(!ns.term())\n\u0009\u0009\u0009do cui@print(ns.get().toStr() ~ \"\\n\")\n\u0009\u0009\u0009do ns.next()\n\u0009\u0009end while\n\u0009\u0009do ns.head()\n\u0009\u0009do ns.del()\n\u0009\u0009do ns.tail()\n\u0009\u0009do ns.del()\n\u0009\u0009do cui@print((^ns).toStr() ~ \"\\n\")\n\u0009\u0009do ns.head()\n\u0009\u0009while(!ns.term())\n\u0009\u0009\u0009do cui@print(ns.get().toStr() ~ \"\\n\")\n\u0009\u0009\u0009do ns.next()\n\u0009\u0009end while\n\u0009\u0009\n\u0009\u0009var ss: list<[]char> :: #list<[]char>\n\u0009\u0009do ss.add(\"ab\")\n\u0009\u0009do ss.add(\"cd\")\n\u0009\u0009do ss.add(\"ef\")\n\u0009\u0009do ss.head()\n\u0009\u0009do ss.ins(\"gh\")\n\u0009\u0009do ss.ins(\"ij\")\n\u0009\u0009do ss.tail()\n\u0009\u0009do ss.ins(\"kl\")\n\u0009\u0009do ss.ins(\"mn\")\n\u0009\u0009do ss.tail()\n\u0009\u0009while(!ss.term())\n\u0009\u0009\u0009do cui@print(ss.get() ~ \"\\n\")\n\u0009\u0009\u0009do ss.prev()\n\u0009\u0009end while\n\u0009\u0009do ss.head()\n\u0009\u0009do ss.del()\n\u0009\u0009do ss.tail()\n\u0009\u0009do ss.del()\n\u0009\u0009do cui@print((^ss).toStr() ~ \"\\n\")\n\u0009\u0009while(!ss.term())\n\u0009\u0009\u0009do cui@print(ss.get() ~ \"\\n\")\n\u0009\u0009\u0009do ss.prev()\n\u0009\u0009end while\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var ns: stack<int> :: #stack<int>\n\u0009\u0009do ns.add(1)\n\u0009\u0009do ns.add(2)\n\u0009\u0009do ns.add(3)\n\u0009\u0009do ns.add(4)\n\u0009\u0009do ns.add(5)\n\u0009\u0009do cui@print(ns.peek().toStr() ~ \"\\n\")\n\u0009\u0009while(^ns <> 0)\n\u0009\u0009\u0009do cui@print(ns.get().toStr() ~ \"\\n\")\n\u0009\u0009end while\n\u0009\u0009do ns.add(0)\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var ns: stack<[]char> :: #stack<[]char>\n\u0009\u0009do ns.add(\"a\")\n\u0009\u0009do ns.add(\"b\")\n\u0009\u0009do ns.add(\"c\")\n\u0009\u0009do ns.add(\"d\")\n\u0009\u0009do ns.add(\"e\")\n\u0009\u0009do cui@print(ns.peek() ~ \"\\n\")\n\u0009\u0009while(^ns <> 0)\n\u0009\u0009\u0009do cui@print(ns.get() ~ \"\\n\")\n\u0009\u0009end while\n\u0009\u0009do ns.add(\"f\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var ns: queue<int> :: #queue<int>\n\u0009\u0009do ns.add(1)\n\u0009\u0009do ns.add(2)\n\u0009\u0009do ns.add(3)\n\u0009\u0009do ns.add(4)\n\u0009\u0009do ns.add(5)\n\u0009\u0009do cui@print(ns.peek().toStr() ~ \"\\n\")\n\u0009\u0009while(^ns <> 0)\n\u0009\u0009\u0009do cui@print(ns.get().toStr() ~ \"\\n\")\n\u0009\u0009end while\n\u0009\u0009do ns.add(0)\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var ns: queue<[]char> :: #queue<[]char>\n\u0009\u0009do ns.add(\"a\")\n\u0009\u0009do ns.add(\"b\")\n\u0009\u0009do ns.add(\"c\")\n\u0009\u0009do ns.add(\"d\")\n\u0009\u0009do ns.add(\"e\")\n\u0009\u0009do cui@print(ns.peek() ~ \"\\n\")\n\u0009\u0009while(^ns <> 0)\n\u0009\u0009\u0009do cui@print(ns.get() ~ \"\\n\")\n\u0009\u0009end while\n\u0009\u0009do ns.add(\"f\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: dict<int, int> :: #dict<int, int>\n\u0009\u0009do n.add(6, 16)\n\u0009\u0009do n.add(8, 18)\n\u0009\u0009do n.add(10, 20)\n\u0009\u0009do n.add(4, 14)\n\u0009\u0009do n.add(2, 12)\n\u0009\u0009do n.add(3, 13)\n\u0009\u0009do n.add(7, 17)\n\u0009\u0009do n.add(1, 11)\n\u0009\u0009do n.add(9, 19)\n\u0009\u0009do cui@print((^n).toStr() ~ \"\\n\")\n\u0009\u0009for i(0, 11)\n\u0009\u0009\u0009var existed: bool\n\u0009\u0009\u0009do cui@print(n.get(i, &existed).toStr() ~ \"\\n\")\n\u0009\u0009\u0009if(!existed)\n\u0009\u0009\u0009\u0009do cui@print(\"Not existed.\" ~ \"\\n\")\n\u0009\u0009\u0009end if\n\u0009\u0009end for\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: dict<int, []char> :: #dict<int, []char>\n\u0009\u0009do n.add(6, \"f\")\n\u0009\u0009do n.add(8, \"h\")\n\u0009\u0009do n.add(10, \"j\")\n\u0009\u0009do n.add(4, \"d\")\n\u0009\u0009do n.add(2, \"b\")\n\u0009\u0009do n.add(3, \"c\")\n\u0009\u0009do n.add(7, \"g\")\n\u0009\u0009do n.add(1, \"a\")\n\u0009\u0009do n.add(9, \"i\")\n\u0009\u0009do cui@print((^n).toStr() ~ \"\\n\")\n\u0009\u0009for i(0, 11)\n\u0009\u0009\u0009var existed: bool\n\u0009\u0009\u0009do cui@print(n.get(i, &existed))\n\u0009\u0009\u0009do cui@print(\"\\n\")\n\u0009\u0009\u0009if(!existed)\n\u0009\u0009\u0009\u0009do cui@print(\"Not existed.\" ~ \"\\n\")\n\u0009\u0009\u0009end if\n\u0009\u0009end for\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: dict<[]char, int> :: #dict<[]char, int>\n\u0009\u0009do n.add(\"f\", 6)\n\u0009\u0009do n.add(\"h\", 8)\n\u0009\u0009do n.add(\"j\", 10)\n\u0009\u0009do n.add(\"d\", 4)\n\u0009\u0009do n.add(\"b\", 2)\n\u0009\u0009do n.add(\"c\", 3)\n\u0009\u0009do n.add(\"g\", 7)\n\u0009\u0009do n.add(\"a\", 1)\n\u0009\u0009do n.add(\"i\", 9)\n\u0009\u0009do cui@print((^n).toStr() ~ \"\\n\")\n\u0009\u0009for i(0, 11)\n\u0009\u0009\u0009var existed: bool\n\u0009\u0009\u0009do cui@print(n.get(((\'a\' $ int + i - 1) $ char).toStr(), &existed).toStr() ~ \"\\n\")\n\u0009\u0009\u0009if(!existed)\n\u0009\u0009\u0009\u0009do cui@print(\"Not existed.\" ~ \"\\n\")\n\u0009\u0009\u0009end if\n\u0009\u0009end for\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: dict<[]char, []char> :: #dict<[]char, []char>\n\u0009\u0009do n.add(\"f\", \"F\")\n\u0009\u0009do n.add(\"h\", \"H\")\n\u0009\u0009do n.add(\"j\", \"J\")\n\u0009\u0009do n.add(\"d\", \"D\")\n\u0009\u0009do n.add(\"b\", \"B\")\n\u0009\u0009do n.add(\"c\", \"C\")\n\u0009\u0009do n.add(\"g\", \"G\")\n\u0009\u0009do n.add(\"a\", \"A\")\n\u0009\u0009do n.add(\"i\", \"I\")\n\u0009\u0009do cui@print((^n).toStr() ~ \"\\n\")\n\u0009\u0009for i(0, 11)\n\u0009\u0009\u0009var existed: bool\n\u0009\u0009\u0009do cui@print(n.get(((\'a\' $ int + i - 1) $ char).toStr(), &existed))\n\u0009\u0009\u0009do cui@print(\"\\n\")\n\u0009\u0009\u0009if(!existed)\n\u0009\u0009\u0009\u0009do cui@print(\"Not existed.\" ~ \"\\n\")\n\u0009\u0009\u0009end if\n\u0009\u0009end for\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: [][]char :: [\"abc\", \"def\"]\n\u0009\u0009var m: [][]char :: ##n\n\u0009\u0009do cui@print((n[0] = m[0]).toStr() ~ \", \" ~ (n[0] =& m[0]).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: list<list<int>> :: #list<list<int>>\n\u0009\u0009var n2: list<int> :: #list<int>\n\u0009\u0009do n2.add(3)\n\u0009\u0009do n2.add(5)\n\u0009\u0009do n.add(n2)\n\u0009\u0009var m: list<list<int>> :: ##n\n\u0009\u0009do n.head()\n\u0009\u0009do n.get().head()\n\u0009\u0009do m.head()\n\u0009\u0009do m.get().head()\n\u0009\u0009do cui@print(n.get().get().toStr() ~ \", \" ~ m.get().get().toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: stack<stack<int>> :: #stack<stack<int>>\n\u0009\u0009var n2: stack<int> :: #stack<int>\n\u0009\u0009do n2.add(3)\n\u0009\u0009do n2.add(5)\n\u0009\u0009do n.add(n2)\n\u0009\u0009var m: stack<stack<int>> :: ##n\n\u0009\u0009do cui@print(n.peek().get().toStr() ~ \", \" ~ m.peek().get().toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.get().get().toStr() ~ \", \" ~ m.get().get().toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: queue<queue<int>> :: #queue<queue<int>>\n\u0009\u0009var n2: queue<int> :: #queue<int>\n\u0009\u0009do n2.add(3)\n\u0009\u0009do n2.add(5)\n\u0009\u0009do n.add(n2)\n\u0009\u0009var m: queue<queue<int>> :: ##n\n\u0009\u0009do cui@print(n.peek().get().toStr() ~ \", \" ~ m.peek().get().toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.get().get().toStr() ~ \", \" ~ m.get().get().toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: dict<[]char, []char> :: #dict<[]char, []char>\n\u0009\u0009do n.add(\"a\", \"A\")\n\u0009\u0009do n.add(\"c\", \"C\")\n\u0009\u0009do n.add(\"b\", \"B\")\n\u0009\u0009var m: dict<[]char, []char> :: ##n\n\u0009\u0009do cui@print(n.get(\"a\", &) ~ n.get(\"b\", &) ~ n.get(\"c\", &) ~ \"\\n\")\n\u0009\u0009do cui@print(m.get(\"a\", &) ~ m.get(\"b\", &) ~ m.get(\"c\", &) ~ \"\\n\")\n\u0009\u0009do cui@print((n.get(\"a\", &) = m.get(\"a\", &)).toStr() ~ \", \" ~ (n.get(\"a\", &) =& m.get(\"a\", &)).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: bit8 :: 0xF6b8\n\u0009\u0009var m: bit8 :: 0x0Ab8\n\u0009\u0009do cui@print(n.or(m).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.and(m).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.xor(m).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.not().toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.shl(1).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.shr(1).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.sar(1).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: bit16 :: 0xF6F6b16\n\u0009\u0009var m: bit16 :: 0x0A0Ab16\n\u0009\u0009do cui@print(n.or(m).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.and(m).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.xor(m).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.not().toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.shl(1).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.shr(1).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.sar(1).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: bit32 :: 0xF6F6F6F6b32\n\u0009\u0009var m: bit32 :: 0x0A0A0A0Ab32\n\u0009\u0009do cui@print(n.or(m).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.and(m).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.xor(m).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.not().toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.shl(1).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.shr(1).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.sar(1).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: bit64 :: 0xF6F6F6F6F6F6F6F6b64\n\u0009\u0009var m: bit64 :: 0x0A0A0A0A0A0A0A0Ab64\n\u0009\u0009do cui@print(n.or(m).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.and(m).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.xor(m).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.not().toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.shl(1).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.shr(1).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(n.sar(1).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print(\"abcdeabcde\".find(\'d\', -1).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(\"abcdeabcde\".find(\'f\', -1).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(\"abcdeabcde\".findLast(\'d\', -1).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(\"abcdeabcde\".findLast(\'f\', -1).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009do cui@print(\"abcde\".sub(1, 3) ~ \"\\n\")\n\u0009\u0009do cui@print(\"abcde\".sub(1, -1) ~ \"\\n\")\n\u0009\u0009do cui@print([\"a\", \"b\", \"c\"].sub(1, 1)[0] ~ \"\\n\")\n\u0009\u0009do cui@print([\"a\", \"b\", \"c\"].sub(1, -1)[1] ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: []char :: \"This is a string value.\"\n\u0009\u0009var m: [][]char :: [\"AB\", \"CD\", \"EF\"]\n\u0009\u0009do n.reverse()\n\u0009\u0009do m.reverse()\n\u0009\u0009do cui@print(n ~ \"\\n\")\n\u0009\u0009do cui@print(m[0] ~ m[1] ~ m[2] ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: []char :: \"This is a string value.\"\n\u0009\u0009var m: [][]char :: [\"AB\", \"CD\", \"EF\"]\n\u0009\u0009do n.sort()\n\u0009\u0009do m.sort()\n\u0009\u0009do cui@print(n ~ \"\\n\")\n\u0009\u0009do cui@print(m[0] ~ m[1] ~ m[2] ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: []char :: \"This is a string value.\"\n\u0009\u0009var m: [][]char :: [\"AB\", \"CD\", \"EF\"]\n\u0009\u0009do n.sortDesc()\n\u0009\u0009do m.sortDesc()\n\u0009\u0009do cui@print(n ~ \"\\n\")\n\u0009\u0009do cui@print(m[0] ~ m[1] ~ m[2] ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print(lib@cos(lib@pi / 6.0).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(lib@sin(lib@pi / 6.0).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(lib@tan(lib@pi / 6.0).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(lib@sqrt(2.0).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(lib@exp(2.0).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(lib@ln(lib@e).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(lib@log(2.0, 8.0).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var x: float :: 10.0\n\u0009\u0009var y: float :: 1.0\n\u0009\u0009do lib@rot(&x, &y, 5.0, 1.0, lib@pi / 2.0)\n\u0009\u0009do cui@print(x.toStr() ~ \", \" ~ y.toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(lib@invRot(x, y, 5.0, 1.0).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(lib@dist(4.0, 5.0, 1.0, 1.0).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var x: float :: 5.0\n\u0009\u0009while(!lib@chase(&x, 10.0, 2.0))\n\u0009\u0009\u0009do cui@print(x.toStr() ~ \"\\n\")\n\u0009\u0009end while\n\u0009\u0009do cui@print(x.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var x: float :: 15.0\n\u0009\u0009while(!lib@chase(&x, 10.0, 2.0))\n\u0009\u0009\u0009do cui@print(x.toStr() ~ \"\\n\")\n\u0009\u0009end while\n\u0009\u0009do cui@print(x.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print(lib@floor(2.5).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(lib@floor(-2.5).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(lib@ceil(2.5).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(lib@ceil(-2.5).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(lib@round(5555.5555, 0).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(lib@round(-5555.5555, 0).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(lib@round(5555.5555, 2).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(lib@round(-5555.5555, 2).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(lib@round(5555.5555, -2).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(lib@round(-5555.5555, -2).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print(\"aBcDeF\".lower() ~ \"\\n\")\n\u0009\u0009do cui@print(\"aBcDeF\".upper() ~ \"\\n\")\n\u0009\u0009do cui@print(\"a\" ~ \"  bcd  \".trim() ~ \"e\" ~ \"\\n\")\n\u0009\u0009do cui@print(\"a\" ~ \"  bcd  \".trimLeft() ~ \"e\" ~ \"\\n\")\n\u0009\u0009do cui@print(\"a\" ~ \"  bcd  \".trimRight() ~ \"e\" ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009func f(a: int, b: &int, c: float, d: &float, e: &char): []char\n\u0009\u0009\u0009do b :: 5\n\u0009\u0009\u0009do d :: 3.5\n\u0009\u0009\u0009do e :: \'Z\'\n\u0009\u0009\u0009ret \"A\"\n\u0009\u0009end func\n\u0009\u0009\n\u0009\u0009var x: func<(int, &int, float, &float, &char): []char> :: f\n\u0009\u0009var a: int\n\u0009\u0009var b: float\n\u0009\u0009var c: char\n\u0009\u0009do cui@print(x(a, &a, b, &b, &c) ~ \", \" ~ a.toStr() ~ \", \" ~ b.toStr() ~ \", \" ~ c.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: float :: 0.0\n\u0009\u0009for(1, 10)\n\u0009\u0009\u0009do n :+ 0.1\n\u0009\u0009end for\n\u0009\u0009do cui@print((n = 1.0).toStr() ~ \", \" ~ lib@same(n, 1.0).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print(\'c\'.offset(1).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(\'c\'.offset(-1).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009class C()\n\u0009\u0009\u0009+var n: int\n\u0009\u0009\u0009\n\u0009\u0009\u0009+*func cmp(t: kuin@Class): int\n\u0009\u0009\u0009\u0009ret me.n - (t $ C).n\n\u0009\u0009\u0009end func\n\u0009\u0009end class\n\u0009\u0009\n\u0009\u0009var a: C :: #C\n\u0009\u0009do a.n :: 3\n\u0009\u0009var b: C :: #C\n\u0009\u0009do b.n :: 5\n\u0009\u0009var c: C :: #C\n\u0009\u0009do c.n :: 3\n\u0009\u0009do cui@print((a < b).toStr() ~ \", \" ~ (a > b).toStr() ~ \", \" ~ (a = b).toStr() ~ \", \" ~ (a <> b).toStr() ~ \"\\n\")\n\u0009\u0009do cui@print((a < c).toStr() ~ \", \" ~ (a > c).toStr() ~ \", \" ~ (a = c).toStr() ~ \", \" ~ (a <> c).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var d: []C :: [#C, #C, #C, #C]\n\u0009\u0009do d[0].n :: 7\n\u0009\u0009do d[1].n :: 3\n\u0009\u0009do d[2].n :: 5\n\u0009\u0009do d[3].n :: 4\n\u0009\u0009do d.sort()\n\u0009\u0009do cui@print(d[0].n.toStr() ~ \", \" ~ d[1].n.toStr() ~ \", \" ~ d[2].n.toStr() ~ \", \" ~ d[3].n.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009class C()\n\u0009\u0009\u0009+var i: int\n\u0009\u0009\u0009+var s: []char\n\u0009\u0009end class\n\u0009\u0009\n\u0009\u0009var a: C :: #C\n\u0009\u0009do a.i :: 5\n\u0009\u0009do a.s :: \"abc\"\n\u0009\u0009var b: C :: ##a\n\u0009\u0009do cui@print(b.i.toStr() ~ \", \" ~ (a.s = b.s).toStr() ~ \", \" ~ (a.s =& b.s).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: int :: 123456789012\n\u0009\u0009var m: int\n\u0009\u0009var bin: []bit8 :: n $> []bit8\n\u0009\u0009do @dump(bin)\n\u0009\u0009do m :: bin $< int\n\u0009\u0009do cui@print(m.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: float :: lib@pi\n\u0009\u0009var m: float\n\u0009\u0009var bin: []bit8 :: n $> []bit8\n\u0009\u0009do @dump(bin)\n\u0009\u0009do m :: bin $< float\n\u0009\u0009do cui@print(m.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: char :: \'X\'\n\u0009\u0009var m: char\n\u0009\u0009var bin: []bit8 :: n $> []bit8\n\u0009\u0009do @dump(bin)\n\u0009\u0009do m :: bin $< char\n\u0009\u0009do cui@print(m.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: bool :: true\n\u0009\u0009var m: bool\n\u0009\u0009var bin: []bit8 :: n $> []bit8\n\u0009\u0009do @dump(bin)\n\u0009\u0009do m :: bin $< bool\n\u0009\u0009do cui@print(m.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009\n\u0009block\n\u0009\u0009var n: bit8 :: 0x12b8\n\u0009\u0009var m: bit8\n\u0009\u0009var bin: []bit8 :: n $> []bit8\n\u0009\u0009do @dump(bin)\n\u0009\u0009do m :: bin $< bit8\n\u0009\u0009do cui@print(m.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: bit16 :: 0x1234b16\n\u0009\u0009var m: bit16\n\u0009\u0009var bin: []bit8 :: n $> []bit8\n\u0009\u0009do @dump(bin)\n\u0009\u0009do m :: bin $< bit16\n\u0009\u0009do cui@print(m.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: bit32 :: 0x12345678b32\n\u0009\u0009var m: bit32\n\u0009\u0009var bin: []bit8 :: n $> []bit8\n\u0009\u0009do @dump(bin)\n\u0009\u0009do m :: bin $< bit32\n\u0009\u0009do cui@print(m.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: bit64 :: 0xF012345678ABCDEFb64\n\u0009\u0009var m: bit64\n\u0009\u0009var bin: []bit8 :: n $> []bit8\n\u0009\u0009do @dump(bin)\n\u0009\u0009do m :: bin $< bit64\n\u0009\u0009do cui@print(m.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: []int :: [1, 2, 3]\n\u0009\u0009var m: []int\n\u0009\u0009var bin: []bit8 :: n $> []bit8\n\u0009\u0009do @dump(bin)\n\u0009\u0009do m :: bin $< []int\n\u0009\u0009do cui@print(m[0].toStr() ~ \", \" ~ m[1].toStr() ~ \", \" ~ m[2].toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: []char :: \"abcdef\"\n\u0009\u0009var m: []char\n\u0009\u0009var bin: []bit8 :: n $> []bit8\n\u0009\u0009do @dump(bin)\n\u0009\u0009do m :: bin $< []char\n\u0009\u0009do cui@print(m ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: [][]char :: [\"ab\", \"cd\", \"ef\"]\n\u0009\u0009var m: [][]char\n\u0009\u0009var bin: []bit8 :: n $> []bit8\n\u0009\u0009do @dump(bin)\n\u0009\u0009do m :: bin $< [][]char\n\u0009\u0009do cui@print(m[0] ~ \", \" ~ m[1] ~ \", \" ~ m[2] ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: list<char> :: #list<char>\n\u0009\u0009var m: list<char>\n\u0009\u0009do n.add(\'a\')\n\u0009\u0009do n.add(\'b\')\n\u0009\u0009do n.add(\'c\')\n\u0009\u0009var bin: []bit8 :: n $> []bit8\n\u0009\u0009do @dump(bin)\n\u0009\u0009do m :: bin $< list<char>\n\u0009\u0009do m.head()\n\u0009\u0009while(!m.term())\n\u0009\u0009\u0009do cui@print(m.get().toStr() ~ \"\\n\")\n\u0009\u0009\u0009do m.next()\n\u0009\u0009end while\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: stack<char> :: #stack<char>\n\u0009\u0009var m: stack<char>\n\u0009\u0009do n.add(\'a\')\n\u0009\u0009do n.add(\'b\')\n\u0009\u0009do n.add(\'c\')\n\u0009\u0009var bin: []bit8 :: n $> []bit8\n\u0009\u0009do @dump(bin)\n\u0009\u0009do m :: bin $< stack<char>\n\u0009\u0009while(^m <> 0)\n\u0009\u0009\u0009do cui@print(m.get().toStr() ~ \"\\n\")\n\u0009\u0009end while\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: queue<char> :: #queue<char>\n\u0009\u0009var m: queue<char>\n\u0009\u0009do n.add(\'a\')\n\u0009\u0009do n.add(\'b\')\n\u0009\u0009do n.add(\'c\')\n\u0009\u0009var bin: []bit8 :: n $> []bit8\n\u0009\u0009do @dump(bin)\n\u0009\u0009do m :: bin $< queue<char>\n\u0009\u0009while(^m <> 0)\n\u0009\u0009\u0009do cui@print(m.get().toStr() ~ \"\\n\")\n\u0009\u0009end while\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: dict<[]char, int> :: #dict<[]char, int>\n\u0009\u0009var m: dict<[]char, int>\n\u0009\u0009do n.add(\"a\", 1)\n\u0009\u0009do n.add(\"c\", 3)\n\u0009\u0009do n.add(\"b\", 2)\n\u0009\u0009var bin: []bit8 :: n $> []bit8\n\u0009\u0009do @dump(bin)\n\u0009\u0009do m :: bin $< dict<[]char, int>\n\u0009\u0009do cui@print(m.get(\"a\", &).toStr() ~ \", \" ~ m.get(\"b\", &).toStr() ~ \", \" ~ m.get(\"c\", &).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009enum E\n\u0009\u0009\u0009x :: 1234\n\u0009\u0009end enum\n\u0009\u0009\n\u0009\u0009var n: E :: %x\n\u0009\u0009var m: E\n\u0009\u0009var bin: []bit8 :: n $> []bit8\n\u0009\u0009do @dump(bin)\n\u0009\u0009do m :: bin $< E\n\u0009\u0009do cui@print((m $ int).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009class C()\n\u0009\u0009\u0009+var a: int\n\u0009\u0009\u0009+var b: []char\n\u0009\u0009end class\n\u0009\u0009\n\u0009\u0009var n: C :: #C\n\u0009\u0009var m: C :: #C\n\u0009\u0009do n.a :: 5\n\u0009\u0009do n.b :: \"abc\"\n\u0009\u0009var bin: []bit8 :: n $> []bit8\n\u0009\u0009do @dump(bin)\n\u0009\u0009do m :: bin $< C\n\u0009\u0009do cui@print(m.a.toStr() ~ \", \" ~ m.b ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009; Single line comment #3.\n\u0009\u0009; Single line comment #4.\n\u0009\u0009{\n\u0009\u0009\u0009\u0009{\n\u0009\u0009\u0009\u0009\u0009Nest comment.\n\u0009\u0009\u0009\u0009}\n\u0009\u0009\u0009}\n\u0009\u0009do cui@print\n\u0009\u0009|\n\u0009\u0009|(\n\u0009\u0009|\"Line breaking.\" ~ \"\\n\"\n\u0009\u0009|)\n\u0009\u0009\n\u0009\u0009;{\n\u0009\u0009do cui@print(\"Comment test #1.\" ~ \"\\n\")\n\u0009\u0009;}\n\u0009\u0009\n\u0009\u0009{\n\u0009\u0009\u0009;}\n\u0009\u0009\u0009\"}\"\n\u0009\u0009\u0009\'}\'\n\u0009\u0009\u0009do cui@print(\"Comment test #2.\" ~ \"\\n\")\n\u0009\u0009\u0009}\n\u0009\u0009\n\u0009\u0009{\n\u0009\u0009\u0009;{\n\u0009\u0009\u0009\"{\"\n\u0009\u0009\u0009\'{\'\n\u0009\u0009\u0009do cui@print(\"Comment test #3.\" ~ \"\\n\")\n\u0009\u0009\u0009}\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: []int :: #[3]int\n\u0009\u0009do a[0] :: 1\n\u0009\u0009do a[1] :: 2\n\u0009\u0009do a[2] :: 3\n\u0009\u0009do cui@print((^a).toStr() ~ \", \" ~ a[0].toStr() ~ \", \" ~ a[1].toStr() ~ \", \" ~ a[2].toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: [][][]char :: #[3, 2, 4]char\n\u0009\u0009do cui@print((^a).toStr() ~ \", \" ~ (^a[0]).toStr() ~ \", \" ~ (^a[0][0]).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var x: float :: 314159.0e-5\n\u0009\u0009do cui@print(x.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009alias t: int\n\u0009\u0009alias u: []char\n\u0009\u0009var a: t\n\u0009\u0009var b: u\n\u0009\u0009do a :: 5\n\u0009\u0009do b :: \"abc\"\n\u0009\u0009do cui@print(a.toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(b ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: list<int> :: #list<int>\n\u0009\u0009do n.add(3)\n\u0009\u0009do n.add(4)\n\u0009\u0009do n.add(5)\n\u0009\u0009var m: []int :: n.toArray()\n\u0009\u0009do cui@print((^m).toStr() ~ \", \" ~ m[0].toStr() ~ \", \" ~ m[1].toStr() ~ \", \" ~ m[2].toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var n: list<[]char> :: #list<[]char>\n\u0009\u0009do n.add(\"ab\")\n\u0009\u0009do n.add(\"cd\")\n\u0009\u0009do n.add(\"ef\")\n\u0009\u0009var m: [][]char :: n.toArray()\n\u0009\u0009do cui@print((^m).toStr() ~ \", \" ~ m[0] ~ \", \" ~ m[1] ~ \", \" ~ m[2] ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var s: []char :: \"abxxcdexxfxxxxg\"\n\u0009\u0009var ts: [][]char :: s.split(\"xx\")\n\u0009\u0009do cui@print((^ts).toStr() ~ \"\\n\")\n\u0009\u0009for i(0, ^ts - 1)\n\u0009\u0009\u0009do cui@print(ts[i] ~ \"\\n\")\n\u0009\u0009end for\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009do cui@print(\'\\u006E\'.toStr() ~ \"\\n\")\n\u0009\u0009do cui@print(\"00\\u0054\\u0065\\u0073\\u007400\" ~ \"\\n\")\n\u0009end block\nend func\n":true;
else if(p==="res/web/")
return f?null:true;
else if(p==="res/web/output.kn")
return f?"const classTableItemSize: int :: 2\n\nvar funcs: queue<\\ast@AstFunc>\nvar classes: queue<\\ast@AstClass>\n\nvar uniqueId: []char\nvar codes: list<[]char>\nvar tmpVars: list<@TmpVar>\nvar globalVars: list<\\ast@AstArg>\nvar localVars: list<\\ast@AstArg>\n\n+class WebInfo(\\ast@HasType)\n\u0009+var id: []char\n\u0009+var breakSkipLabel: []char\n\u0009+var alreadyWritten: bool\nend class\n\nclass TmpVar()\n\u0009+var identifier: []char\n\u0009+var type: \\ast@AstType\nend class\n\n+func output(entry: \\ast@AstFunc, resFiles: list<[]char>): bool\n\u0009do @funcs :: #queue<\\ast@AstFunc>\n\u0009do @funcs.add(entry)\n\u0009do @classes :: #queue<\\ast@AstClass>\n\u0009\n\u0009do @uniqueId :: \"a\"\n\u0009do @codes :: #list<[]char>\n\u0009do @tmpVars :: #list<@TmpVar>\n\u0009do @globalVars :: #list<\\ast@AstArg>\n\u0009do @localVars :: #list<\\ast@AstArg>\n\u0009\n\u0009while(^@funcs > 0 | ^@classes > 0)\n\u0009\u0009while(^@funcs > 0)\n\u0009\u0009\u0009var func_: \\ast@AstFunc :: @funcs.get()\n\u0009\u0009\u0009do @buildFunc(func_)\n\u0009\u0009end while\n\u0009\u0009while(^@classes > 0)\n\u0009\u0009\u0009var class_: \\ast@AstClass :: @classes.get()\n\u0009\u0009\u0009do @buildClass(class_)\n\u0009\u0009end while\n\u0009end while\n\u0009\n\u0009do @write(resFiles)\n\u0009\n\u0009ret true\nend func\n\nfunc buildFunc(ast: \\ast@AstFunc)\n\u0009var info: @WebInfo :: @getInfo(ast)\n\u0009if(info.alreadyWritten)\n\u0009\u0009ret\n\u0009end if\n\u0009do info.alreadyWritten :: true\n\u0009\n\u0009var arg: []char :: \"\"\n\u0009block\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstArg :: items.get()\n\u0009\u0009\u0009var info2: @WebInfo :: @getInfo(item)\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do arg :~ \",\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do arg :~ \"\\{info2.id}\"\n\u0009\u0009\u0009if(item.name <>& null)\n\u0009\u0009\u0009\u0009do arg :~ \" /*\\{item.name}*/\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009\n\u0009if(ast.name <>& null)\n\u0009\u0009do @codes.add(\"// \\{ast.name}\\n\")\n\u0009end if\n\u0009do @codes.add(\"function \\{info.id}(\\{arg}){\\n\")\n\u0009\n\u0009if(ast.funcOption.and(%raw) = %raw)\n\u0009\u0009if(^ast.funcAttr = 1)\n\u0009\u0009\u0009do ast.funcAttr.head()\n\u0009\u0009\u0009var hasMembers: bool :: false\n\u0009\u0009\u0009if(^ast.args > 0)\n\u0009\u0009\u0009\u0009do ast.args.head()\n\u0009\u0009\u0009\u0009var arg2: \\ast@AstArg :: ast.args.get()\n\u0009\u0009\u0009\u0009if(arg2.type.refItem <>& null & arg2.type.refItem.typeId = %class_)\n\u0009\u0009\u0009\u0009\u0009var members: list<\\ast@AstClassItem> :: (arg2.type.refItem $ \\ast@AstClass).items\n\u0009\u0009\u0009\u0009\u0009do \\web\\raw_funcs@write(@codes, ast.funcAttr.get(), ast.args, members)\n\u0009\u0009\u0009\u0009\u0009do hasMembers :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!hasMembers)\n\u0009\u0009\u0009\u0009do \\web\\raw_funcs@write(@codes, ast.funcAttr.get(), ast.args, null)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009end if\n\u0009else\n\u0009\u0009do @codes.tail()\n\u0009\u0009var localVarPos: int :: @codes.idx()\n\u0009\u0009\n\u0009\u0009do @buildStats(ast.stats)\n\u0009\u0009\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\n\u0009\u0009do @codes.head()\n\u0009\u0009do @codes.moveOffset(localVarPos)\n\u0009\u0009do @codes.next()\n\u0009\u0009do @localVars.head()\n\u0009\u0009while(!@localVars.term())\n\u0009\u0009\u0009var localVar: \\ast@AstArg :: @localVars.get()\n\u0009\u0009\u0009var info2: @WebInfo :: @getInfo(localVar)\n\u0009\u0009\u0009if(localVar.name =& null)\n\u0009\u0009\u0009\u0009do @codes.ins(\"let \\{info2.id};\\n\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.ins(\"let \\{info2.id}; // \\{localVar.name}\\n\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @localVars.del()\n\u0009\u0009end while\n\u0009\u0009do @tmpVars.head()\n\u0009\u0009while(!@tmpVars.term())\n\u0009\u0009\u0009var tmpVar: @TmpVar :: @tmpVars.get()\n\u0009\u0009\u0009do @codes.ins(\"let \\{tmpVar.identifier};\\n\")\n\u0009\u0009\u0009do @tmpVars.del()\n\u0009\u0009end while\n\u0009end if\nend func\n\nfunc buildClass(ast: \\ast@AstClass)\n\u0009var parentId: []char :: null\n\u0009if(ast.refItem <>& null)\n\u0009\u0009do parentId :: @refClass(ast.refItem $ \\ast@AstClass)\n\u0009end if\n\u0009if(parentId =& null)\n\u0009\u0009do parentId :: \"Object\"\n\u0009end if\n\u0009var info: @WebInfo :: @getInfo(ast)\n\u0009if(ast.name <>& null)\n\u0009\u0009do @codes.add(\"// \\{ast.name}\\n\")\n\u0009end if\n\u0009block\n\u0009\u0009var ctor: \\ast@AstFunc :: findFunc(ast, \"ctor\")\n\u0009\u0009do @codes.add(\"function \\{info.id}(){\\n\")\n\u0009\u0009do @codes.add(\"\\{parentId}.call(this);\\n\")\n\u0009\u0009if(ctor <>& null)\n\u0009\u0009\u0009var ctorInfo: @WebInfo :: @getInfo(ctor)\n\u0009\u0009\u0009do @codes.add(\"\\{ctorInfo.id}(this);\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009end block\n\u0009do @codes.add(\"\\{info.id}.prototype = Object.create(\\{parentId}.prototype);\\n\")\n\u0009block\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item.def.typeId = %func_)\n\u0009\u0009\u0009\u0009do @funcs.add(item.def $ \\ast@AstFunc)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009; TODO: Destructor.\n\u0009\n\u0009func findFunc(ast: \\ast@AstClass, name: []char): \\ast@AstFunc\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item.def.typeId = %func_ & item.def.name = name)\n\u0009\u0009\u0009\u0009ret item.def $ \\ast@AstFunc\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009ret null\n\u0009end func\nend func\n\nfunc buildStats(stats: list<\\ast@AstStat>)\n\u0009do stats.head()\n\u0009while(!stats.term())\n\u0009\u0009var stat: \\ast@AstStat :: stats.get()\n\u0009\u0009switch(stat.typeId)\n\u0009\u0009case %statIf\n\u0009\u0009\u0009do @buildIf(stat $ \\ast@AstStatIf)\n\u0009\u0009case %statSwitch\n\u0009\u0009\u0009do @buildSwitch(stat $ \\ast@AstStatSwitch)\n\u0009\u0009case %statWhile\n\u0009\u0009\u0009do @buildWhile(stat $ \\ast@AstStatWhile)\n\u0009\u0009case %statFor\n\u0009\u0009\u0009do @buildFor(stat $ \\ast@AstStatFor)\n\u0009\u0009case %statTry\n\u0009\u0009\u0009do @buildTry(stat $ \\ast@AstStatTry)\n\u0009\u0009case %statThrow\n\u0009\u0009\u0009do @buildThrow(stat $ \\ast@AstStatThrow)\n\u0009\u0009case %statBlock\n\u0009\u0009\u0009do @buildBlock(stat $ \\ast@AstStatBlock)\n\u0009\u0009case %statRet\n\u0009\u0009\u0009do @buildRet(stat $ \\ast@AstStatRet)\n\u0009\u0009case %statDo\n\u0009\u0009\u0009do @buildDo(stat $ \\ast@AstStatDo)\n\u0009\u0009case %statBreak\n\u0009\u0009\u0009do @buildBreak(stat $ \\ast@AstStat)\n\u0009\u0009case %statSkip\n\u0009\u0009\u0009do @buildSkip(stat $ \\ast@AstStat)\n\u0009\u0009case %statAssert\n\u0009\u0009\u0009do @buildAssert(stat $ \\ast@AstStatAssert)\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009do stats.next()\n\u0009end while\nend func\n\nfunc buildIf(ast: \\ast@AstStatIf)\n\u0009var infoMe: @WebInfo :: @getInfo(ast)\n\u0009if(ast.cond =& null)\n\u0009\u0009; Optimized code.\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:{\\n\")\n\u0009\u0009end if\n\u0009\u0009do @buildBlock(ast.statBlock)\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009end if\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009end if\n\u0009do @codes.add(\"if(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\"){\\n\")\n\u0009do @buildBlock(ast.statBlock)\n\u0009do @codes.add(\"}\\n\")\n\u0009block\n\u0009\u0009var items: list<\\ast@AstStatElIf> :: ast.elIfs\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatElIf :: items.get()\n\u0009\u0009\u0009do @codes.add(\"else if(\")\n\u0009\u0009\u0009do @buildExpr(item.cond)\n\u0009\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009\u0009do @buildBlock(item.statBlock)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009if(ast.elseStatBlock <>& null)\n\u0009\u0009do @codes.add(\"else{\\n\")\n\u0009\u0009do @buildBlock(ast.elseStatBlock)\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009end if\nend func\n\nfunc buildSwitch(ast: \\ast@AstStatSwitch)\n\u0009var infoMe: @WebInfo :: @getInfo(ast)\n\u0009var info: @WebInfo :: @getInfo(ast.blockVar)\n\u0009if(!info.alreadyWritten)\n\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009do @localVars.add(ast.blockVar)\n\u0009end if\n\u0009var useSwitch: bool :: false\n\u0009if chk(\\ast@isInt(ast.cond.type) | \\ast@isChar(ast.cond.type) | \\ast@isEnum(ast.cond.type) | ast.cond.type.typeId = %typeBit)\n\u0009\u0009do useSwitch :: true\n\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009if(exprs.expr0.typeId.and(%exprValue) <> %exprValue | exprs.expr1 <>& null)\n\u0009\u0009\u0009\u0009\u0009do useSwitch :: false\n\u0009\u0009\u0009\u0009\u0009break chk\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end if\n\u0009do @codes.add(\"\\{info.id}=\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\";\\n\")\n\u0009if(useSwitch)\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"switch(\\{info.id}){\\n\")\n\u0009\u0009block\n\u0009\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009\u0009assert exprs.expr1 =& null\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"case \")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\":\\n\")\n\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @buildBlock(item.statBlock)\n\u0009\u0009\u0009\u0009do @codes.add(\"break;\\n\")\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009if(ast.defaultStatBlock <>& null)\n\u0009\u0009\u0009do @codes.add(\"default:\\n\")\n\u0009\u0009\u0009do @buildBlock(ast.defaultStatBlock)\n\u0009\u0009\u0009do @codes.add(\"break;\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009else\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:{\\n\")\n\u0009\u0009end if\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009do @codes.add(\"if(\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"else if(\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009var first2: bool :: true\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009if(first2)\n\u0009\u0009\u0009\u0009\u0009do first2 :: false\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"||\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(exprs.expr1 =& null)\n\u0009\u0009\u0009\u0009\u0009if(\\ast@isStr(ast.cond.type))\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"\\{info.id}.S===(\")\n\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isRef(ast.cond.type))\n\u0009\u0009\u0009\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"cmp_(\\{info.id},(\")\n\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"))==0\")\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"\\{info.id}===(\")\n\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")<=\\{info.id}&&\\{info.id}<=(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr1)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009\u0009do @buildBlock(item.statBlock)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009if(ast.defaultStatBlock <>& null)\n\u0009\u0009\u0009if(^items = 0)\n\u0009\u0009\u0009\u0009do @codes.add(\"{\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"else{\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @buildBlock(ast.defaultStatBlock)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009end if\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009end if\n\u0009end if\nend func\n\nfunc buildWhile(ast: \\ast@AstStatWhile)\n\u0009var infoMe: @WebInfo :: @getInfo(ast)\n\u0009if(ast.cond =& null)\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"for(;;){\\n\")\n\u0009\u0009do @buildStats(ast.stats)\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009ret\n\u0009end if\n\u0009if(ast.skip_)\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"do{\\n\")\n\u0009\u0009do @buildStats(ast.stats)\n\u0009\u0009do @codes.add(\"}while(\")\n\u0009\u0009do @buildExpr(ast.cond)\n\u0009\u0009do @codes.add(\");\\n\")\n\u0009\u0009ret\n\u0009end if\n\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009end if\n\u0009do @codes.add(\"while(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\"){\\n\")\n\u0009do @buildStats(ast.stats)\n\u0009do @codes.add(\"}\\n\")\nend func\n\nfunc buildFor(ast: \\ast@AstStatFor)\n\u0009var infoMe: @WebInfo :: @getInfo(ast)\n\u0009var info: @WebInfo :: @getInfo(ast.blockVar)\n\u0009if(!info.alreadyWritten)\n\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009do @localVars.add(ast.blockVar)\n\u0009end if\n\u0009var endId: []char :: @addTmpVar(ast.cond.type)\n\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009end if\n\u0009do @codes.add(\"for(\\{info.id}=(\")\n\u0009do @buildExpr(ast.start)\n\u0009do @codes.add(\"),\\{endId}=(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\");\\{info.id}\")\n\u0009assert ast.step.typeId = %exprValuePrim & \\ast@isInt(ast.cond.type)\n\u0009var step: int :: (ast.step $ \\ast@AstExprValuePrim).value $ int\n\u0009if(step > 0)\n\u0009\u0009do @codes.add(\"<=\")\n\u0009else\n\u0009\u0009do @codes.add(\">=\")\n\u0009end if\n\u0009do @codes.add(\"\\{endId};\\{info.id}+=(\")\n\u0009do @buildExpr(ast.step)\n\u0009do @codes.add(\")){\\n\")\n\u0009do @buildStats(ast.stats)\n\u0009do @codes.add(\"}\\n\")\nend func\n\nfunc buildTry(ast: \\ast@AstStatTry)\n\u0009var infoMe: @WebInfo :: @getInfo(ast)\n\u0009var info: @WebInfo :: @getInfo(ast.blockVar)\n\u0009if(!info.alreadyWritten)\n\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009do @localVars.add(ast.blockVar)\n\u0009end if\n\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009end if\n\u0009do @codes.add(\"try{\\n\")\n\u0009do @buildBlock(ast.statBlock)\n\u0009do @codes.add(\"}catch(\\{info.id}){\\n\")\n\u0009block\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstStatCatch> :: ast.catches\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatCatch :: items.get()\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009do @codes.add(\"if(\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"else if(\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009var first2: bool :: true\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009if(first2)\n\u0009\u0009\u0009\u0009\u0009do first2 :: false\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"||\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(exprs.expr1 =& null)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"\\{info.id}===(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")<=\\{info.id}&&\\{info.id}<=(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr1)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009\u0009do @buildBlock(item.statBlock)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009if(first)\n\u0009\u0009\u0009do @codes.add(\"{\\n\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"else{\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"throw \\{info.id};\\n}\\n\")\n\u0009end block\n\u0009do @codes.add(\"}\\n\")\n\u0009if(ast.finallyStatBlock <>& null)\n\u0009\u0009do @codes.add(\"finally{\\n\")\n\u0009\u0009do @buildBlock(ast.finallyStatBlock)\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009end if\nend func\n\nfunc buildThrow(ast: \\ast@AstStatThrow)\n\u0009do @codes.add(\"throw \")\n\u0009do @buildExpr(ast.code)\n\u0009do @codes.add(\";\\n\")\nend func\n\nfunc buildBlock(ast: \\ast@AstStatBlock)\n\u0009var infoMe: @WebInfo :: @getInfo(ast)\n\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:{\\n\")\n\u0009end if\n\u0009do @buildStats(ast.stats)\n\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009end if\nend func\n\nfunc buildRet(ast: \\ast@AstStatRet)\n\u0009if(ast.value =& null)\n\u0009\u0009do @codes.add(\"return;\\n\")\n\u0009else\n\u0009\u0009do @codes.add(\"return \")\n\u0009\u0009do @buildExpr(ast.value)\n\u0009\u0009do @codes.add(\";\\n\")\n\u0009end if\nend func\n\nfunc buildDo(ast: \\ast@AstStatDo)\n\u0009do @buildExpr(ast.expr)\n\u0009do @codes.add(\";\\n\")\nend func\n\nfunc buildBreak(ast: \\ast@AstStat)\n\u0009assert ast.refItem.typeId.and(%statBreakable) = %statBreakable\n\u0009var info: @WebInfo :: @getInfo(ast.refItem)\n\u0009do @codes.add(\"break \\{info.breakSkipLabel};\\n\")\nend func\n\nfunc buildSkip(ast: \\ast@AstStat)\n\u0009assert ast.refItem.typeId.and(%statSkipable) = %statSkipable\n\u0009var info: @WebInfo :: @getInfo(ast.refItem)\n\u0009do @codes.add(\"continue \\{info.breakSkipLabel};\\n\")\nend func\n\nfunc buildAssert(ast: \\ast@AstStatAssert)\n\u0009do @codes.add(\"if(!(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\")){throw \\{excpt@dbgAssertFailed $ bit32};}\\n\")\nend func\n\nfunc buildExpr(ast: \\ast@AstExpr)\n\u0009switch(ast.typeId)\n\u0009case %expr1\n\u0009\u0009do @buildExpr1(ast $ \\ast@AstExpr1)\n\u0009case %expr2\n\u0009\u0009do @buildExpr2(ast $ \\ast@AstExpr2)\n\u0009case %expr3\n\u0009\u0009do @buildExpr3(ast $ \\ast@AstExpr3)\n\u0009case %exprNew\n\u0009\u0009do @buildExprNew(ast $ \\ast@AstExprNew)\n\u0009case %exprNewArray\n\u0009\u0009do @buildExprNewArray(ast $ \\ast@AstExprNewArray)\n\u0009case %exprAs\n\u0009\u0009do @buildExprAs(ast $ \\ast@AstExprAs)\n\u0009case %exprToBin\n\u0009\u0009do @buildExprToBin(ast $ \\ast@AstExprToBin)\n\u0009case %exprFromBin\n\u0009\u0009do @buildExprFromBin(ast $ \\ast@AstExprFromBin)\n\u0009case %exprCall\n\u0009\u0009do @buildExprCall(ast $ \\ast@AstExprCall)\n\u0009case %exprArray\n\u0009\u0009do @buildExprArray(ast $ \\ast@AstExprArray)\n\u0009case %exprDot\n\u0009\u0009do @buildExprDot(ast $ \\ast@AstExprDot)\n\u0009case %exprValue\n\u0009\u0009do @buildExprValue(ast $ \\ast@AstExprValue)\n\u0009case %exprValuePrim\n\u0009\u0009do @buildExprValuePrim(ast $ \\ast@AstExprValuePrim)\n\u0009case %exprValueStr\n\u0009\u0009do @buildExprValueStr(ast $ \\ast@AstExprValueStr)\n\u0009case %exprValueFloat\n\u0009\u0009do @buildExprValueFloat(ast $ \\ast@AstExprValueFloat)\n\u0009case %exprValueArray\n\u0009\u0009do @buildExprValueArray(ast $ \\ast@AstExprValueArray)\n\u0009case %exprRef\n\u0009\u0009do @buildExprRef(ast $ \\ast@AstExpr)\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExpr1(ast: \\ast@AstExpr1)\n\u0009assert ast.varKind <> %unknown\n\u0009switch(ast.kind)\n\u0009case %plus\n\u0009\u0009do @buildExpr(ast.child)\n\u0009case %minus\n\u0009\u0009do @codes.add(\"-(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %not\n\u0009\u0009do @codes.add(\"!(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %copy\n\u0009\u0009var typeId: []char :: @makeTypeId(ast.child.type)\n\u0009\u0009do @codes.add(\"C_(\\{typeId},(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\"))\")\n\u0009case %len\n\u0009\u0009var type: \\ast@AstType :: ast.child.type\n\u0009\u0009if(type.typeId = %typeGen)\n\u0009\u0009\u0009switch((type $ \\ast@AstTypeGen).kind)\n\u0009\u0009\u0009case %list_\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009do @codes.add(\").L\")\n\u0009\u0009\u0009case %stack_\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009do @codes.add(\").length\")\n\u0009\u0009\u0009case %queue_\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009do @codes.add(\").length\")\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009elif(type.typeId = %typeDict)\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009do @codes.add(\").size\")\n\u0009\u0009else\n\u0009\u0009\u0009assert type.typeId = %typeArray\n\u0009\u0009\u0009if(\\ast@isChar((type $ \\ast@AstTypeArray).itemType))\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009do @codes.add(\").S.length\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009do @codes.add(\").length\")\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExpr2(ast: \\ast@AstExpr2)\n\u0009assert ast.varKind <> %unknown\n\u0009var type: \\ast@AstType :: ast.children0.type\n\u0009switch(ast.kind)\n\u0009case %assign\n\u0009\u0009if(ast.children0.typeId = %exprArray & \\ast@isChar((ast.children0 $ \\ast@AstExprArray).type))\n\u0009\u0009\u0009var ast2: \\ast@AstExprArray :: ast.children0 $ \\ast@AstExprArray\n\u0009\u0009\u0009var tmpIdx: []char :: @addTmpVar(ast2.idx.type)\n\u0009\u0009\u0009var tmpChar: []char :: @addTmpVar(ast2.type)\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast2.var_)\n\u0009\u0009\u0009do @codes.add(\").S=(\\{tmpIdx}=(\")\n\u0009\u0009\u0009do @buildExpr(ast2.idx)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast2.var_)\n\u0009\u0009\u0009do @codes.add(\").S.slice(0,\\{tmpIdx})+String.fromCharCode(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")+(\")\n\u0009\u0009\u0009do @buildExpr(ast2.var_)\n\u0009\u0009\u0009do @codes.add(\").S.slice(\\{tmpIdx}+1))\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")=(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %or\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")||(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %and\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")&&(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %lt\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S<(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009elif(\\ast@isRef(type))\n\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))<0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")<(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %gt\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S>(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009elif(\\ast@isRef(type))\n\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))>0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")>(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %le\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S<=(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009elif(\\ast@isRef(type))\n\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))<=0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")<=(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %ge\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S>=(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009elif(\\ast@isRef(type))\n\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))>=0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")>=(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %eq\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S===(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009elif(\\ast@isRef(type))\n\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))==0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")===(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %nEq\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S!==(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009elif(\\ast@isRef(type))\n\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))!=0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")!==(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %eqRef\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")===(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %nEqRef\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")!==(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %cat\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"{S:(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S+(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S}\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").concat(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %add\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")+(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %sub\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")-(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %mul\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")*(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %div\n\u0009\u0009if(!\\ast@isFloat(type))\n\u0009\u0009\u0009do @codes.add(\"~~(\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")/(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009if(!\\ast@isFloat(type))\n\u0009\u0009\u0009do @codes.add(\"))\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %mod\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")%(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %pow\n\u0009\u0009do @codes.add(\"Math.pow((\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\"))\")\n\u0009case %swap\n\u0009\u0009var tmpVar: []char :: @addTmpVar(type)\n\u0009\u0009do @codes.add(\"\\{tmpVar}=(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")=(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")=(\\{tmpVar})\")\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExpr3(ast: \\ast@AstExpr3)\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"(\")\n\u0009do @buildExpr(ast.children0)\n\u0009do @codes.add(\")?(\")\n\u0009do @buildExpr(ast.children1)\n\u0009do @codes.add(\"):(\")\n\u0009do @buildExpr(ast.children2)\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprNew(ast: \\ast@AstExprNew)\n\u0009assert ast.varKind <> %unknown\n\u0009if(\\ast@isClass(ast.itemType))\n\u0009\u0009var class_: \\ast@AstClass :: ast.itemType.refItem $ \\ast@AstClass\n\u0009\u0009var id: []char :: @refClass(class_)\n\u0009\u0009do @codes.add(\"new \\{id}()\")\n\u0009else\n\u0009\u0009if(ast.itemType.typeId = %typeGen)\n\u0009\u0009\u0009var gen: \\ast@AstTypeGen :: ast.itemType $ \\ast@AstTypeGen\n\u0009\u0009\u0009switch(gen.kind)\n\u0009\u0009\u0009case %list_\n\u0009\u0009\u0009\u0009do @codes.add(\"{L:0,H:null,T:null,P:null}\")\n\u0009\u0009\u0009case %stack_\n\u0009\u0009\u0009\u0009do @codes.add(\"[]\")\n\u0009\u0009\u0009case %queue_\n\u0009\u0009\u0009\u0009do @codes.add(\"[]\")\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009else\n\u0009\u0009\u0009assert ast.itemType.typeId = %typeDict\n\u0009\u0009\u0009do @codes.add(\"new Map()\")\n\u0009\u0009end if\n\u0009end if\nend func\n\nfunc buildExprNewArray(ast: \\ast@AstExprNewArray)\n\u0009assert ast.varKind <> %unknown\n\u0009block\n\u0009\u0009var items: list<\\ast@AstExpr> :: ast.idces\n\u0009\u0009do items.head()\n\u0009\u0009if(\\ast@isChar(ast.itemType))\n\u0009\u0009\u0009if(^items = 1)\n\u0009\u0009\u0009\u0009do @codes.add(\"{S:\\\"\\\\0\\\".repeat(\")\n\u0009\u0009\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009\u0009\u0009do @codes.add(\")}\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"(function A_(n){if(n.length===1)return{S:\\\"\\\\0\\\".repeat(\\{@getDefaultValue(ast.itemType)})};else{let a=new Array(n[0]),m=n.shift(),i;for(i=0;i<n[0];i++)a[i]=A_(m);return a;}})([\")\n\u0009\u0009\u0009\u0009var first: bool :: true\n\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\",(\")\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @codes.add(\"])\")\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009if(^items = 1)\n\u0009\u0009\u0009\u0009do @codes.add(\"new Array(\")\n\u0009\u0009\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009\u0009\u0009do @codes.add(\").fill(\\{@getDefaultValue(ast.itemType)})\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"(function A_(n){if(n.length===1)return new Array(n[0]).fill(\\{@getDefaultValue(ast.itemType)})else{let a=new Array(n[0]),m=n.shift(),i;for(i=0;i<n[0];i++)a[i]=A_(m);return a}})([\")\n\u0009\u0009\u0009\u0009var first: bool :: true\n\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\",(\")\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @codes.add(\"])\")\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009end block\nend func\n\nfunc buildExprAs(ast: \\ast@AstExprAs)\n\u0009assert ast.varKind <> %unknown\n\u0009switch(ast.kind)\n\u0009case %as\n\u0009\u0009var t1: \\ast@AstType :: ast.child.type\n\u0009\u0009var t2: \\ast@AstType :: ast.childType\n\u0009\u0009if(\\ast@isClass(t1))\n\u0009\u0009\u0009assert \\ast@isClass(t2)\n\u0009\u0009\u0009do @refClass(t2.refItem $ \\ast@AstClass)\n\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009else\n\u0009\u0009\u0009if(t1.typeId = %typeBit | \\ast@isInt(t1) | \\ast@isChar(t1) | \\ast@isEnum(t1))\n\u0009\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2) | \\ast@isChar(t2) | \\ast@isEnum(t2) | \\ast@isFloat(t2))\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert \\ast@isBool(t2)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")!=0\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009elif(\\ast@isFloat(t1))\n\u0009\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2))\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"~~(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert \\ast@isFloat(t2)\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009assert \\ast@isBool(t1)\n\u0009\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2))\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")?1:0\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert \\ast@isBool(t2)\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009case %is\n\u0009\u0009do @refClass(ast.childType.refItem $ \\ast@AstClass)\n\u0009\u0009var info: @WebInfo :: @getInfo(ast.childType.refItem)\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")instanceof \\{info.id}\")\n\u0009case %nIs\n\u0009\u0009do @refClass(ast.childType.refItem $ \\ast@AstClass)\n\u0009\u0009var info: @WebInfo :: @getInfo(ast.childType.refItem)\n\u0009\u0009do @codes.add(\"!((\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")instanceof \\{info.id})\")\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExprToBin(ast: \\ast@AstExprToBin)\n\u0009; TODO:\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"toBin_(\")\n\u0009do @buildExpr(ast.child)\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprFromBin(ast: \\ast@AstExprFromBin)\n\u0009; TODO:\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"fromBin_((\")\n\u0009do @buildExpr(ast.child)\n\u0009do @codes.add(\"),(\")\n\u0009do @buildExpr(ast.offset)\n\u0009do @codes.add(\"))\")\nend func\n\nfunc buildExprCall(ast: \\ast@AstExprCall)\n\u0009assert ast.varKind <> %unknown\n\u0009var funcType: \\ast@AstTypeFunc :: ast.func_.type $ \\ast@AstTypeFunc\n\u0009var meTypeId: []char :: null\n\u0009if(funcType <>& null & funcType.funcOption.and(%any) = %any)\n\u0009\u0009var items: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009do meTypeId :: @makeTypeId(items.get().arg.type)\n\u0009end if\n\u0009var refNum: int :: 0\n\u0009block\n\u0009\u0009var items: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009if(items.get().refVar)\n\u0009\u0009\u0009\u0009do refNum :+ 1\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009var resultVar: []char :: null\n\u0009var refVar: [][]char :: null\n\u0009if(refNum > 0)\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009if(ast.type <>& null)\n\u0009\u0009\u0009do resultVar :: @addTmpVar(ast.type)\n\u0009\u0009\u0009do @codes.add(\"\\{resultVar}=\")\n\u0009\u0009end if\n\u0009\u0009do refVar :: #[refNum][]char\n\u0009end if\n\u0009do @codes.add(\"(\")\n\u0009do @buildExpr(ast.func_)\n\u0009do @codes.add(\")(\")\n\u0009block\n\u0009\u0009var idx: int :: 0\n\u0009\u0009var refCnt: int :: 0\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstExprCallArg :: items.get()\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\",(\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(meTypeId <>& null & idx = 1)\n\u0009\u0009\u0009\u0009do @codes.add(meTypeId)\n\u0009\u0009\u0009elif(item.refVar)\n\u0009\u0009\u0009\u0009do refVar[refCnt] :: @addTmpVar(item.arg.type)\n\u0009\u0009\u0009\u0009do @codes.add(\"\\{refVar[refCnt]}={$:(\")\n\u0009\u0009\u0009\u0009do @buildExpr(item.arg)\n\u0009\u0009\u0009\u0009do @codes.add(\")},\\{refVar[refCnt]}\")\n\u0009\u0009\u0009\u0009do refCnt :+ 1\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @buildExpr(item.arg)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do @codes.add(\")\")\n\u0009if(refNum > 0)\n\u0009\u0009block\n\u0009\u0009\u0009var idx: int :: 0\n\u0009\u0009\u0009var refCnt: int :: 0\n\u0009\u0009\u0009var items: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstExprCallArg :: items.get()\n\u0009\u0009\u0009\u0009if(meTypeId <>& null & idx = 1)\n\u0009\u0009\u0009\u0009\u0009; Do nothing.\n\u0009\u0009\u0009\u0009elif(item.refVar)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\",(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(item.arg)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")=\\{refVar[refCnt]}.$\")\n\u0009\u0009\u0009\u0009\u0009do refCnt :+ 1\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009if(ast.type <>& null)\n\u0009\u0009\u0009do @codes.add(\",\\{resultVar}\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\")\")\n\u0009end if\n\u0009\n\u0009block\n\u0009\u0009var type: \\ast@AstType :: ast.type\n\u0009\u0009if(type <>& null)\n\u0009\u0009\u0009if(\\ast@isClass(type))\n\u0009\u0009\u0009\u0009do @refClass(type.refItem $ \\ast@AstClass)\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009end block\nend func\n\nfunc buildExprArray(ast: \\ast@AstExprArray)\n\u0009assert ast.varKind <> %unknown\n\u0009if(\\ast@isChar(ast.type))\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.var_)\n\u0009\u0009do @codes.add(\").S.charCodeAt(\")\n\u0009\u0009do @buildExpr(ast.idx)\n\u0009\u0009do @codes.add(\")\")\n\u0009else\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.var_)\n\u0009\u0009do @codes.add(\")[\")\n\u0009\u0009do @buildExpr(ast.idx)\n\u0009\u0009do @codes.add(\"]\")\n\u0009end if\nend func\n\nfunc buildExprDot(ast: \\ast@AstExprDot)\n\u0009assert ast.varKind <> %unknown\n\u0009if(\\ast@isClass(ast.var_.type))\n\u0009\u0009var classItem: \\ast@AstClassItem :: ast.classItem\n\u0009\u0009assert classItem <>& null\n\u0009\u0009do @refClass(ast.var_.type.refItem $ \\ast@AstClass)\n\u0009\u0009var info: @WebInfo\n\u0009\u0009if(classItem.def.typeId = %var_)\n\u0009\u0009\u0009do info :: @getInfo((classItem.def $ \\ast@AstVar).arg)\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.var_)\n\u0009\u0009\u0009do @codes.add(\").\\{info.id}\")\n\u0009\u0009else\n\u0009\u0009\u0009assert classItem.def.typeId = %func_\n\u0009\u0009\u0009do info :: @getInfo(classItem.def)\n\u0009\u0009\u0009; \'ast.var_\' is calculated elsewhere.\n\u0009\u0009\u0009do @codes.add(\"\\{info.id}\")\n\u0009\u0009end if\n\u0009else\n\u0009\u0009assert ast.refItem.typeId = %exprRef\n\u0009\u0009do @buildExprRef(ast.refItem $ \\ast@AstExpr)\n\u0009end if\nend func\n\nfunc buildExprValue(ast: \\ast@AstExprValue)\n\u0009assert ast.type.typeId = %typeNull\n\u0009do @codes.add(\"null\")\nend func\n\nfunc buildExprValuePrim(ast: \\ast@AstExprValuePrim)\n\u0009var type: \\ast@AstType :: ast.type\n\u0009if(\\ast@isInt(type) | \\ast@isEnum(type))\n\u0009\u0009do @codes.add((ast.value $ int).toStr())\n\u0009elif(\\ast@isChar(type))\n\u0009\u0009do @codes.add((ast.value $ bit16).toStr())\n\u0009elif(\\ast@isBool(type))\n\u0009\u0009do @codes.add(ast.value = 0b64 ?(\"false\", \"true\"))\n\u0009elif(type.typeId = %typeBit)\n\u0009\u0009switch((type $ \\ast@AstTypeBit).size)\n\u0009\u0009case 1\n\u0009\u0009\u0009do @codes.add((ast.value $ bit8).toStr())\n\u0009\u0009case 2\n\u0009\u0009\u0009do @codes.add((ast.value $ bit16).toStr())\n\u0009\u0009case 4\n\u0009\u0009\u0009do @codes.add((ast.value $ bit32).toStr())\n\u0009\u0009case 8\n\u0009\u0009\u0009do @codes.add((ast.value $ bit64).toStr())\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009else\n\u0009\u0009assert false\n\u0009end if\nend func\n\nfunc buildExprValueStr(ast: \\ast@AstExprValueStr)\n\u0009var value: []char :: ast.value\n\u0009var s: []char :: \"{S:\\\"\"\n\u0009for i(0, ^value - 1)\n\u0009\u0009do s :~ @escapeChar(value[i])\n\u0009end for\n\u0009do s :~ \"\\\"}\"\n\u0009do @codes.add(s)\nend func\n\nfunc buildExprValueFloat(ast: \\ast@AstExprValueFloat)\n\u0009var value: []char :: ast.value.toStr()\n\u0009if(value = \"inf\")\n\u0009\u0009do @codes.add(\"Infinity\")\n\u0009else\n\u0009\u0009do @codes.add(value)\n\u0009end if\nend func\n\nfunc buildExprValueArray(ast: \\ast@AstExprValueArray)\n\u0009; Note that constant string values are handled by \'ExprValueStr\'.\n\u0009do @codes.add(\"[\")\n\u0009var first: bool :: true\n\u0009var items: list<\\ast@AstExpr> :: ast.values\n\u0009do items.head()\n\u0009while(!items.term())\n\u0009\u0009if(first)\n\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\",(\")\n\u0009\u0009end if\n\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009do @codes.add(\")\")\n\u0009\u0009do items.next()\n\u0009end while\n\u0009do @codes.add(\"]\")\nend func\n\nfunc buildExprRef(ast: \\ast@AstExpr)\n\u0009var ast2: \\ast@Ast :: ast.refItem\n\u0009var info: @WebInfo :: @getInfo(ast2)\n\u0009if(ast2.typeId = %func_)\n\u0009\u0009do @funcs.add(ast2 $ \\ast@AstFunc)\n\u0009\u0009do @codes.add(info.id)\n\u0009else\n\u0009\u0009assert ast2.typeId = %arg\n\u0009\u0009var arg: \\ast@AstArg :: ast2 $ \\ast@AstArg\n\u0009\u0009switch(arg.kind)\n\u0009\u0009case %global\n\u0009\u0009\u0009if(!info.alreadyWritten)\n\u0009\u0009\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009\u0009\u0009do @globalVars.add(arg)\n\u0009\u0009\u0009end if\n\u0009\u0009case %localArg\n\u0009\u0009\u0009; Do nothing.\n\u0009\u0009case %localVar\n\u0009\u0009\u0009if(!info.alreadyWritten)\n\u0009\u0009\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009\u0009\u0009do @localVars.add(arg)\n\u0009\u0009\u0009end if\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009if(arg.refVar)\n\u0009\u0009\u0009do @codes.add(\"\\{info.id}.$\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(info.id)\n\u0009\u0009end if\n\u0009end if\nend func\n\nfunc write(resFiles: list<[]char>)\n\u0009var writer: file@Writer\n\u0009if(\\option@extra.get(\"merge\", &))\n\u0009\u0009var fileName: []char :: file@fileName(\\option@outputFile)\n\u0009\u0009do writer :: file@makeWriter(\\option@outputFile ~ \".html\", false)\n\u0009\u0009do writer.writeStr(\"<!DOCTYPE html>\\n\")\n\u0009\u0009do writer.writeStr(\"<html>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t<head>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t\\t<meta charset=\\\"utf-8\\\" />\\n\")\n\u0009\u0009do writer.writeStr(\"\\t\\t<title>\\{fileName}</title>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t\\t<script type=\\\"text/javascript\\\">\\n\")\n\u0009\u0009do writeJs(writer, resFiles)\n\u0009\u0009do writer.writeStr(\"\\t\\t</script>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t</head>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t<body>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t</body>\\n\")\n\u0009\u0009do writer.writeStr(\"</html>\\n\")\n\u0009\u0009do writer.fin()\n\u0009else\n\u0009\u0009do writer :: file@makeWriter(\\option@outputFile ~ \".js\", false)\n\u0009\u0009do writeJs(writer, resFiles)\n\u0009\u0009do writer.fin()\n\u0009\u0009\n\u0009\u0009var fileName: []char :: file@fileName(\\option@outputFile)\n\u0009\u0009do writer :: file@makeWriter(\\option@outputFile ~ \".html\", false)\n\u0009\u0009do writer.writeStr(\"<!DOCTYPE html>\\n\")\n\u0009\u0009do writer.writeStr(\"<html>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t<head>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t\\t<meta charset=\\\"utf-8\\\" />\\n\")\n\u0009\u0009do writer.writeStr(\"\\t\\t<script src=\\\"\\{fileName}.js\\\" type=\\\"text/javascript\\\"></script>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t\\t<title>\\{fileName}</title>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t</head>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t<body>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t</body>\\n\")\n\u0009\u0009do writer.writeStr(\"</html>\\n\")\n\u0009\u0009do writer.fin()\n\u0009end if\n\u0009\n\u0009func writeJs(writer: file@Writer, resFiles: list<[]char>)\n\u0009\u0009var static: bool :: \\option@extra.get(\"static\", &)\n\u0009\u0009if(static)\n\u0009\u0009\u0009do writer.writeStr(\"\\\"use strict\\\";function \\{file@fileName(\\option@outputFile)}(O_){\\n\")\n\u0009\u0009else\n\u0009\u0009\u0009do writer.writeStr(\"\\\"use strict\\\";!function(f){let d=document;function h(){d.removeEventListener(\\\"DOMContentLoaded\\\",h);removeEventListener(\\\"load\\\",h);f()}\\\"complete\\\"===d.readyState||\\\"loading\\\"!==d.readyState&&!d.documentElement.doScroll?setTimeout(f):(d.addEventListener(\\\"DOMContentLoaded\\\",h),addEventListener(\\\"load\\\",h))}(function(){\\n\")\n\u0009\u0009\u0009do writer.writeStr(\"let O_;\\n\")\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009do @globalVars.head()\n\u0009\u0009while(!@globalVars.term())\n\u0009\u0009\u0009var globalVar: \\ast@AstArg :: @globalVars.get()\n\u0009\u0009\u0009var info: @WebInfo :: @getInfo(globalVar)\n\u0009\u0009\u0009do writer.writeStr(\"let \\{info.id}=\\{@getDefaultValue(globalVar.type)};\\n\")\n\u0009\u0009\u0009do @globalVars.next()\n\u0009\u0009end while\n\u0009\u0009do @codes.head()\n\u0009\u0009while(!@codes.term())\n\u0009\u0009\u0009do writer.writeStr(@codes.get())\n\u0009\u0009\u0009do @codes.next()\n\u0009\u0009end while\n\u0009\u0009\n\u0009\u0009do writer.writeStr(\"function C_(t,v){\\n\")\n\u0009\u0009do writer.writeStr(\"switch(t[0]){\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%int_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%float_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%char_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%bool_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%bit8_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%bit16_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%bit32_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%bit64_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%func_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%enum_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"return v;\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%array $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"if(t[1]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do writer.writeStr(\"return v===null?null:{S:v.S};\\n\")\n\u0009\u0009do writer.writeStr(\"else{\\n\")\n\u0009\u0009do writer.writeStr(\"let a=new Array(v.length);\\n\")\n\u0009\u0009do writer.writeStr(\"for(let i=0;i<v.length;i++)a[i]=C_(t.slice(1),v[i]);\\n\")\n\u0009\u0009do writer.writeStr(\"return a;\\n\")\n\u0009\u0009do writer.writeStr(\"}\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%list_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do writer.writeStr(\"case \\{%stack_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do writer.writeStr(\"case \\{%queue_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do writer.writeStr(\"case \\{%dict_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do writer.writeStr(\"case \\{%class_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do writer.writeStr(\"}\\n\")\n\u0009\u0009do writer.writeStr(\"}\\n\")\n\u0009\u0009\n\u0009\u0009do writer.writeStr(\"function F_(p,f){\\n\")\n\u0009\u0009block\n\u0009\u0009\u0009var first: bool :: true\n\u0009\u0009\u0009do resFiles.head()\n\u0009\u0009\u0009while(!resFiles.term())\n\u0009\u0009\u0009\u0009var resFile: []char :: resFiles.get()\n\u0009\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(\"if(p===\\\"\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(\"else if(p===\\\"\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009for i(^\\option@inputDir, ^resFile - 1)\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(@escapeChar(resFile[i]))\n\u0009\u0009\u0009\u0009end for\n\u0009\u0009\u0009\u0009do writer.writeStr(\"\\\")\\n\")\n\u0009\u0009\u0009\u0009if(resFile[^resFile - 1] = \'/\')\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(\"return f?null:true;\\n\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(\"return f?\\\"\")\n\u0009\u0009\u0009\u0009\u0009var reader: file@Reader :: file@makeReader(resFile)\n\u0009\u0009\u0009\u0009\u0009while(!reader.term())\n\u0009\u0009\u0009\u0009\u0009\u0009var line: []char :: reader.readLine()\n\u0009\u0009\u0009\u0009\u0009\u0009for i(0, ^line - 1)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do writer.writeStr(@escapeChar(line[i]))\n\u0009\u0009\u0009\u0009\u0009\u0009end for\n\u0009\u0009\u0009\u0009\u0009\u0009do writer.writeStr(\"\\\\n\")\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009do reader.fin()\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(\"\\\":true;\\n\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do resFiles.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009if(^resFiles > 0)\n\u0009\u0009\u0009\u0009do writer.writeStr(\"else return f?null:false;\\n\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do writer.writeStr(\"return f?null:false;\\n\")\n\u0009\u0009\u0009end if\n\u0009\u0009end block\n\u0009\u0009do writer.writeStr(\"}\\n\")\n\u0009\u0009\n\u0009\u0009block\n\u0009\u0009\u0009do writer.writeStr(\"function FF_(){return[\")\n\u0009\u0009\u0009var first: bool :: true\n\u0009\u0009\u0009do resFiles.head()\n\u0009\u0009\u0009while(!resFiles.term())\n\u0009\u0009\u0009\u0009var resFile: []char :: resFiles.get()\n\u0009\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(\"\\\"\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(\",\\\"\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009for i(^\\option@inputDir, ^resFile - 1)\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(@escapeChar(resFile[i]))\n\u0009\u0009\u0009\u0009end for\n\u0009\u0009\u0009\u0009do writer.writeStr(\"\\\"\")\n\u0009\u0009\u0009\u0009do resFiles.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do writer.writeStr(\"];}\\n\")\n\u0009\u0009end block\n\u0009\u0009\n\u0009\u0009do writer.writeStr(\"a();\\n\")\n\u0009\u0009if(static)\n\u0009\u0009\u0009do writer.writeStr(\"}\\n\")\n\u0009\u0009else\n\u0009\u0009\u0009do writer.writeStr(\"})\\n\")\n\u0009\u0009end if\n\u0009end func\nend func\n\nfunc getId(): []char\n\u0009var curId: []char :: @uniqueId\n\u0009var newId: []char :: ##@uniqueId\n\u0009while loop2(true)\n\u0009\u0009var idx: int :: ^newId - 1\n\u0009\u0009while loop(true)\n\u0009\u0009\u0009switch(newId[idx])\n\u0009\u0009\u0009case \'z\'\n\u0009\u0009\u0009\u0009do newId[idx] :: idx = 0 ?(\'A\', \'0\')\n\u0009\u0009\u0009case \'9\'\n\u0009\u0009\u0009\u0009do newId[idx] :: \'A\'\n\u0009\u0009\u0009case \'Z\'\n\u0009\u0009\u0009\u0009if(idx = 0)\n\u0009\u0009\u0009\u0009\u0009do newId :: #[^newId + 1]char\n\u0009\u0009\u0009\u0009\u0009do newId.fill(\'a\')\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do newId[idx] :: \'a\'\n\u0009\u0009\u0009\u0009\u0009do idx :- 1\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do newId[idx] :: newId[idx].offset(1)\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009break loop\n\u0009\u0009end while\n\u0009\u0009switch(^newId)\n\u0009\u0009case 2\n\u0009\u0009\u0009switch(newId)\n\u0009\u0009\u0009case \"do\", \"if\", \"in\"\n\u0009\u0009\u0009\u0009skip loop2\n\u0009\u0009\u0009end switch\n\u0009\u0009case 3\n\u0009\u0009\u0009switch(newId)\n\u0009\u0009\u0009case \"for\", \"let\", \"new\", \"try\", \"var\", \"Map\", \"NaN\", \"Set\"\n\u0009\u0009\u0009\u0009skip loop2\n\u0009\u0009\u0009end switch\n\u0009\u0009case 4\n\u0009\u0009\u0009switch(newId)\n\u0009\u0009\u0009case \"case\", \"else\", \"enum\", \"eval\", \"name\", \"null\", \"this\", \"true\", \"void\", \"with\", \"Date\", \"Intl\", \"JSON\", \"Math\"\n\u0009\u0009\u0009\u0009skip loop2\n\u0009\u0009\u0009end switch\n\u0009\u0009end switch\n\u0009\u0009break loop2\n\u0009end while\n\u0009do @uniqueId :: newId\n\u0009ret curId\nend func\n\n+func getInfo(ast: \\ast@Ast): @WebInfo\n\u0009if(ast.extra =& null | ast.extra.typeId <> %info)\n\u0009\u0009var info: @WebInfo :: #@WebInfo\n\u0009\u0009do info.typeId :: %info\n\u0009\u0009do info.id :: @getId()\n\u0009\u0009if(ast.typeId.and(%statBreakable) = %statBreakable & ast.name <>& null & ast.name <> \"$\")\n\u0009\u0009\u0009do info.breakSkipLabel :: @getId()\n\u0009\u0009else\n\u0009\u0009\u0009do info.breakSkipLabel :: null\n\u0009\u0009end if\n\u0009\u0009do info.alreadyWritten :: false\n\u0009\u0009do ast.extra :: info\n\u0009end if\n\u0009ret ast.extra $ @WebInfo\nend func\n\nfunc addTmpVar(type: \\ast@AstType): []char\n\u0009var tmpVar: @TmpVar :: #@TmpVar\n\u0009do tmpVar.identifier :: @getId()\n\u0009do tmpVar.type :: type\n\u0009do @tmpVars.add(tmpVar)\n\u0009ret tmpVar.identifier\nend func\n\nfunc refClass(ast: \\ast@AstClass): []char\n\u0009var info: @WebInfo :: @getInfo(ast)\n\u0009if(info.alreadyWritten)\n\u0009\u0009ret info.id\n\u0009end if\n\u0009do info.alreadyWritten :: true\n\u0009if(ast.refItem <>& null)\n\u0009\u0009do @refClass(ast.refItem $ \\ast@AstClass)\n\u0009end if\n\u0009do @classes.add(ast)\n\u0009ret info.id\nend func\n\nfunc getDefaultValue(type: \\ast@AstType): []char\n\u0009if(\\ast@isNullable(type))\n\u0009\u0009ret \"null\"\n\u0009end if\n\u0009switch(type.typeId)\n\u0009case %typeUser\n\u0009\u0009assert \\ast@isEnum(type)\n\u0009\u0009ret \"0\"\n\u0009case %typeBit\n\u0009\u0009ret \"0\"\n\u0009case %typePrim\n\u0009\u0009switch((type $ \\ast@AstTypePrim).kind)\n\u0009\u0009case %int_, %char_\n\u0009\u0009\u0009ret \"0\"\n\u0009\u0009case %float_\n\u0009\u0009\u0009ret \"0\"\n\u0009\u0009case %bool_\n\u0009\u0009\u0009ret \"false\"\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc makeTypeId(type: \\ast@AstType): []char\n\u0009var result: []char :: \"[\"\n\u0009var first: bool :: true\n\u0009var items: list<int> :: \\convert@getTypeId(type)\n\u0009do items.head()\n\u0009while(!items.term())\n\u0009\u0009if(first)\n\u0009\u0009\u0009do first :: false\n\u0009\u0009else\n\u0009\u0009\u0009do result :~ \",\"\n\u0009\u0009end if\n\u0009\u0009do result :~ items.get().toStr()\n\u0009\u0009do items.next()\n\u0009end while\n\u0009do result :~ \"]\"\n\u0009ret result\nend func\n\nfunc escapeChar(c: char): []char\n\u0009switch(c)\n\u0009case \'\"\'\n\u0009\u0009ret \"\\\\\\\"\"\n\u0009case \'\\\'\'\n\u0009\u0009ret \"\\\\\'\"\n\u0009case \'\\\\\'\n\u0009\u0009ret \"\\\\\\\\\"\n\u0009case \' \' to \'~\'\n\u0009\u0009ret c.toStr()\n\u0009default\n\u0009\u0009ret \"\\\\u\\{(c $ bit16).toStr().sub(2, -1)}\"\n\u0009end switch\nend func\n":true;
else if(p==="res/web/raw_funcs.kn")
return f?"+func write(codes: list<[]char>, attr: []char, args: list<\\ast@AstArg>, members: list<\\ast@AstClassItem>)\n\u0009switch(attr)\n\u0009case \"acos\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.acos(\\{x.id});\\n\")\n\u0009case \"acosh\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.log(\\{x.id}+Math.sqrt(\\{x.id}*\\{x.id}-1));\\n\")\n\u0009case \"addr\"\n\u0009\u0009; TODO:\n\u0009case \"addDict\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var key: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{meType.id}[1]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[2]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.set(\\{key.id}.S, \\{item.id});\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.set(\\{key.id}, \\{item.id});\\n\")\n\u0009case \"addList\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let n_={P:null,N:null,I:\\{item.id}};\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}.H===null){\\{me_.id}.H=n_;\\{me_.id}.T=n_}else{n_.P=\\{me_.id}.T;\\{me_.id}.T.N=n_;\\{me_.id}.T=n_}\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.L++;\\n\")\n\u0009case \"addQueue\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}.push(\\{item.id});\\n\")\n\u0009case \"addStack\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}.push(\\{item.id});\\n\")\n\u0009case \"and\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}&\\{n.id};\\n\")\n\u0009case \"asin\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.asin(\\{x.id});\\n\")\n\u0009case \"asinh\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.log(\\{x.id}+Math.sqrt(\\{x.id}*\\{x.id}+1));\\n\")\n\u0009case \"atan\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.atan(\\{x.id});\\n\")\n\u0009case \"atanh\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return 0.5*Math.log((1+\\{x.id})/(1-\\{x.id}));\\n\")\n\u0009case \"ceil\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.ceil(\\{x.id});\\n\")\n\u0009case \"cmdLine\"\n\u0009\u0009do codes.add(\"let r_=(O_&&O_.cmdLine)?O_.cmdLine:location.search.slice(1).split(\\\"&\\\");\\n\")\n\u0009\u0009do codes.add(\"if(r_.length===1&&r_[0]===\\\"\\\")return[];\\n\")\n\u0009\u0009do codes.add(\"for(let i_=0;i_<r_.length;i_++)\\n\")\n\u0009\u0009do codes.add(\"r_[i_]={S:r_[i_]};\\n\")\n\u0009\u0009do codes.add(\"return r_;\\n\")\n\u0009case \"cos\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.cos(\\{x.id});\\n\")\n\u0009case \"cosh\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.cosh(\\{x.id});\\n\")\n\u0009case \"del\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let p_=\\{me_.id}.P;\\n\")\n\u0009\u0009do codes.add(\"if(p_.P===null)\\{me_.id}.H=p_.N;else p_.P.N=p_.N;\\n\")\n\u0009\u0009do codes.add(\"if(p_.N===null)\\{me_.id}.T=p_.P;else p_.N.P=p_.P;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.P=p_.N;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.L--;\\n\")\n\u0009case \"dist\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var y: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var centerX: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var centerY: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"var x_=\\{x.id}-\\{centerX.id},y_=\\{y.id}-\\{centerY.id};\\n\")\n\u0009\u0009do codes.add(\"return Math.sqrt(x_*x_+y_*y_);\\n\")\n\u0009case \"exp\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.exp(\\{x.id});\\n\")\n\u0009case \"fill\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var value: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{meType.id}[0]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[1]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.S=String.fromCharCode(\\{value.id}).repeat(\\{me_.id}.S.length);\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.fill(\\{value.id});\\n\")\n\u0009case \"findArray\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var start: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{meType.id}[0]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[1]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.S.indexOf(String.fromCharCode(\\{item.id}),\\{start.id}===-1?0:\\{start.id});\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.indexOf(\\{item.id},\\{start.id}===-1?0:\\{start.id});\\n\")\n\u0009case \"findBin\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let a_=0,b_=\\{me_.id}.length-1,c_,m_,f_;\\n\")\n\u0009\u0009do codes.add(\"switch(\\{meType.id}[0]){\\n\")\n\u0009\u0009do codes.add(\"case \\{%int_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%float_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%char_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit8_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit16_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit32_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit64_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%enum_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"f_=function(a,b){return a>b?1:a<b?-1:0};\\n\")\n\u0009\u0009do codes.add(\"break;\\n\")\n\u0009\u0009do codes.add(\"case \\{%array $ \\convert@runtimeTypeId $ int}:\\n\") {TODO:}\n\u0009\u0009do codes.add(\"f_=function(a,b){return a.S>b.S?1:a.S<b.S?-1:0};\\n\")\n\u0009\u0009do codes.add(\"break;\\n\")\n\u0009\u0009do codes.add(\"default:\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"break;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"while (a_<=b_){\\n\")\n\u0009\u0009do codes.add(\"c_=~~((a_+b_)/2);\\n\")\n\u0009\u0009do codes.add(\"m_=f_(\\{item.id},\\{me_.id}[c_]);\\n\")\n\u0009\u0009do codes.add(\"if(m_<0)b_=c_-1;\\n\")\n\u0009\u0009do codes.add(\"else if(m_>0)a_=c_+1;\\n\")\n\u0009\u0009do codes.add(\"else return c_;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return -1;\\n\")\n\u0009case \"findLastArray\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var start: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{meType.id}[0]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[1]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.S.lastIndexOf(String.fromCharCode(\\{item.id}),\\{start.id}===-1?\\{me_.id}.S.length-1:\\{start.id});\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.lastIndexOf(\\{item.id},\\{start.id}===-1?\\{me_.id}.S.length-1:\\{start.id});\\n\")\n\u0009case \"floor\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.floor(\\{x.id});\\n\")\n\u0009case \"forEach\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var callback: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var data: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let D_={F:\\{callback.id},D:\\{data.id},C:true};\\n\")\n\u0009\u0009do codes.add(\"if(\\{meType.id}[1]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[2]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.forEach(function(V_,K_){if(this.C)this.C=this.F({S:K_},V_,this.D)},D_);\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.forEach(function(V_,K_){if(this.C)this.C=this.F(K_,V_,this.D)},D_);\\n\")\n\u0009\u0009do codes.add(\"return D_.C;\\n\")\n\u0009case \"getDict\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var key: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var existed: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let r_;\\n\")\n\u0009\u0009do codes.add(\"if(\\{meType.id}[1]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[2]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"r_=\\{me_.id}.get(\\{key.id}.S);\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"r_=\\{me_.id}.get(\\{key.id});\\n\")\n\u0009\u0009do codes.add(\"if(!(\\{existed.id}.$=r_!==undefined)){\\n\")\n\u0009\u0009do codes.add(\"switch(\\{meType.id}){\\n\") {TODO: [2]}\n\u0009\u0009do codes.add(\"case \\{%int_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%float_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%char_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit8_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit16_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit32_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit64_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%enum_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"case \\{%bool_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return false;\\n\")\n\u0009\u0009do codes.add(\"default:\\n\")\n\u0009\u0009do codes.add(\"return null;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return r_;\\n\")\n\u0009case \"getList\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}.P.I;\\n\")\n\u0009case \"getQueue\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}.shift();\\n\")\n\u0009case \"getStack\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}.pop();\\n\")\n\u0009case \"head\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}.P=\\{me_.id}.H;\\n\")\n\u0009case \"idx\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let p_=\\{me_.id}.H,i_=0;\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}.P===null)return -1;\\n\")\n\u0009\u0009do codes.add(\"while(p_!==null){\\n\")\n\u0009\u0009do codes.add(\"if(p_===\\{me_.id}.P)return i_\\n\")\n\u0009\u0009do codes.add(\"i_++;\\n\")\n\u0009\u0009do codes.add(\"p_=p_.N;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return -1;\\n\")\n\u0009case \"ins\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let p_=\\{me_.id}.P;\\n\")\n\u0009\u0009do codes.add(\"let n_={P:p_.P,N:p_,I:\\{item.id}}\\n\")\n\u0009\u0009do codes.add(\"if(p_.P===null)\\{me_.id}.H=n_;else p_.P.N=n_;\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}.T===null)\\{me_.id}.T=n_;\\n\")\n\u0009\u0009do codes.add(\"p_.P=n_;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.L++;\\n\")\n\u0009case \"invRot\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var y: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var centerX: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var centerY: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"var r_=Math.atan2(\\{y.id}-\\{centerY.id},\\{x.id}-\\{centerX.id});\\n\")\n\u0009\u0009do codes.add(\"return r_<0.0?r_+2.0*Math.PI:r_;\\n\")\n\u0009case \"ln\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.log(\\{x.id});\\n\")\n\u0009case \"moveOffset\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var offset: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{offset.id}>=0){\\n\")\n\u0009\u0009do codes.add(\"for(let i_=0;i_<\\{offset.id};i_++){\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}.P===null)break;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.P=\\{me_.id}.P.N;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"for(let i_=0;i_>\\{offset.id};i_--){\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}.P===null)break;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.P=\\{me_.id}.P.P;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"next\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}.P=\\{me_.id}.P.N;\\n\")\n\u0009case \"not\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return ~\\{me_.id};\\n\")\n\u0009case \"or\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}|\\{n.id};\\n\")\n\u0009case \"peekQueue\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}[0];\\n\")\n\u0009case \"peekStack\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}[\\{me_.id}.length-1];\\n\")\n\u0009case \"prev\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}.P=\\{me_.id}.P.P;\\n\")\n\u0009case \"rnd\"\n\u0009\u0009do args.head()\n\u0009\u0009var min: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var max: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return ~~(Math.random()*(\\{max.id}-\\{min.id}+1))+\\{min.id};\\n\")\n\u0009case \"rndFloat\"\n\u0009\u0009do args.head()\n\u0009\u0009var min: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var max: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.random()*(\\{max.id}-\\{min.id})+\\{min.id};\\n\")\n\u0009case \"sar\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}>>\\{n.id};\\n\")\n\u0009case \"shl\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}<<\\{n.id};\\n\")\n\u0009case \"shr\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}>>>\\{n.id};\\n\")\n\u0009case \"sin\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.sin(\\{x.id});\\n\")\n\u0009case \"sinh\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.sinh(\\{x.id});\\n\")\n\u0009case \"sqrt\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.sqrt(\\{x.id});\\n\")\n\u0009case \"sub\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var start: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var len: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{meType.id}[0]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[1]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"return {S:\\{len.id}===-1?\\{me_.id}.S.slice(\\{start.id}):\\{me_.id}.S.slice(\\{start.id},\\{start.id}+\\{len.id})};\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"return \\{len.id}===-1?\\{me_.id}.slice(\\{start.id}):\\{me_.id}.slice(\\{start.id},\\{start.id}+\\{len.id});\\n\")\n\u0009case \"sysTime\"\n\u0009\u0009do codes.add(\"return new Date().getTime();\\n\")\n\u0009case \"tail\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}.P=\\{me_.id}.T;\\n\")\n\u0009case \"tan\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.tan(\\{x.id});\\n\")\n\u0009case \"tanh\"\n\u0009\u0009do args.head()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.tanh(\\{x.id});\\n\")\n\u0009case \"term\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}.P===null;\\n\")\n\u0009case \"toArray\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let a_=new Array(\\{me_.id}.L),e_=\\{me_.id}.H;\\n\")\n\u0009\u0009do codes.add(\"for(let i_=0;i_<\\{me_.id}.L;i_++){\\n\")\n\u0009\u0009do codes.add(\"a_[i_]=e_.I;\\n\")\n\u0009\u0009do codes.add(\"e_=e_.N;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return a_;\\n\")\n\u0009case \"toBit64\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var success: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{me_.id}.S.length>=2&&\\{me_.id}.S[0]===\\\"0\\\"&&\\{me_.id}.S[1]===\\\"x\\\"){\\n\")\n\u0009\u0009do codes.add(\"let s_=\\{me_.id}.S.slice(2),r_=Number(\\{me_.id}.S);\\n\")\n\u0009\u0009do codes.add(\"\\{success.id}.$=!isNaN(r_);\\n\")\n\u0009\u0009do codes.add(\"return parseInt(s_,16);\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"let r_=Number(\\{me_.id}.S);\\n\")\n\u0009\u0009do codes.add(\"\\{success.id}.$=!isNaN(r_);\\n\")\n\u0009\u0009do codes.add(\"return parseInt(\\{me_.id}.S,10);\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"toFloat\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var success: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let r_=Number(\\{me_.id}.S);\\n\")\n\u0009\u0009do codes.add(\"\\{success.id}.$=!isNaN(r_);\\n\")\n\u0009\u0009do codes.add(\"return r_;\\n\")\n\u0009case \"toInt\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var success: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{me_.id}.S.length>=2&&\\{me_.id}.S[0]===\\\"0\\\"&&\\{me_.id}.S[1]===\\\"x\\\"){\\n\")\n\u0009\u0009do codes.add(\"let s_=\\{me_.id}.S.slice(2),r_=Number(\\{me_.id}.S);\\n\")\n\u0009\u0009do codes.add(\"\\{success.id}.$=!isNaN(r_);\\n\")\n\u0009\u0009do codes.add(\"return parseInt(s_,16);\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"let r_=Number(\\{me_.id}.S);\\n\")\n\u0009\u0009do codes.add(\"\\{success.id}.$=!isNaN(r_);\\n\")\n\u0009\u0009do codes.add(\"return parseInt(\\{me_.id}.S,10);\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"toStr\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var type: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let n_;\\n\")\n\u0009\u0009do codes.add(\"switch(\\{type.id}[0]){\\n\")\n\u0009\u0009do codes.add(\"case \\{%int_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%float_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%enum_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return{S:\\{me_.id}.toString(10)};\\n\")\n\u0009\u0009do codes.add(\"case \\{%char_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return{S:String.fromCharCode(\\{me_.id})};\\n\")\n\u0009\u0009do codes.add(\"case \\{%bool_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return{S:\\{me_.id}?\\\"true\\\":\\\"false\\\"};\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit8_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"n_=\\{me_.id}>=0?~~\\{me_.id}&0xFF:0xFF-(~\\{me_.id}&0xFF);\\n\")\n\u0009\u0009do codes.add(\"return{S:\\\"0x\\\"+(\\\"00\\\"+n_.toString(16)).slice(-2).toUpperCase()};\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit16_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"n_=\\{me_.id}>=0?~~\\{me_.id}&0xFFFF:0xFFFF-(~\\{me_.id}&0xFFFF);\\n\")\n\u0009\u0009do codes.add(\"return{S:\\\"0x\\\"+(\\\"0000\\\"+n_.toString(16)).slice(-4).toUpperCase()};\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit32_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"n_=\\{me_.id}>>>0;\\n\")\n\u0009\u0009do codes.add(\"return{S:\\\"0x\\\"+(\\\"00000000\\\"+n_.toString(16)).slice(-8).toUpperCase()};\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit64_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"n_=\\{me_.id}>>>0;\\n\")\n\u0009\u0009do codes.add(\"return{S:\\\"0x\\\"+((\\{me_.id}>=0?\\\"0000000000000000\\\":\\\"FFFFFFFFFFFFFFFF\\\")+n_.toString(16)).slice(-16).toUpperCase()};\\n\")\n\u0009\u0009do codes.add(\"case \\{%array $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"if(\\{type.id}[1]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id};\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"xor\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}^\\{n.id};\\n\")\n\u0009case \"cui_print\"\n\u0009\u0009do args.head()\n\u0009\u0009var str: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{str.id}===null)\\{str.id}={S:\\\"(null)\\\"};\\n\")\n\u0009\u0009do codes.add(\"if(O_&&O_.print){O_.print(\\{str.id}.S);return;}\\n\")\n\u0009\u0009do codes.add(\"console.log(\\{str.id}.S);\\n\")\n\u0009case \"file_copyFile\"\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"return false;\\n\")\n\u0009case \"file_exist\"\n\u0009\u0009do args.head()\n\u0009\u0009var path: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let f_=false,p_=\\{path.id}.S;\\n\")\n\u0009\u0009do codes.add(\"if(O_&&O_.readFile)f_=O_.readFile(p_)!==null;\\n\")\n\u0009\u0009do codes.add(\"if(f_===false){\\n\")\n\u0009\u0009do codes.add(\"if(p_.length>=4&&p_[0]===\\\"r\\\"&&p_[1]===\\\"e\\\"&&p_[2]===\\\"s\\\"&&p_[3]===\\\"/\\\")\\n\")\n\u0009\u0009do codes.add(\"f_=F_(p_,false);\\n\")\n\u0009\u0009do codes.add(\"else{\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return f_;\\n\")\n\u0009case \"file_forEach\"\n\u0009\u0009do args.head()\n\u0009\u0009var path: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var recursion: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var callback: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var data: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let f_,p_=\\{path.id}.S;\\n\")\n\u0009\u0009do codes.add(\"if(p_.length>=4&&p_[0]===\\\"r\\\"&&p_[1]===\\\"e\\\"&&p_[2]===\\\"s\\\"&&p_[3]===\\\"/\\\")\\n\")\n\u0009\u0009do codes.add(\"f_=FF_();\\n\")\n\u0009\u0009do codes.add(\"for(let i_=0;i_<f_.length;i_++){\\n\")\n\u0009\u0009do codes.add(\"if(f_[i_].slice(0,p_.length)===p_&&(\\{recursion.id}||f_[i_].slice(p_.length).indexOf(\\\"/\\\")===-1)){\\n\")\n\u0009\u0009do codes.add(\"if(!\\{callback.id}({S:f_[i_]},f_[i_][f_[i_].length-1]===\'/\',\\{data.id}))return false\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return true;\\n\")\n\u0009case \"file_makeReader\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var path: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"let f_=null,p_=\\{path.id}.S;\\n\")\n\u0009\u0009do codes.add(\"if(O_&&O_.readFile)f_=O_.readFile(p_);\\n\")\n\u0009\u0009do codes.add(\"if(f_===null){\\n\")\n\u0009\u0009do codes.add(\"if(p_.length>=4&&p_[0]===\\\"r\\\"&&p_[1]===\\\"e\\\"&&p_[2]===\\\"s\\\"&&p_[3]===\\\"/\\\")\\n\")\n\u0009\u0009do codes.add(\"f_=F_(p_,true);\\n\")\n\u0009\u0009do codes.add(\"else{\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"if(f_===null)return null;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}={F:f_,I:0};\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id};\\n\")\n\u0009case \"file_makeWriter\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var path: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var append: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}={F:\\\"\\\",I:0,P:\\{path.id}.S};\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id};\\n\")\n\u0009case \"file_readerFin\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.F=null;\\n\")\n\u0009case \"file_readerGetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.\\{handle.id}.I;\\n\")\n\u0009case \"file_readerReadLetter\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.\\{handle.id}.F.charCodeAt(\\{me_.id}.\\{handle.id}.I++);\\n\")\n\u0009case \"file_readerSetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var origin: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var pos: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.I=\\{pos.id};\\n\")\n\u0009case \"file_readerTerm\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.\\{handle.id}.I>=\\{me_.id}.\\{handle.id}.F.length;\\n\")\n\u0009case \"file_writerFin\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"var d_=\\{me_.id}.\\{handle.id}.F.replace(\\\"\\\\n\\\", \\\"\\\\u000D\\\\n\\\");\\n\")\n\u0009\u0009do codes.add(\"if(O_&&O_.writeFile){O_.writeFile(\\{me_.id}.\\{handle.id}.P,d_);return;}\\n\")\n\u0009\u0009do codes.add(\"let b_=new Blob([d_]);\\n\")\n\u0009\u0009do codes.add(\"let l_=document.createElement(\\\"a\\\");\\n\")\n\u0009\u0009do codes.add(\"l_.download=\\{me_.id}.\\{handle.id}.P;\\n\")\n\u0009\u0009do codes.add(\"l_.href=(URL||webkitURL).createObjectURL(b_);\\n\")\n\u0009\u0009do codes.add(\"l_.setAttribute(\\\"style\\\",\\\"display:none\\\");\\n\")\n\u0009\u0009do codes.add(\"document.body.appendChild(l_);\\n\")\n\u0009\u0009do codes.add(\"l_.click();\\n\")\n\u0009\u0009do codes.add(\"document.body.removeChild(l_);\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.F=null;\\n\")\n\u0009case \"file_writerGetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.\\{handle.id}.I;\\n\")\n\u0009case \"file_writerSetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var origin: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var pos: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.I=\\{pos.id};\\n\")\n\u0009case \"file_writerWrite\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009; TODO:\n\u0009case \"file_writerWriteChar\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}.\\{handle.id}.I<\\{me_.id}.\\{handle.id}.F.length)\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.F=\\{me_.id}.\\{handle.id}.F.slice(0,\\{me_.id}.\\{handle.id}.I)+String.fromCharCode(\\{n.id})+\\{me_.id}.\\{handle.id}.F.slice(\\{me_.id}.\\{handle.id}.I+1);\\n\")\n\u0009\u0009do codes.add(\"else{\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.F+=String.fromCharCode(\\{n.id});\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.I++;\\n\")\n\u0009case \"wnd_editBaseGetText\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.\\{handle.id}.H.value;\\n\")\n\u0009case \"wnd_makeEditMulti\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var parent: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var y: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var width: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var height: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var anchorX: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var anchorY: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"let h_=document.createElement(\\\"textarea\\\");\\n\")\n\u0009\u0009do codes.add(\"h_.setAttribute(\\\"cols\\\",\\\"\\{width.id}\\\");\\n\")\n\u0009\u0009do codes.add(\"h_.setAttribute(\\\"rows\\\",\\\"\\{height.id}\\\");\\n\")\n\u0009\u0009do codes.add(\"document.body.appendChild(c_);\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}={C:c_};\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id};\\n\")\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\n\u0009\n\u0009func search(members: list<\\ast@AstClassItem>, name: []char): \\web\\output@WebInfo\n\u0009\u0009do members.head()\n\u0009\u0009while(!members.term())\n\u0009\u0009\u0009var def: \\ast@Ast :: members.get().def\n\u0009\u0009\u0009if(def.typeId = %var_ & (def $ \\ast@AstVar).arg.name <>& null & (def $ \\ast@AstVar).arg.name = name)\n\u0009\u0009\u0009\u0009ret \\web\\output@getInfo((def $ \\ast@AstVar).arg)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do members.next()\n\u0009\u0009end while\n\u0009\u0009assert false\n\u0009\u0009ret null\n\u0009end func\nend func\n":true;
else return f?null:false;
}
function FF_(){return["res/","res/analyze.kn","res/ast.kn","res/builtin_func.kn","res/convert.kn","res/cpp/","res/cpp/output.kn","res/cpp/raw_funcs.kn","res/err.kn","res/main.kn","res/msg.kn","res/option.kn","res/parse.kn","res/pos.kn","res/sys/","res/sys/common.h","res/sys/cui.kn","res/sys/dbg.kn","res/sys/excpt.kn","res/sys/file.kn","res/sys/kuin.kn","res/sys/lib.kn","res/sys/preset00_cui.knp","res/sys/preset00_wnd.knp","res/sys/preset01_cui.knp","res/sys/preset01_wnd.knp","res/sys/preset02_cui.knp","res/sys/preset02_wnd.knp","res/sys/preset03_cui.knp","res/sys/preset03_wnd.knp","res/sys/wnd.kn","res/test.kn","res/web/","res/web/output.kn","res/web/raw_funcs.kn"];}
a();
}
