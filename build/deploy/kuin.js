"use strict";function kuin(O_){
let m=0;
let s=false;
let x=false;
let y=null;
let F=false;
let I=null;
let J=null;
let K=null;
let L=null;
let M=null;
let N=null;
let O=null;
let P=null;
let Q=null;
let R=null;
let S=null;
let T=null;
let U=null;
let V=null;
let W=null;
let X=null;
let Y=null;
let Z=null;
let aa=null;
let ab=null;
let ac=null;
let ad=null;
let ae=null;
let af=null;
let ag=null;
let ah=null;
let ai=null;
let aj=null;
let ak=null;
let al=null;
let am=null;
let an=null;
let ao=null;
let ap=null;
let aW=false;
let b5=false;
let bL=0;
let bW=0;
let c0=0;
let eR=0;
let pF=0;
let pG=0;
let pH=0;
let pI=0;
let pJ=false;
let pK=0;
// $
function a(){
let c=0; // $
try{
(e)();
(f)();
(g)();
}catch(c){
if((0)<=c&&c<=(4294967295)){
(i)((c));
}
else{
throw c;
}
}
finally{
(k)();
(l)();
}
}
// _init
function e(){
}
// _initVars
function f(){
(m)=(0);
}
// main
function g(){
if(!((o)())){
(q)((1));
return;
}
if(s){
(u)(({S:({S:({S:"Kuin Programming Language v."}).S+((v)((2019),([0]))).S}).S+({S:({S:({S:"."}).S+((v)((10),([0]))).S}).S+({S:({S:({S:"."}).S+((v)((17),([0]))).S}).S+({S:"\u000A"}).S}).S}).S}));
(u)(({S:"(C)Kuina-chan\u000A"}));
(q)((0));
return;
}
if((x)||((y)===(null))){
(u)(({S:"Usage: kuincl [-i input.kn] [-o output.kn] [-s \'sys\' directory] [-c icon.ico] [-e environment] [-a appcode] [-r] [-h] [-v] [-q]\u000A"}));
(q)((0));
return;
}
if((B)()){
(D)((196609),(null),(null));
(q)((0));
return;
}
if(!(F)){
(D)((196610),(null),(null));
}
(q)((1));
}
// _err
function i(H /*excpt*/){
}
// _finVars
function k(){
(I)=(null);
(J)=(null);
(K)=(null);
(L)=(null);
(M)=(null);
(N)=(null);
(O)=(null);
(P)=(null);
(Q)=(null);
(R)=(null);
(S)=(null);
(T)=(null);
(U)=(null);
(y)=(null);
(V)=(null);
(W)=(null);
(X)=(null);
(Y)=(null);
(Z)=(null);
(aa)=(null);
(ab)=(null);
(ac)=(null);
(ad)=(null);
(ae)=(null);
(af)=(null);
(ag)=(null);
(ah)=(null);
(ai)=(null);
(aj)=(null);
(ak)=(null);
(al)=(null);
(am)=(null);
(an)=(null);
(ao)=(null);
(ap)=(null);
}
// _fin
function l(){
}
// acquireOption
function o(){
let aq=null; // cmdLines
let au=0;
let aw=null; // cmdLine
let a1=0;
let bc=null; // envStr
let by=null; // appCodeStr
let b8=null; // extra
let bO=null;
let cc=false; // success
let av=0;
let a4=false;
let a6=null;
let a7=0;
let aB=false;
let aC=null;
let aD=0;
let aH=false;
let aI=null;
let aJ=0;
let aN=false;
let aO=null;
let aP=0;
let aT=false;
let aV=false;
let ba=false;
let bb=null;
let bd=0;
let bh=false;
let bi=false;
let bm=false;
let bn=false;
let br=false;
let bs=false;
let bw=false;
let bx=null;
let bz=0;
let b3=false;
let b4=false;
let bA=false;
let bB=null;
let bC=0;
let bZ=0;
let cb=false;
(aq)=((ar)());
(Y)=(new Map());
at:
for(au=(0),av=(((aq).length)-(1));au<=av;au+=(1)){
(aw)=((aq)[au]);
if((((aw).S.length)===(2))&&(((aw).S.charCodeAt(0))===(0x002D))){
a0:
switch((aw).S.charCodeAt(1)){
case 0x0069:
if(!((a4=(a5)((a6={$:(y)},a6),(aq),(a7={$:(au)},a7),(a1)),(y)=a6.$,(au)=a7.$,a4))){
return false;
}
break;
case 0x006F:
if(!((aB=(a5)((aC={$:(V)},aC),(aq),(aD={$:(au)},aD),(a1)),(V)=aC.$,(au)=aD.$,aB))){
return false;
}
break;
case 0x0073:
if(!((aH=(a5)((aI={$:(W)},aI),(aq),(aJ={$:(au)},aJ),(a1)),(W)=aI.$,(au)=aJ.$,aH))){
return false;
}
break;
case 0x0063:
if(!((aN=(a5)((aO={$:(X)},aO),(aq),(aP={$:(au)},aP),(a1)),(X)=aO.$,(au)=aP.$,aN))){
return false;
}
break;
case 0x0072:
if(!((aT=(aU)((aV={$:(aW)},aV),(a1)),(aW)=aV.$,aT))){
return false;
}
break;
case 0x0065:
if(!((ba=(a5)((bb={$:(bc)},bb),(aq),(bd={$:(au)},bd),(a1)),(bc)=bb.$,(au)=bd.$,ba))){
return false;
}
break;
case 0x0068:
if(!((bh=(aU)((bi={$:(x)},bi),(a1)),(x)=bi.$,bh))){
return false;
}
break;
case 0x0076:
if(!((bm=(aU)((bn={$:(s)},bn),(a1)),(s)=bn.$,bm))){
return false;
}
break;
case 0x0071:
if(!((br=(aU)((bs={$:(F)},bs),(a1)),(F)=bs.$,br))){
return false;
}
break;
case 0x0061:
if(!((bw=(a5)((bx={$:(by)},bx),(aq),(bz={$:(au)},bz),(a1)),(by)=bx.$,(au)=bz.$,bw))){
return false;
}
break;
case 0x0064:
if(!((b3=(aU)((b4={$:(b5)},b4),(a1)),(b5)=b4.$,b3))){
return false;
}
break;
case 0x0078:
(b8)=(null);
if(!((bA=(a5)((bB={$:(b8)},bB),(aq),(bC={$:(au)},bC),(a1)),(b8)=bB.$,(au)=bC.$,bA))){
return false;
}
(bE)((Y),([133,129,2,3]),(b8),(true));
break;
default:
(D)((2),(null),([({S:({S:({S:"-"}).S+((v)((a1),([2]))).S}).S+({S:""}).S})]));
return false;
break;
}
}
else{
(D)((2),(null),([({S:({S:({S:""}).S+((v)((aw),([129,2]))).S}).S+({S:""}).S})]));
return false;
}
}
if((y)===(null)){
return true;
}
if((bc)===(null)){
(bL)=(0);
}
else{
bO=bc;
if(bO.S===({S:"cui"}).S){
(bL)=(0);
}
else if(bO.S===({S:"wnd"}).S){
(bL)=(1);
}
else if(bO.S===({S:"web"}).S){
(bL)=(2);
}
else if(bO.S===({S:"cpp"}).S){
(bL)=(3);
}
else{(D)((1),(null),([({S:"-e"})]));
}
}
if((by)===(null)){
(bW)=((bX)((1),(4294967295)));
}
else{
(bW)=((bZ=(ca)((by),(cb={$:(cc)},cb)),(cc)=cb.$,bZ));
if(!(cc)){
(D)((1),(null),([({S:"-a"})]));
return false;
}
}
if((V)===(null)){
(V)=({S:((ch)((y))).S+({S:"out"}).S});
}
else{
(V)=((cj)((V)));
}
if((W)===(null)){
(W)=({S:"sys/"});
}
if((X)===(null)){
(X)=({S:(W).S+({S:"default.ico"}).S});
}
(Z)=((ch)((y)));
(aa)=((cj)(((co)((y)))));
(ab)=((ch)((V)));
if(((cq)((y))).S!==({S:"kn"}).S){
(D)((3),(null),([(aa)]));
}
return true;
}
// exitCode
function q(cs /*code*/){
if(((cs)<(0))||((4294967295)<(cs))){
throw 3910598662;
}
}
// print
function u(cx /*str*/){
if(O_&&O_.print){O_.print(cx.S);return;}
console.log(cx.S);
}
// _toStr
function v(cy /*me_*/,cz /*type*/){
let n_;
switch(cz[0]){
case 0:
case 1:
case 9:
return{S:cy.toString(10)};
case 2:
return{S:String.fromCharCode(cy)};
case 3:
return{S:cy?"true":"false"};
case 4:
n_=cy>=0?~~cy&0xFF:0xFF-(~cy&0xFF);
return{S:"0x"+("00"+n_.toString(16)).slice(-2).toUpperCase()};
case 5:
n_=cy>=0?~~cy&0xFFFF:0xFFFF-(~cy&0xFFFF);
return{S:"0x"+("0000"+n_.toString(16)).slice(-4).toUpperCase()};
case 6:
n_=cy>>>0;
return{S:"0x"+("00000000"+n_.toString(16)).slice(-8).toUpperCase()};
case 7:
n_=cy>>>0;
return{S:"0x"+((cy>=0?"0000000000000000":"FFFFFFFFFFFFFFFF")+n_.toString(16)).slice(-16).toUpperCase()};
case 129:
if(cz[1]===2)
return cy;
}
}
// build
function B(){
let c1=0; // beginTime
let c3=null; // asts
let c5=null; // entry
let cD=null; // resDir
let cE=null; // resFiles
let cN=0;
(c0)=(0);
(c1)=((c2)());
(D)((196611),(null),([((v)(((((c2)())-(c1))/(1000)),([1])))]));
(c3)=((c4)());
(D)((196612),(null),([((v)(((((c2)())-(c1))/(1000)),([1])))]));
(c5)=((c6)((c3)));
(D)((196613),(null),([((v)(((((c2)())-(c1))/(1000)),([1])))]));
if((c0)>(0)){
return false;
}
(cD)=({S:(Z).S+({S:"res/"}).S});
(cE)=(new cF());
((cE).cG)=({L:0,H:null,T:null,P:null});
if((cI)((cD))){
(cK)((cD),(true),(cL),(cE));
}
switch(bL){
case 3:
if(!((cQ)((c5),((cE).cG)))){
return false;
}
break;
case 2:
if(!((cU)((c5),((cE).cG)))){
return false;
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(D)((196614),(null),([((v)(((((c2)())-(c1))/(1000)),([1])))]));
return true;
}
// err
function D(cX /*id*/,cY /*pos*/,cZ /*args*/){
let dc=null; // msg
if(((cX)<(196608))&&((c0)>=(100))){
return;
}
(dc)=((dd)((cX),(cZ)));
(u)(({S:((v)((cX),([6]))).S+({S:": "}).S}));
if((cY)!==(null)){
(u)(({S:({S:({S:"["}).S+((v)(((cY).dh),([129,2]))).S}).S+({S:({S:({S:": "}).S+((v)(((cY).di),([0]))).S}).S+({S:({S:({S:", "}).S+((v)(((cY).dj),([0]))).S}).S+({S:"]"}).S}).S}).S}));
}
(u)(({S:(dc).S+({S:"\u000A"}).S}));
if((cX)<(196608)){
(c0)=((c0)+(1));
}
}
// cmdLine
function ar(){
let r_=(O_&&O_.cmdLine)?O_.cmdLine:location.search.slice(1).split("&");
if(r_.length===1&&r_[0]==="")return[];
for(let i_=0;i_<r_.length;i_++)
r_[i_]={S:r_[i_]};
return r_;
}
// getArg1
function a5(dn /*out*/,dp /*cmdLines*/,dq /*idx*/,dr /*option*/){
if(((dn.$)!==(null))||(((dq.$)+(1))>=((dp).length))){
(D)((1),(null),([({S:({S:({S:"-"}).S+((v)((dr),([2]))).S}).S+({S:""}).S})]));
return false;
}
(dn.$)=((dp)[(dq.$)+(1)]);
(dq.$)=((dq.$)+(1));
return true;
}
// getArg0
function aU(dv /*out*/,dw /*option*/){
if((dv.$)!==(false)){
(D)((1),(null),([({S:({S:({S:"-"}).S+((v)((dw),([2]))).S}).S+({S:""}).S})]));
return false;
}
(dv.$)=(true);
return true;
}
// _addDict
function bE(dz /*me_*/,d0 /*type*/,d1 /*key*/,d2 /*item*/){
if(d0[1]===129&&d0[2]===2)
dz.set(d1.S, d2);
else
dz.set(d1, d2);
}
// rnd
function bX(d3 /*min*/,d4 /*max*/){
return ~~(Math.random()*(d4-d3+1))+d3;
}
// _toInt
function ca(d5 /*me_*/,d6 /*success*/){
if(d5.S.length>=2&&d5.S[0]==="0"&&d5.S[1]==="x"){
let s_=d5.S.slice(2),r_=Number(d5.S);
d6.$=!isNaN(r_);
return parseInt(s_,16);
}else{
let r_=Number(d5.S);
d6.$=!isNaN(r_);
return parseInt(d5.S,10);
}
}
// dir
function ch(d7 /*path*/){
let d8=0; // p
let dE=null; // r
let dH=0;
let dI=0;
let dJ=0;
let dK=0;
if(!((d7)!==(null))){throw 0xE9170000;}
(d8)=(((d7).S.length)-(1));
while((((d8)>=(0))&&(((d7).S.charCodeAt(d8))!==(0x002F)))&&(((d7).S.charCodeAt(d8))!==(0x005C))){
(d8)=((d8)-(1));
}
if((d8)<(0)){
return {S:"./"};
}
else{
(dE)=({S:"\0".repeat((d8)+(1))});
dG:
for(dH=(0),dI=(d8);dH<=dI;dH+=(1)){
(dE).S=(dJ=(dH),(dE).S.slice(0,dJ)+String.fromCharCode((((d7).S.charCodeAt(dH))===(0x005C))?(0x002F):((d7).S.charCodeAt(dH)))+(dE).S.slice(dJ+1));
}
return dE;
}
}
// delExt
function cj(dL /*path*/){
let dM=0; // p
let dR=null; // r
let dU=0;
let dV=0;
let dW=0;
let dX=0;
if(!((dL)!==(null))){throw 0xE9170000;}
(dM)=(((dL).S.length)-(1));
while(((((dM)>=(0))&&(((dL).S.charCodeAt(dM))!==(0x002F)))&&(((dL).S.charCodeAt(dM))!==(0x005C)))&&(((dL).S.charCodeAt(dM))!==(0x002E))){
(dM)=((dM)-(1));
}
if(((dM)<(0))||(((dL).S.charCodeAt(dM))!==(0x002E))){
return dL;
}
(dR)=({S:"\0".repeat(dM)});
dT:
for(dU=(0),dV=((dM)-(1));dU<=dV;dU+=(1)){
(dR).S=(dW=(dU),(dR).S.slice(0,dW)+String.fromCharCode((((dL).S.charCodeAt(dU))===(0x005C))?(0x002F):((dL).S.charCodeAt(dU)))+(dR).S.slice(dW+1));
}
return dR;
}
// fileName
function co(dY /*path*/){
let dZ=0; // p
let ef=null; // r
let ei=0;
let ej=0;
let ek=0;
let el=0;
if(!((dY)!==(null))){throw 0xE9170000;}
(dZ)=(((dY).S.length)-(1));
while((((dZ)>=(0))&&(((dY).S.charCodeAt(dZ))!==(0x002F)))&&(((dY).S.charCodeAt(dZ))!==(0x005C))){
(dZ)=((dZ)-(1));
}
if((dZ)<(0)){
return dY;
}
(dZ)=((dZ)+(1));
(ef)=({S:"\0".repeat(((dY).S.length)-(dZ))});
eh:
for(ei=(0),ej=((((dY).S.length)-(dZ))-(1));ei<=ej;ei+=(1)){
(ef).S=(ek=(ei),(ef).S.slice(0,ek)+String.fromCharCode((dY).S.charCodeAt((dZ)+(ei)))+(ef).S.slice(ek+1));
}
return ef;
}
// ext
function cq(em /*path*/){
let en=0; // p
let eu=null; // r
let ex=0;
let ey=0;
let ez=0;
let e0=0;
if(!((em)!==(null))){throw 0xE9170000;}
(en)=(((em).S.length)-(1));
while(((((en)>=(0))&&(((em).S.charCodeAt(en))!==(0x002F)))&&(((em).S.charCodeAt(en))!==(0x005C)))&&(((em).S.charCodeAt(en))!==(0x002E))){
(en)=((en)-(1));
}
if(((em).S.charCodeAt(en))!==(0x002E)){
return {S:""};
}
else{
(en)=((en)+(1));
(eu)=({S:"\0".repeat(((em).S.length)-(en))});
ew:
for(ex=(0),ey=((((em).S.length)-(en))-(1));ex<=ey;ex+=(1)){
(eu).S=(ez=(ex),(eu).S.slice(0,ez)+String.fromCharCode((em).S.charCodeAt((en)+(ex)))+(eu).S.slice(ez+1));
}
return eu;
}
}
// sysTime
function c2(){
return new Date().getTime();
}
// parse
function c4(){
let e1=null; // endFlag
(ad)=(new Map());
(bE)((ad),([133,129,2,134]),({S:({S:"\\"}).S+(aa).S}),(null));
(bE)((ad),([133,129,2,134]),({S:"kuin"}),(null));
(e1)=(new e2());
((e1).e3)=(false);
while(!((e1).e3)){
((e1).e3)=(true);
(ae)=(new Map());
(e5)((ad),([133,129,2,134]),(e6),(e1));
(ad)=(ae);
}
return ad;
}
// analyze
function c6(e7 /*asts*/){
let e8=null; // mainFunc
(I)=(e7);
(e8)=((e9)());
if((e8)===(null)){
return null;
}
(e5)((e7),([133,129,2,134]),(eC),(null));
return (eD)((e8));
}
// exist
function cI(eE /*path*/){
let f_=false,p_=eE.S;
if(O_&&O_.readFile)f_=O_.readFile(p_)!==null;
if(f_===false){
if(p_.length>=4&&p_[0]==="r"&&p_[1]==="e"&&p_[2]==="s"&&p_[3]==="/")
f_=F_(p_,false);
else{
}
}
return f_;
}
// forEach
function cK(eF /*path*/,eG /*recursion*/,eH /*callback*/,eI /*data*/){
let f_,p_=eF.S;
if(p_.length>=4&&p_[0]==="r"&&p_[1]==="e"&&p_[2]==="s"&&p_[3]==="/")
f_=FF_();
for(let i_=0;i_<f_.length;i_++){
if(f_[i_].slice(0,p_.length)===p_&&(eG||f_[i_].slice(p_.length).indexOf("/")===-1)){
if(!eH({S:f_[i_]},f_[i_][f_[i_].length-1]==='/',eI))return false}
}
return true;
}
// searchResFiles
function cL(eJ /*path*/,eK /*isDir*/,eL /*data*/){
let eM=null; // data2
(eM)=(eL);
(eN)(((eM).cG),([130,129,2]),(eJ));
return true;
}
// output
function cQ(eO /*entry*/,eP /*resFiles*/){
let eU=null; // func_
let eY=null; // class_
(K)=([]);
(eQ)((K),([132,134]),(eO));
(L)=([]);
(M)=({S:"a"});
(N)=({L:0,H:null,T:null,P:null});
(O)=({L:0,H:null,T:null,P:null});
(P)=({L:0,H:null,T:null,P:null});
(Q)=({L:0,H:null,T:null,P:null});
(R)=({L:0,H:null,T:null,P:null});
(S)=({L:0,H:null,T:null,P:null});
(T)=({L:0,H:null,T:null,P:null});
(eR)=(0);
(U)=({L:0,H:null,T:null,P:null});
while((((K).length)>(0))||(((L).length)>(0))){
while(((K).length)>(0)){
(eU)=((eV)((K),([132,134])));
(eW)((eU));
}
while(((L).length)>(0)){
(eY)=((eV)((L),([132,134])));
(fa)((eY));
}
}
(fb)((eP));
return true;
}
// output
function cU(fc /*entry*/,fd /*resFiles*/){
let fg=null; // func_
let fj=null; // class_
(aj)=([]);
(eQ)((aj),([132,134]),(fc));
(ak)=([]);
(al)=({S:"a"});
(am)=({L:0,H:null,T:null,P:null});
(an)=({L:0,H:null,T:null,P:null});
(ao)=({L:0,H:null,T:null,P:null});
(ap)=({L:0,H:null,T:null,P:null});
while((((aj).length)>(0))||(((ak).length)>(0))){
while(((aj).length)>(0)){
(fg)=((eV)((aj),([132,134])));
(fh)((fg));
}
while(((ak).length)>(0)){
(fj)=((eV)((ak),([132,134])));
(fk)((fj));
}
}
(fl)((fd));
return true;
}
// get
function dd(fm /*id*/,fn /*args*/){
let fp=0;
let fs=0;
let fx=0;
let f2=0;
let f7=0;
let fC=0;
let fH=0;
let fM=0;
let fR=0;
let fW=0;
let gb=0;
let gg=0;
let gl=0;
let gq=0;
let gv=0;
let g0=0;
let g5=0;
let gA=0;
let gF=0;
let gK=0;
let gP=0;
let gU=0;
let gZ=0;
let he=0;
let hj=0;
let ho=0;
let ht=0;
let hy=0;
let h3=0;
let h8=0;
let hD=0;
let hI=0;
let hN=0;
let hS=0;
let hX=0;
let ic=0;
let ii=0;
let io=0;
let it=0;
let iy=0;
let i3=0;
let i8=0;
let iD=0;
let iI=0;
let iN=0;
let iS=0;
let iX=0;
let jc=0;
let jh=0;
let jm=0;
let jr=0;
let jw=0;
let j1=0;
let j6=0;
let jB=0;
let jG=0;
let jL=0;
let jQ=0;
let jV=0;
let ka=0;
let kf=0;
let kk=0;
let kp=0;
let ku=0;
let kz=0;
let k4=0;
let k9=0;
let kE=0;
let kJ=0;
let kO=0;
let kT=0;
let kY=0;
let ld=0;
let li=0;
let ln=0;
let ls=0;
let lx=0;
let l2=0;
let l7=0;
let lC=0;
let lH=0;
let lM=0;
let lR=0;
let lW=0;
let mb=0;
let mg=0;
let ml=0;
let mq=0;
let mv=0;
let m0=0;
let m5=0;
let mA=0;
let mF=0;
let mK=0;
let mP=0;
let mU=0;
let mZ=0;
let ne=0;
let nj=0;
let no=0;
let nt=0;
let ny=0;
let n3=0;
let n8=0;
let nD=0;
let nI=0;
let nN=0;
let nS=0;
let nX=0;
let oc=0;
let oh=0;
let om=0;
let or=0;
let ow=0;
let o1=0;
let o6=0;
let oB=0;
let oG=0;
let oL=0;
let oQ=0;
let oV=0;
let pa=0;
let pf=0;
let pk=0;
let pp=0;
switch(fm){
case 1:
switch(m){
case 0:
return {S:({S:({S:"\u30AA\u30D7\u30B7\u30E7\u30F3\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u4F7F\u308F\u308C\u65B9\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The option \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' was used incorrectly."}).S};
break;
}
break;
case 2:
switch(m){
case 0:
return {S:({S:({S:"\u4E0D\u660E\u306A\u30AA\u30D7\u30B7\u30E7\u30F3\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u6307\u5B9A\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"Unexpected option: \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 3:
switch(m){
case 0:
return {S:({S:({S:"\u5165\u529B\u30D5\u30A1\u30A4\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u62E1\u5F35\u5B50\u306F\u300C.kn\u300D\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The extension of the input file \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' must be \'.kn\'."}).S};
break;
}
break;
case 4:
switch(m){
case 0:
return {S:({S:({S:"\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u540D\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306B\u4F7F\u3048\u306A\u3044\u6587\u5B57\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The source file name \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' contains characters that cannot be used."}).S};
break;
}
break;
case 5:
switch(m){
case 0:
return {S:({S:({S:"\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u958B\u3051\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"Cannot open source file \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 6:
switch(m){
case 0:
return {S:({S:({S:"\u30B7\u30B9\u30C6\u30E0\u30D5\u30A1\u30A4\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u958B\u3051\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The system file \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' could not be opened."}).S};
break;
}
break;
case 7:
switch(m){
case 0:
return {S:({S:({S:"\u30B7\u30B9\u30C6\u30E0\u30D5\u30A1\u30A4\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u58CA\u308C\u3066\u3044\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The system file \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' is broken."}).S};
break;
}
break;
case 65537:
switch(m){
case 0:
return {S:({S:({S:"\u540C\u3058\u30B9\u30B3\u30FC\u30D7\u5185\u306B\u65E2\u306B\u540C\u3058\u8B58\u5225\u5B50\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u5B58\u5728\u3057\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The same identifier \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' already exists in the same scope."}).S};
break;
}
break;
case 65538:
switch(m){
case 0:
return {S:({S:({S:"\u4E0A\u4F4D\u306E\u30B9\u30B3\u30FC\u30D7\u5185\u306B\u65E2\u306B\u540C\u3058\u8B58\u5225\u5B50\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u5B58\u5728\u3057\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The same identifier \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' already exists in the upper scope."}).S};
break;
}
break;
case 65539:
switch(m){
case 0:
return {S:"\u30B3\u30E1\u30F3\u30C8\u306E\u300C{\u300D\u306B\u5BFE\u5FDC\u3059\u308B\u300C}\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"There is no \'}\' corresponding to \'{\' for comment."};
break;
}
break;
case 65540:
switch(m){
case 0:
return {S:"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3084\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u4E2D\u306B\u30BF\u30D6\u6587\u5B57\u306F\u8A18\u8FF0\u3067\u304D\u307E\u305B\u3093\u3002 \u30A8\u30B9\u30B1\u30FC\u30D7\u30B7\u30FC\u30B1\u30F3\u30B9\u300C\\t\u300D\u3092\u4EE3\u7528\u3057\u3066\u304F\u3060\u3055\u3044\u3002"};
break;
default:
return {S:"Tab characters cannot be written in character literals and string literals. Use the escape sequence \'\\t\' instead."};
break;
}
break;
case 65541:
switch(m){
case 0:
return {S:"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3084\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u4E2D\u3067\u306F\u6539\u884C\u3067\u304D\u307E\u305B\u3093\u3002 \u30A8\u30B9\u30B1\u30FC\u30D7\u30B7\u30FC\u30B1\u30F3\u30B9\u300C\\n\u300D\u3092\u4EE3\u7528\u3057\u3066\u304F\u3060\u3055\u3044\u3002"};
break;
default:
return {S:"Line breaks are not allowed in character literals and string literals. Use the escape sequence \'\\n\' instead."};
break;
}
break;
case 65542:
switch(m){
case 0:
return {S:({S:({S:"\u8B58\u5225\u5B50\u306B\u306F\u4F7F\u3048\u306A\u3044\u6587\u5B57\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The character \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' that cannot be used in identifiers was written."}).S};
break;
}
break;
case 65543:
switch(m){
case 0:
return {S:"\u8B58\u5225\u5B50\u306B\u6B63\u3057\u304F\u306A\u3044\u5F62\u5F0F\u3067\u300C@\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"Incorrect \'@\' was written in an identifier."};
break;
}
break;
case 65544:
switch(m){
case 0:
return {S:({S:({S:"\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u540D\u306E\u6307\u5B9A\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306B\u5927\u6587\u5B57\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"A source file name description \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' contains uppercase letters."}).S};
break;
}
break;
case 65545:
switch(m){
case 0:
return {S:"\u8B58\u5225\u5B50\u306B\u6B63\u3057\u304F\u306A\u3044\u5F62\u5F0F\u3067\u300C\\\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"Incorrect \'\\\' was written in an identifier."};
break;
}
break;
case 65546:
switch(m){
case 0:
return {S:({S:({S:"\u8B58\u5225\u5B50\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 128\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The identifier \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"...\' is too long. Must be 128 characters or less."}).S};
break;
}
break;
case 65547:
switch(m){
case 0:
return {S:({S:({S:"\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u30D6\u30ED\u30C3\u30AF\u3082\u3057\u304F\u306F\u6587\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"An incorrect block or sentence \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' was written."}).S};
break;
}
break;
case 65548:
switch(m){
case 0:
return {S:({S:({S:"\u95A2\u6570\u5C5E\u6027\u306B\u306F\u4F7F\u3048\u306A\u3044\u6587\u5B57\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The character \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' that cannot be used in function attributes was written."}).S};
break;
}
break;
case 65549:
switch(m){
case 0:
return {S:({S:({S:"\u95A2\u6570\u5C5E\u6027\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 128\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The function attribute \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"...\' is too long. Must be 128 characters or less."}).S};
break;
}
break;
case 65550:
switch(m){
case 0:
return {S:({S:({S:"\u6587\u5B57\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u308B\u3079\u304D\u7B87\u6240\u306B\u3001\u4E0D\u6B63\u306A\u6587\u5B57\u300C"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S}).S};
break;
default:
return {S:({S:({S:"An invalid character \'"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\' was written in a place where the character \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' should be written."}).S}).S};
break;
}
break;
case 65551:
switch(m){
case 0:
return {S:({S:({S:"\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u306B\u5BFE\u5FDC\u3059\u308B\u300Cend "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002"}).S}).S};
break;
default:
return {S:({S:({S:"There is no \'end "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\' corresponding to \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\'."}).S}).S};
break;
}
break;
case 65552:
switch(m){
case 0:
return {S:({S:({S:"\u95A2\u6570\u4EE5\u5916\u306E\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"Overridden non-function member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 65553:
switch(m){
case 0:
return {S:({S:({S:"\u95A2\u6570\u304A\u3088\u3073\u5909\u6570\u4EE5\u5916\u306E\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u3092\u516C\u958B\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' other than functions and variables has been released."}).S};
break;
}
break;
case 65554:
switch(m){
case 0:
return {S:({S:({S:"\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u304C\u300Cend "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u3067\u306F\u306A\u304F\u4E0D\u6B63\u306A\u300Cend "}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:"\u300D\u3067\u9589\u3058\u3089\u308C\u307E\u3057\u305F\u3002"}).S}).S}).S};
break;
default:
return {S:({S:({S:"\'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\' was closed with invalid \'end "}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\' instead of \'end "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\'."}).S}).S}).S};
break;
}
break;
case 65555:
switch(m){
case 0:
return {S:({S:({S:"\u6B63\u3057\u304F\u306A\u3044\u5F62\u5F0F\u306E\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"Incorrectly formatted member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' was written."}).S};
break;
}
break;
case 65556:
switch(m){
case 0:
return {S:"\u5F15\u6570\u4EE5\u5916\u306E\u5909\u6570\u306B\u4E0D\u6B63\u306A\u300C&\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"An invalid \'&\' was written in other than an argument."};
break;
}
break;
case 65557:
switch(m){
case 0:
return {S:"\u5F15\u6570\u306B\u521D\u671F\u5316\u5B50\u300C::\u300D\u3092\u8A18\u8FF0\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The initializer \'::\' cannot be written in arguments."};
break;
}
break;
case 65558:
switch(m){
case 0:
return {S:"\u30E1\u30F3\u30D0\u306B\u521D\u671F\u5316\u5B50\u300C::\u300D\u3092\u8A18\u8FF0\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The initializer \'::\' cannot be written in members."};
break;
}
break;
case 65559:
switch(m){
case 0:
return {S:"const\u6587\u306B\u306F\u521D\u671F\u5316\u5B50\u300C::\u300D\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The initializer \'::\' must be written in const statements."};
break;
}
break;
case 65560:
switch(m){
case 0:
return {S:"\u30D6\u30ED\u30C3\u30AF\u306B\u5BFE\u5FDC\u3059\u308B\u300Cend\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"There is no \'end\' corresponding to a block."};
break;
}
break;
case 65561:
switch(m){
case 0:
return {S:({S:({S:"\u300Cend "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306F\u4E0D\u6B63\u306A\u5F62\u5F0F\u3067\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"\'end "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' is incorrectly formatted."}).S};
break;
}
break;
case 65562:
switch(m){
case 0:
return {S:({S:({S:"\u30D6\u30ED\u30C3\u30AF\u3068\u5BFE\u5FDC\u3057\u306A\u3044\u4E0D\u6B63\u306A\u300Cend "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u3067\u9589\u3058\u3089\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"Closed with invalid \'end "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' that does not correspond to the block."}).S};
break;
}
break;
case 65563:
switch(m){
case 0:
return {S:"\u300Cif\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Celse\u300D\u7BC0\u306E\u5F8C\u306B\u4E0D\u6B63\u306A\u300Celif\u300D\u7BC0\u3084\u300Celse\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"In an \'if\' block, an invalid \'elif\' or \'else\' clauses is written after an \'else\' clause."};
break;
}
break;
case 65564:
switch(m){
case 0:
return {S:"\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Cdefault\u300D\u7BC0\u306E\u5F8C\u306B\u4E0D\u6B63\u306A\u300Ccase\u300D\u7BC0\u3084\u300Cdefault\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"In a \'switch\' block, an invalid \'case\' or \'default\' clauses is written after a \'default\' clause."};
break;
}
break;
case 65565:
switch(m){
case 0:
return {S:"\u300Ctry\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Cfinally\u300D\u7BC0\u306E\u5F8C\u306B\u4E0D\u6B63\u306A\u300Ccatch\u300D\u7BC0\u3084\u300Cfinally\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"In a \'try\' block, an invalid \'catch\' or \'finally\' clauses is written after a \'finally\' clause."};
break;
}
break;
case 65566:
switch(m){
case 0:
return {S:({S:({S:"\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u30D6\u30ED\u30C3\u30AF\u4EE5\u5916\u3067\u4E0D\u6B63\u306A\u300C"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:"\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S}).S};
break;
default:
return {S:({S:({S:"A invalid \'"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\' clause was written outside \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' blocks."}).S}).S};
break;
}
break;
case 65567:
switch(m){
case 0:
return {S:"\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Ccase\u300D\u300Cdefault\u300D\u300Cend switch\u300D\u306E\u3044\u305A\u308C\u304B\u304C\u8A18\u8FF0\u3055\u308C\u308B\u3079\u304D\u7B87\u6240\u306B\u305D\u308C\u4EE5\u5916\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"In a \'switch\' block, clauses other than \'case\', \'default\' and \'end switch\' were written."};
break;
}
break;
case 65568:
switch(m){
case 0:
return {S:({S:({S:"\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u308B\u3079\u304D\u7B87\u6240\u306B\u4E0D\u6B63\u306A\u300C"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S}).S};
break;
default:
return {S:({S:({S:"An invalid \'"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\' was written where \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' should be written."}).S}).S};
break;
}
break;
case 65569:
switch(m){
case 0:
return {S:({S:({S:"\u300C\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u6F14\u7B97\u5B50\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"An incorrect operator \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' was written."}).S};
break;
}
break;
case 65570:
switch(m){
case 0:
return {S:({S:({S:"\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 1024\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The string literal \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' is too long. Must be 1024 characters or less."}).S};
break;
}
break;
case 65571:
switch(m){
case 0:
return {S:({S:({S:"\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u30A8\u30B9\u30B1\u30FC\u30D7\u30B7\u30FC\u30B1\u30F3\u30B9\u300C\\"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"A invalid escape sequence \'\\"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' was written."}).S};
break;
}
break;
case 65572:
switch(m){
case 0:
return {S:"\u6587\u5B57\u30B3\u30FC\u30C9\u8868\u8A18\u306F\u300C\\u\u300D\u306B\u7D9A\u3044\u3066\u3001\u6570\u5B57\u307E\u305F\u306F\u5927\u6587\u5B57\u30A2\u30EB\u30D5\u30A1\u30D9\u30C3\u30C8\u30674\u6841\u306E16\u9032\u6570\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"Character code representations must be \'\\u\' followed by a 4-digit hexadecimal number in numbers or capital letters."};
break;
}
break;
case 65573:
switch(m){
case 0:
return {S:"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3082\u3057\u304F\u306F\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u304C\u9589\u3058\u3089\u308C\u3066\u3044\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"A character literal or string literal is not closed."};
break;
}
break;
case 65574:
switch(m){
case 0:
return {S:({S:({S:"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 1\u6587\u5B57\u5206\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The character literal \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"...\' is too long. A character literal must contain one character."}).S};
break;
}
break;
case 65575:
switch(m){
case 0:
return {S:"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u304C\u7A7A\u3067\u3059\u3002 1\u6587\u5B57\u5206\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"There is an empty character literal. A character literal must contain one character."};
break;
}
break;
case 65576:
switch(m){
case 0:
return {S:"\u62EC\u5F27\u300C(\u300D\u306B\u5BFE\u5FDC\u3059\u308B\u300C)\u300D\u304C\u3001\u3042\u308B\u3079\u304D\u5834\u6240\u306B\u5B58\u5728\u3057\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The \')\' corresponding to the parenthesis \'(\' does not exist where it should be."};
break;
}
break;
case 65577:
switch(m){
case 0:
return {S:({S:({S:"\u6570\u5024\u30EA\u30C6\u30E9\u30EB\u306B\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"An invalid \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' was written in a numeric literal."}).S};
break;
}
break;
case 65578:
switch(m){
case 0:
return {S:({S:({S:"\u6570\u5024\u30EA\u30C6\u30E9\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 1024\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The numeric literal \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' is too long. Must be 1024 characters or less."}).S};
break;
}
break;
case 65579:
switch(m){
case 0:
return {S:"16\u9032\u6570\u30EA\u30C6\u30E9\u30EB\u306F\u300C0x\u300D\u304B\u3089\u59CB\u3081\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"Hexadecimal literals must start with \'0x\'."};
break;
}
break;
case 65580:
switch(m){
case 0:
return {S:"\u6307\u6570\u8868\u8A18\u30EA\u30C6\u30E9\u30EB\u306F\u300Ce+\u300D\u3082\u3057\u304F\u306F\u300Ce-\u300D\u304B\u3089\u59CB\u3081\u3066\u6307\u6570\u90E8\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"Exponential notation literals must start with \'e+\' or \'e-\' and write the exponent part."};
break;
}
break;
case 65581:
switch(m){
case 0:
return {S:({S:({S:"\u6D6E\u52D5\u5C0F\u6570\u70B9\u30EA\u30C6\u30E9\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u89E3\u91C8\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002 \u5024\u304C\u5927\u304D\u3059\u304E\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The floating point literal \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' could not be interpreted. The value may be too large."}).S};
break;
}
break;
case 65582:
switch(m){
case 0:
return {S:({S:({S:"\u30D3\u30C3\u30C8\u578B\u30EA\u30C6\u30E9\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u63A5\u5C3E\u8F9E\u306F\u300Cb8\u300D\u300Cb16\u300D\u300Cb32\u300D\u300Cb64\u300D\u306E\u3044\u305A\u308C\u304B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The suffix of bit type literal \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' must be either \'b8\', \'b16\', \'b32\' or \'b64\'."}).S};
break;
}
break;
case 65583:
switch(m){
case 0:
return {S:({S:({S:"\u6574\u6570\u30EA\u30C6\u30E9\u30EB\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u30AA\u30FC\u30D0\u30FC\u30D5\u30ED\u30FC\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The integer literal \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' has overflowed."}).S};
break;
}
break;
case 131073:
switch(m){
case 0:
return {S:"\u300Cmain\u300D\u95A2\u6570\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002 \u30B3\u30F3\u30D1\u30A4\u30EB\u3059\u308B\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u306B\u300Cfunc main()\u300D\u3092\u5B9A\u7FA9\u3057\u3066\u304F\u3060\u3055\u3044\u3002"};
break;
default:
return {S:"\'main\' function does not exist. Define \'func main()\' in the source files to be compiled."};
break;
}
break;
case 131074:
switch(m){
case 0:
return {S:"\u300Cmain\u300D\u95A2\u6570\u306E\u5B9A\u7FA9\u306F\u300Cfunc main()\u300D\u3068\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The definition of the \'main\' function must be \'func main()\'."};
break;
}
break;
case 131075:
switch(m){
case 0:
return {S:({S:({S:"\u30E1\u30F3\u30D0\u3082\u3057\u304F\u306F\u5909\u6570\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306B\u3001\u300Cme\u300D\u3092\u4ECB\u3055\u305A\u76F4\u63A5\u30A2\u30AF\u30BB\u30B9\u3057\u305F\u304B\u3001\u95A2\u6570\u3092\u8D85\u3048\u3066\u30A2\u30AF\u30BB\u30B9\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The member or variable \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' was accessed directly without \'me\', or accessed beyond the function."}).S};
break;
}
break;
case 131076:
switch(m){
case 0:
return {S:({S:({S:"\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"@\u300D\u306B\u3064\u3044\u3066\u3001\u81EA\u8EAB\u306E\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u306E\u30B0\u30ED\u30FC\u30D0\u30EB\u8981\u7D20\u3092\u53C2\u7167\u3059\u308B\u3068\u304D\u306F\u3001\u300C@\u300D\u306E\u524D\u306E\u30BD\u30FC\u30B9\u540D\u3092\u7701\u7565\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"For \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"@\', when referring to global elements in its own source file, the source name before the \'@\' must be omitted."}).S};
break;
}
break;
case 131077:
switch(m){
case 0:
return {S:({S:({S:"\u4ED6\u306E\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u306E\u516C\u958B\u3055\u308C\u3066\u3044\u306A\u3044\u8981\u7D20\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u3092\u53C2\u7167\u3057\u307E\u3057\u305F\u3002\u8981\u7D20\u306E\u5148\u982D\u306B\u300C+\u300D\u304C\u4ED8\u3044\u3066\u3044\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"A non-public element \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' in another souce file was referenced. The element must start with a \'+\'."}).S};
break;
}
break;
case 131078:
switch(m){
case 0:
return {S:({S:({S:"\u8B58\u5225\u5B50\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u5B9A\u7FA9\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002\u540D\u524D\u3092\u9593\u9055\u3048\u3066\u3044\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The definition of identifier \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' was not be found. The name may have been written incorrectly."}).S};
break;
}
break;
case 131079:
switch(m){
case 0:
return {S:({S:({S:"\u300Calias "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u5B9A\u7FA9\u304C\u5FAA\u74B0\u3057\u3066\u3044\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The definition of \'alias "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' is circulating."}).S};
break;
}
break;
case 131080:
switch(m){
case 0:
return {S:({S:({S:"\u300Cclass "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u7D99\u627F\u304C\u5FAA\u74B0\u3057\u3066\u3044\u307E\u3059\u3002"}).S};
break;
default:
return {S:({S:({S:"The inheritance of \'class "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' is circulating."}).S};
break;
}
break;
case 131081:
switch(m){
case 0:
return {S:({S:({S:"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B\u89AA\u30AF\u30E9\u30B9\u306E\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' of the parent class to override cannot be found."}).S};
break;
}
break;
case 131082:
switch(m){
case 0:
return {S:({S:({S:"\u30E1\u30F3\u30D0\u540D\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u89AA\u30AF\u30E9\u30B9\u306E\u3082\u306E\u3068\u91CD\u8907\u3057\u3066\u3044\u307E\u3059\u3002 \u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B\u5834\u5408\u306F\u300C*\u300D\u3092\u4ED8\u3051\u3066\u304F\u3060\u3055\u3044\u3002"}).S};
break;
default:
return {S:({S:({S:"The member name \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' is duplicated with that of the parent class. Add \'*\' when overriding."}).S};
break;
}
break;
case 131083:
switch(m){
case 0:
return {S:({S:({S:"\u95A2\u6570\u4EE5\u5916\u306E\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"Overridden non-function member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 131084:
switch(m){
case 0:
return {S:({S:({S:"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u305F\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u3068\u30A2\u30AF\u30BB\u30B9\u4FEE\u98FE\u5B50\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The access modifier does not match that of the overridden member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 131085:
switch(m){
case 0:
return {S:({S:({S:"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u305F\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u3068\u578B\u3082\u3057\u304F\u306F\u5F15\u6570\u540D\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The types or argument names do not match that of the overridden member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 131086:
switch(m){
case 0:
return {S:({S:({S:"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u304C\u8A31\u53EF\u3055\u308C\u3066\u3044\u306A\u3044\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' that is not allowed to be overridden was overridden."}).S};
break;
}
break;
case 131087:
switch(m){
case 0:
return {S:({S:({S:"\u5217\u6319\u578B\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u306E\u8981\u7D20\u300C%"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:"\u300D\u306E\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u300Cint\u300D\u578B\u306E\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S}).S};
break;
default:
return {S:({S:({S:"The value of the element \'%"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\' of enumeration type \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' must be an \'int\' value that can be made a constant at compile time."}).S}).S};
break;
}
break;
case 131088:
switch(m){
case 0:
return {S:({S:({S:"\u5217\u6319\u578B\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u306E\u8981\u7D20\u300C%"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:"\u300D\u306E\u5024\u304C\u300Cint\u300D\u578B\u306E\u6709\u52B9\u7BC4\u56F2\u3092\u8D85\u3048\u307E\u3057\u305F\u3002"}).S}).S};
break;
default:
return {S:({S:({S:"The value of the element \'%"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\' of enumeration type \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' exceeds the valid range of \'int\' type."}).S}).S};
break;
}
break;
case 131089:
switch(m){
case 0:
return {S:({S:({S:"\u5217\u6319\u578B\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u306E\u8981\u7D20\u300C%"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u306E\u5024\u300C"}).S+((v)(((fn)[2]),([129,2]))).S}).S+({S:"\u300D\u304C\u5225\u306E\u8981\u7D20\u306E\u5024\u3068\u91CD\u8907\u3057\u3066\u3044\u307E\u3059\u3002"}).S}).S}).S};
break;
default:
return {S:({S:({S:"The value \'"}).S+((v)(((fn)[2]),([129,2]))).S}).S+({S:({S:({S:"\' of the element \'%"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\' of enumeration type \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' is duplicated with the value of another element."}).S}).S}).S};
break;
}
break;
case 131090:
switch(m){
case 0:
return {S:({S:({S:"\u5217\u6319\u578B\u5185\u306B\u5B58\u5728\u3057\u306A\u3044\u8981\u7D20\u540D\u300C%"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The element name \'%"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' that does not exist in the enumeration type was written."}).S};
break;
}
break;
case 131091:
switch(m){
case 0:
return {S:({S:({S:"\u30B0\u30ED\u30FC\u30D0\u30EB\u5909\u6570\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The value of global variable \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' must be a constant at compile time."}).S};
break;
}
break;
case 131092:
switch(m){
case 0:
return {S:({S:({S:"\u300Cconst\u300D\u6587\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The value of \'const\' statement \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' must be a constant at compile time."}).S};
break;
}
break;
case 131093:
switch(m){
case 0:
return {S:({S:({S:"\u5909\u6570\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306E\u578B\u3068\u5024\u306E\u578B\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The type of the variable \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' does not match the value type."}).S};
break;
}
break;
case 131094:
switch(m){
case 0:
return {S:"\u300Cif\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The conditional expression of the \'if\' block must be \'bool\' type."};
break;
}
break;
case 131095:
switch(m){
case 0:
return {S:"\u300Celif\u300D\u7BC0\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The conditional expression of the \'elif\' clause must be \'bool\' type."};
break;
}
break;
case 131096:
switch(m){
case 0:
return {S:"\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306F\u6BD4\u8F03\u53EF\u80FD\u306A\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The conditional expression of the \'switch\' block must be a comparable type."};
break;
}
break;
case 131097:
switch(m){
case 0:
return {S:"\u300Ccase\u300D\u7BC0\u306E\u578B\u304C\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306E\u578B\u3068\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The type of the \'case\' clause does not match the type of the conditional expression in the \'switch\' block."};
break;
}
break;
case 131098:
switch(m){
case 0:
return {S:"\u300Cwhile\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The conditional expression of the \'while\' block must be \'bool\' type."};
break;
}
break;
case 131099:
switch(m){
case 0:
return {S:"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u521D\u671F\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The begin value of the \'for\' block must be \'int\' type."};
break;
}
break;
case 131100:
switch(m){
case 0:
return {S:"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u7D42\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The end value of the \'for\' block must be \'int\' type."};
break;
}
break;
case 131101:
switch(m){
case 0:
return {S:"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u5897\u6E1B\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The increase / decrease value of the \'for\' block must be \'int\' type."};
break;
}
break;
case 131102:
switch(m){
case 0:
return {S:"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u5897\u6E1B\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The increase / decrease value of the \'for\' block must be a constant at compile time."};
break;
}
break;
case 131103:
switch(m){
case 0:
return {S:"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u5897\u6E1B\u5024\u306F\u300C0\u300D\u4EE5\u5916\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The increase / decrease value of the \'for\' block must be other than \'0\'."};
break;
}
break;
case 131104:
switch(m){
case 0:
return {S:"\u300Ccatch\u300D\u7BC0\u306E\u6761\u4EF6\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u300Cint\u300D\u578B\u306E\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The condition value in the \'catch\' clause must be an \'int\' value that can be a constant at compile time."};
break;
}
break;
case 131105:
switch(m){
case 0:
return {S:"\u300Cthrow\u300D\u6587\u306E\u4F8B\u5916\u30B3\u30FC\u30C9\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The exception code for the \'throw\' statement must be \'int\'."};
break;
}
break;
case 131106:
switch(m){
case 0:
return {S:"\u623B\u308A\u5024\u3092\u8FD4\u3059\u95A2\u6570\u3067\u306F\u300Cret\u300D\u6587\u306F\u5024\u3092\u8FD4\u3055\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"For functions that return a value, \'ret\' statements must return a value."};
break;
}
break;
case 131107:
switch(m){
case 0:
return {S:"\u300Cret\u300D\u6587\u306E\u5024\u306E\u578B\u304C\u95A2\u6570\u306E\u623B\u308A\u5024\u306E\u578B\u3068\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The type of the \'ret\' statement does not match the return type of the function."};
break;
}
break;
case 131108:
switch(m){
case 0:
return {S:"\u300Cdo\u300D\u6587\u3067\u6700\u5F8C\u306B\u884C\u3046\u6F14\u7B97\u306F\u300C::\u300D\u6F14\u7B97\u5B50\u3084\u95A2\u6570\u547C\u3073\u51FA\u3057\u306A\u3069\u306E\u526F\u4F5C\u7528\u306E\u3042\u308B\u6F14\u7B97\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The last operation in \'do\' statements must be with side effects such as \'::\' operator or function calls."};
break;
}
break;
case 131109:
switch(m){
case 0:
return {S:({S:({S:"\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u6587\u306B\u306F\u30D6\u30ED\u30C3\u30AF\u540D\u3092\u6307\u5B9A\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"\'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' statements must be given block names."}).S};
break;
}
break;
case 131110:
switch(m){
case 0:
return {S:"\u300Cassert\u300D\u6587\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The conditional expression of the \'assert\' statement must be \'bool\' type."};
break;
}
break;
case 131111:
switch(m){
case 0:
return {S:"\u578B\u3092\u8A18\u8FF0\u3059\u3079\u304D\u3068\u3053\u308D\u306B\u578B\u4EE5\u5916\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"A non-type was written where a type should be written."};
break;
}
break;
case 131112:
switch(m){
case 0:
return {S:"\u5024\u304C\u8A2D\u5B9A\u3055\u308C\u308B\u3079\u304D\u5834\u6240\u306B\u5024\u304C\u6E21\u3055\u308C\u307E\u305B\u3093\u3067\u3057\u305F\u3002"};
break;
default:
return {S:"No value was passed where some value should be set."};
break;
}
break;
case 131113:
switch(m){
case 0:
return {S:"\u6F14\u7B97\u5B50\u306E\u578B\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"Incorrect type for operator."};
break;
}
break;
case 131114:
switch(m){
case 0:
return {S:"\u4EE3\u5165\u6F14\u7B97\u5B50\u306E\u5DE6\u8FBA\u5024\u304C\u4EE3\u5165\u53EF\u80FD\u306A\u5909\u6570\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The left value of the assignment operator is not an assignable variable."};
break;
}
break;
case 131115:
switch(m){
case 0:
return {S:"\u300Cnull\u300D\u306F\u5024\u6BD4\u8F03\u304C\u3067\u304D\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"\'null\' cannot be compared by value."};
break;
}
break;
case 131116:
switch(m){
case 0:
return {S:({S:({S:"\u300Cenum\u300D\u306E\u8981\u7D20\u540D\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304B\u3089\u578B\u304C\u63A8\u6E2C\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"The type could not be inferred from the element name \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' of \'enum\'."}).S};
break;
}
break;
case 131117:
switch(m){
case 0:
return {S:"\u300Cnull\u300D\u306F\u300C~\u300D\u6F14\u7B97\u5B50\u3067\u9023\u7D50\u3067\u304D\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"\'null\' cannot be concatenated with the \'~\' operator."};
break;
}
break;
case 131118:
switch(m){
case 0:
return {S:"0\u3067\u9664\u7B97\u3057\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"Divided by 0."};
break;
}
break;
case 131119:
switch(m){
case 0:
return {S:"\u300C:$\u300D\u6F14\u7B97\u5B50\u306E\u5DE6\u8FBA\u5024\u3082\u3057\u304F\u306F\u53F3\u8FBA\u5024\u304C\u4EE3\u5165\u53EF\u80FD\u306A\u5909\u6570\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The left or right value of the \':$\' operator is not an assignable variable."};
break;
}
break;
case 131120:
switch(m){
case 0:
return {S:"\u300C?(,)\u300D\u6F14\u7B97\u5B50\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The conditional expression for the \'?(,)\' operator must be \'bool\'."};
break;
}
break;
case 131121:
switch(m){
case 0:
return {S:"\u300C?(,)\u300D\u6F14\u7B97\u5B50\u306E\u62EC\u5F27\u5185\u306E2\u3064\u306E\u5024\u306F\u540C\u3058\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The two values in the parenthesis for the \'?(,)\' operator must be the same type."};
break;
}
break;
case 131122:
switch(m){
case 0:
return {S:"\u300C#\u300D\u6F14\u7B97\u5B50\u306F\u30AF\u30E9\u30B9\u3084\u300Clist\u300D\u300Cdict\u300D\u306A\u3069\u306E\u53C2\u7167\u578B\u306B\u3057\u304B\u4F7F\u3048\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The \'#\' operator can only be used for reference types such as classes, \'list\' and \'dict\'."};
break;
}
break;
case 131123:
switch(m){
case 0:
return {S:"\u300C#\u300D\u6F14\u7B97\u5B50\u306B\u8A18\u8FF0\u3059\u308B\u914D\u5217\u306E\u8981\u7D20\u6570\u306E\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The number of array elements written in the \'#\' operator must be \'int\'."};
break;
}
break;
case 131124:
switch(m){
case 0:
return {S:"\u95A2\u6570\u3067\u306A\u3044\u3082\u306E\u3092\u95A2\u6570\u547C\u3073\u51FA\u3057\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"A non-function was called as if it were a function."};
break;
}
break;
case 131125:
switch(m){
case 0:
return {S:({S:({S:""}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u500B\u306E\u5F15\u6570\u3092\u53D7\u3051\u53D6\u308B\u95A2\u6570\u547C\u3073\u51FA\u3057\u306B"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\u500B\u306E\u5F15\u6570\u304C\u6307\u5B9A\u3055\u308C\u307E\u3057\u305F\u3002 \u95A2\u6570\u306E\u578B\u306F\u300C"}).S+((v)(((fn)[2]),([129,2]))).S}).S+({S:"\u300D\u3067\u3059\u3002"}).S}).S}).S};
break;
default:
return {S:({S:({S:""}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:" arguments were written in the function call that received "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:" arguments. The function type is \'"}).S+((v)(((fn)[2]),([129,2]))).S}).S+({S:"\'"}).S}).S}).S};
break;
}
break;
case 131126:
switch(m){
case 0:
return {S:({S:({S:"\u95A2\u6570\u547C\u3073\u51FA\u3057\u306E"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u756A\u76EE\u306E\u53C2\u7167\u6E21\u3057\u306E\u5F15\u6570\u306B\u3001\u53C2\u7167\u3092\u53D6\u308C\u306A\u3044\u5024\u304C\u6E21\u3055\u308C\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"A value that cannot be referenced was passed to the "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"th/st/nd/rd argument, which is a reference argument, of the function call."}).S};
break;
}
break;
case 131127:
switch(m){
case 0:
return {S:({S:({S:"\u95A2\u6570\u547C\u3073\u51FA\u3057\u306E\u5F15\u6570\u306E\u578B\u304C\u7570\u306A\u308A\u307E\u3059\u3002 "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:({S:({S:"\u756A\u76EE\u306E\u5F15\u6570\u3067\u300C"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\u300D\u3092\u6307\u5B9A\u3059\u3079\u304D\u3068\u3053\u308D\u306B\u300C"}).S+((v)(((fn)[2]),([129,2]))).S}).S+({S:"\u300D\u304C\u6E21\u3055\u308C\u307E\u3057\u305F\u3002"}).S}).S}).S};
break;
default:
return {S:({S:({S:"The type of arguments of the function call is different. \'"}).S+((v)(((fn)[2]),([129,2]))).S}).S+({S:({S:({S:"\' has been passed where \'"}).S+((v)(((fn)[1]),([129,2]))).S}).S+({S:({S:({S:"\' should be written in the "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"th/st/nd/rd argument."}).S}).S}).S};
break;
}
break;
case 131128:
switch(m){
case 0:
return {S:"\u914D\u5217\u3067\u306A\u3044\u3082\u306E\u306B\u914D\u5217\u30A2\u30AF\u30BB\u30B9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"A non-array was accessed as an array."};
break;
}
break;
case 131129:
switch(m){
case 0:
return {S:"\u914D\u5217\u306E\u6DFB\u5B57\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"Array indices must be \'int\'."};
break;
}
break;
case 131130:
switch(m){
case 0:
return {S:({S:({S:"\u53C2\u7167\u5148\u306E\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002"}).S};
break;
default:
return {S:({S:({S:"The referenced member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' does not exist."}).S};
break;
}
break;
case 131131:
switch(m){
case 0:
return {S:({S:({S:"\u516C\u958B\u3055\u308C\u3066\u3044\u306A\u3044\u30E1\u30F3\u30D0\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u3092\u53C2\u7167\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"An unpublished member \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\' was referenced."}).S};
break;
}
break;
case 131132:
switch(m){
case 0:
return {S:"\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306E\u8981\u7D20\u306E\u578B\u304C\u4E00\u81F4\u3057\u3066\u3044\u307E\u305B\u3093\u3002"};
break;
default:
return {S:"The element types of the array initializer \'[]\' do not match."};
break;
}
break;
case 131133:
switch(m){
case 0:
return {S:"\u5024\u578B\u306E\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306B\u300Cnull\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002"};
break;
default:
return {S:"\'null\' was written in the value type array initializer \'[]\'."};
break;
}
break;
case 131134:
switch(m){
case 0:
return {S:"\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306E\u3059\u3079\u3066\u306E\u8981\u7D20\u304C\u300Cenum\u300D\u306E\u8981\u7D20\u540D\u306E\u305F\u3081\u3001\u578B\u304C\u6C7A\u5B9A\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002 \u3044\u305A\u308C\u304B\u306E\u8981\u7D20\u540D\u3092\u30AD\u30E3\u30B9\u30C8\u3057\u3066\u578B\u3092\u793A\u3057\u3066\u304F\u3060\u3055\u3044\u3002"};
break;
default:
return {S:"The type could not be determined because all elements of the array initializer \'[]\' are element names of \'enum\'. Cast one of the element names to indicate the type."};
break;
}
break;
case 131135:
switch(m){
case 0:
return {S:"\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306E\u3059\u3079\u3066\u306E\u8981\u7D20\u304C\u300Cnull\u300D\u306E\u305F\u3081\u3001\u578B\u304C\u6C7A\u5B9A\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002 \u3044\u305A\u308C\u304B\u306E\u300Cnull\u300D\u3092\u30AD\u30E3\u30B9\u30C8\u3057\u3066\u578B\u3092\u793A\u3057\u3066\u304F\u3060\u3055\u3044\u3002"};
break;
default:
return {S:"The type could not be determined because all elements of the array initializer \'[]\' are \'null\'. Cast one of \'null\' to indicate the type."};
break;
}
break;
case 131136:
switch(m){
case 0:
return {S:({S:({S:"\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u306A\u3044\u8981\u7D20\u300C"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u300D\u306B\u30A2\u30AF\u30BB\u30B9\u3057\u307E\u3057\u305F\u3002"}).S};
break;
default:
return {S:({S:({S:"Accessed inaccessible element \'"}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\'."}).S};
break;
}
break;
case 196609:
switch(m){
case 0:
return {S:"\u6210\u529F\u3002"};
break;
default:
return {S:"Success."};
break;
}
break;
case 196610:
switch(m){
case 0:
return {S:"\u5931\u6557\u3002"};
break;
default:
return {S:"Failure."};
break;
}
break;
case 196611:
switch(m){
case 0:
return {S:({S:({S:"\u30B3\u30F3\u30D1\u30A4\u30EB\u958B\u59CB: "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u79D2\u3002"}).S};
break;
default:
return {S:({S:({S:"Compilation started: "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"s."}).S};
break;
}
break;
case 196612:
switch(m){
case 0:
return {S:({S:({S:"\u5B57\u53E5\u69CB\u6587\u89E3\u6790\u5B8C\u4E86: "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u79D2\u3002"}).S};
break;
default:
return {S:({S:({S:"Parsing is complete: "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"s."}).S};
break;
}
break;
case 196613:
switch(m){
case 0:
return {S:({S:({S:"\u610F\u5473\u89E3\u6790\u5B8C\u4E86: "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u79D2\u3002"}).S};
break;
default:
return {S:({S:({S:"Semantic analysis is complete: "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"s."}).S};
break;
}
break;
case 196614:
switch(m){
case 0:
return {S:({S:({S:"\u751F\u6210\u51E6\u7406\u5B8C\u4E86: "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"\u79D2\u3002"}).S};
break;
default:
return {S:({S:({S:"Generation process is complete: "}).S+((v)(((fn)[0]),([129,2]))).S}).S+({S:"s."}).S};
break;
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// _forEach
function e5(pt /*me_*/,pu /*type*/,pv /*callback*/,pw /*data*/){
let D_={F:pv,D:pw,C:true};
if(pu[1]===129&&pu[2]===2)
pt.forEach(function(V_,K_){if(this.C)this.C=this.F({S:K_},V_,this.D)},D_);
else
pt.forEach(function(V_,K_){if(this.C)this.C=this.F(K_,V_,this.D)},D_);
return D_.C;
}
// parseSrc
function e6(px /*key*/,py /*value*/,pz /*data*/){
let p7=null; // truePath
let pL=null; // ast
if((py)!==(null)){
(bE)((ae),([133,129,2,134]),(px),(py));
return true;
}
if(!((p3)((px)))){
(D)((4),(null),([(px)]));
return true;
}
((pz).e3)=(false);
if(((px).S.charCodeAt(0))===(0x005C)){
(p7)=({S:({S:(Z).S+((p8)(((p9)((px),([129,2]),(1),(-1))))).S}).S+({S:".kn"}).S});
}
else{
(p7)=({S:({S:(W).S+((p8)((px))).S}).S+({S:".kn"}).S});
}
(af)=((pB)((new pC()),(p7)));
if((af)===(null)){
(D)((5),(null),([(p7)]));
return true;
}
(ag)=(px);
(pF)=(1);
(pG)=(0);
(pH)=(0x0000);
(pI)=(0x0000);
(pJ)=(false);
(ah)=([]);
(pK)=(0);
(ai)=(null);
(pL)=((pM)());
(pO)((af));
(bE)((ae),([133,129,2,134]),(px),(pL));
return true;
}
// searchMain
function e9(){
let pP=null; // ast
let pT=false;
let pW=null; // mainFunc
let qa=false;
let qe=null; // mainFunc2
let pQ=null;
let pS=false;
let pX=null;
let pZ=false;
(pP)=((pQ=(pR)((I),([133,129,2,134]),({S:({S:"\\"}).S+(aa).S}),(pS={$:(pT)},pS)),(pT)=pS.$,pQ));
if((pP)===(null)){
(D)((131073),(null),(null));
return null;
}
(pW)=((pX=(pR)(((pP).pY),([133,129,2,134]),({S:"main"}),(pZ={$:(qa)},pZ)),(qa)=pZ.$,pX));
if(((pW)===(null))||(((pW).qc)!==(256))){
(D)((131073),(null),(null));
return null;
}
(qe)=(pW);
if(((((((qe).qg).L)!==(0))||(((qe).qh)!==(null)))||(((qe).qi)!==(0)))||((((qe).qj).L)!==(0))){
(D)((131074),((qe).ql),(null));
}
return qe;
}
// resolveIdentifier
function eC(qm /*key*/,qn /*value*/,qo /*data*/){
let qp=null; // scopeRefedItems
let qu=null; // item
let qx=null; // ast
let q1=false; // otherFile
let q2=0; // ptrAt
let q4=null; // ptrName
let q5=null; // foundAst
let qA=null; // ptrSrc
let qE=null; // ast2
let qH=false;
let qM=false;
let qO=null; // scope
let qQ=false; // overFunc
let rc=null; // ast2
let rf=false;
let ri=false; // err
let rn=0; // kind
let qF=null;
let qG=false;
let qK=null;
let qL=false;
let rd=null;
let re=false;
if(!((qn)instanceof pN)){throw 0xE9170000;}
(qp)=((qn).qq);
(qr)((qp),([130,134]));
while(!((qt)((qp),([130,134])))){
(qu)=((qv)((qp),([130,134])));
(qx)=((qu).qy);
if(!(((qx).qz)===(null))){throw 0xE9170000;}
if(!(((qx).q0)!==(null))){throw 0xE9170000;}
(q1)=(false);
(q2)=((q3)(((qx).q0),([129,2]),(0x0040),(-1)));
(q4)=(((q2)===(-1))?((qx).q0):((p9)(((qx).q0),([129,2]),((q2)+(1)),(-1))));
(q5)=(null);
if((q2)!==(-1)){
if((q2)===(0)){
(qA)=(qm);
}
else{
(qA)=((p9)(((qx).q0),([129,2]),(0),(q2)));
if((qA).S===(qm).S){
(D)((131076),((qx).ql),([(qA)]));
}
(q1)=(true);
}
(qE)=((qF=(pR)((I),([133,129,2,134]),(qA),(qG={$:(qH)},qG)),(qH)=qG.$,qF));
if((qE)!==(null)){
(q5)=((qK=(pR)(((qE).pY),([133,129,2,134]),(q4),(qL={$:(qM)},qL)),(qM)=qL.$,qK));
}
}
else{
(qO)=((qu).qP);
(qQ)=(false);
qS:
while(true){
if(((qO).qU)===(null)){
break qS;
}
if((((qO).qX)!==(null))&&(((qO).qX).S===(q4).S)){
if((((qO).qc)===(256))&&(((qO).q0)!==(null))){
(D)((131075),((qx).ql),([(q4)]));
}
else{
(q5)=(qO);
break qS;
}
}
(rc)=((rd=(pR)(((qO).pY),([133,129,2,134]),(q4),(re={$:(rf)},re)),(rf)=re.$,rd));
if((rc)!==(null)){
(ri)=(false);
if(qQ){
if(((rc).qc)===(7)){
(rn)=((rc).rp);
if((((rn)===(5))||((rn)===(3)))||((rn)===(2))){
(ri)=(true);
}
}
if((!(ri))&&(((rt)(((rc).qc),([9]),(66048)))===(66048))){
(ri)=(true);
}
}
if(((!(ri))&&(((rc).qc)===(256)))&&(((rc).q0)!==(null))){
(ri)=(true);
}
if(ri){
(D)((131075),((qx).ql),([(q4)]));
}
else{
(q5)=(rc);
break qS;
}
}
if(((qO).qc)===(256)){
(qQ)=(true);
}
(qO)=((qO).qU);
}
}
if((q5)!==(null)){
if((q1)&&(!((q5).r5))){
(D)((131077),((qx).ql),([((qx).q0)]));
}
((qx).qz)=(q5);
}
else{
(D)((131078),((qx).ql),([((qx).q0)]));
((qx).qz)=(null);
}
(r8)((qp),([130,134]));
}
return true;
}
// rebuild
function eD(r9 /*mainFunc*/){
let rB=null; // entry
let rE=null; // root
let rH=false;
let rF=null;
let rG=false;
(rB)=((rC)((r9)));
(rD)((rB));
(rE)=((rF=(pR)((I),([133,129,2,134]),({S:({S:"\\"}).S+(aa).S}),(rG={$:(rH)},rG)),(rH)=rG.$,rF));
if(!((rE)instanceof pN)){throw 0xE9170000;}
(eN)(((rE).rI),([130,134]),(rB));
(e5)((I),([133,129,2,134]),(rJ),(null));
return rB;
}
// _addList
function eN(rK /*me_*/,rL /*type*/,rM /*item*/){
let n_={P:null,N:null,I:rM};
if(rK.H===null){rK.H=n_;rK.T=n_}else{n_.P=rK.T;rK.T.N=n_;rK.T=n_}
rK.L++;
}
// _addQueue
function eQ(rN /*me_*/,rO /*type*/,rP /*item*/){
rN.push(rP);
}
// _getQueue
function eV(rQ /*me_*/,rR /*type*/){
return rQ.shift();
}
// buildFunc
function eW(rS /*ast*/){
let rT=null; // info
let rZ=null; // template
let sn=null; // retType
let sr=null; // arg
let st=0; // idx
let su=null; // items
let sw=null; // item
let s0=null; // info2
let sY=false; // hasMembers
let tb=null; // arg2
let tf=null; // members
let tm=0; // localVarPos
let ts=null; // localVar
let tt=null; // info2
let t1=null; // tmpVar
(rT)=((rU)((rS)));
if((rT).rX){
return;
}
((rT).rX)=(true);
(rZ)=({S:""});
if(((rt)(((rS).qi),([9]),(1)))===(1)){
if(((rt)(((rS).qi),([9]),(32)))===(32)){
(rZ)=({S:"template<typename T_, typename K_, typename V_> "});
}
else if(((rt)(((rS).qi),([9]),(8)))===(8)){
if(((rt)(((rS).qi),([9]),(16)))===(16)){
(rZ)=({S:"template<typename T_, typename C_, typename R_> "});
}
else{
(rZ)=({S:"template<typename T_, typename C_> "});
}
}
else if(((rt)(((rS).qi),([9]),(16)))===(16)){
(rZ)=({S:"template<typename T_, typename R_> "});
}
else if(((rt)(((rS).qi),([9]),(256)))===(256)){
(rZ)=({S:"template<typename T_, typename K_, typename V_> "});
}
else{
(rZ)=({S:"template<typename T_> "});
}
}
if(((rt)(((rS).qi),([9]),(16)))===(16)){
(sn)=({S:"R_"});
}
else if(((rt)(((rS).qi),([9]),(4)))===(4)){
(sn)=({S:"T_"});
}
else{
(sn)=((sq)(((rS).qh)));
}
(sr)=({S:""});
(st)=(0);
(su)=((rS).qg);
(qr)((su),([130,134]));
while(!((qt)((su),([130,134])))){
(sw)=((qv)((su),([130,134])));
if((st)!==(0)){
(sr)=({S:(sr).S+({S:", "}).S});
}
(s0)=((rU)((sw)));
if((((rt)(((rS).qi),([9]),(1)))===(1))&&((st)===(0))){
if(!((s3)(((sw).s4)))){throw 0xE9170000;}
(sr)=({S:(sr).S+({S:"T_"}).S});
}
else if((((rt)(((rS).qi),([9]),(32)))===(32))&&((st)===(2))){
if(!((s3)(((sw).s4)))){throw 0xE9170000;}
(sr)=({S:(sr).S+({S:"K_"}).S});
}
else if((((rt)(((rS).qi),([9]),(32)))===(32))&&((st)===(3))){
if(!((s3)(((sw).s4)))){throw 0xE9170000;}
(sr)=({S:(sr).S+({S:"V_"}).S});
}
else if((((rt)(((rS).qi),([9]),(8)))===(8))&&((st)===(2))){
if(!((s3)(((sw).s4)))){throw 0xE9170000;}
(sr)=({S:(sr).S+({S:"C_"}).S});
}
else if((((rt)(((rS).qi),([9]),(2)))===(2))&&((st)===(2))){
if(!((s3)(((sw).s4)))){throw 0xE9170000;}
(sr)=({S:(sr).S+({S:"T_"}).S});
}
else if((((rt)(((rS).qi),([9]),(256)))===(256))&&((st)===(2))){
if(!((s3)(((sw).s4)))){throw 0xE9170000;}
(sr)=({S:(sr).S+({S:"const void*"}).S});
}
else{
(sr)=({S:(sr).S+({S:({S:({S:""}).S+((v)(((sq)(((sw).s4))),([129,2]))).S}).S+({S:""}).S}).S});
}
if((sw).sJ){
(sr)=({S:(sr).S+({S:"*"}).S});
}
(sr)=({S:(sr).S+({S:({S:({S:" "}).S+((v)(((s0).sN),([129,2]))).S}).S+({S:""}).S}).S});
if(((sw).qX)!==(null)){
(sr)=({S:(sr).S+({S:({S:({S:" /*"}).S+((v)(((sw).qX),([129,2]))).S}).S+({S:"*/"}).S}).S});
}
(r8)((su),([130,134]));
(st)=((st)+(1));
}
if(((rS).qX)!==(null)){
(eN)((P),([130,129,2]),({S:({S:({S:"// "}).S+((v)(((rS).qX),([129,2]))).S}).S+({S:"\u000A"}).S}));
}
(eN)((O),([130,129,2]),({S:({S:({S:""}).S+((v)((rZ),([129,2]))).S}).S+({S:({S:({S:"static "}).S+((v)((sn),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((rT).sN),([129,2]))).S}).S+({S:({S:({S:"("}).S+((v)((sr),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}).S}));
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)((rZ),([129,2]))).S}).S+({S:({S:({S:"static "}).S+((v)((sn),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((rT).sN),([129,2]))).S}).S+({S:({S:({S:"("}).S+((v)((sr),([129,2]))).S}).S+({S:"){\u000A"}).S}).S}).S}).S}));
if(((rt)(((rS).qi),([9]),(4096)))===(4096)){
if((((rS).qj).L)===(1)){
(qr)(((rS).qj),([130,129,2]));
(sY)=(false);
if((((rS).qg).L)>(0)){
(qr)(((rS).qg),([130,134]));
(tb)=((qv)(((rS).qg),([130,134])));
if(((((tb).s4).qz)!==(null))&&(((((tb).s4).qz).qc)===(5))){
(tf)=((((tb).s4).qz).tg);
(th)((P),((qv)(((rS).qj),([130,129,2]))),((rS).qg),(tf));
(sY)=(true);
}
}
if(!(sY)){
(th)((P),((qv)(((rS).qj),([130,129,2]))),((rS).qg),(null));
}
(eN)((P),([130,129,2]),({S:"}\u000A"}));
}
}
else{
(tl)((P),([130,129,2]));
(tm)=((tn)((P),([130,129,2])));
(to)(((rS).tp),(null),(null));
(eN)((P),([130,129,2]),({S:"}\u000A"}));
(qr)((P),([130,129,2]));
(tq)((P),([130,129,2]),(tm));
(r8)((P),([130,129,2]));
(qr)((T),([130,134]));
while(!((qt)((T),([130,134])))){
(ts)=((qv)((T),([130,134])));
(tt)=((rU)((ts)));
if(((ts).qX)===(null)){
(tw)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((sq)(((ts).s4))),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((tt).sN),([129,2]))).S}).S+({S:({S:({S:" = "}).S+((v)(((tx)(((ts).s4))),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
}
else{
(tw)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((sq)(((ts).s4))),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((tt).sN),([129,2]))).S}).S+({S:({S:({S:" = "}).S+((v)(((tx)(((ts).s4))),([129,2]))).S}).S+({S:({S:({S:"; // "}).S+((v)(((ts).qX),([129,2]))).S}).S+({S:"\u000A"}).S}).S}).S}).S}));
}
(tz)((T),([130,134]));
}
(qr)((R),([130,134]));
while(!((qt)((R),([130,134])))){
(t1)=((qv)((R),([130,134])));
(tw)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((sq)(((t1).t3))),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((t1).t4),([129,2]))).S}).S+({S:({S:({S:" = "}).S+((v)(((tx)(((t1).t3))),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
(tz)((R),([130,134]));
}
}
}
// buildClass
function fa(t5 /*ast*/){
let t6=null; // parentId
let tC=null; // info
let tH=0; // parentOffset
let tJ=null; // parentInfo
let tN=null; // items
let tP=null; // item
let tU=null; // var_
let tW=null; // info2
let tZ=null; // ctor
let ud=null; // ctorInfo
let uf=null; // cmp
let ui=null; // cmpInfo
let uj=null; // copy
let ul=null; // copyInfo
let un=null; // items
let up=null; // item
let us=null; // var_
let ut=null; // info2
(t6)=(null);
if(((t5).qz)!==(null)){
(t6)=((t9)(((t5).qz)));
}
if((t6)===(null)){
(t6)=({S:"Class_"});
}
(tC)=((rU)((t5)));
if(!(((tC).tE)!==(-1))){throw 0xE9170000;}
if(((t5).qz)===(null)){
(tH)=(0);
}
else{
(tJ)=((rU)(((t5).qz)));
if(!(((tJ).tE)!==(-1))){throw 0xE9170000;}
(tH)=((tJ).tE);
}
(eN)((U),([130,129,2]),({S:({S:({S:"classTable_["}).S+((v)((((tC).tE)*(2)),([0]))).S}).S+({S:({S:({S:"] = "}).S+((v)(((tH)*(2)),([0]))).S}).S+({S:";\u000A"}).S}).S}));
if(((t5).qX)!==(null)){
(eN)((N),([130,129,2]),({S:({S:({S:"// "}).S+((v)(((t5).qX),([129,2]))).S}).S+({S:"\u000A"}).S}));
}
(eN)((N),([130,129,2]),({S:({S:({S:"class "}).S+((v)(((tC).sN),([129,2]))).S}).S+({S:({S:({S:" : public "}).S+((v)((t6),([129,2]))).S}).S+({S:"{\u000Apublic:\u000A"}).S}).S}));
(eN)((N),([130,129,2]),({S:({S:({S:""}).S+((v)(((tC).sN),([129,2]))).S}).S+({S:"();\u000A"}).S}));
(eN)((Q),([130,129,2]),({S:({S:({S:""}).S+((v)(((tC).sN),([129,2]))).S}).S+({S:({S:({S:"::"}).S+((v)(((tC).sN),([129,2]))).S}).S+({S:({S:({S:"(): "}).S+((v)((t6),([129,2]))).S}).S+({S:"()"}).S}).S}).S}));
(tN)=((t5).tg);
(qr)((tN),([130,134]));
while(!((qt)((tN),([130,134])))){
(tP)=((qv)((tN),([130,134])));
if((((tP).tS).qc)===(2)){
(tU)=((tP).tS);
(tW)=((rU)(((tU).tX)));
(eN)((Q),([130,129,2]),({S:({S:({S:", "}).S+((v)(((tW).sN),([129,2]))).S}).S+({S:"()"}).S}));
}
(r8)((tN),([130,134]));
}
(eN)((Q),([130,129,2]),({S:"{\u000A"}));
(eN)((Q),([130,129,2]),({S:({S:({S:"Y = "}).S+((v)((((tC).tE)*(2)),([0]))).S}).S+({S:";\u000A"}).S}));
(tZ)=((ua)((t5),({S:"ctor"})));
if((tZ)!==(null)){
(ud)=((rU)((tZ)));
(eN)((Q),([130,129,2]),({S:({S:({S:""}).S+((v)(((ud).sN),([129,2]))).S}).S+({S:"(this);\u000A"}).S}));
}
(eN)((Q),([130,129,2]),({S:"}\u000A"}));
(uf)=((ua)((t5),({S:"cmp"})));
if((uf)!==(null)){
(ui)=((rU)((uf)));
(eN)((N),([130,129,2]),({S:"virtual int64_t cmp_(Class_* t) override;\u000A"}));
(eN)((Q),([130,129,2]),({S:({S:({S:"int64_t "}).S+((v)(((tC).sN),([129,2]))).S}).S+({S:"::cmp_(Class_* t){\u000A"}).S}));
(eN)((Q),([130,129,2]),({S:({S:({S:""}).S+((v)(((tC).sN),([129,2]))).S}).S+({S:({S:({S:"* u = reinterpret_cast<"}).S+((v)(((tC).sN),([129,2]))).S}).S+({S:"*>(t);\u000A"}).S}).S}));
(eN)((Q),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((ui).sN),([129,2]))).S}).S+({S:"(this, u);\u000A"}).S}));
(eN)((Q),([130,129,2]),({S:"}\u000A"}));
}
(uj)=((ua)((t5),({S:"_copy"})));
if(!((uj)!==(null))){throw 0xE9170000;}
(ul)=((rU)((uj)));
(eN)((N),([130,129,2]),({S:"virtual Class_* copy_(Class_* t) override;\u000A"}));
(eN)((Q),([130,129,2]),({S:({S:({S:"Class_* "}).S+((v)(((tC).sN),([129,2]))).S}).S+({S:"::copy_(Class_* t){\u000A"}).S}));
(eN)((Q),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((ul).sN),([129,2]))).S}).S+({S:"(this);\u000A"}).S}));
(eN)((Q),([130,129,2]),({S:"}\u000A"}));
(un)=((t5).tg);
(qr)((un),([130,134]));
while(!((qt)((un),([130,134])))){
(up)=((qv)((un),([130,134])));
if((((up).tS).qc)===(2)){
(us)=((up).tS);
(ut)=((rU)(((us).tX)));
if((((us).tX).qX)===(null)){
(eN)((N),([130,129,2]),({S:({S:({S:""}).S+((v)(((sq)((((us).tX).s4))),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((ut).sN),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else{
(eN)((N),([130,129,2]),({S:({S:({S:""}).S+((v)(((sq)((((us).tX).s4))),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((ut).sN),([129,2]))).S}).S+({S:({S:({S:"; // "}).S+((v)((((us).tX).qX),([129,2]))).S}).S+({S:"\u000A"}).S}).S}).S}));
}
}
(r8)((un),([130,134]));
}
(eN)((N),([130,129,2]),({S:"};\u000A"}));
}
// write
function fb(ux /*resFiles*/){
let u1=false;
let u3=null; // writer
let u6=null; // reader
let u9=null; // s
let uG=null; // writer
let uz=false;
let u0=false;
if((uz=(pR)((Y),([133,129,2,3]),({S:"merge"}),(u0={$:(u1)},u0)),(u1)=u0.$,uz)){
(u3)=((u4)((new u5()),({S:(V).S+({S:".cpp"}).S}),(false)));
(u6)=((pB)((new pC()),({S:(W).S+({S:"common.h"}).S})));
while(!((u8)((u6)))){
(u9)=((uA)((u6)));
(uB)((u3),({S:(u9).S+({S:"\u000A"}).S}));
}
(pO)((u6));
(uC)((u3),(ux));
(uD)((u3));
}
else{
(uF)(({S:(ab).S+({S:"common.h"}).S}),({S:(W).S+({S:"common.h"}).S}));
(uG)=((u4)((new u5()),({S:(V).S+({S:".cpp"}).S}),(false)));
(uB)((uG),({S:"#include \"common.h\"\u000A"}));
(uC)((uG),(ux));
(uD)((uG));
}
}
// buildFunc
function fh(uH /*ast*/){
let uI=null; // info
let uO=null; // arg
let uQ=false; // first
let uR=null; // items
let uT=null; // item
let uU=null; // info2
let vk=false; // hasMembers
let vn=null; // arg2
let vq=null; // members
let vv=0; // localVarPos
let vy=null; // localVar
let vz=null; // info2
let v5=null; // tmpVar
(uI)=((uJ)((uH)));
if((uI).uM){
return;
}
((uI).uM)=(true);
(uO)=({S:""});
(uQ)=(true);
(uR)=((uH).qg);
(qr)((uR),([130,134]));
while(!((qt)((uR),([130,134])))){
(uT)=((qv)((uR),([130,134])));
(uU)=((uJ)((uT)));
if(uQ){
(uQ)=(false);
}
else{
(uO)=({S:(uO).S+({S:","}).S});
}
(uO)=({S:(uO).S+({S:({S:({S:""}).S+((v)(((uU).va),([129,2]))).S}).S+({S:""}).S}).S});
if(((uT).qX)!==(null)){
(uO)=({S:(uO).S+({S:({S:({S:" /*"}).S+((v)(((uT).qX),([129,2]))).S}).S+({S:"*/"}).S}).S});
}
(r8)((uR),([130,134]));
}
if(((uH).qX)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:"// "}).S+((v)(((uH).qX),([129,2]))).S}).S+({S:"\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:({S:({S:"function "}).S+((v)(((uI).va),([129,2]))).S}).S+({S:({S:({S:"("}).S+((v)((uO),([129,2]))).S}).S+({S:"){\u000A"}).S}).S}));
if(((rt)(((uH).qi),([9]),(4096)))===(4096)){
if((((uH).qj).L)===(1)){
(qr)(((uH).qj),([130,129,2]));
(vk)=(false);
if((((uH).qg).L)>(0)){
(qr)(((uH).qg),([130,134]));
(vn)=((qv)(((uH).qg),([130,134])));
if(((((vn).s4).qz)!==(null))&&(((((vn).s4).qz).qc)===(5))){
(vq)=((((vn).s4).qz).tg);
(vr)((am),((qv)(((uH).qj),([130,129,2]))),((uH).qg),(vq));
(vk)=(true);
}
}
if(!(vk)){
(vr)((am),((qv)(((uH).qj),([130,129,2]))),((uH).qg),(null));
}
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
}
else{
(tl)((am),([130,129,2]));
(vv)=((tn)((am),([130,129,2])));
(vw)(((uH).tp));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
(qr)((am),([130,129,2]));
(tq)((am),([130,129,2]),(vv));
(r8)((am),([130,129,2]));
(qr)((ap),([130,134]));
while(!((qt)((ap),([130,134])))){
(vy)=((qv)((ap),([130,134])));
(vz)=((uJ)((vy)));
if(((vy).qX)===(null)){
(tw)((am),([130,129,2]),({S:({S:({S:"let "}).S+((v)(((vz).va),([129,2]))).S}).S+({S:({S:({S:"="}).S+((v)(((v2)(((vy).s4))),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else{
(tw)((am),([130,129,2]),({S:({S:({S:"let "}).S+((v)(((vz).va),([129,2]))).S}).S+({S:({S:({S:"="}).S+((v)(((v2)(((vy).s4))),([129,2]))).S}).S+({S:({S:({S:"; // "}).S+((v)(((vy).qX),([129,2]))).S}).S+({S:"\u000A"}).S}).S}).S}));
}
(tz)((ap),([130,134]));
}
(qr)((an),([130,134]));
while(!((qt)((an),([130,134])))){
(v5)=((qv)((an),([130,134])));
(tw)((am),([130,129,2]),({S:({S:({S:"let "}).S+((v)(((v5).v7),([129,2]))).S}).S+({S:({S:({S:"="}).S+((v)(((v2)(((v5).v8))),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
(tz)((an),([130,134]));
}
}
}
// buildClass
function fk(v9 /*ast*/){
let vA=null; // parentId
let vG=null; // info
let vK=null; // ctor
let vO=null; // ctorInfo
let vQ=null; // items
let vS=null; // item
(vA)=(null);
if(((v9).qz)!==(null)){
(vA)=((vD)(((v9).qz)));
}
if((vA)===(null)){
(vA)=({S:"Object"});
}
(vG)=((uJ)((v9)));
if(((v9).qX)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:"// "}).S+((v)(((v9).qX),([129,2]))).S}).S+({S:"\u000A"}).S}));
}
(vK)=((vL)((v9),({S:"ctor"})));
(eN)((am),([130,129,2]),({S:({S:({S:"function "}).S+((v)(((vG).va),([129,2]))).S}).S+({S:"(){\u000A"}).S}));
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)((vA),([129,2]))).S}).S+({S:".call(this);\u000A"}).S}));
if((vK)!==(null)){
(vO)=((uJ)((vK)));
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((vO).va),([129,2]))).S}).S+({S:"(this);\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:"}\u000A"}));
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((vG).va),([129,2]))).S}).S+({S:({S:({S:".prototype = Object.create("}).S+((v)((vA),([129,2]))).S}).S+({S:".prototype);\u000A"}).S}).S}));
(vQ)=((v9).tg);
(qr)((vQ),([130,134]));
while(!((qt)((vQ),([130,134])))){
(vS)=((qv)((vQ),([130,134])));
if((((vS).tS).qc)===(256)){
(eQ)((aj),([132,134]),((vS).tS));
}
(r8)((vQ),([130,134]));
}
}
// write
function fl(vV /*resFiles*/){
let vZ=false;
let wb=null; // fileName
let wc=null; // writer
let wf=null; // fileName
let vX=false;
let vY=false;
if((vX=(pR)((Y),([133,129,2,3]),({S:"merge"}),(vY={$:(vZ)},vY)),(vZ)=vY.$,vX)){
(wb)=((co)((V)));
(wc)=((u4)((new u5()),({S:(V).S+({S:".html"}).S}),(false)));
(uB)((wc),({S:"<!DOCTYPE html>\u000A"}));
(uB)((wc),({S:"<html>\u000A"}));
(uB)((wc),({S:"\u0009<head>\u000A"}));
(uB)((wc),({S:"\u0009\u0009<meta charset=\"utf-8\" />\u000A"}));
(uB)((wc),({S:({S:({S:"\u0009\u0009<title>"}).S+((v)((wb),([129,2]))).S}).S+({S:"</title>\u000A"}).S}));
(uB)((wc),({S:"\u0009\u0009<script type=\"text/javascript\">\u000A"}));
(wd)((wc),(vV));
(uB)((wc),({S:"\u0009\u0009</script>\u000A"}));
(uB)((wc),({S:"\u0009</head>\u000A"}));
(uB)((wc),({S:"\u0009<body>\u000A"}));
(uB)((wc),({S:"\u0009</body>\u000A"}));
(uB)((wc),({S:"</html>\u000A"}));
(uD)((wc));
}
else{
(wc)=((u4)((new u5()),({S:(V).S+({S:".js"}).S}),(false)));
(wd)((wc),(vV));
(uD)((wc));
(wf)=((co)((V)));
(wc)=((u4)((new u5()),({S:(V).S+({S:".html"}).S}),(false)));
(uB)((wc),({S:"<!DOCTYPE html>\u000A"}));
(uB)((wc),({S:"<html>\u000A"}));
(uB)((wc),({S:"\u0009<head>\u000A"}));
(uB)((wc),({S:"\u0009\u0009<meta charset=\"utf-8\" />\u000A"}));
(uB)((wc),({S:({S:({S:"\u0009\u0009<script src=\""}).S+((v)((wf),([129,2]))).S}).S+({S:".js\" type=\"text/javascript\"></script>\u000A"}).S}));
(uB)((wc),({S:({S:({S:"\u0009\u0009<title>"}).S+((v)((wf),([129,2]))).S}).S+({S:"</title>\u000A"}).S}));
(uB)((wc),({S:"\u0009</head>\u000A"}));
(uB)((wc),({S:"\u0009<body>\u000A"}));
(uB)((wc),({S:"\u0009</body>\u000A"}));
(uB)((wc),({S:"</html>\u000A"}));
(uD)((wc));
}
}
// isCorrectSrcName
function p3(wg /*name*/){
let wh=0; // idx
(wh)=(0);
if(((wh)<((wg).S.length))&&(((wg).S.charCodeAt(wh))===(0x005C))){
(wh)=((wh)+(1));
}
while(true){
if(((wh)>=((wg).S.length))||(!((((0x0061)<=((wg).S.charCodeAt(wh)))&&(((wg).S.charCodeAt(wh))<=(0x007A)))||(((wg).S.charCodeAt(wh))===(0x005F))))){
return false;
}
wp:
while(true){
(wh)=((wh)+(1));
if((wh)>=((wg).S.length)){
return true;
}
if(((((0x0061)<=((wg).S.charCodeAt(wh)))&&(((wg).S.charCodeAt(wh))<=(0x007A)))||(((wg).S.charCodeAt(wh))===(0x005F)))||(((0x0030)<=((wg).S.charCodeAt(wh)))&&(((wg).S.charCodeAt(wh))<=(0x0039)))){
continue wp;
}
if(((wg).S.charCodeAt(wh))===(0x005C)){
(wh)=((wh)+(1));
break wp;
}
return false;
}
}
}
// replacePath
function p8(wy /*path*/){
let wz=null; // r
let w2=0;
let w3=0;
let w4=0;
let w5=0;
(wz)=({S:"\0".repeat((wy).S.length)});
w1:
for(w2=(0),w3=(((wy).S.length)-(1));w2<=w3;w2+=(1)){
(wz).S=(w4=(w2),(wz).S.slice(0,w4)+String.fromCharCode((((wy).S.charCodeAt(w2))===(0x005C))?(0x002F):((wy).S.charCodeAt(w2)))+(wz).S.slice(w4+1));
}
return wz;
}
// _sub
function p9(w6 /*me_*/,w7 /*type*/,w8 /*start*/,w9 /*len*/){
if(w7[0]===129&&w7[1]===2)
return {S:w9===-1?w6.S.slice(w8):w6.S.slice(w8,w8+w9)};
else
return w9===-1?w6.slice(w8):w6.slice(w8,w8+w9);
}
// makeReader
function pB(wA /*me2*/,wB /*path*/){
let f_=null,p_=wB.S;
if(O_&&O_.readFile)f_=O_.readFile(p_);
if(f_===null){
if(p_.length>=4&&p_[0]==="r"&&p_[1]==="e"&&p_[2]==="s"&&p_[3]==="/")
f_=F_(p_,true);
else{
}
}
if(f_===null)return null;
wA.wC={F:f_,I:0};
return wA;
}
// parseRoot
function pM(){
let wD=null; // ast
let wK=0; // c
let wP=false; // itemPublic
let wU=0; // row
let wV=0; // col
let wW=null; // id
let wZ=null;
let xb=null; // item
(wD)=(new pN());
(wE)((wD),(1),((wF)((ag),(1),(1))),(null),(false));
((wD).qq)=({L:0,H:null,T:null,P:null});
((wD).rI)=({L:0,H:null,T:null,P:null});
(ai)=((wD).qq);
((wD).pY)=(new Map());
(wG)((ah),([131,134]),(wD));
(pH)=(0x000A);
(pH)=((wH)());
wJ:
while(true){
(wK)=((wH)());
if((wK)===(0x0000)){
break wJ;
}
if((wK)===(0x000A)){
continue wJ;
}
(wP)=(false);
if((wK)===(0x002B)){
(wP)=(true);
}
else{
(pH)=(wK);
}
(wU)=(pF);
(wV)=(pG);
(wW)=((wX)((true),(false)));
wZ=wW;
if(wZ.S===({S:"func"}).S){
(xb)=((xc)((null),(false)));
}
else if(wZ.S===({S:"var"}).S){
(xb)=((xe)((1),(null)));
}
else if(wZ.S===({S:"const"}).S){
(xb)=((xg)());
}
else if(wZ.S===({S:"alias"}).S){
(xb)=((xj)());
}
else if(wZ.S===({S:"include"}).S){
}
else if(wZ.S===({S:"class"}).S){
(xb)=((xn)());
}
else if(wZ.S===({S:"enum"}).S){
(xb)=((xp)());
}
else{(D)((65547),((wF)((ag),(wU),(wV))),([(wW)]));
(xs)(((xt)()));
continue wJ;
}
if(((xb).qc)===(2)){
(((xb).tX).r5)=(wP);
}
else if(((xb).qc)===(3)){
(((xb).xx).r5)=(wP);
}
else{
((xb).r5)=(wP);
}
(eN)(((wD).rI),([130,134]),(xb));
}
(xz)((ah),([131,134]));
return wD;
}
// _getDict
function pR(x0 /*me_*/,x1 /*type*/,x2 /*key*/,x3 /*existed*/){
let r_;
if(x1[1]===129&&x1[2]===2)
r_=x0.get(x2.S);
else
r_=x0.get(x2);
if(!(x3.$=r_!==undefined)){
switch(x1){
case 0:
case 1:
case 2:
case 4:
case 5:
case 6:
case 7:
case 9:
return 0;
case 3:
return false;
default:
return null;
}
}
return r_;
}
// _head
function qr(x4 /*me_*/,x5 /*type*/){
x4.P=x4.H;
}
// _term
function qt(x6 /*me_*/,x7 /*type*/){
return x6.P===null;
}
// _getList
function qv(x8 /*me_*/,x9 /*type*/){
return x8.P.I;
}
// _findArray
function q3(xA /*me_*/,xB /*type*/,xC /*item*/,xD /*start*/){
if(xB[0]===129&&xB[1]===2)
return xA.S.indexOf(String.fromCharCode(xC),xD===-1?0:xD);
else
return xA.indexOf(xC,xD===-1?0:xD);
}
// _and
function rt(xE /*me_*/,xF /*type*/,xG /*n*/){
return xE&xG;
}
// _next
function r8(xH /*me_*/,xI /*type*/){
xH.P=xH.P.N;
}
// makeEntryPoint
function rC(xJ /*mainFunc*/){
let xK=null; // pos
let xL=null; // entry
let xO=null; // try_
let xT=null; // var_
let xV=null; // type
let yb=null; // block_
let yh=null; // block_
let yk=null; // funcs
let yo=null; // do_
let yr=null; // call
let yx=null; // ref
let y1=null; // catch_
let y5=null; // block_
let y8=null; // exprs
let yB=null; // expr
let yH=null; // type
let yL=null; // expr
let yN=null; // type
let yQ=null; // do_
let yS=null; // call
let yU=null; // ref_
let yW=null; // excpt
let zb=null; // ref_
let ze=null; // funcs
let zh=null; // do_
let zj=null; // call
let zl=null; // ref
(xK)=((wF)(({S:"kuin"}),(1),(1)));
(xL)=(new c7());
(xM)((xL),(256),(xK));
((xL).qX)=({S:"$"});
((xL).qi)=(0);
((xL).qj)=({L:0,H:null,T:null,P:null});
((xL).qg)=({L:0,H:null,T:null,P:null});
((xL).qh)=(null);
((xL).tp)=({L:0,H:null,T:null,P:null});
(xO)=(new xP());
(xM)((xO),(66051),(xK));
(xT)=(new ro());
(xM)((xT),(7),(xK));
((xT).qX)=({S:"$"});
((xT).rp)=(3);
((xT).sJ)=(false);
(xV)=(new xW());
(xM)((xV),(1026),(xK));
((xV).xX)=(0);
((xT).s4)=(xV);
((xT).xY)=(null);
((xO).xZ)=(xT);
(yb)=(new yc());
(xM)((yb),(66052),(xK));
((yb).qX)=({S:"$"});
((yb).xZ)=(null);
((yb).yd)=({L:0,H:null,T:null,P:null});
((xO).ye)=(yb);
((xO).yf)=({L:0,H:null,T:null,P:null});
(yh)=(new yc());
(xM)((yh),(66052),(xK));
((yh).qX)=({S:"$"});
((yh).xZ)=(null);
((yh).yd)=({L:0,H:null,T:null,P:null});
((xO).yi)=(yh);
(yk)=({L:0,H:null,T:null,P:null});
(eN)((yk),([130,134]),((yl)(({S:"kuin"}),({S:"_init"}),(false))));
(eN)((yk),([130,134]),((yl)(({S:"kuin"}),({S:"_initVars"}),(false))));
(eN)((yk),([130,134]),(xJ));
(qr)((yk),([130,134]));
while(!((qt)((yk),([130,134])))){
(yo)=(new yp());
(xM)((yo),(528),(xK));
(yr)=(new ys());
(yu)((yr),(2057),(xK));
((yr).yv)=({L:0,H:null,T:null,P:null});
(yx)=(new yt());
(yu)((yx),(2062),(xK));
((yx).qz)=((qv)((yk),([130,134])));
((yr).yy)=(yx);
((yo).yz)=(yr);
(eN)((((xO).ye).yd),([130,134]),(yo));
(r8)((yk),([130,134]));
}
(y1)=(new y2());
(xM)((y1),(524),(xK));
((y1).y3)=({L:0,H:null,T:null,P:null});
(y5)=(new yc());
(xM)((y5),(66052),(xK));
((y5).qX)=({S:"$"});
((y5).xZ)=(null);
((y5).yd)=({L:0,H:null,T:null,P:null});
((y1).y6)=(y5);
(y8)=(new y9());
(yB)=(new yC());
(yu)((yB),(67585),(xK));
((yB).yE)=(1);
((yB).yF)=(0x0000000000000000);
(yH)=(new xW());
(xM)((yH),(1026),(xK));
((yH).xX)=(0);
((yB).yI)=(yH);
((y8).yJ)=(yB);
(yL)=(new yC());
(yu)((yL),(67585),(xK));
((yL).yE)=(1);
((yL).yF)=(0x00000000FFFFFFFF);
(yN)=(new xW());
(xM)((yN),(1026),(xK));
((yN).xX)=(0);
((yL).yI)=(yN);
((y8).yO)=(yL);
(eN)(((y1).y3),([130,134]),(y8));
(yQ)=(new yp());
(xM)((yQ),(528),(xK));
(yS)=(new ys());
(yu)((yS),(2057),(xK));
((yS).yv)=({L:0,H:null,T:null,P:null});
(yU)=(new yt());
(yu)((yU),(2062),(xK));
((yU).qz)=((yl)(({S:"kuin"}),({S:"_err"}),(false)));
((yS).yy)=(yU);
(yW)=(new yX());
((yW).yY)=(false);
((yW).yZ)=(false);
(zb)=(new yt());
(yu)((zb),(2062),(xK));
((zb).qz)=((xO).xZ);
((yW).zc)=(zb);
(eN)(((yS).yv),([130,134]),(yW));
((yQ).yz)=(yS);
(eN)((((y1).y6).yd),([130,134]),(yQ));
(eN)(((xO).yf),([130,134]),(y1));
(ze)=({L:0,H:null,T:null,P:null});
(eN)((ze),([130,134]),((yl)(({S:"kuin"}),({S:"_finVars"}),(false))));
(eN)((ze),([130,134]),((yl)(({S:"kuin"}),({S:"_fin"}),(false))));
(qr)((ze),([130,134]));
while(!((qt)((ze),([130,134])))){
(zh)=(new yp());
(xM)((zh),(528),(xK));
(zj)=(new ys());
(yu)((zj),(2057),(xK));
((zj).yv)=({L:0,H:null,T:null,P:null});
(zl)=(new yt());
(yu)((zl),(2062),(xK));
((zl).qz)=((qv)((ze),([130,134])));
((zj).yy)=(zl);
((zh).yz)=(zj);
(eN)((((xO).yi).yd),([130,134]),(zh));
(r8)((ze),([130,134]));
}
(eN)(((xL).tp),([130,134]),(xO));
return xL;
}
// rebuildFunc
function rD(zm /*ast*/){
let zq=null; // items
if(((zm).zo)!==(null)){
return;
}
((zm).zo)=(zm);
(zq)=((zm).qg);
(qr)((zq),([130,134]));
while(!((qt)((zq),([130,134])))){
(zs)(((qv)((zq),([130,134]))));
(r8)((zq),([130,134]));
}
if(((zm).qh)!==(null)){
((zm).qh)=((zv)(((zm).qh),(null)));
}
((zm).tp)=((zw)(((zm).tp),((zm).qh),(zm)));
}
// rebuildRoot
function rJ(zx /*key*/,zy /*value*/,zz /*data*/){
let z0=null; // ast
let z3=null; // initVarsFunc
let z4=null; // finVarsFunc
let z5=null; // items
let z7=null; // item
let zB=null; // var_
let zF=null; // do_
let zH=null; // assign
let zL=null; // ref
let zS=null; // do_
let zU=null; // assign
let zW=null; // ref
(z0)=(zy);
if(((z0).zo)!==(null)){
return true;
}
((z0).zo)=(z0);
(z3)=((yl)(({S:"kuin"}),({S:"_initVars"}),(false)));
(z4)=((yl)(({S:"kuin"}),({S:"_finVars"}),(false)));
(z5)=((z0).rI);
(qr)((z5),([130,134]));
while(!((qt)((z5),([130,134])))){
(z7)=((qv)((z5),([130,134])));
if(((z7).qc)===(256)){
(rD)((z7));
}
else if(((z7).qc)===(2)){
(zB)=(z7);
if(!((((zB).tX).rp)===(1))){throw 0xE9170000;}
if((((zB).tX).xY)!==(null)){
(((zB).tX).xY)=((zE)((((zB).tX).xY),(false)));
(zF)=(new yp());
(xM)((zF),(528),((z0).ql));
(zH)=(new zI());
(yu)((zH),(2050),((z0).ql));
((zH).zJ)=(0);
(zL)=(new yt());
(yu)((zL),(2062),((z0).ql));
((zL).yI)=(((zB).tX).s4);
((zL).qz)=((zB).tX);
((zH).zM)=(zL);
((zH).zN)=(((zB).tX).xY);
((zF).yz)=(zH);
(eN)(((z3).tp),([130,134]),((zO)((zF),(null),(null))));
}
if(((((zB).tX).s4)!==(null))&&((zQ)((((zB).tX).s4)))){
(zS)=(new yp());
(xM)((zS),(528),((z0).ql));
(zU)=(new zI());
(yu)((zU),(2050),((z0).ql));
((zU).zJ)=(0);
(zW)=(new yt());
(yu)((zW),(2062),((z0).ql));
((zW).yI)=(((zB).tX).s4);
((zW).qz)=((zB).tX);
((zU).zM)=(zW);
((zU).zN)=((zX)(((z0).ql)));
((zS).yz)=(zU);
(eN)(((z4).tp),([130,134]),((zO)((zS),(null),(null))));
}
}
else{
if(!((((((z7).qc)===(3))||(((z7).qc)===(4)))||(((z7).qc)===(5)))||(((z7).qc)===(6)))){throw 0xE9170000;}
}
(r8)((z5),([130,134]));
}
return true;
}
// getInfo
function rU(zZ /*ast*/){
let Ac=null; // info
if((((zZ).zo)===(null))||((((zZ).zo).qc)!==(268435456))){
(Ac)=(new rV());
((Ac).qc)=(268435456);
((Ac).sN)=((Ad)());
if(((((rt)(((zZ).qc),([9]),(66048)))===(66048))&&(((zZ).qX)!==(null)))&&(((zZ).qX).S!==({S:"$"}).S)){
((Ac).Ag)=((Ad)());
if(((rt)(((zZ).qc),([9]),(16843264)))===(16843264)){
((Ac).Aj)=((Ad)());
}
else{
((Ac).Aj)=(null);
}
}
else{
((Ac).Ag)=(null);
((Ac).Aj)=(null);
}
((Ac).tE)=(-1);
((Ac).rX)=(false);
((Ac).Am)=(false);
((Ac).An)=(false);
((zZ).zo)=(Ac);
}
return (zZ).zo;
}
// getType
function sq(Ao /*type*/){
let As=0;
let A1=null; // func_
let A3=null; // id
let A6=null; // arg
let A7=false; // first
let A8=null; // items
let AB=null; // item
let AO=null; // gen
let AR=0;
let AZ=null; // dict_
let Be=null; // prim
let Bg=0;
let Bn=null; // ref
let Bq=null; // info
if((Ao)===(null)){
return {S:"void"};
}
switch((Ao).qc){
case 66561:
return {S:({S:({S:"Array_<"}).S+((v)(((sq)(((Ao).Aw))),([129,2]))).S}).S+({S:">*"}).S};
break;
case 1025:
return {S:({S:({S:"uint"}).S+((v)((((Ao).Az)*(8)),([0]))).S}).S+({S:"_t"}).S};
break;
case 66562:
(A1)=(Ao);
(A3)=((Ad)());
(eN)((O),([130,129,2]),({S:({S:({S:"typedef "}).S+((v)(((sq)(((A1).A4))),([129,2]))).S}).S+({S:({S:({S:"(*"}).S+((v)((A3),([129,2]))).S}).S+({S:")("}).S}).S}));
(A6)=({S:""});
(A7)=(true);
(A8)=((A1).A9);
(qr)((A8),([130,134]));
while(!((qt)((A8),([130,134])))){
(AB)=((qv)((A8),([130,134])));
if(A7){
(A7)=(false);
}
else{
(A6)=({S:(A6).S+({S:", "}).S});
}
(A6)=({S:(A6).S+({S:({S:({S:""}).S+((v)(((sq)(((AB).AI))),([129,2]))).S}).S+({S:""}).S}).S});
if((AB).AK){
(A6)=({S:(A6).S+({S:"*"}).S});
}
(r8)((A8),([130,134]));
}
(eN)((O),([130,129,2]),({S:({S:({S:""}).S+((v)((A6),([129,2]))).S}).S+({S:");\u000A"}).S}));
return A3;
break;
case 66563:
(AO)=(Ao);
switch((AO).AS){
case 0:
return {S:({S:({S:"List_<"}).S+((v)(((sq)(((AO).AU))),([129,2]))).S}).S+({S:">*"}).S};
break;
case 1:
return {S:({S:({S:"Stack_<"}).S+((v)(((sq)(((AO).AU))),([129,2]))).S}).S+({S:">*"}).S};
break;
case 2:
return {S:({S:({S:"Queue_<"}).S+((v)(((sq)(((AO).AU))),([129,2]))).S}).S+({S:">*"}).S};
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
break;
case 66564:
(AZ)=(Ao);
return {S:({S:({S:"Dict_<"}).S+((v)(((sq)(((AZ).Bb))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sq)(((AZ).Bc))),([129,2]))).S}).S+({S:">*"}).S}).S};
break;
case 1026:
(Be)=(Ao);
switch((Be).xX){
case 0:
return {S:"int64_t"};
break;
case 1:
return {S:"double"};
break;
case 2:
return {S:"char16_t"};
break;
case 3:
return {S:"bool"};
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
break;
case 66565:
(Bn)=((Ao).qz);
if(((Bn).qc)===(5)){
(t9)((Bn));
(Bq)=((rU)((Bn)));
return {S:((Bq).sN).S+({S:"*"}).S};
}
else{
if(!(((Bn).qc)===(6))){throw 0xE9170000;}
return {S:"int64_t"};
}
break;
case 1027:
if(!(false)){throw 0xE9170000;}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// isInt
function s3(Bu /*type*/){
return (((Bu).qc)===(1026))&&(((Bu).xX)===(0));
}
// write
function th(Bv /*codes*/,Bw /*attr*/,Bx /*args*/,By /*members*/){
let B0=null;
let B2=null; // class_
let B4=null; // me_
let B5=null; // key
let B6=null; // item
let B8=null; // me_
let B9=null; // item
let BB=null; // me_
let BC=null; // item
let BE=null; // me_
let BF=null; // item
let BH=null; // me_
let BI=null; // n
let BL=null; // me_
let BN=null; // me_
let BO=null; // value
let BQ=null; // me_
let BR=null; // item
let BS=null; // start
let BU=null; // me_
let BV=null; // item
let BX=null; // me_
let BY=null; // callback
let BZ=null; // data
let Cb=null; // me_
let Cc=null; // key
let Cd=null; // existed
let Cf=null; // me_
let Ch=null; // me_
let Cj=null; // me_
let Cl=null; // me_
let Cn=null; // me_
let Cp=null; // me_
let Cq=null; // item
let Cs=null; // me_
let Ct=null; // offset
let Cv=null; // me_
let Cx=null; // me_
let Cy=null; // n
let C0=null; // me_
let C2=null; // me_
let C4=null; // min
let C5=null; // max
let C7=null; // min
let C8=null; // max
let CA=null; // me_
let CB=null; // start
let CC=null; // len
let CF=null; // me_
let CH=null; // me_
let CJ=null; // me_
let CK=null; // success
let CM=null; // me_
let CN=null; // success
let CP=null; // me_
let CQ=null; // success
let CS=null; // me_
let CU=null; // str
let CW=null; // dst
let CX=null; // src
let CZ=null; // path
let Db=null; // path
let Dc=null; // recursion
let Dd=null; // callback
let De=null; // data
let Dg=null; // me_
let Dh=null; // path
let Di=null; // handle
let Dl=null; // me_
let Dm=null; // path
let Dn=null; // append
let Do=null; // handle
let Dq=null; // me_
let Dr=null; // handle
let Dt=null; // me_
let Du=null; // handle
let Dw=null; // me_
let Dx=null; // handle
let Dz=null; // me_
let D0=null; // origin
let D1=null; // pos
let D2=null; // handle
let D4=null; // me_
let D5=null; // handle
let D7=null; // me_
let D8=null; // handle
let DA=null; // me_
let DB=null; // handle
let DD=null; // me_
let DE=null; // origin
let DF=null; // pos
let DG=null; // handle
let DI=null; // me_
let DJ=null; // n
let DK=null; // handle
let DM=null; // me_
let DN=null; // n
let DO=null; // handle
B0=Bw;
if(B0.S===({S:"addr"}).S){
(qr)((Bx),([130,134]));
(B2)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"return reinterpret_cast<uint64_t>("}).S+((v)(((B2).sN),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B0.S===({S:"addDict"}).S){
(qr)((Bx),([130,134]));
(B4)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(r8)((Bx),([130,134]));
(B5)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(B6)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:""}).S+((v)(((B4).sN),([129,2]))).S}).S+({S:({S:({S:"->Add("}).S+((v)(((B5).sN),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((B6).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
}
else if(B0.S===({S:"addList"}).S){
(qr)((Bx),([130,134]));
(B8)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(r8)((Bx),([130,134]));
(B9)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:""}).S+((v)(((B8).sN),([129,2]))).S}).S+({S:({S:({S:"->B.push_back("}).S+((v)(((B9).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(B0.S===({S:"addQueue"}).S){
(qr)((Bx),([130,134]));
(BB)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(r8)((Bx),([130,134]));
(BC)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:""}).S+((v)(((BB).sN),([129,2]))).S}).S+({S:({S:({S:"->B.push("}).S+((v)(((BC).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(B0.S===({S:"addStack"}).S){
(qr)((Bx),([130,134]));
(BE)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(r8)((Bx),([130,134]));
(BF)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:""}).S+((v)(((BE).sN),([129,2]))).S}).S+({S:({S:({S:"->B.push("}).S+((v)(((BF).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(B0.S===({S:"and"}).S){
(qr)((Bx),([130,134]));
(BH)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(r8)((Bx),([130,134]));
(BI)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((BH).sN),([129,2]))).S}).S+({S:({S:({S:" & "}).S+((v)(((BI).sN),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(B0.S===({S:"cmdLine"}).S){
(eN)((Bv),([130,129,2]),({S:"Array_<Array_<char16_t>*>* a_ = new Array_<Array_<char16_t>*>();\u000A"}));
(eN)((Bv),([130,129,2]),({S:"a_->L = argc_;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"a_->B = new Array_<char16_t>*[static_cast<size_t>(argc_)];\u000A"}));
(eN)((Bv),([130,129,2]),({S:"for (int64_t i_ = 0; i_ < argc_; i_++){\u000A"}));
(eN)((Bv),([130,129,2]),({S:"std::string s_ = argv_[i_];\u000A"}));
(eN)((Bv),([130,129,2]),({S:"const std::u16string t_ = utf8ToUtf16_(s_);\u000A"}));
(eN)((Bv),([130,129,2]),({S:"a_->B[i_] = new Array_<char16_t>();\u000A"}));
(eN)((Bv),([130,129,2]),({S:"a_->B[i_]->L = static_cast<int64_t>(t_.size());\u000A"}));
(eN)((Bv),([130,129,2]),({S:"a_->B[i_]->B = new char16_t[t_.size() + 1];\u000A"}));
(eN)((Bv),([130,129,2]),({S:"std::memcpy(a_->B[i_]->B, t_.c_str(), sizeof(char16_t) * (t_.size() + 1));\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}\u000A"}));
(eN)((Bv),([130,129,2]),({S:"return a_;\u000A"}));
}
else if(B0.S===({S:"del"}).S){
(qr)((Bx),([130,134]));
(BL)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"auto& i_ = "}).S+((v)(((BL).sN),([129,2]))).S}).S+({S:"->I++;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:({S:({S:""}).S+((v)(((BL).sN),([129,2]))).S}).S+({S:"->B.erase(i_);\u000A"}).S}));
}
else if(B0.S===({S:"fill"}).S){
(qr)((Bx),([130,134]));
(BN)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(r8)((Bx),([130,134]));
(BO)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"for(int64_t i_ = 0; i_ < "}).S+((v)(((BN).sN),([129,2]))).S}).S+({S:({S:({S:"->L; i_++) "}).S+((v)(((BN).sN),([129,2]))).S}).S+({S:({S:({S:"->B[i_] = "}).S+((v)(((BO).sN),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
}
else if(B0.S===({S:"findArray"}).S){
(qr)((Bx),([130,134]));
(BQ)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(r8)((Bx),([130,134]));
(BR)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(BS)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((BS).sN),([129,2]))).S}).S+({S:({S:({S:" == -1) "}).S+((v)(((BS).sN),([129,2]))).S}).S+({S:" = 0;\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((BS).sN),([129,2]))).S}).S+({S:" < 0) return -1;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"for(int64_t i_ = "}).S+((v)(((BS).sN),([129,2]))).S}).S+({S:({S:({S:"; i_ < "}).S+((v)(((BQ).sN),([129,2]))).S}).S+({S:"->L; i_++){\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((BQ).sN),([129,2]))).S}).S+({S:({S:({S:"->B[i_] == "}).S+((v)(((BR).sN),([129,2]))).S}).S+({S:") return i_;\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:"}\u000A"}));
(eN)((Bv),([130,129,2]),({S:"return -1;\u000A"}));
}
else if(B0.S===({S:"findBin"}).S){
(qr)((Bx),([130,134]));
(BU)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(r8)((Bx),([130,134]));
(BV)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"int64_t a_ = 0, b_ = "}).S+((v)(((BU).sN),([129,2]))).S}).S+({S:"->L - 1;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"while (a_ <= b_) {\u000A"}));
(eN)((Bv),([130,129,2]),({S:"int64_t c_ = (a_ + b_) / 2;\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"int64_t m_ = cmp_("}).S+((v)(((BV).sN),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((BU).sN),([129,2]))).S}).S+({S:"->B[c_]);\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:"if(m_ < 0) b_ = c_ - 1;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"else if(m_ > 0) a_ = c_ + 1;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"else return c_;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}\u000A"}));
(eN)((Bv),([130,129,2]),({S:"return -1;\u000A"}));
}
else if(B0.S===({S:"forEach"}).S){
(qr)((Bx),([130,134]));
(BX)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(r8)((Bx),([130,134]));
(BY)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(BZ)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"return dictForEach_("}).S+((v)(((BX).sN),([129,2]))).S}).S+({S:({S:({S:"->B, static_cast<bool(*)(K_, V_, Class_*)>("}).S+((v)(((BY).sN),([129,2]))).S}).S+({S:({S:({S:"), "}).S+((v)(((BZ).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
}
else if(B0.S===({S:"getDict"}).S){
(qr)((Bx),([130,134]));
(Cb)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(r8)((Bx),([130,134]));
(Cc)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(Cd)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"return dictSearch_("}).S+((v)(((Cb).sN),([129,2]))).S}).S+({S:({S:({S:"->B, "}).S+((v)(((Cc).sN),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((Cd).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
}
else if(B0.S===({S:"getList"}).S){
(qr)((Bx),([130,134]));
(Cf)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"return *"}).S+((v)(((Cf).sN),([129,2]))).S}).S+({S:"->I;\u000A"}).S}));
}
else if(B0.S===({S:"getQueue"}).S){
(qr)((Bx),([130,134]));
(Ch)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"R_ r_ = "}).S+((v)(((Ch).sN),([129,2]))).S}).S+({S:"->B.front();\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:({S:({S:""}).S+((v)(((Ch).sN),([129,2]))).S}).S+({S:"->B.pop();\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"return r_;\u000A"}));
}
else if(B0.S===({S:"getStack"}).S){
(qr)((Bx),([130,134]));
(Cj)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"R_ r_ = "}).S+((v)(((Cj).sN),([129,2]))).S}).S+({S:"->B.top();\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:({S:({S:""}).S+((v)(((Cj).sN),([129,2]))).S}).S+({S:"->B.pop();\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"return r_;\u000A"}));
}
else if(B0.S===({S:"head"}).S){
(qr)((Bx),([130,134]));
(Cl)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:""}).S+((v)(((Cl).sN),([129,2]))).S}).S+({S:({S:({S:"->I = "}).S+((v)(((Cl).sN),([129,2]))).S}).S+({S:"->B.begin();\u000A"}).S}).S}));
}
else if(B0.S===({S:"idx"}).S){
(qr)((Bx),([130,134]));
(Cn)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:"int64_t i_ = 0;\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"for(auto& t_ = "}).S+((v)(((Cn).sN),([129,2]))).S}).S+({S:({S:({S:"->B.begin(); t_ != "}).S+((v)(((Cn).sN),([129,2]))).S}).S+({S:"->B.end(); ++t_){\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"if(t_ == "}).S+((v)(((Cn).sN),([129,2]))).S}).S+({S:"->I) return i_;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"i_++;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}\u000A"}));
(eN)((Bv),([130,129,2]),({S:"return -1;\u000A"}));
}
else if(B0.S===({S:"ins"}).S){
(qr)((Bx),([130,134]));
(Cp)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(r8)((Bx),([130,134]));
(Cq)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:""}).S+((v)(((Cp).sN),([129,2]))).S}).S+({S:({S:({S:"->B.insert("}).S+((v)(((Cp).sN),([129,2]))).S}).S+({S:({S:({S:"->I, "}).S+((v)(((Cq).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
}
else if(B0.S===({S:"moveOffset"}).S){
(qr)((Bx),([130,134]));
(Cs)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(r8)((Bx),([130,134]));
(Ct)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Ct).sN),([129,2]))).S}).S+({S:" >= 0){\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"for(int64_t i_ = 0; i_ < "}).S+((v)(((Ct).sN),([129,2]))).S}).S+({S:"; i_++){\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Cs).sN),([129,2]))).S}).S+({S:({S:({S:"->I == "}).S+((v)(((Cs).sN),([129,2]))).S}).S+({S:"->B.end()) break;\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"++"}).S+((v)(((Cs).sN),([129,2]))).S}).S+({S:"->I;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"}\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}else{\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"for(int64_t i_ = 0; i_ > "}).S+((v)(((Ct).sN),([129,2]))).S}).S+({S:"; i_--){\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Cs).sN),([129,2]))).S}).S+({S:({S:({S:"->I == "}).S+((v)(((Cs).sN),([129,2]))).S}).S+({S:"->B.end()) break;\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"--"}).S+((v)(((Cs).sN),([129,2]))).S}).S+({S:"->I;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"}\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}\u000A"}));
}
else if(B0.S===({S:"next"}).S){
(qr)((Bx),([130,134]));
(Cv)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"++"}).S+((v)(((Cv).sN),([129,2]))).S}).S+({S:"->I;\u000A"}).S}));
}
else if(B0.S===({S:"or"}).S){
(qr)((Bx),([130,134]));
(Cx)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(r8)((Bx),([130,134]));
(Cy)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Cx).sN),([129,2]))).S}).S+({S:({S:({S:" | "}).S+((v)(((Cy).sN),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(B0.S===({S:"peekQueue"}).S){
(qr)((Bx),([130,134]));
(C0)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((C0).sN),([129,2]))).S}).S+({S:"->B.front();\u000A"}).S}));
}
else if(B0.S===({S:"peekStack"}).S){
(qr)((Bx),([130,134]));
(C2)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((C2).sN),([129,2]))).S}).S+({S:"->B.top();\u000A"}).S}));
}
else if(B0.S===({S:"rnd"}).S){
(qr)((Bx),([130,134]));
(C4)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(C5)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"return rnd_("}).S+((v)(((C4).sN),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((C5).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(B0.S===({S:"rndFloat"}).S){
(qr)((Bx),([130,134]));
(C7)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(C8)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"return rndFloat_("}).S+((v)(((C7).sN),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((C8).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(B0.S===({S:"sub"}).S){
(qr)((Bx),([130,134]));
(CA)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(r8)((Bx),([130,134]));
(CB)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(CC)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"return sub_("}).S+((v)(((CA).sN),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((CB).sN),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((CC).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
}
else if(B0.S===({S:"sysTime"}).S){
(eN)((Bv),([130,129,2]),({S:"return static_cast<int64_t>(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());\u000A"}));
}
else if(B0.S===({S:"tail"}).S){
(qr)((Bx),([130,134]));
(CF)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:""}).S+((v)(((CF).sN),([129,2]))).S}).S+({S:({S:({S:"->I = "}).S+((v)(((CF).sN),([129,2]))).S}).S+({S:"->B.end();\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"--"}).S+((v)(((CF).sN),([129,2]))).S}).S+({S:"->I;\u000A"}).S}));
}
else if(B0.S===({S:"term"}).S){
(qr)((Bx),([130,134]));
(CH)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((CH).sN),([129,2]))).S}).S+({S:({S:({S:"->I == "}).S+((v)(((CH).sN),([129,2]))).S}).S+({S:"->B.end();\u000A"}).S}).S}));
}
else if(B0.S===({S:"toBit64"}).S){
(qr)((Bx),([130,134]));
(CJ)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(CK)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"std::u16string s_ = "}).S+((v)(((CJ).sN),([129,2]))).S}).S+({S:"->B;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"const std::string& t_ = utf16ToUtf8_(s_);\u000A"}));
(eN)((Bv),([130,129,2]),({S:"try{\u000A"}));
(eN)((Bv),([130,129,2]),({S:"size_t s_;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"uint64_t v_ = t_.size() > 2 && t_[0] == \'0\' && t_[1] == \'x\' ? std::stoull(t_, &s_, 16) : std::stoull(t_, &s_);\u000A"}));
(eN)((Bv),([130,129,2]),({S:"if(s_ == t_.size()){\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((CK).sN),([129,2]))).S}).S+({S:" = true;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"return v_;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}else{\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((CK).sN),([129,2]))).S}).S+({S:" = false;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"return 0;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}catch(...){\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((CK).sN),([129,2]))).S}).S+({S:" = false;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"return 0;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}\u000A"}));
}
else if(B0.S===({S:"toFloat"}).S){
(qr)((Bx),([130,134]));
(CM)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(CN)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"std::u16string s_ = "}).S+((v)(((CM).sN),([129,2]))).S}).S+({S:"->B;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"const std::string& t_ = utf16ToUtf8_(s_);\u000A"}));
(eN)((Bv),([130,129,2]),({S:"try{\u000A"}));
(eN)((Bv),([130,129,2]),({S:"size_t s_;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"double v_ = std::stod(t_, &s_);\u000A"}));
(eN)((Bv),([130,129,2]),({S:"if(s_ == t_.size()){\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((CN).sN),([129,2]))).S}).S+({S:" = true;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"return v_;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}else{\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((CN).sN),([129,2]))).S}).S+({S:" = false;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"return 0;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}catch(...){\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((CN).sN),([129,2]))).S}).S+({S:" = false;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"return 0;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}\u000A"}));
}
else if(B0.S===({S:"toInt"}).S){
(qr)((Bx),([130,134]));
(CP)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(CQ)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"std::u16string s_ = "}).S+((v)(((CP).sN),([129,2]))).S}).S+({S:"->B;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"const std::string& t_ = utf16ToUtf8_(s_);\u000A"}));
(eN)((Bv),([130,129,2]),({S:"try{\u000A"}));
(eN)((Bv),([130,129,2]),({S:"size_t s_;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"int64_t v_ = t_.size() > 2 && t_[0] == \'0\' && t_[1] == \'x\' ? std::stoll(t_, &s_, 16) : std::stoull(t_, &s_);\u000A"}));
(eN)((Bv),([130,129,2]),({S:"if(s_ == t_.size()){\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((CQ).sN),([129,2]))).S}).S+({S:" = true;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"return v_;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}else{\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((CQ).sN),([129,2]))).S}).S+({S:" = false;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"return 0;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}catch(...){\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"*"}).S+((v)(((CQ).sN),([129,2]))).S}).S+({S:" = false;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"return 0;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}\u000A"}));
}
else if(B0.S===({S:"toStr"}).S){
(qr)((Bx),([130,134]));
(CS)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"return toStr_("}).S+((v)(((CS).sN),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B0.S===({S:"cui_print"}).S){
(qr)((Bx),([130,134]));
(CU)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"std::u16string s_ = "}).S+((v)(((CU).sN),([129,2]))).S}).S+({S:"->B;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"const std::string& t_ = utf16ToUtf8_(s_);\u000A"}));
(eN)((Bv),([130,129,2]),({S:"std::cout << t_ << std::flush;\u000A"}));
}
else if(B0.S===({S:"file_copyFile"}).S){
(qr)((Bx),([130,134]));
(CW)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(CX)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:({S:({S:"return copyFile_("}).S+((v)(((CW).sN),([129,2]))).S}).S+({S:({S:({S:"->B, "}).S+((v)(((CX).sN),([129,2]))).S}).S+({S:"->B);\u000A"}).S}).S}));
}
else if(B0.S===({S:"file_exist"}).S){
(qr)((Bx),([130,134]));
(CZ)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:"return false;\u000A"}));
}
else if(B0.S===({S:"file_forEach"}).S){
(qr)((Bx),([130,134]));
(Db)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(Dc)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(Dd)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(De)=((rU)(((qv)((Bx),([130,134])))));
(eN)((Bv),([130,129,2]),({S:"return false;\u000A"}));
}
else if(B0.S===({S:"file_makeReader"}).S){
(qr)((Bx),([130,134]));
(Dg)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(Dh)=((rU)(((qv)((Bx),([130,134])))));
(Di)=((Dj)((By),({S:"handle"})));
(eN)((Bv),([130,129,2]),({S:({S:({S:""}).S+((v)(((Dg).sN),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((Di).sN),([129,2]))).S}).S+({S:" = reinterpret_cast<int64_t>(new reader_());\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"std::u16string s_ = "}).S+((v)(((Dh).sN),([129,2]))).S}).S+({S:"->B;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"const std::string& t_ = utf16ToUtf8_(s_);\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"reader_* r_ = reinterpret_cast<reader_*>("}).S+((v)(((Dg).sN),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((Di).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:"r_->F = new std::ifstream(t_.c_str(), std::ios::in | std::ios::binary);\u000A"}));
(eN)((Bv),([130,129,2]),({S:"if(!*r_->F) return nullptr;\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Dg).sN),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
else if(B0.S===({S:"file_makeWriter"}).S){
(qr)((Bx),([130,134]));
(Dl)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(Dm)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(Dn)=((rU)(((qv)((Bx),([130,134])))));
(Do)=((Dj)((By),({S:"handle"})));
(eN)((Bv),([130,129,2]),({S:({S:({S:""}).S+((v)(((Dl).sN),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((Do).sN),([129,2]))).S}).S+({S:" = reinterpret_cast<int64_t>(new writer_());\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"std::u16string s_ = "}).S+((v)(((Dm).sN),([129,2]))).S}).S+({S:"->B;\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"const std::string& t_ = utf16ToUtf8_(s_);\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"writer_* r_ = reinterpret_cast<writer_*>("}).S+((v)(((Dl).sN),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((Do).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"r_->F = new std::ofstream(t_.c_str(), std::ios::out | std::ios::binary | ("}).S+((v)(((Dn).sN),([129,2]))).S}).S+({S:" ? std::ios::app : std::ios::trunc));\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"if(!*r_->F) return nullptr;\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Dl).sN),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
else if(B0.S===({S:"file_readerFin"}).S){
(qr)((Bx),([130,134]));
(Dq)=((rU)(((qv)((Bx),([130,134])))));
(Dr)=((Dj)((By),({S:"handle"})));
(eN)((Bv),([130,129,2]),({S:({S:({S:"reader_* r_ = reinterpret_cast<reader_*>("}).S+((v)(((Dq).sN),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((Dr).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:"r_->F->close();\u000A"}));
}
else if(B0.S===({S:"file_readerGetPos"}).S){
(qr)((Bx),([130,134]));
(Dt)=((rU)(((qv)((Bx),([130,134])))));
(Du)=((Dj)((By),({S:"handle"})));
(eN)((Bv),([130,129,2]),({S:({S:({S:"reader_* r_ = reinterpret_cast<reader_*>("}).S+((v)(((Dt).sN),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((Du).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:"return static_cast<int64_t>(r_->F->tellg());\u000A"}));
}
else if(B0.S===({S:"file_readerReadLetter"}).S){
(qr)((Bx),([130,134]));
(Dw)=((rU)(((qv)((Bx),([130,134])))));
(Dx)=((Dj)((By),({S:"handle"})));
(eN)((Bv),([130,129,2]),({S:({S:({S:"reader_* r_ = reinterpret_cast<reader_*>("}).S+((v)(((Dw).sN),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((Dx).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:"return readUtf8_(r_->F);\u000A"}));
}
else if(B0.S===({S:"file_readerSetPos"}).S){
(qr)((Bx),([130,134]));
(Dz)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(D0)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(D1)=((rU)(((qv)((Bx),([130,134])))));
(D2)=((Dj)((By),({S:"handle"})));
(eN)((Bv),([130,129,2]),({S:({S:({S:"reader_* r_ = reinterpret_cast<reader_*>("}).S+((v)(((Dz).sN),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((D2).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:"std::ios_base::seekdir o_ = std::ios_base::beg;\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"switch("}).S+((v)(((D0).sN),([129,2]))).S}).S+({S:"){\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"case 0: o_ = std::ios_base::beg; break;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"case 1: o_ = std::ios_base::cur; break;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"case 2: o_ = std::ios_base::end; break;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"r_->F->seekg("}).S+((v)(((D1).sN),([129,2]))).S}).S+({S:", o_);\u000A"}).S}));
}
else if(B0.S===({S:"file_readerTerm"}).S){
(qr)((Bx),([130,134]));
(D4)=((rU)(((qv)((Bx),([130,134])))));
(D5)=((Dj)((By),({S:"handle"})));
(eN)((Bv),([130,129,2]),({S:({S:({S:"reader_* r_ = reinterpret_cast<reader_*>("}).S+((v)(((D4).sN),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((D5).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:"char c_;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"if(r_->F->get(c_)) {\u000A"}));
(eN)((Bv),([130,129,2]),({S:"r_->F->seekg(-1, std::ios_base::cur);\u000A"}));
(eN)((Bv),([130,129,2]),({S:"return false;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}\u000A"}));
(eN)((Bv),([130,129,2]),({S:"return true;\u000A"}));
}
else if(B0.S===({S:"file_writerFin"}).S){
(qr)((Bx),([130,134]));
(D7)=((rU)(((qv)((Bx),([130,134])))));
(D8)=((Dj)((By),({S:"handle"})));
(eN)((Bv),([130,129,2]),({S:({S:({S:"writer_* r_ = reinterpret_cast<writer_*>("}).S+((v)(((D7).sN),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((D8).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:"r_->F->close();\u000A"}));
}
else if(B0.S===({S:"file_writerGetPos"}).S){
(qr)((Bx),([130,134]));
(DA)=((rU)(((qv)((Bx),([130,134])))));
(DB)=((Dj)((By),({S:"handle"})));
(eN)((Bv),([130,129,2]),({S:({S:({S:"writer_* r_ = reinterpret_cast<writer_*>("}).S+((v)(((DA).sN),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((DB).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:"return static_cast<int64_t>(r_->F->tellp());\u000A"}));
}
else if(B0.S===({S:"file_writerSetPos"}).S){
(qr)((Bx),([130,134]));
(DD)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(DE)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(DF)=((rU)(((qv)((Bx),([130,134])))));
(DG)=((Dj)((By),({S:"handle"})));
(eN)((Bv),([130,129,2]),({S:({S:({S:"writer_* r_ = reinterpret_cast<writer_*>("}).S+((v)(((DD).sN),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((DG).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:"std::ios_base::seekdir o_ = std::ios_base::beg;\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"switch("}).S+((v)(((DE).sN),([129,2]))).S}).S+({S:"){\u000A"}).S}));
(eN)((Bv),([130,129,2]),({S:"case 0: o_ = std::ios_base::beg; break;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"case 1: o_ = std::ios_base::cur; break;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"case 2: o_ = std::ios_base::end; break;\u000A"}));
(eN)((Bv),([130,129,2]),({S:"}\u000A"}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"r_->F->seekp("}).S+((v)(((DF).sN),([129,2]))).S}).S+({S:", o_);\u000A"}).S}));
}
else if(B0.S===({S:"file_writerWrite"}).S){
(qr)((Bx),([130,134]));
(DI)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(DJ)=((rU)(((qv)((Bx),([130,134])))));
(DK)=((Dj)((By),({S:"handle"})));
(eN)((Bv),([130,129,2]),({S:({S:({S:"writer_* r_ = reinterpret_cast<writer_*>("}).S+((v)(((DI).sN),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((DK).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"r_->F->write(reinterpret_cast<char*>("}).S+((v)(((DJ).sN),([129,2]))).S}).S+({S:({S:({S:"->B), "}).S+((v)(((DJ).sN),([129,2]))).S}).S+({S:"->L);\u000A"}).S}).S}));
}
else if(B0.S===({S:"file_writerWriteChar"}).S){
(qr)((Bx),([130,134]));
(DM)=((rU)(((qv)((Bx),([130,134])))));
(r8)((Bx),([130,134]));
(DN)=((rU)(((qv)((Bx),([130,134])))));
(DO)=((Dj)((By),({S:"handle"})));
(eN)((Bv),([130,129,2]),({S:({S:({S:"writer_* r_ = reinterpret_cast<writer_*>("}).S+((v)(((DM).sN),([129,2]))).S}).S+({S:({S:({S:"->"}).S+((v)(((DO).sN),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((Bv),([130,129,2]),({S:({S:({S:"writeUtf8_(r_->F, "}).S+((v)(((DN).sN),([129,2]))).S}).S+({S:");\u000A"}).S}));
}
else if(B0.S===({S:"wnd_editBaseGetText"}).S){
}
else if(B0.S===({S:"wnd_makeEditMulti"}).S){
}
else{if(!(false)){throw 0xE9170000;}
}
}
// _tail
function tl(DS /*me_*/,DT /*type*/){
DS.P=DS.T;
}
// _idx
function tn(DU /*me_*/,DV /*type*/){
let p_=DU.H,i_=0;
if(DU.P===null)return -1;
while(p_!==null){
if(p_===DU.P)return i_
i_++;
p_=p_.N;
}
return -1;
}
// buildStats
function to(DW /*stats*/,DX /*breakStat*/,DY /*skipStat*/){
let Ea=null; // stat
let Ec=0;
(qr)((DW),([130,134]));
while(!((qt)((DW),([130,134])))){
(Ea)=((qv)((DW),([130,134])));
switch((Ea).qc){
case 66049:
(Ee)((Ea),(DX),(DY));
break;
case 66050:
(Eh)((Ea),(DX),(DY));
break;
case 16843265:
(Ek)((Ea),(DX),(DY));
break;
case 16843266:
(Eo)((Ea),(DX),(DY));
break;
case 66051:
(Er)((Ea),(DX),(DY));
break;
case 526:
(Et)((Ea));
break;
case 66052:
(Ew)((Ea),(DX),(DY));
break;
case 527:
(Ey)((Ea));
break;
case 528:
(E1)((Ea));
break;
case 529:
(E3)((Ea),(DX));
break;
case 530:
(E5)((Ea),(DY));
break;
case 531:
(E7)((Ea));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(r8)((DW),([130,134]));
}
}
// _moveOffset
function tq(EA /*me_*/,EB /*type*/,EC /*offset*/){
if(EC>=0){
for(let i_=0;i_<EC;i_++){
if(EA.P===null)break;
EA.P=EA.P.N;
}
}else{
for(let i_=0;i_>EC;i_--){
if(EA.P===null)break;
EA.P=EA.P.P;
}
}
}
// _ins
function tw(ED /*me_*/,EE /*type*/,EF /*item*/){
let p_=ED.P;
let n_={P:p_.P,N:p_,I:EF}
if(p_.P===null)ED.H=n_;else p_.P.N=n_;
if(ED.T===null)ED.T=n_;
p_.P=n_;
ED.L++;
}
// getDefaultValue
function tx(EG /*type*/){
let EL=0;
let ER=0;
if((EI)((EG))){
return {S:"nullptr"};
}
switch((EG).qc){
case 66565:
if(!((EN)((EG)))){throw 0xE9170000;}
return {S:"0"};
break;
case 1025:
return {S:"0"};
break;
case 1026:
switch((EG).xX){
case 0:
case 2:
return {S:"0"};
break;
case 1:
return {S:"0.0"};
break;
case 3:
return {S:"false"};
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// _del
function tz(EX /*me_*/,EY /*type*/){
let p_=EX.P;
if(p_.P===null)EX.H=p_.N;else p_.P.N=p_.N;
if(p_.N===null)EX.T=p_.P;else p_.N.P=p_.P;
EX.P=p_.N;
EX.L--;
}
// refClass
function t9(EZ /*ast*/){
let Fa=null; // info
let Fj=null; // items
let Fl=null; // item
let Fo=null; // func_
let Fr=null; // items2
let Ft=null; // arg
let Fv=null; // var_
(Fa)=((rU)((EZ)));
if((Fa).rX){
return (Fa).sN;
}
((Fa).rX)=(true);
if(((EZ).qz)!==(null)){
(t9)(((EZ).qz));
}
if(((Fa).tE)===(-1)){
((Fa).tE)=(eR);
(eR)=((eR)+(1));
}
(Fj)=((EZ).tg);
(qr)((Fj),([130,134]));
while(!((qt)((Fj),([130,134])))){
(Fl)=((qv)((Fj),([130,134])));
if((((Fl).tS).qc)===(256)){
(Fo)=((Fl).tS);
if(((Fo).qh)!==(null)){
(sq)(((Fo).qh));
}
(Fr)=((Fo).qg);
(qr)((Fr),([130,134]));
while(!((qt)((Fr),([130,134])))){
(Ft)=((qv)((Fr),([130,134])));
(sq)(((Ft).s4));
(r8)((Fr),([130,134]));
}
(eQ)((K),([132,134]),(Fo));
}
else if((((Fl).tS).qc)===(2)){
(Fv)=((Fl).tS);
(sq)((((Fv).tX).s4));
}
(r8)((Fj),([130,134]));
}
(eQ)((L),([132,134]),(EZ));
return (Fa).sN;
}
// findFunc
function ua(Fw /*ast*/,Fx /*name*/){
let Fy=null; // items
let F0=null; // item
(Fy)=((Fw).tg);
(qr)((Fy),([130,134]));
while(!((qt)((Fy),([130,134])))){
(F0)=((qv)((Fy),([130,134])));
if(((((F0).tS).qc)===(256))&&((((F0).tS).qX).S===(Fx).S)){
return (F0).tS;
}
(r8)((Fy),([130,134]));
}
return null;
}
// makeWriter
function u4(F3 /*me2*/,F4 /*path*/,F5 /*append*/){
F3.F6={F:"",I:0,P:F4.S};
return F3;
}
// writeCpp
function uC(F7 /*writer*/,F8 /*resFiles*/){
let FE=null; // globalVar
let FF=null; // info
let FK=null; // item
(uB)((F7),({S:"namespace {\u000A"}));
(qr)((N),([130,129,2]));
while(!((qt)((N),([130,129,2])))){
(uB)((F7),((qv)((N),([130,129,2]))));
(r8)((N),([130,129,2]));
}
(qr)((O),([130,129,2]));
while(!((qt)((O),([130,129,2])))){
(uB)((F7),((qv)((O),([130,129,2]))));
(r8)((O),([130,129,2]));
}
if((eR)!==(0)){
(uB)((F7),({S:({S:({S:"static int64_t classTable_["}).S+((v)(((eR)*(2)),([0]))).S}).S+({S:"];\u000A"}).S}));
}
(uB)((F7),({S:"static int64_t argc_;\u000A"}));
(uB)((F7),({S:"static char** argv_;\u000A"}));
(qr)((S),([130,134]));
while(!((qt)((S),([130,134])))){
(FE)=((qv)((S),([130,134])));
(FF)=((rU)((FE)));
(uB)((F7),({S:({S:({S:"static "}).S+((v)(((sq)(((FE).s4))),([129,2]))).S}).S+({S:({S:({S:" "}).S+((v)(((FF).sN),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
(r8)((S),([130,134]));
}
(qr)((Q),([130,129,2]));
while(!((qt)((Q),([130,129,2])))){
(uB)((F7),((qv)((Q),([130,129,2]))));
(r8)((Q),([130,129,2]));
}
(qr)((P),([130,129,2]));
while(!((qt)((P),([130,129,2])))){
(uB)((F7),((qv)((P),([130,129,2]))));
(r8)((P),([130,129,2]));
}
(uB)((F7),({S:"}\u000A"}));
(uB)((F7),({S:"int main(int c_, char** v_){\u000A"}));
(uB)((F7),({S:"argc_ = c_ - 1;\u000A"}));
(uB)((F7),({S:"argv_ = v_ + 1;\u000A"}));
(qr)((U),([130,129,2]));
while(!((qt)((U),([130,129,2])))){
(FK)=((qv)((U),([130,129,2])));
(uB)((F7),(FK));
(r8)((U),([130,129,2]));
}
(uB)((F7),({S:"init_();\u000A"}));
(uB)((F7),({S:"a();\u000A"}));
(uB)((F7),({S:"return 0;\u000A"}));
(uB)((F7),({S:"}\u000A"}));
}
// copyFile
function uF(FL /*dst*/,FM /*src*/){
return false;
}
// getInfo
function uJ(FN /*ast*/){
let FQ=null; // info
if((((FN).zo)===(null))||((((FN).zo).qc)!==(268435456))){
(FQ)=(new uK());
((FQ).qc)=(268435456);
((FQ).va)=((FR)());
if(((((rt)(((FN).qc),([9]),(66048)))===(66048))&&(((FN).qX)!==(null)))&&(((FN).qX).S!==({S:"$"}).S)){
((FQ).FU)=((FR)());
}
else{
((FQ).FU)=(null);
}
((FQ).uM)=(false);
((FN).zo)=(FQ);
}
return (FN).zo;
}
// write
function vr(FW /*codes*/,FX /*attr*/,FY /*args*/,FZ /*members*/){
let Gb=null;
let Ge=null; // me_
let Gf=null; // meType
let Gg=null; // key
let Gh=null; // item
let Gj=null; // me_
let Gk=null; // item
let Gm=null; // me_
let Gn=null; // item
let Gp=null; // me_
let Gq=null; // item
let Gs=null; // me_
let Gt=null; // n
let Gw=null; // me_
let Gy=null; // me_
let Gz=null; // meType
let G0=null; // value
let G2=null; // me_
let G3=null; // meType
let G4=null; // item
let G5=null; // start
let G7=null; // me_
let G8=null; // meType
let G9=null; // item
let GB=null; // me_
let GC=null; // meType
let GD=null; // callback
let GE=null; // data
let GG=null; // me_
let GH=null; // meType
let GI=null; // key
let GJ=null; // existed
let GL=null; // me_
let GN=null; // me_
let GP=null; // me_
let GR=null; // me_
let GT=null; // me_
let GV=null; // me_
let GW=null; // item
let GY=null; // me_
let GZ=null; // offset
let Hb=null; // me_
let Hd=null; // me_
let He=null; // n
let Hg=null; // me_
let Hi=null; // me_
let Hk=null; // min
let Hl=null; // max
let Hn=null; // min
let Ho=null; // max
let Hq=null; // me_
let Hr=null; // meType
let Hs=null; // start
let Ht=null; // len
let Hw=null; // me_
let Hy=null; // me_
let H0=null; // me_
let H1=null; // success
let H3=null; // me_
let H4=null; // success
let H6=null; // me_
let H7=null; // success
let H9=null; // me_
let HA=null; // type
let HC=null; // str
let HF=null; // path
let HH=null; // path
let HI=null; // recursion
let HJ=null; // callback
let HK=null; // data
let HM=null; // me_
let HN=null; // path
let HO=null; // handle
let HR=null; // me_
let HS=null; // path
let HT=null; // append
let HU=null; // handle
let HW=null; // me_
let HX=null; // handle
let HZ=null; // me_
let Ia=null; // handle
let Ic=null; // me_
let Id=null; // handle
let If=null; // me_
let Ig=null; // origin
let Ih=null; // pos
let Ii=null; // handle
let Ik=null; // me_
let Il=null; // handle
let In=null; // me_
let Io=null; // handle
let Iq=null; // me_
let Ir=null; // handle
let It=null; // me_
let Iu=null; // origin
let Iv=null; // pos
let Iw=null; // handle
let Iy=null; // me_
let Iz=null; // n
let I0=null; // handle
let I2=null; // me_
let I3=null; // n
let I4=null; // handle
let I6=null; // me_
let I7=null; // handle
let I9=null; // me_
let IA=null; // parent
let IB=null; // x
let IC=null; // y
let ID=null; // width
let IE=null; // height
let IF=null; // anchorX
let IG=null; // anchorY
let IH=null; // handle
Gb=FX;
if(Gb.S===({S:"addr"}).S){
}
else if(Gb.S===({S:"addDict"}).S){
(qr)((FY),([130,134]));
(Ge)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(Gf)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(Gg)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(Gh)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Gf).va),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((Gf).va),([129,2]))).S}).S+({S:({S:({S:"[2]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((Ge).va),([129,2]))).S}).S+({S:({S:({S:".set("}).S+((v)(((Gg).va),([129,2]))).S}).S+({S:({S:({S:".S, "}).S+((v)(((Gh).va),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:"else\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((Ge).va),([129,2]))).S}).S+({S:({S:({S:".set("}).S+((v)(((Gg).va),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((Gh).va),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
}
else if(Gb.S===({S:"addList"}).S){
(qr)((FY),([130,134]));
(Gj)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(r8)((FY),([130,134]));
(Gk)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"let n_={P:null,N:null,I:"}).S+((v)(((Gk).va),([129,2]))).S}).S+({S:"};\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Gj).va),([129,2]))).S}).S+({S:({S:({S:".H===null){"}).S+((v)(((Gj).va),([129,2]))).S}).S+({S:({S:({S:".H=n_;"}).S+((v)(((Gj).va),([129,2]))).S}).S+({S:({S:({S:".T=n_}else{n_.P="}).S+((v)(((Gj).va),([129,2]))).S}).S+({S:({S:({S:".T;"}).S+((v)(((Gj).va),([129,2]))).S}).S+({S:({S:({S:".T.N=n_;"}).S+((v)(((Gj).va),([129,2]))).S}).S+({S:".T=n_}\u000A"}).S}).S}).S}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((Gj).va),([129,2]))).S}).S+({S:".L++;\u000A"}).S}));
}
else if(Gb.S===({S:"addQueue"}).S){
(qr)((FY),([130,134]));
(Gm)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(r8)((FY),([130,134]));
(Gn)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((Gm).va),([129,2]))).S}).S+({S:({S:({S:".push("}).S+((v)(((Gn).va),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(Gb.S===({S:"addStack"}).S){
(qr)((FY),([130,134]));
(Gp)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(r8)((FY),([130,134]));
(Gq)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((Gp).va),([129,2]))).S}).S+({S:({S:({S:".push("}).S+((v)(((Gq).va),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(Gb.S===({S:"and"}).S){
(qr)((FY),([130,134]));
(Gs)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(r8)((FY),([130,134]));
(Gt)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Gs).va),([129,2]))).S}).S+({S:({S:({S:"&"}).S+((v)(((Gt).va),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(Gb.S===({S:"cmdLine"}).S){
(eN)((FW),([130,129,2]),({S:"let r_=(O_&&O_.cmdLine)?O_.cmdLine:location.search.slice(1).split(\"&\");\u000A"}));
(eN)((FW),([130,129,2]),({S:"if(r_.length===1&&r_[0]===\"\")return[];\u000A"}));
(eN)((FW),([130,129,2]),({S:"for(let i_=0;i_<r_.length;i_++)\u000A"}));
(eN)((FW),([130,129,2]),({S:"r_[i_]={S:r_[i_]};\u000A"}));
(eN)((FW),([130,129,2]),({S:"return r_;\u000A"}));
}
else if(Gb.S===({S:"del"}).S){
(qr)((FY),([130,134]));
(Gw)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"let p_="}).S+((v)(((Gw).va),([129,2]))).S}).S+({S:".P;\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"if(p_.P===null)"}).S+((v)(((Gw).va),([129,2]))).S}).S+({S:".H=p_.N;else p_.P.N=p_.N;\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"if(p_.N===null)"}).S+((v)(((Gw).va),([129,2]))).S}).S+({S:".T=p_.P;else p_.N.P=p_.P;\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((Gw).va),([129,2]))).S}).S+({S:".P=p_.N;\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((Gw).va),([129,2]))).S}).S+({S:".L--;\u000A"}).S}));
}
else if(Gb.S===({S:"fill"}).S){
(qr)((FY),([130,134]));
(Gy)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(Gz)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(G0)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Gz).va),([129,2]))).S}).S+({S:({S:({S:"[0]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((Gz).va),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((Gy).va),([129,2]))).S}).S+({S:({S:({S:".S=String.fromCharCode("}).S+((v)(((G0).va),([129,2]))).S}).S+({S:({S:({S:").repeat("}).S+((v)(((Gy).va),([129,2]))).S}).S+({S:".S.length);\u000A"}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:"else\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((Gy).va),([129,2]))).S}).S+({S:({S:({S:".fill("}).S+((v)(((G0).va),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
}
else if(Gb.S===({S:"findArray"}).S){
(qr)((FY),([130,134]));
(G2)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(G3)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(G4)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(G5)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((G3).va),([129,2]))).S}).S+({S:({S:({S:"[0]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((G3).va),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((G2).va),([129,2]))).S}).S+({S:({S:({S:".S.indexOf(String.fromCharCode("}).S+((v)(((G4).va),([129,2]))).S}).S+({S:({S:({S:"),"}).S+((v)(((G5).va),([129,2]))).S}).S+({S:({S:({S:"===-1?0:"}).S+((v)(((G5).va),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:"else\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((G2).va),([129,2]))).S}).S+({S:({S:({S:".indexOf("}).S+((v)(((G4).va),([129,2]))).S}).S+({S:({S:({S:","}).S+((v)(((G5).va),([129,2]))).S}).S+({S:({S:({S:"===-1?0:"}).S+((v)(((G5).va),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}).S}));
}
else if(Gb.S===({S:"findBin"}).S){
(qr)((FY),([130,134]));
(G7)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(G8)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(G9)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"let a_=0,b_="}).S+((v)(((G7).va),([129,2]))).S}).S+({S:".length-1,c_,m_,f_;\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"switch("}).S+((v)(((G8).va),([129,2]))).S}).S+({S:"[0]){\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((0),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((1),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((2),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((4),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((5),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((6),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((7),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((9),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"f_=function(a,b){return a>b?1:a<b?-1:0};\u000A"}));
(eN)((FW),([130,129,2]),({S:"break;\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((129),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"f_=function(a,b){return a.S>b.S?1:a.S<b.S?-1:0};\u000A"}));
(eN)((FW),([130,129,2]),({S:"break;\u000A"}));
(eN)((FW),([130,129,2]),({S:"default:\u000A"}));
(eN)((FW),([130,129,2]),({S:"break;\u000A"}));
(eN)((FW),([130,129,2]),({S:"}\u000A"}));
(eN)((FW),([130,129,2]),({S:"while (a_<=b_){\u000A"}));
(eN)((FW),([130,129,2]),({S:"c_=~~((a_+b_)/2);\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:"m_=f_("}).S+((v)(((G9).va),([129,2]))).S}).S+({S:({S:({S:","}).S+((v)(((G7).va),([129,2]))).S}).S+({S:"[c_]);\u000A"}).S}).S}));
(eN)((FW),([130,129,2]),({S:"if(m_<0)b_=c_-1;\u000A"}));
(eN)((FW),([130,129,2]),({S:"else if(m_>0)a_=c_+1;\u000A"}));
(eN)((FW),([130,129,2]),({S:"else return c_;\u000A"}));
(eN)((FW),([130,129,2]),({S:"}\u000A"}));
(eN)((FW),([130,129,2]),({S:"return -1;\u000A"}));
}
else if(Gb.S===({S:"forEach"}).S){
(qr)((FY),([130,134]));
(GB)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(GC)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(GD)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(GE)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"let D_={F:"}).S+((v)(((GD).va),([129,2]))).S}).S+({S:({S:({S:",D:"}).S+((v)(((GE).va),([129,2]))).S}).S+({S:",C:true};\u000A"}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((GC).va),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((GC).va),([129,2]))).S}).S+({S:({S:({S:"[2]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((GB).va),([129,2]))).S}).S+({S:".forEach(function(V_,K_){if(this.C)this.C=this.F({S:K_},V_,this.D)},D_);\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"else\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((GB).va),([129,2]))).S}).S+({S:".forEach(function(V_,K_){if(this.C)this.C=this.F(K_,V_,this.D)},D_);\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"return D_.C;\u000A"}));
}
else if(Gb.S===({S:"getDict"}).S){
(qr)((FY),([130,134]));
(GG)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(GH)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(GI)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(GJ)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:"let r_;\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((GH).va),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((GH).va),([129,2]))).S}).S+({S:({S:({S:"[2]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"r_="}).S+((v)(((GG).va),([129,2]))).S}).S+({S:({S:({S:".get("}).S+((v)(((GI).va),([129,2]))).S}).S+({S:".S);\u000A"}).S}).S}));
(eN)((FW),([130,129,2]),({S:"else\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:"r_="}).S+((v)(((GG).va),([129,2]))).S}).S+({S:({S:({S:".get("}).S+((v)(((GI).va),([129,2]))).S}).S+({S:");\u000A"}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"if(!("}).S+((v)(((GJ).va),([129,2]))).S}).S+({S:".$=r_!==undefined)){\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"switch("}).S+((v)(((GH).va),([129,2]))).S}).S+({S:"){\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((0),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((1),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((2),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((4),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((5),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((6),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((7),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((9),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"return 0;\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((3),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"return false;\u000A"}));
(eN)((FW),([130,129,2]),({S:"default:\u000A"}));
(eN)((FW),([130,129,2]),({S:"return null;\u000A"}));
(eN)((FW),([130,129,2]),({S:"}\u000A"}));
(eN)((FW),([130,129,2]),({S:"}\u000A"}));
(eN)((FW),([130,129,2]),({S:"return r_;\u000A"}));
}
else if(Gb.S===({S:"getList"}).S){
(qr)((FY),([130,134]));
(GL)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((GL).va),([129,2]))).S}).S+({S:".P.I;\u000A"}).S}));
}
else if(Gb.S===({S:"getQueue"}).S){
(qr)((FY),([130,134]));
(GN)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((GN).va),([129,2]))).S}).S+({S:".shift();\u000A"}).S}));
}
else if(Gb.S===({S:"getStack"}).S){
(qr)((FY),([130,134]));
(GP)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((GP).va),([129,2]))).S}).S+({S:".pop();\u000A"}).S}));
}
else if(Gb.S===({S:"head"}).S){
(qr)((FY),([130,134]));
(GR)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((GR).va),([129,2]))).S}).S+({S:({S:({S:".P="}).S+((v)(((GR).va),([129,2]))).S}).S+({S:".H;\u000A"}).S}).S}));
}
else if(Gb.S===({S:"idx"}).S){
(qr)((FY),([130,134]));
(GT)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"let p_="}).S+((v)(((GT).va),([129,2]))).S}).S+({S:".H,i_=0;\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((GT).va),([129,2]))).S}).S+({S:".P===null)return -1;\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"while(p_!==null){\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:"if(p_==="}).S+((v)(((GT).va),([129,2]))).S}).S+({S:".P)return i_\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"i_++;\u000A"}));
(eN)((FW),([130,129,2]),({S:"p_=p_.N;\u000A"}));
(eN)((FW),([130,129,2]),({S:"}\u000A"}));
(eN)((FW),([130,129,2]),({S:"return -1;\u000A"}));
}
else if(Gb.S===({S:"ins"}).S){
(qr)((FY),([130,134]));
(GV)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(r8)((FY),([130,134]));
(GW)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"let p_="}).S+((v)(((GV).va),([129,2]))).S}).S+({S:".P;\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"let n_={P:p_.P,N:p_,I:"}).S+((v)(((GW).va),([129,2]))).S}).S+({S:"}\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"if(p_.P===null)"}).S+((v)(((GV).va),([129,2]))).S}).S+({S:".H=n_;else p_.P.N=n_;\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((GV).va),([129,2]))).S}).S+({S:({S:({S:".T===null)"}).S+((v)(((GV).va),([129,2]))).S}).S+({S:".T=n_;\u000A"}).S}).S}));
(eN)((FW),([130,129,2]),({S:"p_.P=n_;\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((GV).va),([129,2]))).S}).S+({S:".L++;\u000A"}).S}));
}
else if(Gb.S===({S:"moveOffset"}).S){
(qr)((FY),([130,134]));
(GY)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(r8)((FY),([130,134]));
(GZ)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((GZ).va),([129,2]))).S}).S+({S:">=0){\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"for(let i_=0;i_<"}).S+((v)(((GZ).va),([129,2]))).S}).S+({S:";i_++){\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((GY).va),([129,2]))).S}).S+({S:".P===null)break;\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((GY).va),([129,2]))).S}).S+({S:({S:({S:".P="}).S+((v)(((GY).va),([129,2]))).S}).S+({S:".P.N;\u000A"}).S}).S}));
(eN)((FW),([130,129,2]),({S:"}\u000A"}));
(eN)((FW),([130,129,2]),({S:"}else{\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:"for(let i_=0;i_>"}).S+((v)(((GZ).va),([129,2]))).S}).S+({S:";i_--){\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((GY).va),([129,2]))).S}).S+({S:".P===null)break;\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((GY).va),([129,2]))).S}).S+({S:({S:({S:".P="}).S+((v)(((GY).va),([129,2]))).S}).S+({S:".P.P;\u000A"}).S}).S}));
(eN)((FW),([130,129,2]),({S:"}\u000A"}));
(eN)((FW),([130,129,2]),({S:"}\u000A"}));
}
else if(Gb.S===({S:"next"}).S){
(qr)((FY),([130,134]));
(Hb)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((Hb).va),([129,2]))).S}).S+({S:({S:({S:".P="}).S+((v)(((Hb).va),([129,2]))).S}).S+({S:".P.N;\u000A"}).S}).S}));
}
else if(Gb.S===({S:"or"}).S){
(qr)((FY),([130,134]));
(Hd)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(r8)((FY),([130,134]));
(He)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Hd).va),([129,2]))).S}).S+({S:({S:({S:"|"}).S+((v)(((He).va),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
}
else if(Gb.S===({S:"peekQueue"}).S){
(qr)((FY),([130,134]));
(Hg)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Hg).va),([129,2]))).S}).S+({S:"[0];\u000A"}).S}));
}
else if(Gb.S===({S:"peekStack"}).S){
(qr)((FY),([130,134]));
(Hi)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Hi).va),([129,2]))).S}).S+({S:({S:({S:"["}).S+((v)(((Hi).va),([129,2]))).S}).S+({S:".length-1];\u000A"}).S}).S}));
}
else if(Gb.S===({S:"rnd"}).S){
(qr)((FY),([130,134]));
(Hk)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(Hl)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"return ~~(Math.random()*("}).S+((v)(((Hl).va),([129,2]))).S}).S+({S:({S:({S:"-"}).S+((v)(((Hk).va),([129,2]))).S}).S+({S:({S:({S:"+1))+"}).S+((v)(((Hk).va),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
}
else if(Gb.S===({S:"rndFloat"}).S){
(qr)((FY),([130,134]));
(Hn)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(Ho)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"return Math.random()*("}).S+((v)(((Ho).va),([129,2]))).S}).S+({S:({S:({S:"-"}).S+((v)(((Hn).va),([129,2]))).S}).S+({S:({S:({S:")+"}).S+((v)(((Hn).va),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
}
else if(Gb.S===({S:"sub"}).S){
(qr)((FY),([130,134]));
(Hq)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(Hr)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(Hs)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(Ht)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((Hr).va),([129,2]))).S}).S+({S:({S:({S:"[0]==="}).S+((v)((129),([0]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((Hr).va),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"return {S:"}).S+((v)(((Ht).va),([129,2]))).S}).S+({S:({S:({S:"===-1?"}).S+((v)(((Hq).va),([129,2]))).S}).S+({S:({S:({S:".S.slice("}).S+((v)(((Hs).va),([129,2]))).S}).S+({S:({S:({S:"):"}).S+((v)(((Hq).va),([129,2]))).S}).S+({S:({S:({S:".S.slice("}).S+((v)(((Hs).va),([129,2]))).S}).S+({S:({S:({S:","}).S+((v)(((Hs).va),([129,2]))).S}).S+({S:({S:({S:"+"}).S+((v)(((Ht).va),([129,2]))).S}).S+({S:")};\u000A"}).S}).S}).S}).S}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:"else\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Ht).va),([129,2]))).S}).S+({S:({S:({S:"===-1?"}).S+((v)(((Hq).va),([129,2]))).S}).S+({S:({S:({S:".slice("}).S+((v)(((Hs).va),([129,2]))).S}).S+({S:({S:({S:"):"}).S+((v)(((Hq).va),([129,2]))).S}).S+({S:({S:({S:".slice("}).S+((v)(((Hs).va),([129,2]))).S}).S+({S:({S:({S:","}).S+((v)(((Hs).va),([129,2]))).S}).S+({S:({S:({S:"+"}).S+((v)(((Ht).va),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}).S}).S}).S}).S}));
}
else if(Gb.S===({S:"sysTime"}).S){
(eN)((FW),([130,129,2]),({S:"return new Date().getTime();\u000A"}));
}
else if(Gb.S===({S:"tail"}).S){
(qr)((FY),([130,134]));
(Hw)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((Hw).va),([129,2]))).S}).S+({S:({S:({S:".P="}).S+((v)(((Hw).va),([129,2]))).S}).S+({S:".T;\u000A"}).S}).S}));
}
else if(Gb.S===({S:"term"}).S){
(qr)((FY),([130,134]));
(Hy)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Hy).va),([129,2]))).S}).S+({S:".P===null;\u000A"}).S}));
}
else if(Gb.S===({S:"toBit64"}).S){
(qr)((FY),([130,134]));
(H0)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(H1)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((H0).va),([129,2]))).S}).S+({S:({S:({S:".S.length>=2&&"}).S+((v)(((H0).va),([129,2]))).S}).S+({S:({S:({S:".S[0]===\"0\"&&"}).S+((v)(((H0).va),([129,2]))).S}).S+({S:".S[1]===\"x\"){\u000A"}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"let s_="}).S+((v)(((H0).va),([129,2]))).S}).S+({S:({S:({S:".S.slice(2),r_=Number("}).S+((v)(((H0).va),([129,2]))).S}).S+({S:".S);\u000A"}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((H1).va),([129,2]))).S}).S+({S:".$=!isNaN(r_);\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"return parseInt(s_,16);\u000A"}));
(eN)((FW),([130,129,2]),({S:"}else{\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:"let r_=Number("}).S+((v)(((H0).va),([129,2]))).S}).S+({S:".S);\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((H1).va),([129,2]))).S}).S+({S:".$=!isNaN(r_);\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"return parseInt("}).S+((v)(((H0).va),([129,2]))).S}).S+({S:".S,10);\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"}\u000A"}));
}
else if(Gb.S===({S:"toFloat"}).S){
(qr)((FY),([130,134]));
(H3)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(H4)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"let r_=Number("}).S+((v)(((H3).va),([129,2]))).S}).S+({S:".S);\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((H4).va),([129,2]))).S}).S+({S:".$=!isNaN(r_);\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"return r_;\u000A"}));
}
else if(Gb.S===({S:"toInt"}).S){
(qr)((FY),([130,134]));
(H6)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(H7)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((H6).va),([129,2]))).S}).S+({S:({S:({S:".S.length>=2&&"}).S+((v)(((H6).va),([129,2]))).S}).S+({S:({S:({S:".S[0]===\"0\"&&"}).S+((v)(((H6).va),([129,2]))).S}).S+({S:".S[1]===\"x\"){\u000A"}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"let s_="}).S+((v)(((H6).va),([129,2]))).S}).S+({S:({S:({S:".S.slice(2),r_=Number("}).S+((v)(((H6).va),([129,2]))).S}).S+({S:".S);\u000A"}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((H7).va),([129,2]))).S}).S+({S:".$=!isNaN(r_);\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"return parseInt(s_,16);\u000A"}));
(eN)((FW),([130,129,2]),({S:"}else{\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:"let r_=Number("}).S+((v)(((H6).va),([129,2]))).S}).S+({S:".S);\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((H7).va),([129,2]))).S}).S+({S:".$=!isNaN(r_);\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"return parseInt("}).S+((v)(((H6).va),([129,2]))).S}).S+({S:".S,10);\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"}\u000A"}));
}
else if(Gb.S===({S:"toStr"}).S){
(qr)((FY),([130,134]));
(H9)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(HA)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:"let n_;\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:"switch("}).S+((v)(((HA).va),([129,2]))).S}).S+({S:"[0]){\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((0),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((1),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((9),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"return{S:"}).S+((v)(((H9).va),([129,2]))).S}).S+({S:".toString(10)};\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((2),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"return{S:String.fromCharCode("}).S+((v)(((H9).va),([129,2]))).S}).S+({S:")};\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((3),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"return{S:"}).S+((v)(((H9).va),([129,2]))).S}).S+({S:"?\"true\":\"false\"};\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((4),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"n_="}).S+((v)(((H9).va),([129,2]))).S}).S+({S:({S:({S:">=0?~~"}).S+((v)(((H9).va),([129,2]))).S}).S+({S:({S:({S:"&0xFF:0xFF-(~"}).S+((v)(((H9).va),([129,2]))).S}).S+({S:"&0xFF);\u000A"}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:"return{S:\"0x\"+(\"00\"+n_.toString(16)).slice(-2).toUpperCase()};\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((5),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"n_="}).S+((v)(((H9).va),([129,2]))).S}).S+({S:({S:({S:">=0?~~"}).S+((v)(((H9).va),([129,2]))).S}).S+({S:({S:({S:"&0xFFFF:0xFFFF-(~"}).S+((v)(((H9).va),([129,2]))).S}).S+({S:"&0xFFFF);\u000A"}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:"return{S:\"0x\"+(\"0000\"+n_.toString(16)).slice(-4).toUpperCase()};\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((6),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"n_="}).S+((v)(((H9).va),([129,2]))).S}).S+({S:">>>0;\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"return{S:\"0x\"+(\"00000000\"+n_.toString(16)).slice(-8).toUpperCase()};\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((7),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"n_="}).S+((v)(((H9).va),([129,2]))).S}).S+({S:">>>0;\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"return{S:\"0x\"+(("}).S+((v)(((H9).va),([129,2]))).S}).S+({S:">=0?\"0000000000000000\":\"FFFFFFFFFFFFFFFF\")+n_.toString(16)).slice(-16).toUpperCase()};\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"case "}).S+((v)((129),([0]))).S}).S+({S:":\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((HA).va),([129,2]))).S}).S+({S:({S:({S:"[1]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((H9).va),([129,2]))).S}).S+({S:";\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"}\u000A"}));
}
else if(Gb.S===({S:"cui_print"}).S){
(qr)((FY),([130,134]));
(HC)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"if(O_&&O_.print){O_.print("}).S+((v)(((HC).va),([129,2]))).S}).S+({S:".S);return;}\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"console.log("}).S+((v)(((HC).va),([129,2]))).S}).S+({S:".S);\u000A"}).S}));
}
else if(Gb.S===({S:"file_copyFile"}).S){
(eN)((FW),([130,129,2]),({S:"return false;\u000A"}));
}
else if(Gb.S===({S:"file_exist"}).S){
(qr)((FY),([130,134]));
(HF)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"let f_=false,p_="}).S+((v)(((HF).va),([129,2]))).S}).S+({S:".S;\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"if(O_&&O_.readFile)f_=O_.readFile(p_)!==null;\u000A"}));
(eN)((FW),([130,129,2]),({S:"if(f_===false){\u000A"}));
(eN)((FW),([130,129,2]),({S:"if(p_.length>=4&&p_[0]===\"r\"&&p_[1]===\"e\"&&p_[2]===\"s\"&&p_[3]===\"/\")\u000A"}));
(eN)((FW),([130,129,2]),({S:"f_=F_(p_,false);\u000A"}));
(eN)((FW),([130,129,2]),({S:"else{\u000A"}));
(eN)((FW),([130,129,2]),({S:"}\u000A"}));
(eN)((FW),([130,129,2]),({S:"}\u000A"}));
(eN)((FW),([130,129,2]),({S:"return f_;\u000A"}));
}
else if(Gb.S===({S:"file_forEach"}).S){
(qr)((FY),([130,134]));
(HH)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(HI)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(HJ)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(HK)=((uJ)(((qv)((FY),([130,134])))));
(eN)((FW),([130,129,2]),({S:({S:({S:"let f_,p_="}).S+((v)(((HH).va),([129,2]))).S}).S+({S:".S;\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"if(p_.length>=4&&p_[0]===\"r\"&&p_[1]===\"e\"&&p_[2]===\"s\"&&p_[3]===\"/\")\u000A"}));
(eN)((FW),([130,129,2]),({S:"f_=FF_();\u000A"}));
(eN)((FW),([130,129,2]),({S:"for(let i_=0;i_<f_.length;i_++){\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:"if(f_[i_].slice(0,p_.length)===p_&&("}).S+((v)(((HI).va),([129,2]))).S}).S+({S:"||f_[i_].slice(p_.length).indexOf(\"/\")===-1)){\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"if(!"}).S+((v)(((HJ).va),([129,2]))).S}).S+({S:({S:({S:"({S:f_[i_]},f_[i_][f_[i_].length-1]===\'/\',"}).S+((v)(((HK).va),([129,2]))).S}).S+({S:"))return false"}).S}).S}));
(eN)((FW),([130,129,2]),({S:"}\u000A"}));
(eN)((FW),([130,129,2]),({S:"}\u000A"}));
(eN)((FW),([130,129,2]),({S:"return true;\u000A"}));
}
else if(Gb.S===({S:"file_makeReader"}).S){
(qr)((FY),([130,134]));
(HM)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(HN)=((uJ)(((qv)((FY),([130,134])))));
(HO)=((HP)((FZ),({S:"handle"})));
(eN)((FW),([130,129,2]),({S:({S:({S:"let f_=null,p_="}).S+((v)(((HN).va),([129,2]))).S}).S+({S:".S;\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"if(O_&&O_.readFile)f_=O_.readFile(p_);\u000A"}));
(eN)((FW),([130,129,2]),({S:"if(f_===null){\u000A"}));
(eN)((FW),([130,129,2]),({S:"if(p_.length>=4&&p_[0]===\"r\"&&p_[1]===\"e\"&&p_[2]===\"s\"&&p_[3]===\"/\")\u000A"}));
(eN)((FW),([130,129,2]),({S:"f_=F_(p_,true);\u000A"}));
(eN)((FW),([130,129,2]),({S:"else{\u000A"}));
(eN)((FW),([130,129,2]),({S:"}\u000A"}));
(eN)((FW),([130,129,2]),({S:"}\u000A"}));
(eN)((FW),([130,129,2]),({S:"if(f_===null)return null;\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((HM).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((HO).va),([129,2]))).S}).S+({S:"={F:f_,I:0};\u000A"}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((HM).va),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
else if(Gb.S===({S:"file_makeWriter"}).S){
(qr)((FY),([130,134]));
(HR)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(HS)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(HT)=((uJ)(((qv)((FY),([130,134])))));
(HU)=((HP)((FZ),({S:"handle"})));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((HR).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((HU).va),([129,2]))).S}).S+({S:({S:({S:"={F:\"\",I:0,P:"}).S+((v)(((HS).va),([129,2]))).S}).S+({S:".S};\u000A"}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((HR).va),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
else if(Gb.S===({S:"file_readerFin"}).S){
(qr)((FY),([130,134]));
(HW)=((uJ)(((qv)((FY),([130,134])))));
(HX)=((HP)((FZ),({S:"handle"})));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((HW).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((HX).va),([129,2]))).S}).S+({S:".F=null;\u000A"}).S}).S}));
}
else if(Gb.S===({S:"file_readerGetPos"}).S){
(qr)((FY),([130,134]));
(HZ)=((uJ)(((qv)((FY),([130,134])))));
(Ia)=((HP)((FZ),({S:"handle"})));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((HZ).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Ia).va),([129,2]))).S}).S+({S:".I;\u000A"}).S}).S}));
}
else if(Gb.S===({S:"file_readerReadLetter"}).S){
(qr)((FY),([130,134]));
(Ic)=((uJ)(((qv)((FY),([130,134])))));
(Id)=((HP)((FZ),({S:"handle"})));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Ic).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Id).va),([129,2]))).S}).S+({S:({S:({S:".F.charCodeAt("}).S+((v)(((Ic).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Id).va),([129,2]))).S}).S+({S:".I++);\u000A"}).S}).S}).S}).S}));
}
else if(Gb.S===({S:"file_readerSetPos"}).S){
(qr)((FY),([130,134]));
(If)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(Ig)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(Ih)=((uJ)(((qv)((FY),([130,134])))));
(Ii)=((HP)((FZ),({S:"handle"})));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((If).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Ii).va),([129,2]))).S}).S+({S:({S:({S:".I="}).S+((v)(((Ih).va),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
}
else if(Gb.S===({S:"file_readerTerm"}).S){
(qr)((FY),([130,134]));
(Ik)=((uJ)(((qv)((FY),([130,134])))));
(Il)=((HP)((FZ),({S:"handle"})));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Ik).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Il).va),([129,2]))).S}).S+({S:({S:({S:".I>="}).S+((v)(((Ik).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Il).va),([129,2]))).S}).S+({S:".F.length;\u000A"}).S}).S}).S}).S}));
}
else if(Gb.S===({S:"file_writerFin"}).S){
(qr)((FY),([130,134]));
(In)=((uJ)(((qv)((FY),([130,134])))));
(Io)=((HP)((FZ),({S:"handle"})));
(eN)((FW),([130,129,2]),({S:({S:({S:"var d_="}).S+((v)(((In).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Io).va),([129,2]))).S}).S+({S:".F.replace(\"\\n\", \"\\u000D\\n\");\u000A"}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"if(O_&&O_.writeFile){O_.writeFile("}).S+((v)(((In).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Io).va),([129,2]))).S}).S+({S:".P,d_);return;}\u000A"}).S}).S}));
(eN)((FW),([130,129,2]),({S:"let b_=new Blob([d_]);\u000A"}));
(eN)((FW),([130,129,2]),({S:"let l_=document.createElement(\"a\");\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:"l_.download="}).S+((v)(((In).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Io).va),([129,2]))).S}).S+({S:".P;\u000A"}).S}).S}));
(eN)((FW),([130,129,2]),({S:"l_.href=(URL||webkitURL).createObjectURL(b_);\u000A"}));
(eN)((FW),([130,129,2]),({S:"l_.setAttribute(\"style\",\"display:none\");\u000A"}));
(eN)((FW),([130,129,2]),({S:"document.body.appendChild(l_);\u000A"}));
(eN)((FW),([130,129,2]),({S:"l_.click();\u000A"}));
(eN)((FW),([130,129,2]),({S:"document.body.removeChild(l_);\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((In).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Io).va),([129,2]))).S}).S+({S:".F=null;\u000A"}).S}).S}));
}
else if(Gb.S===({S:"file_writerGetPos"}).S){
(qr)((FY),([130,134]));
(Iq)=((uJ)(((qv)((FY),([130,134])))));
(Ir)=((HP)((FZ),({S:"handle"})));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((Iq).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Ir).va),([129,2]))).S}).S+({S:".I;\u000A"}).S}).S}));
}
else if(Gb.S===({S:"file_writerSetPos"}).S){
(qr)((FY),([130,134]));
(It)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(Iu)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(Iv)=((uJ)(((qv)((FY),([130,134])))));
(Iw)=((HP)((FZ),({S:"handle"})));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((It).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((Iw).va),([129,2]))).S}).S+({S:({S:({S:".I="}).S+((v)(((Iv).va),([129,2]))).S}).S+({S:";\u000A"}).S}).S}).S}));
}
else if(Gb.S===({S:"file_writerWrite"}).S){
(qr)((FY),([130,134]));
(Iy)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(Iz)=((uJ)(((qv)((FY),([130,134])))));
(I0)=((HP)((FZ),({S:"handle"})));
}
else if(Gb.S===({S:"file_writerWriteChar"}).S){
(qr)((FY),([130,134]));
(I2)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(I3)=((uJ)(((qv)((FY),([130,134])))));
(I4)=((HP)((FZ),({S:"handle"})));
(eN)((FW),([130,129,2]),({S:({S:({S:"if("}).S+((v)(((I2).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((I4).va),([129,2]))).S}).S+({S:({S:({S:".I<"}).S+((v)(((I2).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((I4).va),([129,2]))).S}).S+({S:".F.length)\u000A"}).S}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((I2).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((I4).va),([129,2]))).S}).S+({S:({S:({S:".F="}).S+((v)(((I2).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((I4).va),([129,2]))).S}).S+({S:({S:({S:".F.slice(0,"}).S+((v)(((I2).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((I4).va),([129,2]))).S}).S+({S:({S:({S:".I)+String.fromCharCode("}).S+((v)(((I3).va),([129,2]))).S}).S+({S:({S:({S:")+"}).S+((v)(((I2).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((I4).va),([129,2]))).S}).S+({S:({S:({S:".F.slice("}).S+((v)(((I2).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((I4).va),([129,2]))).S}).S+({S:".I+1);\u000A"}).S}).S}).S}).S}).S}).S}).S}).S}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:"else{\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((I2).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((I4).va),([129,2]))).S}).S+({S:({S:({S:".F+=String.fromCharCode("}).S+((v)(((I3).va),([129,2]))).S}).S+({S:");\u000A"}).S}).S}).S}));
(eN)((FW),([130,129,2]),({S:"}\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((I2).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((I4).va),([129,2]))).S}).S+({S:".I++;\u000A"}).S}).S}));
}
else if(Gb.S===({S:"wnd_editBaseGetText"}).S){
(qr)((FY),([130,134]));
(I6)=((uJ)(((qv)((FY),([130,134])))));
(I7)=((HP)((FZ),({S:"handle"})));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((I6).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((I7).va),([129,2]))).S}).S+({S:".H.value;\u000A"}).S}).S}));
}
else if(Gb.S===({S:"wnd_makeEditMulti"}).S){
(qr)((FY),([130,134]));
(I9)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(IA)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(IB)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(IC)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(ID)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(IE)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(IF)=((uJ)(((qv)((FY),([130,134])))));
(r8)((FY),([130,134]));
(IG)=((uJ)(((qv)((FY),([130,134])))));
(IH)=((HP)((FZ),({S:"handle"})));
(eN)((FW),([130,129,2]),({S:"let h_=document.createElement(\"textarea\");\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:"h_.setAttribute(\"cols\",\""}).S+((v)(((ID).va),([129,2]))).S}).S+({S:"\");\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"h_.setAttribute(\"rows\",\""}).S+((v)(((IE).va),([129,2]))).S}).S+({S:"\");\u000A"}).S}));
(eN)((FW),([130,129,2]),({S:"document.body.appendChild(c_);\u000A"}));
(eN)((FW),([130,129,2]),({S:({S:({S:""}).S+((v)(((I9).va),([129,2]))).S}).S+({S:({S:({S:"."}).S+((v)(((IH).va),([129,2]))).S}).S+({S:"={C:c_};\u000A"}).S}).S}));
(eN)((FW),([130,129,2]),({S:({S:({S:"return "}).S+((v)(((I9).va),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
else{if(!(false)){throw 0xE9170000;}
}
}
// buildStats
function vw(IJ /*stats*/){
let IL=null; // stat
let IN=0;
(qr)((IJ),([130,134]));
while(!((qt)((IJ),([130,134])))){
(IL)=((qv)((IJ),([130,134])));
switch((IL).qc){
case 66049:
(IP)((IL));
break;
case 66050:
(IR)((IL));
break;
case 16843265:
(IT)((IL));
break;
case 16843266:
(IV)((IL));
break;
case 66051:
(IX)((IL));
break;
case 526:
(IZ)((IL));
break;
case 66052:
(Jb)((IL));
break;
case 527:
(Jd)((IL));
break;
case 528:
(Jf)((IL));
break;
case 529:
(Jh)((IL));
break;
case 530:
(Jj)((IL));
break;
case 531:
(Jl)((IL));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(r8)((IJ),([130,134]));
}
}
// getDefaultValue
function v2(Jn /*type*/){
let Jr=0;
let Jw=0;
if((EI)((Jn))){
return {S:"null"};
}
switch((Jn).qc){
case 66565:
if(!((EN)((Jn)))){throw 0xE9170000;}
return {S:"0"};
break;
case 1025:
return {S:"0"};
break;
case 1026:
switch((Jn).xX){
case 0:
case 2:
return {S:"0"};
break;
case 1:
return {S:"0"};
break;
case 3:
return {S:"false"};
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// refClass
function vD(J2 /*ast*/){
let J3=null; // info
(J3)=((uJ)((J2)));
if((J3).uM){
return (J3).va;
}
((J3).uM)=(true);
if(((J2).qz)!==(null)){
(vD)(((J2).qz));
}
(eQ)((ak),([132,134]),(J2));
return (J3).va;
}
// findFunc
function vL(J8 /*ast*/,J9 /*name*/){
let JA=null; // items
let JC=null; // item
(JA)=((J8).tg);
(qr)((JA),([130,134]));
while(!((qt)((JA),([130,134])))){
(JC)=((qv)((JA),([130,134])));
if(((((JC).tS).qc)===(256))&&((((JC).tS).qX).S===(J9).S)){
return (JC).tS;
}
(r8)((JA),([130,134]));
}
return null;
}
// writeJs
function wd(JF /*writer*/,JG /*resFiles*/){
let JH=false; // static
let JK=false;
let JP=null; // globalVar
let JQ=null; // info
let JT=false; // first
let JV=null; // resFile
let Kb=0;
let Kh=null; // reader
let Kj=null; // line
let Km=0;
let Ks=false; // first
let Ku=null; // resFile
let K0=0;
let JI=false;
let JJ=false;
let Kc=0;
let Kn=0;
let K1=0;
(JH)=((JI=(pR)((Y),([133,129,2,3]),({S:"static"}),(JJ={$:(JK)},JJ)),(JK)=JJ.$,JI));
if(JH){
(uB)((JF),({S:({S:({S:"\"use strict\";function "}).S+((v)(((co)((V))),([129,2]))).S}).S+({S:"(O_){\u000A"}).S}));
}
else{
(uB)((JF),({S:"\"use strict\";!function(f){let d=document;function h(){d.removeEventListener(\"DOMContentLoaded\",h);removeEventListener(\"load\",h);f()}\"complete\"===d.readyState||\"loading\"!==d.readyState&&!d.documentElement.doScroll?setTimeout(f):(d.addEventListener(\"DOMContentLoaded\",h),addEventListener(\"load\",h))}(function(){\u000A"}));
(uB)((JF),({S:"let O_;\u000A"}));
}
(qr)((ao),([130,134]));
while(!((qt)((ao),([130,134])))){
(JP)=((qv)((ao),([130,134])));
(JQ)=((uJ)((JP)));
(uB)((JF),({S:({S:({S:"let "}).S+((v)(((JQ).va),([129,2]))).S}).S+({S:({S:({S:"="}).S+((v)(((v2)(((JP).s4))),([129,2]))).S}).S+({S:";\u000A"}).S}).S}));
(r8)((ao),([130,134]));
}
(qr)((am),([130,129,2]));
while(!((qt)((am),([130,129,2])))){
(uB)((JF),((qv)((am),([130,129,2]))));
(r8)((am),([130,129,2]));
}
(uB)((JF),({S:"function C_(t,v){\u000A"}));
(uB)((JF),({S:"switch(t[0]){\u000A"}));
(uB)((JF),({S:({S:({S:"case "}).S+((v)((0),([0]))).S}).S+({S:":\u000A"}).S}));
(uB)((JF),({S:({S:({S:"case "}).S+((v)((1),([0]))).S}).S+({S:":\u000A"}).S}));
(uB)((JF),({S:({S:({S:"case "}).S+((v)((2),([0]))).S}).S+({S:":\u000A"}).S}));
(uB)((JF),({S:({S:({S:"case "}).S+((v)((3),([0]))).S}).S+({S:":\u000A"}).S}));
(uB)((JF),({S:({S:({S:"case "}).S+((v)((4),([0]))).S}).S+({S:":\u000A"}).S}));
(uB)((JF),({S:({S:({S:"case "}).S+((v)((5),([0]))).S}).S+({S:":\u000A"}).S}));
(uB)((JF),({S:({S:({S:"case "}).S+((v)((6),([0]))).S}).S+({S:":\u000A"}).S}));
(uB)((JF),({S:({S:({S:"case "}).S+((v)((7),([0]))).S}).S+({S:":\u000A"}).S}));
(uB)((JF),({S:({S:({S:"case "}).S+((v)((8),([0]))).S}).S+({S:":\u000A"}).S}));
(uB)((JF),({S:({S:({S:"case "}).S+((v)((9),([0]))).S}).S+({S:":\u000A"}).S}));
(uB)((JF),({S:"return v;\u000A"}));
(uB)((JF),({S:({S:({S:"case "}).S+((v)((129),([0]))).S}).S+({S:":\u000A"}).S}));
(uB)((JF),({S:({S:({S:"if(t[1]==="}).S+((v)((2),([0]))).S}).S+({S:")\u000A"}).S}));
(uB)((JF),({S:"return v===null?null:{S:v.S};\u000A"}));
(uB)((JF),({S:"else{\u000A"}));
(uB)((JF),({S:"let a=new Array(v.length);\u000A"}));
(uB)((JF),({S:"for(let i=0;i<v.length;i++)a[i]=C_(t.slice(1),v[i]);\u000A"}));
(uB)((JF),({S:"return a;\u000A"}));
(uB)((JF),({S:"}\u000A"}));
(uB)((JF),({S:({S:({S:"case "}).S+((v)((130),([0]))).S}).S+({S:":\u000A"}).S}));
(uB)((JF),({S:({S:({S:"case "}).S+((v)((131),([0]))).S}).S+({S:":\u000A"}).S}));
(uB)((JF),({S:({S:({S:"case "}).S+((v)((132),([0]))).S}).S+({S:":\u000A"}).S}));
(uB)((JF),({S:({S:({S:"case "}).S+((v)((133),([0]))).S}).S+({S:":\u000A"}).S}));
(uB)((JF),({S:({S:({S:"case "}).S+((v)((134),([0]))).S}).S+({S:":\u000A"}).S}));
(uB)((JF),({S:"}\u000A"}));
(uB)((JF),({S:"}\u000A"}));
(uB)((JF),({S:"function F_(p,f){\u000A"}));
(JT)=(true);
(qr)((JG),([130,129,2]));
while(!((qt)((JG),([130,129,2])))){
(JV)=((qv)((JG),([130,129,2])));
if(JT){
(JT)=(false);
(uB)((JF),({S:"if(p===\""}));
}
else{
(uB)((JF),({S:"else if(p===\""}));
}
Ka:
for(Kb=((Z).S.length),Kc=(((JV).S.length)-(1));Kb<=Kc;Kb+=(1)){
(uB)((JF),((Kd)(((JV).S.charCodeAt(Kb)))));
}
(uB)((JF),({S:"\")\u000A"}));
if(((JV).S.charCodeAt(((JV).S.length)-(1)))===(0x002F)){
(uB)((JF),({S:"return f?null:true;\u000A"}));
}
else{
(uB)((JF),({S:"return f?\""}));
(Kh)=((pB)((new pC()),(JV)));
while(!((u8)((Kh)))){
(Kj)=((uA)((Kh)));
Kl:
for(Km=(0),Kn=(((Kj).S.length)-(1));Km<=Kn;Km+=(1)){
(uB)((JF),((Kd)(((Kj).S.charCodeAt(Km)))));
}
(uB)((JF),({S:"\\n"}));
}
(pO)((Kh));
(uB)((JF),({S:"\":true;\u000A"}));
}
(r8)((JG),([130,129,2]));
}
if(((JG).L)>(0)){
(uB)((JF),({S:"else return f?null:false;\u000A"}));
}
else{
(uB)((JF),({S:"return f?null:false;\u000A"}));
}
(uB)((JF),({S:"}\u000A"}));
(uB)((JF),({S:"function FF_(){return["}));
(Ks)=(true);
(qr)((JG),([130,129,2]));
while(!((qt)((JG),([130,129,2])))){
(Ku)=((qv)((JG),([130,129,2])));
if(Ks){
(Ks)=(false);
(uB)((JF),({S:"\""}));
}
else{
(uB)((JF),({S:",\""}));
}
Kz:
for(K0=((Z).S.length),K1=(((Ku).S.length)-(1));K0<=K1;K0+=(1)){
(uB)((JF),((Kd)(((Ku).S.charCodeAt(K0)))));
}
(uB)((JF),({S:"\""}));
(r8)((JG),([130,129,2]));
}
(uB)((JF),({S:"];}\u000A"}));
(uB)((JF),({S:"a();\u000A"}));
if(JH){
(uB)((JF),({S:"}\u000A"}));
}
else{
(uB)((JF),({S:"})\u000A"}));
}
}
// initAst
function wE(K5 /*ast*/,K6 /*typeId*/,K7 /*pos*/,K8 /*name*/,K9 /*setParent*/){
if(!(!((K5)instanceof yt))){throw 0xE9170000;}
(KA)((K5),(K6),(K7),(K8),(K9));
}
// make
function wF(KB /*srcName*/,KC /*row*/,KD /*col*/){
let KE=null; // pos
(KE)=(new dg());
((KE).dh)=(KB);
((KE).di)=(KC);
((KE).dj)=(KD);
return KE;
}
// _addStack
function wG(KF /*me_*/,KG /*type*/,KH /*item*/){
KF.push(KH);
}
// readChar
function wH(){
let KK=0; // c
let KO=0;
KJ:
while(true){
(KK)=((xt)());
if((KK)===(0x000A)){
(KK)=((wH)());
switch(KK){
case 0x000A:
return 0x000A;
break;
case 0x003B:
do{
(KK)=((KS)());
if((KK)===(0x0000)){
return 0x0000;
}
}while((KK)!==(0x000A));
(pH)=(KK);
continue KJ;
break;
case 0x007C:
return (wH)();
break;
}
(pI)=(KK);
return 0x000A;
}
if((KK)!==(0x0020)){
return KK;
}
}
}
// readIdentifier
function wX(KY /*skipSpaces*/,KZ /*refName*/){
let La=0; // c
let Lf=null; // buf
let Lg=0; // pos
let Lh=false; // at
let Lk=0;
let Lq=null; // srcName
let Lt=0;
let Lv=0; // c2
let Lu=0;
let L4=0;
let L5=0;
(La)=((KY)?((wH)()):((xt)()));
if(!((((((0x0061)<=(La))&&((La)<=(0x007A)))||(((0x0041)<=(La))&&((La)<=(0x005A))))||((La)===(0x005F)))||((KZ)&&(((La)===(0x0040))||((La)===(0x005C)))))){
(pH)=(La);
(D)((65542),((Ld)()),([((Le)((La)))]));
return {S:""};
}
(Lf)=({S:"\0".repeat(128)});
(Lg)=(0);
(Lh)=(false);
do{
switch(La){
case 0x0040:
if(Lh){
(pH)=(La);
(D)((65543),((Ld)()),(null));
return {S:""};
}
if((Lg)!==(0)){
(Lq)=((p9)((Lf),([129,2]),(0),(Lg)));
Ls:
for(Lt=(0),Lu=(((Lq).S.length)-(1));Lt<=Lu;Lt+=(1)){
(Lv)=((Lq).S.charCodeAt(Lt));
if(((0x0041)<=(Lv))&&((Lv)<=(0x005A))){
(pH)=(La);
(D)((65544),((Ld)()),([(Lq)]));
return {S:""};
}
}
(Ly)((Lq));
}
(Lh)=(true);
break;
case 0x005C:
if(Lh){
(pH)=(La);
(D)((65545),((Ld)()),(null));
return {S:""};
}
break;
}
if((Lg)===(128)){
(pH)=(La);
(D)((65546),((Ld)()),([(Lf)]));
return {S:""};
}
(Lf).S=(L4=(Lg),(Lf).S.slice(0,L4)+String.fromCharCode(La)+(Lf).S.slice(L4+1));
(Lg)=((Lg)+(1));
(La)=((xt)());
}while(((((((0x0061)<=(La))&&((La)<=(0x007A)))||(((0x0041)<=(La))&&((La)<=(0x005A))))||((La)===(0x005F)))||(((0x0030)<=(La))&&((La)<=(0x0039))))||((KZ)&&(((La)===(0x0040))||((La)===(0x005C)))));
(pH)=(La);
return (p9)((Lf),([129,2]),(0),(Lg));
}
// parseFunc
function xc(L7 /*parentClass*/,L8 /*overritten*/){
let L9=null; // ast
let LB=0; // c
let LG=0; // row
let LH=0; // col
let LI=null; // s
let LN=0;
let M5=null; // arg
let M8=null; // type
let MB=0; // c
let MO=0; // c
let MW=null; // stat
(L9)=(new c7());
((L9).qi)=(0);
((L9).qj)=({L:0,H:null,T:null,P:null});
(LB)=((wH)());
if((LB)===(0x005B)){
LF:
while(true){
(LG)=(pF);
(LH)=(pG);
(LI)=((LJ)());
if(((((LI).S.length)===(5))&&(((LI).S.charCodeAt(0))===(0x005F)))&&(((LI).S.charCodeAt(1))===(0x005F))){
switch((LI).S.charCodeAt(2)){
case 0x0061:
if((((LI).S.charCodeAt(3))===(0x006E))&&(((LI).S.charCodeAt(4))===(0x0079))){
((L9).qi)=((LR)(((L9).qi),([9]),(1)));
}
break;
case 0x0066:
if((((LI).S.charCodeAt(3))===(0x0072))&&(((LI).S.charCodeAt(4))===(0x0063))){
((L9).qi)=((LR)(((L9).qi),([9]),(128)));
}
break;
case 0x006B:
if((((LI).S.charCodeAt(3))===(0x0076))&&(((LI).S.charCodeAt(4))===(0x0066))){
((L9).qi)=((LR)(((L9).qi),([9]),(256)));
}
break;
case 0x006D:
if((((LI).S.charCodeAt(3))===(0x006B))&&(((LI).S.charCodeAt(4))===(0x0069))){
((L9).qi)=((LR)(((L9).qi),([9]),(2048)));
}
break;
case 0x0072:
if((((LI).S.charCodeAt(3))===(0x0061))&&(((LI).S.charCodeAt(4))===(0x0077))){
((L9).qi)=((LR)(((L9).qi),([9]),(4096)));
}
else if((((LI).S.charCodeAt(3))===(0x006D))&&(((LI).S.charCodeAt(4))===(0x0065))){
((L9).qi)=((LR)(((L9).qi),([9]),(4)));
}
else if((((LI).S.charCodeAt(3))===(0x0063))&&(((LI).S.charCodeAt(4))===(0x0068))){
((L9).qi)=((LR)(((L9).qi),([9]),(16)));
}
else if(((LI).S.charCodeAt(3))===(0x0061)){
if(((LI).S.charCodeAt(4))===(0x0063)){
((L9).qi)=((LR)(((L9).qi),([9]),(64)));
}
else if(((LI).S.charCodeAt(4))===(0x006B)){
((L9).qi)=((LR)(((L9).qi),([9]),(512)));
}
else if(((LI).S.charCodeAt(4))===(0x0076)){
((L9).qi)=((LR)(((L9).qi),([9]),(1024)));
}
}
break;
case 0x0074:
if((((LI).S.charCodeAt(3))===(0x006D))&&(((LI).S.charCodeAt(4))===(0x0065))){
((L9).qi)=((LR)(((L9).qi),([9]),(2)));
}
else if((((LI).S.charCodeAt(3))===(0x0063))&&(((LI).S.charCodeAt(4))===(0x0068))){
((L9).qi)=((LR)(((L9).qi),([9]),(8)));
}
else if((((LI).S.charCodeAt(3))===(0x006B))&&(((LI).S.charCodeAt(4))===(0x0076))){
((L9).qi)=((LR)(((L9).qi),([9]),(32)));
}
break;
}
}
else{
(eN)(((L9).qj),([130,129,2]),(LI));
}
(LB)=((wH)());
if((LB)===(0x0000)){
break LF;
}
if((LB)===(0x005D)){
break LF;
}
if((LB)!==(0x002C)){
(Mx)((0x002C),(LB));
break LF;
}
}
}
else{
(pH)=(LB);
}
(wE)((L9),(256),((Ld)()),((wX)((true),(false))),(true));
((L9).qg)=({L:0,H:null,T:null,P:null});
((L9).qh)=(null);
((L9).tp)=({L:0,H:null,T:null,P:null});
((L9).pY)=(new Map());
(wG)((ah),([131,134]),(L9));
if((L7)!==(null)){
(M1)((L9),(L7));
}
(M2)((0x0028),(true));
if((L7)!==(null)){
(M5)=(new ro());
(wE)((M5),(7),((L9).ql),(null),(false));
((M5).qX)=({S:"me"});
((M5).rp)=(2);
((M5).sJ)=(false);
((M5).xY)=(null);
(M6)((M5),(false));
(M8)=(new M9());
(wE)((M8),(66565),((L9).ql),(null),(false));
(M1)((M8),(L7));
((M5).s4)=(M8);
(eN)(((L9).qg),([130,134]),(M5));
}
(MB)=((wH)());
if((MB)!==(0x0029)){
(pH)=(MB);
MF:
while(true){
(eN)(((L9).qg),([130,134]),((MG)((2),(null))));
(MB)=((wH)());
if((MB)===(0x0000)){
break MF;
}
if((MB)===(0x0029)){
break MF;
}
if((MB)!==(0x002C)){
(Mx)((0x002C),(MB));
break MF;
}
}
}
(MO)=((wH)());
if((MO)===(0x003A)){
((L9).qh)=((MR)());
(MO)=((wH)());
}
if((MO)!==(0x000A)){
(Mx)((0x000A),(MO));
}
MV:
while(true){
(MW)=((MX)((L9)));
if((MW)===(null)){
if(pJ){
break MV;
}
else{
continue MV;
}
}
if(((MW).qc)===(513)){
break MV;
}
(eN)(((L9).tp),([130,134]),(MW));
}
(xz)((ah),([131,134]));
return L9;
}
// parseVar
function xe(Nf /*kind*/,Ng /*parentClass*/){
let Nh=null; // ast
(Nh)=(new tV());
(wE)((Nh),(2),((Ld)()),(null),(false));
((Nh).tX)=((MG)((Nf),(Ng)));
(M2)((0x000A),(true));
return Nh;
}
// parseConst
function xg(){
let Ni=null; // ast
(Ni)=(new xh());
(wE)((Ni),(3),((Ld)()),(null),(false));
((Ni).xx)=((MG)((4),(null)));
(M2)((0x000A),(true));
return Ni;
}
// parseAlias
function xj(){
let Nj=null; // ast
(Nj)=(new xk());
(wE)((Nj),(4),((Ld)()),((wX)((true),(false))),(true));
(M2)((0x003A),(true));
((Nj).Nk)=((MR)());
(M2)((0x000A),(true));
return Nj;
}
// parseClass
function xn(){
let Nl=null; // ast
let Nn=0; // c
let Nr=false; // kuinSrc
let Nw=0; // c
let N1=0; // row
let N2=0; // col
let N3=null; // item
let ND=null; // id
let NE=null; // className
let NQ=null;
let NS=null; // id2
let NV=null; // astEndClass
(Nl)=(new eZ());
(wE)((Nl),(5),((Ld)()),((wX)((true),(false))),(true));
((Nl).tg)=({L:0,H:null,T:null,P:null});
(M2)((0x0028),(true));
(Nn)=((wH)());
if((Nn)!==(0x0029)){
(pH)=(Nn);
(M1)((Nl),((wX)((true),(true))));
(M2)((0x0029),(true));
}
else{
(Nr)=((ag).S===({S:"kuin"}).S);
if(!((Nr)&&(((Nl).qX).S===({S:"Class"}).S))){
(M1)((Nl),((Nr)?({S:"@Class"}):({S:"kuin@Class"})));
}
}
(M2)((0x000A),(true));
((Nl).pY)=(new Map());
(wG)((ah),([131,134]),(Nl));
Nv:
while(true){
(Nw)=((wH)());
if((Nw)===(0x0000)){
(D)((65551),((Ld)()),([({S:"class"})]));
break Nv;
}
if((Nw)===(0x000A)){
continue Nv;
}
(N1)=(pF);
(N2)=(pG);
(N3)=(new tQ());
((N3).N4)=(false);
((N3).N5)=(false);
((N3).N6)=(null);
if((Nw)===(0x002B)){
((N3).N4)=(true);
}
else{
(pH)=(Nw);
}
(Nw)=((wH)());
if((Nw)===(0x002A)){
((N3).N5)=(true);
}
else{
(pH)=(Nw);
}
(ND)=((wX)((true),(false)));
(NE)=(((((Nl).qU).qc)===(1))?({S:({S:"@"}).S+((Nl).qX).S}):((Nl).qX));
if((ND).S===({S:"func"}).S){
((N3).tS)=((xc)((NE),((N3).N5)));
}
else if((ND).S===({S:"var"}).S){
if((N3).N5){
(D)((65552),((wF)((ag),(N1),(N2))),([(ND)]));
}
((N3).tS)=((xe)((5),(NE)));
}
else{
if((N3).N4){
(D)((65553),((wF)((ag),(N1),(N2))),([(ND)]));
}
if((N3).N5){
(D)((65552),((wF)((ag),(N1),(N2))),([(ND)]));
}
NQ=ND;
if(NQ.S===({S:"end"}).S){
(NS)=((wX)((true),(false)));
if((NS).S!==({S:"class"}).S){
(D)((65554),((wF)((ag),(N1),(N2))),([({S:"class"}),(NS)]));
}
(NV)=(new c8());
(wE)((NV),(0),((wF)((ag),(N1),(N2))),(null),(false));
(M2)((0x000A),(true));
break Nv;
}
else if(NQ.S===({S:"const"}).S){
((N3).tS)=((xg)());
}
else if(NQ.S===({S:"alias"}).S){
((N3).tS)=((xj)());
}
else if(NQ.S===({S:"class"}).S){
((N3).tS)=((xn)());
}
else{(D)((65555),((wF)((ag),(N1),(N2))),([(ND)]));
(xs)(((xt)()));
continue Nv;
}
}
(eN)(((Nl).tg),([130,134]),(N3));
}
(xz)((ah),([131,134]));
return Nl;
}
// parseEnum
function xp(){
let Oa=null; // ast
let Oe=0; // c
let Oj=null; // id
let Om=null; // id2
let Or=null; // item
let Ow=null; // expr
(Oa)=(new xq());
(wE)((Oa),(6),((Ld)()),((wX)((true),(false))),(true));
((Oa).Ob)=({L:0,H:null,T:null,P:null});
(M2)((0x000A),(true));
((Oa).pY)=(new Map());
(wG)((ah),([131,134]),(Oa));
Od:
while(true){
(Oe)=((wH)());
if((Oe)===(0x0000)){
(D)((65551),((Ld)()),([({S:"enum"})]));
break Od;
}
if((Oe)===(0x000A)){
continue Od;
}
(pH)=(Oe);
(Oj)=((wX)((true),(false)));
if((Oj).S===({S:"end"}).S){
(Om)=((wX)((true),(false)));
if((Om).S!==({S:"enum"}).S){
(D)((65554),((Ld)()),([({S:"enum"}),(Om)]));
}
(M2)((0x000A),(true));
break Od;
}
(Oe)=((wH)());
if((Oe)===(0x003A)){
(M2)((0x003A),(false));
(Or)=((Os)());
if((Or)===(null)){
(xs)(((xt)()));
continue Od;
}
(Oe)=((wH)());
}
else{
(Ow)=(new yC());
(Ox)((Ow),(67585),((Oa).ql));
((Ow).yI)=(null);
((Ow).yF)=(0x0000000000000000);
(Or)=(Ow);
}
((Or).qX)=(Oj);
if((Oe)!==(0x000A)){
(Mx)((0x000A),(Oe));
}
(eN)(((Oa).Ob),([130,134]),(Or));
(M6)((Or),(true));
}
(xz)((ah),([131,134]));
return Oa;
}
// readUntilRet
function xs(O0 /*c*/){
while(((O0)!==(0x000A))&&((O0)!==(0x0000))){
(O0)=((xt)());
}
(pH)=(O0);
}
// read
function xt(){
let O2=0; // c
let O4=0;
(O2)=((KS)());
switch(O2){
case 0x007B:
(O6)();
return 0x0020;
break;
case 0x0009:
return 0x0020;
break;
}
return O2;
}
// _getStack
function xz(O8 /*me_*/,O9 /*type*/){
return O8.pop();
}
// initAst
function xM(OA /*ast*/,OB /*typeId*/,OC /*pos*/){
if(!(!((OA)instanceof yt))){throw 0xE9170000;}
(OD)((OA),(OB),(OC));
}
// searchStdItem
function yl(OE /*src*/,OF /*identifier*/,OG /*makeExprRef*/){
let OH=null; // ast
let OK=false;
let ON=null; // ast2
let OQ=false;
let OV=null; // expr
let OI=null;
let OJ=false;
let OO=null;
let OP=false;
(OH)=((OI=(pR)((I),([133,129,2,134]),(OE),(OJ={$:(OK)},OJ)),(OK)=OJ.$,OI));
if((OH)===(null)){
(D)((6),(null),([(OE)]));
return null;
}
(ON)=((OO=(pR)(((OH).pY),([133,129,2,134]),(OF),(OP={$:(OQ)},OP)),(OQ)=OP.$,OO));
if((OH)===(null)){
(D)((7),(null),([(OE)]));
return null;
}
if(OG){
(OV)=(new yt());
(yu)((OV),(2062),((wF)(({S:"kuin"}),(1),(1))));
((OV).qz)=(ON);
return (OW)((OV));
}
return ON;
}
// initAstExpr
function yu(OX /*ast*/,OY /*typeId*/,OZ /*pos*/){
if(!((OX)instanceof yt)){throw 0xE9170000;}
(OD)((OX),(OY),(OZ));
((OX).yI)=(null);
((OX).yE)=(0);
}
// rebuildArg
function zs(Pa /*ast*/){
if(((Pa).zo)!==(null)){
return;
}
((Pa).zo)=(Pa);
((Pa).s4)=((zv)(((Pa).s4),(null)));
if(((Pa).xY)!==(null)){
((Pa).xY)=((zE)(((Pa).xY),(false)));
if(((Pa).xY)===(null)){
return;
}
if((((Pa).rp)===(1))&&(((rt)((((Pa).xY).qc),([9]),(67584)))!==(67584))){
(D)((131091),((Pa).ql),([((Pa).qX)]));
}
if((((Pa).rp)===(4))&&(((rt)((((Pa).xY).qc),([9]),(67584)))!==(67584))){
(D)((131092),((Pa).ql),([((Pa).qX)]));
}
if(!((Pm)((((Pa).xY).yI),((Pa).s4),(false)))){
(D)((131093),((Pa).ql),([((Pa).qX)]));
}
else if(((((Pa).xY).yI).qc)===(1028)){
((Pa).xY)=((Pp)(((Pa).xY),((Pa).s4)));
}
}
}
// rebuildType
function zv(Pq /*ast*/,Pr /*parentAlias*/){
let Pu=0; // type
let Pw=0;
let Py=null; // refItem
let P2=0;
let PC=null; // ast2
let PD=null; // items
let PF=null; // arg
let PK=null; // ast2
if(((Pq).zo)!==(null)){
return (Pq).zo;
}
((Pq).zo)=(Pq);
(Pu)=((Pq).qc);
switch(Pu){
case 66565:
(Py)=((Pq).qz);
if((Py)===(null)){
return null;
}
switch((Py).qc){
case 5:
(P4)((Py));
break;
case 6:
(P6)((Py));
break;
case 4:
(P8)((Py),(Pr));
((Pq).zo)=((Py).Nk);
(Pq)=((Py).Nk);
break;
default:
(D)((131111),((Pq).ql),(null));
return null;
break;
}
break;
case 66561:
((Pq).Aw)=((zv)(((Pq).Aw),(Pr)));
break;
case 66562:
(PC)=(Pq);
(PD)=((PC).A9);
(qr)((PD),([130,134]));
while(!((qt)((PD),([130,134])))){
(PF)=((qv)((PD),([130,134])));
((PF).AI)=((zv)(((PF).AI),(Pr)));
(r8)((PD),([130,134]));
}
if(((PC).A4)!==(null)){
((PC).A4)=((zv)(((PC).A4),(Pr)));
}
break;
case 66563:
((Pq).AU)=((zv)(((Pq).AU),(Pr)));
break;
case 66564:
(PK)=(Pq);
((PK).Bb)=((zv)(((PK).Bb),(Pr)));
((PK).Bc)=((zv)(((PK).Bc),(Pr)));
break;
default:
if(!(((((Pu)===(0))||((Pu)===(1025)))||((Pu)===(1026)))||((Pu)===(1027)))){throw 0xE9170000;}
break;
}
return Pq;
}
// refreshStats
function zw(PM /*stats*/,PN /*retType*/,PO /*parentFunc*/){
let PP=null; // stats2
let PR=null; // stat
(PP)=({L:0,H:null,T:null,P:null});
(qr)((PM),([130,134]));
while(!((qt)((PM),([130,134])))){
(PR)=((zO)(((qv)((PM),([130,134]))),(PN),(PO)));
if((PR)!==(null)){
(eN)((PP),([130,134]),(PR));
}
(r8)((PM),([130,134]));
}
return PP;
}
// rebuildExpr
function zE(PU /*ast*/,PV /*nullable*/){
let PZ=0;
if((PU)===(null)){
return null;
}
switch((PU).qc){
case 0:
return null;
break;
case 2049:
(PU)=((Qc)((PU)));
break;
case 2050:
(PU)=((Qf)((PU)));
break;
case 2051:
(PU)=((Qh)((PU)));
break;
case 2052:
(PU)=((Qk)((PU)));
break;
case 2053:
(PU)=((Qn)((PU)));
break;
case 2054:
(PU)=((Qq)((PU)));
break;
case 2055:
(PU)=((Qt)((PU)));
break;
case 2056:
(PU)=((Qw)((PU)));
break;
case 2057:
(PU)=((Qz)((PU)));
break;
case 2058:
(PU)=((Q1)((PU)));
break;
case 2059:
(PU)=((Q4)((PU)));
break;
case 67584:
(PU)=((Q7)((PU)));
break;
case 67585:
(PU)=((Q9)((PU)));
break;
case 67586:
(PU)=((QB)((PU)));
break;
case 67587:
(PU)=((QE)((PU)));
break;
case 67588:
(PU)=((QH)((PU)));
break;
case 2060:
(PU)=((QK)((PU)));
break;
case 2062:
(PU)=((OW)((PU)));
break;
}
if((PU)===(null)){
return null;
}
if((!(PV))&&(((PU).yI)===(null))){
(D)((131112),((PU).ql),(null));
return null;
}
return PU;
}
// rebuildStat
function zO(QR /*ast*/,QS /*retType*/,QT /*parentFunc*/){
let QX=0;
let Ra=null; // ast2
let Re=null; // arg
let Rh=null; // args
let Ri=null; // refClass
let Rj=null; // items
let Rm=null; // item
let Rp=null; // astRef
let Rt=null; // astDo
let Rv=null; // astAssign
let Rx=null; // astRef
if((QR)===(null)){
return null;
}
switch((QR).qc){
case 514:
case 516:
case 517:
case 518:
case 519:
return null;
break;
case 515:
(Ra)=(QR);
(Rc)(((Ra).Rd));
(Re)=(((Ra).Rd).tX);
if((((Re).qX)!==(null))&&(((Re).qX).S===({S:"super"}).S)){
if(!(((QT)!==(null))&&(((QT).qX)!==(null)))){throw 0xE9170000;}
if(!((((Re).s4).qc)===(66562))){throw 0xE9170000;}
(Rh)=(((Re).s4).A9);
(qr)((Rh),([130,134]));
(Ri)=((((qv)((Rh),([130,134]))).AI).qz);
if(!(((Ri).qc)===(5))){throw 0xE9170000;}
(Rj)=((Ri).tg);
(qr)((Rj),([130,134]));
Rl:
while(!((qt)((Rj),([130,134])))){
(Rm)=((qv)((Rj),([130,134])));
if(((((Rm).tS).qX)!==(null))&&((((Rm).tS).qX).S===((QT).qX).S)){
if(!((Rm).N5)){throw 0xE9170000;}
(Rp)=(new yt());
(yu)((Rp),(2062),((QR).ql));
((Rp).qz)=(((Rm).N6).tS);
((Re).xY)=(Rp);
break Rl;
}
(r8)((Rj),([130,134]));
}
if(!(!((qt)((Rj),([130,134]))))){throw 0xE9170000;}
}
if(((Re).xY)===(null)){
return null;
}
(Rt)=(new yp());
(xM)((Rt),(528),((QR).ql));
(Rv)=(new zI());
(yu)((Rv),(2050),((QR).ql));
((Rv).zJ)=(0);
(Rx)=(new yt());
(yu)((Rx),(2062),((QR).ql));
((Rx).qz)=(Re);
((Rv).zM)=(Rx);
((Rv).zN)=((Re).xY);
((Rt).yz)=(Rv);
((Re).xY)=(null);
(QR)=((zO)((Rt),(QS),(QT)));
break;
case 66049:
(QR)=((Rz)((QR),(QS),(QT)));
break;
case 66050:
(QR)=((R1)((QR),(QS),(QT)));
break;
case 16843265:
(QR)=((R3)((QR),(QS),(QT)));
break;
case 16843266:
(QR)=((R5)((QR),(QS),(QT)));
break;
case 66051:
(QR)=((R7)((QR),(QS),(QT)));
break;
case 526:
(QR)=((R9)((QR)));
break;
case 66052:
(QR)=((RB)((QR),(QS),(QT)));
break;
case 527:
(QR)=((RD)((QR),(QS)));
break;
case 528:
(QR)=((RF)((QR)));
break;
case 529:
(QR)=((RH)((QR),(QS),(QT)));
break;
case 530:
(QR)=((RJ)((QR),(QS),(QT)));
break;
case 531:
(QR)=((RL)((QR)));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
if((QR)===(null)){
return null;
}
if(!(((QR).zo)!==(null))){throw 0xE9170000;}
return QR;
}
// isRef
function zQ(RP /*type*/){
let RQ=0; // typeId
(RQ)=((RP).qc);
return ((((RQ)===(66561))||((RQ)===(66563)))||((RQ)===(66564)))||((RR)((RP)));
}
// makeExprNull
function zX(RS /*pos*/){
let RT=null; // value
let RV=null; // type
(RT)=(new yD());
(yu)((RT),(67584),(RS));
(RV)=(new RW());
(xM)((RV),(1027),(RS));
((RT).yI)=(RV);
return RT;
}
// getId
function Ad(){
let RX=null; // curId
let RY=null; // newId
let Sb=0; // idx
let Ss=0;
let Sv=null;
let Sz=null;
let S3=null;
let Sk=0;
let Sl=0;
let So=0;
let Sp=0;
(RX)=(M);
(RY)=(C_([129,2],(M)));
Sa:
while(true){
(Sb)=(((RY).S.length)-(1));
Sd:
while(true){
if(((RY).S.charCodeAt(Sb))===(0x007A)){
if((Sb)===(0)){
(RY)=({S:"\0".repeat(((RY).S.length)+(1))});
(Si)((RY),([129,2]),(0x0061));
}
else{
(RY).S=(Sk=(Sb),(RY).S.slice(0,Sk)+String.fromCharCode(0x0061)+(RY).S.slice(Sk+1));
(Sb)=((Sb)-(1));
continue Sd;
}
}
else{
(RY).S=(So=(Sb),(RY).S.slice(0,So)+String.fromCharCode((Sq)(((RY).S.charCodeAt(Sb)),(1)))+(RY).S.slice(So+1));
}
break Sd;
}
switch((RY).S.length){
case 2:
Sv=RY;
if(Sv.S===({S:"do"}).S||Sv.S===({S:"if"}).S||Sv.S===({S:"or"}).S){
continue Sa;
}
break;
case 3:
Sz=RY;
if(Sz.S===({S:"and"}).S||Sz.S===({S:"asm"}).S||Sz.S===({S:"for"}).S||Sz.S===({S:"int"}).S||Sz.S===({S:"new"}).S||Sz.S===({S:"not"}).S||Sz.S===({S:"try"}).S||Sz.S===({S:"xor"}).S){
continue Sa;
}
break;
case 4:
S3=RY;
if(S3.S===({S:"auto"}).S||S3.S===({S:"bool"}).S||S3.S===({S:"case"}).S||S3.S===({S:"char"}).S||S3.S===({S:"else"}).S||S3.S===({S:"enum"}).S||S3.S===({S:"goto"}).S||S3.S===({S:"long"}).S||S3.S===({S:"main"}).S||S3.S===({S:"this"}).S||S3.S===({S:"true"}).S||S3.S===({S:"void"}).S){
continue Sa;
}
break;
}
break Sa;
}
(M)=(RY);
return RX;
}
// search
function Dj(S5 /*members*/,S6 /*name*/){
let S8=null; // def
(qr)((S5),([130,134]));
while(!((qt)((S5),([130,134])))){
(S8)=(((qv)((S5),([130,134]))).tS);
if(((((S8).qc)===(2))&&((((S8).tX).qX)!==(null)))&&((((S8).tX).qX).S===(S6).S)){
return (rU)(((S8).tX));
}
(r8)((S5),([130,134]));
}
if(!(false)){throw 0xE9170000;}
return null;
}
// buildIf
function Ee(SB /*ast*/,SC /*breakStat*/,SD /*skipStat*/){
let SE=null; // infoMe
let SN=null; // items
let SQ=null; // item
(SE)=((rU)((SB)));
if(((SB).SG)===(null)){
(Ew)(((SB).SI),(SC),(SD));
if((((SE).Ag)!==(null))&&((SE).Am)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((SE).Ag),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
return;
}
(eN)((P),([130,129,2]),({S:"if("}));
(SL)(((SB).SG));
(eN)((P),([130,129,2]),({S:"){\u000A"}));
(Ew)(((SB).SI),(SC),(SD));
(eN)((P),([130,129,2]),({S:"}\u000A"}));
(SN)=((SB).SO);
(qr)((SN),([130,134]));
while(!((qt)((SN),([130,134])))){
(SQ)=((qv)((SN),([130,134])));
(eN)((P),([130,129,2]),({S:"else if("}));
(SL)(((SQ).SS));
(eN)((P),([130,129,2]),({S:"){\u000A"}));
(Ew)(((SQ).ST),(SC),(SD));
(eN)((P),([130,129,2]),({S:"}\u000A"}));
(r8)((SN),([130,134]));
}
if(((SB).SV)!==(null)){
(eN)((P),([130,129,2]),({S:"else{\u000A"}));
(Ew)(((SB).SV),(SC),(SD));
(eN)((P),([130,129,2]),({S:"}\u000A"}));
}
if((((SE).Ag)!==(null))&&((SE).Am)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((SE).Ag),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
}
// buildSwitch
function Eh(SZ /*ast*/,Ta /*breakStat*/,Tb /*skipStat*/){
let Tc=null; // infoMe
let Td=null; // info
let Tg=false; // useSwitch
let Tm=null; // items
let Tp=null; // item
let Tr=null; // items2
let Tu=null; // exprs
let T0=null; // items
let T2=null; // item
let T3=null; // items2
let T5=null; // exprs
let TC=false; // first
let TD=null; // items
let TF=null; // item
let TJ=false; // first2
let TK=null; // items2
let TM=null; // exprs
(Tc)=((rU)((SZ)));
(Td)=((rU)(((SZ).xZ)));
if(!((Td).rX)){
((Td).rX)=(true);
(eN)((T),([130,134]),((SZ).xZ));
}
(Tg)=(false);
Ti:
if(((((s3)((((SZ).Tj).yI)))||((Tk)((((SZ).Tj).yI))))||((EN)((((SZ).Tj).yI))))||(((((SZ).Tj).yI).qc)===(1025))){
(Tg)=(true);
(Tm)=((SZ).Tn);
(qr)((Tm),([130,134]));
while(!((qt)((Tm),([130,134])))){
(Tp)=((qv)((Tm),([130,134])));
(Tr)=((Tp).Ts);
(qr)((Tr),([130,134]));
while(!((qt)((Tr),([130,134])))){
(Tu)=((qv)((Tr),([130,134])));
if((((rt)((((Tu).yJ).qc),([9]),(67584)))!==(67584))||(((Tu).yO)!==(null))){
(Tg)=(false);
break Ti;
}
(r8)((Tr),([130,134]));
}
(r8)((Tm),([130,134]));
}
}
if(Tg){
(eN)((P),([130,129,2]),({S:"switch("}));
(SL)(((SZ).Tj));
(eN)((P),([130,129,2]),({S:"){\u000A"}));
(T0)=((SZ).Tn);
(qr)((T0),([130,134]));
while(!((qt)((T0),([130,134])))){
(T2)=((qv)((T0),([130,134])));
(T3)=((T2).Ts);
(qr)((T3),([130,134]));
while(!((qt)((T3),([130,134])))){
(T5)=((qv)((T3),([130,134])));
if(!(((T5).yO)===(null))){throw 0xE9170000;}
(eN)((P),([130,129,2]),({S:"case "}));
(SL)(((T5).yJ));
(eN)((P),([130,129,2]),({S:":\u000A"}));
(r8)((T3),([130,134]));
}
(Ew)(((T2).T6),(SZ),(Tb));
(eN)((P),([130,129,2]),({S:"break;\u000A"}));
(r8)((T0),([130,134]));
}
if(((SZ).T8)!==(null)){
(eN)((P),([130,129,2]),({S:"default:\u000A"}));
(Ew)(((SZ).T8),(SZ),(Tb));
(eN)((P),([130,129,2]),({S:"break;\u000A"}));
}
(eN)((P),([130,129,2]),({S:"}\u000A"}));
}
else{
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((Td).sN),([129,2]))).S}).S+({S:" = "}).S}));
(SL)(((SZ).Tj));
(eN)((P),([130,129,2]),({S:";\u000A"}));
(TC)=(true);
(TD)=((SZ).Tn);
(qr)((TD),([130,134]));
while(!((qt)((TD),([130,134])))){
(TF)=((qv)((TD),([130,134])));
if(TC){
(TC)=(false);
(eN)((P),([130,129,2]),({S:"if("}));
}
else{
(eN)((P),([130,129,2]),({S:"else if("}));
}
(TJ)=(true);
(TK)=((TF).Ts);
(qr)((TK),([130,134]));
while(!((qt)((TK),([130,134])))){
(TM)=((qv)((TK),([130,134])));
if(TJ){
(TJ)=(false);
}
else{
(eN)((P),([130,129,2]),({S:" || "}));
}
if(((TM).yO)===(null)){
if((zQ)((((SZ).Tj).yI))){
(eN)((P),([130,129,2]),({S:({S:({S:"cmp_("}).S+((v)(((Td).sN),([129,2]))).S}).S+({S:", ("}).S}));
(SL)(((TM).yJ));
(eN)((P),([130,129,2]),({S:")) == 0"}));
}
else{
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((Td).sN),([129,2]))).S}).S+({S:" == ("}).S}));
(SL)(((TM).yJ));
(eN)((P),([130,129,2]),({S:")"}));
}
}
else{
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((TM).yJ));
(eN)((P),([130,129,2]),({S:({S:({S:") <= "}).S+((v)(((Td).sN),([129,2]))).S}).S+({S:({S:({S:" && "}).S+((v)(((Td).sN),([129,2]))).S}).S+({S:" <= ("}).S}).S}));
(SL)(((TM).yO));
(eN)((P),([130,129,2]),({S:")"}));
}
(r8)((TK),([130,134]));
}
(eN)((P),([130,129,2]),({S:"){\u000A"}));
(Ew)(((TF).T6),(Ta),(Tb));
(eN)((P),([130,129,2]),({S:"}\u000A"}));
(r8)((TD),([130,134]));
}
if(((SZ).T8)!==(null)){
(eN)((P),([130,129,2]),({S:"else{"}));
(Ew)(((SZ).T8),(Ta),(Tb));
(eN)((P),([130,129,2]),({S:"}\u000A"}));
}
}
if((((Tc).Ag)!==(null))&&((Tc).Am)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((Tc).Ag),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
}
// buildWhile
function Ek(Ua /*ast*/,Ub /*breakStat*/,Uc /*skipStat*/){
let Ud=null; // infoMe
(Ud)=((rU)((Ua)));
if(((Ua).Uf)===(null)){
(eN)((P),([130,129,2]),({S:"for(;;){\u000A"}));
(to)(((Ua).Uh),(Ua),(Ua));
if((((Ud).Aj)!==(null))&&((Ud).An)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((Ud).Aj),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
(eN)((P),([130,129,2]),({S:"}\u000A"}));
if((((Ud).Ag)!==(null))&&((Ud).Am)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((Ud).Ag),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
return;
}
if((Ua).Un){
(eN)((P),([130,129,2]),({S:"do{\u000A"}));
(to)(((Ua).Uh),(Ua),(Ua));
if((((Ud).Aj)!==(null))&&((Ud).An)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((Ud).Aj),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
(eN)((P),([130,129,2]),({S:"}while("}));
(SL)(((Ua).Uf));
(eN)((P),([130,129,2]),({S:");\u000A"}));
if((((Ud).Ag)!==(null))&&((Ud).Am)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((Ud).Ag),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
return;
}
(eN)((P),([130,129,2]),({S:"while("}));
(SL)(((Ua).Uf));
(eN)((P),([130,129,2]),({S:"){\u000A"}));
(to)(((Ua).Uh),(Ua),(Ua));
if((((Ud).Aj)!==(null))&&((Ud).An)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((Ud).Aj),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
(eN)((P),([130,129,2]),({S:"}\u000A"}));
if((((Ud).Ag)!==(null))&&((Ud).Am)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((Ud).Ag),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
}
// buildFor
function Eo(Ux /*ast*/,Uy /*breakStat*/,Uz /*skipStat*/){
let U0=null; // infoMe
let U1=null; // info
let U4=null; // endId
let U9=0; // step
(U0)=((rU)((Ux)));
(U1)=((rU)(((Ux).xZ)));
if(!((U1).rX)){
((U1).rX)=(true);
(eN)((T),([130,134]),((Ux).xZ));
}
(U4)=((U5)((((Ux).U6).yI)));
(eN)((P),([130,129,2]),({S:({S:({S:"for("}).S+((v)(((U1).sN),([129,2]))).S}).S+({S:" = ("}).S}));
(SL)(((Ux).U7));
(eN)((P),([130,129,2]),({S:({S:({S:"), "}).S+((v)((U4),([129,2]))).S}).S+({S:" = ("}).S}));
(SL)(((Ux).U6));
(eN)((P),([130,129,2]),({S:({S:({S:"); "}).S+((v)(((U1).sN),([129,2]))).S}).S+({S:" "}).S}));
if(!(((((Ux).U8).qc)===(67585))&&((s3)((((Ux).U6).yI))))){throw 0xE9170000;}
(U9)=(((Ux).U8).yF);
if((U9)>(0)){
(eN)((P),([130,129,2]),({S:"<="}));
}
else{
(eN)((P),([130,129,2]),({S:">="}));
}
(eN)((P),([130,129,2]),({S:({S:({S:" "}).S+((v)((U4),([129,2]))).S}).S+({S:({S:({S:"; "}).S+((v)(((U1).sN),([129,2]))).S}).S+({S:" "}).S}).S}));
if((U9)>(0)){
(eN)((P),([130,129,2]),({S:"+= ("}));
}
else{
(eN)((P),([130,129,2]),({S:"-= ("}));
}
(SL)(((Ux).U8));
(eN)((P),([130,129,2]),({S:")){\u000A"}));
(to)(((Ux).UG),(Ux),(Ux));
if((((U0).Aj)!==(null))&&((U0).An)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((U0).Aj),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
(eN)((P),([130,129,2]),({S:"}\u000A"}));
if((((U0).Ag)!==(null))&&((U0).Am)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((U0).Ag),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
}
// buildTry
function Er(UL /*ast*/,UM /*breakStat*/,UN /*skipStat*/){
let UO=null; // infoMe
let UP=null; // info
let UX=false; // first
let UY=null; // items
let Va=null; // item
let Ve=false; // first2
let Vf=null; // items2
let Vh=null; // exprs
(UO)=((rU)((UL)));
(UP)=((rU)(((UL).xZ)));
if(!((UP).rX)){
((UP).rX)=(true);
(eN)((T),([130,134]),((UL).xZ));
}
if(((UL).yi)!==(null)){
(eN)((P),([130,129,2]),({S:"try{\u000A"}));
}
(eN)((P),([130,129,2]),({S:"try{\u000A"}));
(Ew)(((UL).ye),(UM),(UN));
if(((UL).yi)!==(null)){
(Ew)(((UL).yi),(UM),(UN));
}
(eN)((P),([130,129,2]),({S:({S:({S:"}catch(int64_t "}).S+((v)(((UP).sN),([129,2]))).S}).S+({S:"){\u000A"}).S}));
(UX)=(true);
(UY)=((UL).yf);
(qr)((UY),([130,134]));
while(!((qt)((UY),([130,134])))){
(Va)=((qv)((UY),([130,134])));
if(UX){
(UX)=(false);
(eN)((P),([130,129,2]),({S:"if("}));
}
else{
(eN)((P),([130,129,2]),({S:"else if("}));
}
(Ve)=(true);
(Vf)=((Va).y3);
(qr)((Vf),([130,134]));
while(!((qt)((Vf),([130,134])))){
(Vh)=((qv)((Vf),([130,134])));
if(Ve){
(Ve)=(false);
}
else{
(eN)((P),([130,129,2]),({S:" || "}));
}
if(((Vh).yO)===(null)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((UP).sN),([129,2]))).S}).S+({S:" == ("}).S}));
(SL)(((Vh).yJ));
(eN)((P),([130,129,2]),({S:")"}));
}
else{
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((Vh).yJ));
(eN)((P),([130,129,2]),({S:({S:({S:") <= "}).S+((v)(((UP).sN),([129,2]))).S}).S+({S:({S:({S:" && "}).S+((v)(((UP).sN),([129,2]))).S}).S+({S:" <= ("}).S}).S}));
(SL)(((Vh).yO));
(eN)((P),([130,129,2]),({S:")"}));
}
(r8)((Vf),([130,134]));
}
(eN)((P),([130,129,2]),({S:"){\u000A"}));
(Ew)(((Va).y6),(UM),(UN));
(eN)((P),([130,129,2]),({S:"}\u000A"}));
(r8)((UY),([130,134]));
}
if(UX){
(eN)((P),([130,129,2]),({S:"{\u000A"}));
}
else{
(eN)((P),([130,129,2]),({S:"else{\u000A"}));
}
(eN)((P),([130,129,2]),({S:"throw;\u000A}\u000A"}));
(eN)((P),([130,129,2]),({S:"}\u000A"}));
if(((UL).yi)!==(null)){
(eN)((P),([130,129,2]),({S:"}\u000Acatch(...){\u000A"}));
(Ew)(((UL).yi),(UM),(UN));
(eN)((P),([130,129,2]),({S:"throw;\u000A}\u000A"}));
}
if((((UO).Ag)!==(null))&&((UO).Am)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((UO).Ag),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
}
// buildThrow
function Et(Vv /*ast*/){
(eN)((P),([130,129,2]),({S:"throw "}));
(SL)(((Vv).Vw));
(eN)((P),([130,129,2]),({S:";\u000A"}));
}
// buildBlock
function Ew(Vx /*ast*/,Vy /*breakStat*/,Vz /*skipStat*/){
let V0=null; // infoMe
(V0)=((rU)((Vx)));
(to)(((Vx).yd),(Vy),(Vz));
if((((V0).Ag)!==(null))&&((V0).Am)){
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((V0).Ag),([129,2]))).S}).S+({S:":;\u000A"}).S}));
}
}
// buildRet
function Ey(V3 /*ast*/){
if(((V3).V5)===(null)){
(eN)((P),([130,129,2]),({S:"return;\u000A"}));
}
else{
(eN)((P),([130,129,2]),({S:"return "}));
(SL)(((V3).V5));
(eN)((P),([130,129,2]),({S:";\u000A"}));
}
}
// buildDo
function E1(V8 /*ast*/){
(SL)(((V8).yz));
(eN)((P),([130,129,2]),({S:";\u000A"}));
}
// buildBreak
function E3(V9 /*ast*/,VA /*breakStat*/){
let VE=null; // info
if(!(((rt)((((V9).qz).qc),([9]),(66048)))===(66048))){throw 0xE9170000;}
if(((V9).qz)===(VA)){
(eN)((P),([130,129,2]),({S:"break;\u000A"}));
}
else{
(VE)=((rU)(((V9).qz)));
((VE).Am)=(true);
(eN)((P),([130,129,2]),({S:({S:({S:"goto "}).S+((v)(((VE).Ag),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
}
// buildSkip
function E5(VF /*ast*/,VG /*skipStat*/){
let VK=null; // info
if(!(((rt)((((VF).qz).qc),([9]),(16843264)))===(16843264))){throw 0xE9170000;}
if(((VF).qz)===(VG)){
(eN)((P),([130,129,2]),({S:"continue;\u000A"}));
}
else{
(VK)=((rU)(((VF).qz)));
((VK).An)=(true);
(eN)((P),([130,129,2]),({S:({S:({S:"goto "}).S+((v)(((VK).Aj),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
}
// buildAssert
function E7(VL /*ast*/){
(eN)((P),([130,129,2]),({S:"if(!("}));
(SL)(((VL).VM));
(eN)((P),([130,129,2]),({S:({S:({S:")){\u000Athrow "}).S+((v)((0xE9170000),([6]))).S}).S+({S:"U;\u000A}\u000A"}).S}));
}
// isNullable
function EI(VN /*type*/){
return (((rt)(((VN).qc),([9]),(66560)))===(66560))&&(!((EN)((VN))));
}
// isEnum
function EN(VO /*type*/){
return (((VO).qc)===(66565))&&((((VO).qz).qc)===(6));
}
// getId
function FR(){
let VP=null; // curId
let VQ=null; // newId
let VT=0; // idx
let VX=0;
let Wp=0;
let Ws=null;
let Ww=null;
let W0=null;
let VZ=0;
let Wa=0;
let Wc=0;
let Wd=0;
let Wi=0;
let Wj=0;
let Wm=0;
let Wn=0;
(VP)=(al);
(VQ)=(C_([129,2],(al)));
VS:
while(true){
(VT)=(((VQ).S.length)-(1));
VV:
while(true){
switch((VQ).S.charCodeAt(VT)){
case 0x007A:
(VQ).S=(VZ=(VT),(VQ).S.slice(0,VZ)+String.fromCharCode(((VT)===(0))?(0x0041):(0x0030))+(VQ).S.slice(VZ+1));
break;
case 0x0039:
(VQ).S=(Wc=(VT),(VQ).S.slice(0,Wc)+String.fromCharCode(0x0041)+(VQ).S.slice(Wc+1));
break;
case 0x005A:
if((VT)===(0)){
(VQ)=({S:"\0".repeat(((VQ).S.length)+(1))});
(Si)((VQ),([129,2]),(0x0061));
}
else{
(VQ).S=(Wi=(VT),(VQ).S.slice(0,Wi)+String.fromCharCode(0x0061)+(VQ).S.slice(Wi+1));
(VT)=((VT)-(1));
continue VV;
}
break;
default:
(VQ).S=(Wm=(VT),(VQ).S.slice(0,Wm)+String.fromCharCode((Sq)(((VQ).S.charCodeAt(VT)),(1)))+(VQ).S.slice(Wm+1));
break;
}
break VV;
}
switch((VQ).S.length){
case 2:
Ws=VQ;
if(Ws.S===({S:"do"}).S||Ws.S===({S:"if"}).S||Ws.S===({S:"in"}).S){
continue VS;
}
break;
case 3:
Ww=VQ;
if(Ww.S===({S:"for"}).S||Ww.S===({S:"let"}).S||Ww.S===({S:"new"}).S||Ww.S===({S:"try"}).S||Ww.S===({S:"var"}).S||Ww.S===({S:"Map"}).S||Ww.S===({S:"NaN"}).S||Ww.S===({S:"Set"}).S){
continue VS;
}
break;
case 4:
W0=VQ;
if(W0.S===({S:"case"}).S||W0.S===({S:"else"}).S||W0.S===({S:"enum"}).S||W0.S===({S:"eval"}).S||W0.S===({S:"name"}).S||W0.S===({S:"null"}).S||W0.S===({S:"this"}).S||W0.S===({S:"true"}).S||W0.S===({S:"void"}).S||W0.S===({S:"with"}).S||W0.S===({S:"Date"}).S||W0.S===({S:"Intl"}).S||W0.S===({S:"JSON"}).S||W0.S===({S:"Math"}).S){
continue VS;
}
break;
}
break VS;
}
(al)=(VQ);
return VP;
}
// search
function HP(W2 /*members*/,W3 /*name*/){
let W5=null; // def
(qr)((W2),([130,134]));
while(!((qt)((W2),([130,134])))){
(W5)=(((qv)((W2),([130,134]))).tS);
if(((((W5).qc)===(2))&&((((W5).tX).qX)!==(null)))&&((((W5).tX).qX).S===(W3).S)){
return (uJ)(((W5).tX));
}
(r8)((W2),([130,134]));
}
if(!(false)){throw 0xE9170000;}
return null;
}
// buildIf
function IP(W8 /*ast*/){
let W9=null; // infoMe
let WK=null; // items
let WM=null; // item
(W9)=((uJ)((W8)));
if(((W8).SG)===(null)){
if(((W9).FU)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((W9).FU),([129,2]))).S}).S+({S:":{\u000A"}).S}));
}
(Jb)(((W8).SI));
if(((W9).FU)!==(null)){
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
return;
}
if(((W9).FU)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((W9).FU),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:"if("}));
(WI)(((W8).SG));
(eN)((am),([130,129,2]),({S:"){\u000A"}));
(Jb)(((W8).SI));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
(WK)=((W8).SO);
(qr)((WK),([130,134]));
while(!((qt)((WK),([130,134])))){
(WM)=((qv)((WK),([130,134])));
(eN)((am),([130,129,2]),({S:"else if("}));
(WI)(((WM).SS));
(eN)((am),([130,129,2]),({S:"){\u000A"}));
(Jb)(((WM).ST));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
(r8)((WK),([130,134]));
}
if(((W8).SV)!==(null)){
(eN)((am),([130,129,2]),({S:"else{\u000A"}));
(Jb)(((W8).SV));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
}
// buildSwitch
function IR(WP /*ast*/){
let WQ=null; // infoMe
let WR=null; // info
let WU=false; // useSwitch
let WY=null; // items
let Xa=null; // item
let Xb=null; // items2
let Xd=null; // exprs
let Xl=null; // items
let Xn=null; // item
let Xo=null; // items2
let Xq=null; // exprs
let Xx=false; // first
let Xy=null; // items
let X0=null; // item
let X4=false; // first2
let X5=null; // items2
let X7=null; // exprs
(WQ)=((uJ)((WP)));
(WR)=((uJ)(((WP).xZ)));
if(!((WR).uM)){
((WR).uM)=(true);
(eN)((ap),([130,134]),((WP).xZ));
}
(WU)=(false);
WW:
if(((((s3)((((WP).Tj).yI)))||((Tk)((((WP).Tj).yI))))||((EN)((((WP).Tj).yI))))||(((((WP).Tj).yI).qc)===(1025))){
(WU)=(true);
(WY)=((WP).Tn);
(qr)((WY),([130,134]));
while(!((qt)((WY),([130,134])))){
(Xa)=((qv)((WY),([130,134])));
(Xb)=((Xa).Ts);
(qr)((Xb),([130,134]));
while(!((qt)((Xb),([130,134])))){
(Xd)=((qv)((Xb),([130,134])));
if((((rt)((((Xd).yJ).qc),([9]),(67584)))!==(67584))||(((Xd).yO)!==(null))){
(WU)=(false);
break WW;
}
(r8)((Xb),([130,134]));
}
(r8)((WY),([130,134]));
}
}
if(WU){
if(((WQ).FU)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((WQ).FU),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:"switch("}));
(WI)(((WP).Tj));
(eN)((am),([130,129,2]),({S:"){\u000A"}));
(Xl)=((WP).Tn);
(qr)((Xl),([130,134]));
while(!((qt)((Xl),([130,134])))){
(Xn)=((qv)((Xl),([130,134])));
(Xo)=((Xn).Ts);
(qr)((Xo),([130,134]));
while(!((qt)((Xo),([130,134])))){
(Xq)=((qv)((Xo),([130,134])));
if(!(((Xq).yO)===(null))){throw 0xE9170000;}
(eN)((am),([130,129,2]),({S:"case "}));
(WI)(((Xq).yJ));
(eN)((am),([130,129,2]),({S:":\u000A"}));
(r8)((Xo),([130,134]));
}
(Jb)(((Xn).T6));
(eN)((am),([130,129,2]),({S:"break;\u000A"}));
(r8)((Xl),([130,134]));
}
if(((WP).T8)!==(null)){
(eN)((am),([130,129,2]),({S:"default:\u000A"}));
(Jb)(((WP).T8));
(eN)((am),([130,129,2]),({S:"break;\u000A"}));
}
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
else{
if(((WQ).FU)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((WQ).FU),([129,2]))).S}).S+({S:":{\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((WR).va),([129,2]))).S}).S+({S:"="}).S}));
(WI)(((WP).Tj));
(eN)((am),([130,129,2]),({S:";\u000A"}));
(Xx)=(true);
(Xy)=((WP).Tn);
(qr)((Xy),([130,134]));
while(!((qt)((Xy),([130,134])))){
(X0)=((qv)((Xy),([130,134])));
if(Xx){
(Xx)=(false);
(eN)((am),([130,129,2]),({S:"if("}));
}
else{
(eN)((am),([130,129,2]),({S:"else if("}));
}
(X4)=(true);
(X5)=((X0).Ts);
(qr)((X5),([130,134]));
while(!((qt)((X5),([130,134])))){
(X7)=((qv)((X5),([130,134])));
if(X4){
(X4)=(false);
}
else{
(eN)((am),([130,129,2]),({S:"||"}));
}
if(((X7).yO)===(null)){
if((XE)((((WP).Tj).yI))){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((WR).va),([129,2]))).S}).S+({S:".S===("}).S}));
(WI)(((X7).yJ));
(eN)((am),([130,129,2]),({S:").S"}));
}
else if((zQ)((((WP).Tj).yI))){
(eN)((am),([130,129,2]),({S:({S:({S:"cmp_("}).S+((v)(((WR).va),([129,2]))).S}).S+({S:",("}).S}));
(WI)(((X7).yJ));
(eN)((am),([130,129,2]),({S:"))==0"}));
}
else{
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((WR).va),([129,2]))).S}).S+({S:"===("}).S}));
(WI)(((X7).yJ));
(eN)((am),([130,129,2]),({S:")"}));
}
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((X7).yJ));
(eN)((am),([130,129,2]),({S:({S:({S:")<="}).S+((v)(((WR).va),([129,2]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((WR).va),([129,2]))).S}).S+({S:"<=("}).S}).S}));
(WI)(((X7).yO));
(eN)((am),([130,129,2]),({S:")"}));
}
(r8)((X5),([130,134]));
}
(eN)((am),([130,129,2]),({S:"){\u000A"}));
(Jb)(((X0).T6));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
(r8)((Xy),([130,134]));
}
if(((WP).T8)!==(null)){
(eN)((am),([130,129,2]),({S:"else{"}));
(Jb)(((WP).T8));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
if(((WQ).FU)!==(null)){
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
}
}
// buildWhile
function IT(XN /*ast*/){
let XO=null; // infoMe
(XO)=((uJ)((XN)));
if(((XN).Uf)===(null)){
if(((XO).FU)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((XO).FU),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:"for(;;){\u000A"}));
(vw)(((XN).Uh));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
return;
}
if((XN).Un){
if(((XO).FU)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((XO).FU),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:"do{\u000A"}));
(vw)(((XN).Uh));
(eN)((am),([130,129,2]),({S:"}while("}));
(WI)(((XN).Uf));
(eN)((am),([130,129,2]),({S:");\u000A"}));
return;
}
if(((XO).FU)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((XO).FU),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:"while("}));
(WI)(((XN).Uf));
(eN)((am),([130,129,2]),({S:"){\u000A"}));
(vw)(((XN).Uh));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
// buildFor
function IV(XZ /*ast*/){
let Ya=null; // infoMe
let Yb=null; // info
let Ye=null; // endId
let Yi=0; // step
(Ya)=((uJ)((XZ)));
(Yb)=((uJ)(((XZ).xZ)));
if(!((Yb).uM)){
((Yb).uM)=(true);
(eN)((ap),([130,134]),((XZ).xZ));
}
(Ye)=((Yf)((((XZ).U6).yI)));
if(((Ya).FU)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Ya).FU),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:({S:({S:"for("}).S+((v)(((Yb).va),([129,2]))).S}).S+({S:"=("}).S}));
(WI)(((XZ).U7));
(eN)((am),([130,129,2]),({S:({S:({S:"),"}).S+((v)((Ye),([129,2]))).S}).S+({S:"=("}).S}));
(WI)(((XZ).U6));
(eN)((am),([130,129,2]),({S:({S:({S:");"}).S+((v)(((Yb).va),([129,2]))).S}).S+({S:""}).S}));
if(!(((((XZ).U8).qc)===(67585))&&((s3)((((XZ).U6).yI))))){throw 0xE9170000;}
(Yi)=(((XZ).U8).yF);
if((Yi)>(0)){
(eN)((am),([130,129,2]),({S:"<="}));
}
else{
(eN)((am),([130,129,2]),({S:">="}));
}
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)((Ye),([129,2]))).S}).S+({S:({S:({S:";"}).S+((v)(((Yb).va),([129,2]))).S}).S+({S:""}).S}).S}));
if((Yi)>(0)){
(eN)((am),([130,129,2]),({S:"+=("}));
}
else{
(eN)((am),([130,129,2]),({S:"-=("}));
}
(WI)(((XZ).U8));
(eN)((am),([130,129,2]),({S:")){\u000A"}));
(vw)(((XZ).UG));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
// buildTry
function IX(Yp /*ast*/){
let Yq=null; // infoMe
let Yr=null; // info
let Yx=false; // first
let Yy=null; // items
let Y0=null; // item
let Y4=false; // first2
let Y5=null; // items2
let Y7=null; // exprs
(Yq)=((uJ)((Yp)));
(Yr)=((uJ)(((Yp).xZ)));
if(!((Yr).uM)){
((Yr).uM)=(true);
(eN)((ap),([130,134]),((Yp).xZ));
}
if(((Yq).FU)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Yq).FU),([129,2]))).S}).S+({S:":\u000A"}).S}));
}
(eN)((am),([130,129,2]),({S:"try{\u000A"}));
(Jb)(((Yp).ye));
(eN)((am),([130,129,2]),({S:({S:({S:"}catch("}).S+((v)(((Yr).va),([129,2]))).S}).S+({S:"){\u000A"}).S}));
(Yx)=(true);
(Yy)=((Yp).yf);
(qr)((Yy),([130,134]));
while(!((qt)((Yy),([130,134])))){
(Y0)=((qv)((Yy),([130,134])));
if(Yx){
(Yx)=(false);
(eN)((am),([130,129,2]),({S:"if("}));
}
else{
(eN)((am),([130,129,2]),({S:"else if("}));
}
(Y4)=(true);
(Y5)=((Y0).y3);
(qr)((Y5),([130,134]));
while(!((qt)((Y5),([130,134])))){
(Y7)=((qv)((Y5),([130,134])));
if(Y4){
(Y4)=(false);
}
else{
(eN)((am),([130,129,2]),({S:"||"}));
}
if(((Y7).yO)===(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((Yr).va),([129,2]))).S}).S+({S:"===("}).S}));
(WI)(((Y7).yJ));
(eN)((am),([130,129,2]),({S:")"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((Y7).yJ));
(eN)((am),([130,129,2]),({S:({S:({S:")<="}).S+((v)(((Yr).va),([129,2]))).S}).S+({S:({S:({S:"&&"}).S+((v)(((Yr).va),([129,2]))).S}).S+({S:"<=("}).S}).S}));
(WI)(((Y7).yO));
(eN)((am),([130,129,2]),({S:")"}));
}
(r8)((Y5),([130,134]));
}
(eN)((am),([130,129,2]),({S:"){\u000A"}));
(Jb)(((Y0).y6));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
(r8)((Yy),([130,134]));
}
if(Yx){
(eN)((am),([130,129,2]),({S:"{\u000A"}));
}
else{
(eN)((am),([130,129,2]),({S:"else{\u000A"}));
}
(eN)((am),([130,129,2]),({S:({S:({S:"throw "}).S+((v)(((Yr).va),([129,2]))).S}).S+({S:";\u000A}\u000A"}).S}));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
if(((Yp).yi)!==(null)){
(eN)((am),([130,129,2]),({S:"finally{\u000A"}));
(Jb)(((Yp).yi));
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
}
// buildThrow
function IZ(YJ /*ast*/){
(eN)((am),([130,129,2]),({S:"throw "}));
(WI)(((YJ).Vw));
(eN)((am),([130,129,2]),({S:";\u000A"}));
}
// buildBlock
function Jb(YK /*ast*/){
let YL=null; // infoMe
(YL)=((uJ)((YK)));
if(((YL).FU)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((YL).FU),([129,2]))).S}).S+({S:":{\u000A"}).S}));
}
(vw)(((YK).yd));
if(((YL).FU)!==(null)){
(eN)((am),([130,129,2]),({S:"}\u000A"}));
}
}
// buildRet
function Jd(YQ /*ast*/){
if(((YQ).V5)===(null)){
(eN)((am),([130,129,2]),({S:"return;\u000A"}));
}
else{
(eN)((am),([130,129,2]),({S:"return "}));
(WI)(((YQ).V5));
(eN)((am),([130,129,2]),({S:";\u000A"}));
}
}
// buildDo
function Jf(YU /*ast*/){
(WI)(((YU).yz));
(eN)((am),([130,129,2]),({S:";\u000A"}));
}
// buildBreak
function Jh(YV /*ast*/){
let YW=null; // info
if(!(((rt)((((YV).qz).qc),([9]),(66048)))===(66048))){throw 0xE9170000;}
(YW)=((uJ)(((YV).qz)));
(eN)((am),([130,129,2]),({S:({S:({S:"break "}).S+((v)(((YW).FU),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
// buildSkip
function Jj(YX /*ast*/){
let YY=null; // info
if(!(((rt)((((YX).qz).qc),([9]),(16843264)))===(16843264))){throw 0xE9170000;}
(YY)=((uJ)(((YX).qz)));
(eN)((am),([130,129,2]),({S:({S:({S:"continue "}).S+((v)(((YY).FU),([129,2]))).S}).S+({S:";\u000A"}).S}));
}
// buildAssert
function Jl(YZ /*ast*/){
(eN)((am),([130,129,2]),({S:"if(!("}));
(WI)(((YZ).VM));
(eN)((am),([130,129,2]),({S:({S:({S:")){throw "}).S+((v)((0xE9170000),([6]))).S}).S+({S:";}\u000A"}).S}));
}
// escapeChar
function Kd(Za /*c*/){
let Zc=0;
Zc=Za;
if(Zc===(0x0022)){
return {S:"\\\""};
}
else if(Zc===(0x0027)){
return {S:"\\\'"};
}
else if(Zc===(0x005C)){
return {S:"\\\\"};
}
else if((0x0020)<=Zc&&Zc<=(0x007E)){
return (v)((Za),([2]));
}
else{return {S:({S:({S:"\\u"}).S+((v)(((p9)(((v)((Za),([5]))),([129,2]),(2),(-1))),([129,2]))).S}).S+({S:""}).S};
}
}
// initAstImpl
function KA(Zi /*ast*/,Zj /*typeId*/,Zk /*pos*/,Zl /*name*/,Zm /*setParent*/){
((Zi).qc)=(Zj);
((Zi).ql)=(Zk);
((Zi).qX)=(Zl);
((Zi).qU)=(null);
((Zi).pY)=(null);
((Zi).q0)=(null);
((Zi).qz)=(null);
((Zi).zo)=(null);
((Zi).r5)=(false);
if(((Zi).qX)!==(null)){
(M6)((Zi),(true));
}
if(Zm){
((Zi).qU)=((Zr)((ah),([131,134])));
}
}
// readBuf
function KS(){
let Zx=0; // c
if((pH)===(0x0000)){
if((pI)===(0x0000)){
do{
(Zx)=(((u8)((af)))?(0x0000):((Zy)((af))));
}while((Zx)===(0x000D));
if((Zx)===(0x000A)){
(pF)=((pF)+(1));
(pG)=(0);
}
else if((Zx)===(0x0000)){
if(!(pJ)){
(pJ)=(true);
(Zx)=(0x000A);
(pF)=((pF)+(1));
(pG)=(0);
}
}
else{
(pG)=((pG)+(1));
}
}
else{
(Zx)=(pI);
(pI)=(0x0000);
}
}
else{
(Zx)=(pH);
(pH)=(0x0000);
}
return Zx;
}
// makePos
function Ld(){
return (wF)((ag),(pF),(pG));
}
// charToStr
function Le(ZA /*c*/){
let ZC=0;
switch(ZA){
case 0x0000:
return {S:" "};
break;
case 0x000D:
if(!(false)){throw 0xE9170000;}
break;
case 0x000A:
return {S:"(RETURN)"};
break;
case 0x0009:
case 0x0020:
return {S:"(SPACE)"};
break;
}
return (v)((ZA),([2]));
}
// addSrc
function Ly(ZH /*name*/){
let ZL=false;
let ZJ=null;
let ZK=false;
if(((ZJ=(pR)((ae),([133,129,2,134]),(ZH),(ZK={$:(ZL)},ZK)),(ZL)=ZK.$,ZJ))===(null)){
(bE)((ae),([133,129,2,134]),(ZH),(null));
}
}
// readFuncAttr
function LJ(){
let ZN=0; // c
let ZQ=null; // buf
let ZR=0; // pos
let ZV=0;
let ZW=0;
(ZN)=((wH)());
if(!(((((((0x0061)<=(ZN))&&((ZN)<=(0x007A)))||(((0x0041)<=(ZN))&&((ZN)<=(0x005A))))||(((0x0030)<=(ZN))&&((ZN)<=(0x0039))))||((ZN)===(0x005F)))||((ZN)===(0x002E)))){
(D)((65548),((Ld)()),([((Le)((ZN)))]));
return {S:""};
}
(ZQ)=({S:"\0".repeat(128)});
(ZR)=(0);
do{
if((ZR)===(128)){
(D)((65549),((Ld)()),([(ZQ)]));
return {S:""};
}
(ZQ).S=(ZV=(ZR),(ZQ).S.slice(0,ZV)+String.fromCharCode(ZN)+(ZQ).S.slice(ZV+1));
(ZR)=((ZR)+(1));
(ZN)=((xt)());
}while(((((((0x0061)<=(ZN))&&((ZN)<=(0x007A)))||(((0x0041)<=(ZN))&&((ZN)<=(0x005A))))||(((0x0030)<=(ZN))&&((ZN)<=(0x0039))))||((ZN)===(0x005F)))||((ZN)===(0x002E)));
(pH)=(ZN);
return (p9)((ZQ),([129,2]),(0),(ZR));
}
// _or
function LR(ZY /*me_*/,ZZ /*type*/,aaa /*n*/){
return ZY|aaa;
}
// nextCharErr
function Mx(aab /*c*/,aac /*c2*/){
(D)((65550),((Ld)()),([((Le)((aab))),((Le)((aac)))]));
(xs)((aac));
}
// addScopeRefeds
function M1(aad /*ast*/,aae /*name*/){
let aaf=null; // scopeRefedItem
((aad).q0)=(aae);
(aaf)=(new qw());
((aaf).qy)=(aad);
((aaf).qP)=((Zr)((ah),([131,134])));
(eN)((ai),([130,134]),(aaf));
}
// assertNextChar
function M2(aag /*c*/,aah /*skipSpaces*/){
let aai=0; // c2
(aai)=((aah)?((wH)()):((xt)()));
if((aag)!==(aai)){
(Mx)((aag),(aai));
(pH)=(aai);
}
}
// addScopeName
function M6(aal /*ast*/,aam /*refuseReserved*/){
let aaq=null; // scope
let aau=false;
let aaw=null; // parent
let aax=false; // overFunc
let aa4=null; // child
let aa7=false;
let aaA=false; // flag
let aaF=0; // kind
let aas=null;
let aat=false;
let aa5=null;
let aa6=false;
if(!(((aal).qX)!==(null))){throw 0xE9170000;}
if((aam)&&((aao)(((aal).qX)))){
(D)((65537),((Ld)()),([((aal).qX)]));
return;
}
(aaq)=((Zr)((ah),([131,134])));
if(((aas=(pR)(((aaq).pY),([133,129,2,134]),((aal).qX),(aat={$:(aau)},aat)),(aau)=aat.$,aas))!==(null)){
(D)((65537),((Ld)()),([((aal).qX)]));
}
(aaw)=(aaq);
(aax)=(false);
aaz:
while(true){
if(((aaw).qU)===(null)){
break aaz;
}
if(((((aaw).qX)!==(null))&&(((aaw).qX).S===((aal).qX).S))&&(!((((aaw).qc)===(256))&&(((aaw).q0)!==(null))))){
(D)((65538),((Ld)()),([((aal).qX)]));
return;
}
(aa4)=((aa5=(pR)(((aaw).pY),([133,129,2,134]),((aal).qX),(aa6={$:(aa7)},aa6)),(aa7)=aa6.$,aa5));
if((aa4)!==(null)){
(aaA)=(false);
if(aax){
if(((aa4).qc)===(7)){
(aaF)=((aa4).rp);
if((((aaF)===(5))||((aaF)===(3)))||((aaF)===(2))){
(aaA)=(true);
}
}
if((!(aaA))&&(((rt)(((aa4).qc),([9]),(66048)))===(66048))){
(aaA)=(true);
}
}
if(((!(aaA))&&(((aa4).qc)===(256)))&&(((aa4).q0)!==(null))){
(aaA)=(true);
}
if(!(aaA)){
(D)((65538),((Ld)()),([((aal).qX)]));
return;
}
}
if(((aaw).qc)===(256)){
(aax)=(true);
}
(aaw)=((aaw).qU);
}
(bE)(((aaq).pY),([133,129,2,134]),((aal).qX),(aal));
}
// parseArg
function MG(aaQ /*kind*/,aaR /*parentClass*/){
let aaS=null; // ast
let aaW=0; // c
let abe=0; // c
let abi=0;
(aaS)=(new ro());
(wE)((aaS),(7),((Ld)()),((wX)((true),(false))),(false));
((aaS).rp)=(aaQ);
((aaS).sJ)=(false);
if((aaR)!==(null)){
(M1)((aaS),(aaR));
}
(M2)((0x003A),(true));
(aaW)=((wH)());
if((aaW)===(0x0026)){
if((aaQ)!==(2)){
(D)((65556),((Ld)()),(null));
}
else{
((aaS).sJ)=(true);
}
}
else{
(pH)=(aaW);
}
((aaS).s4)=((MR)());
(abe)=((wH)());
if((abe)===(0x003A)){
(M2)((0x003A),(false));
if(!((aaQ)!==(0))){throw 0xE9170000;}
switch(aaQ){
case 2:
(D)((65557),((Ld)()),(null));
((aaS).xY)=(null);
break;
case 5:
(D)((65558),((Ld)()),(null));
((aaS).xY)=(null);
break;
default:
((aaS).xY)=((Os)());
break;
}
}
else{
if((aaQ)===(4)){
(D)((65559),((Ld)()),(null));
}
((aaS).xY)=(null);
(pH)=(abe);
}
return aaS;
}
// parseType
function MR(){
let abp=null; // pos
let abq=null; // ast
let abr=0; // c
let abu=null; // ast2
let abw=null; // id
let abz=null; // size
let ab2=null; // ast2
let ab5=false;
let ab9=null;
let abB=null; // ast2
let abI=null; // arg
let abX=null; // ast2
let abZ=null; // ast2
let acb=null; // ast2
let acd=null; // ast2
let acf=null; // ast2
let ach=null; // ast2
let acj=null; // ast2
let acl=null; // ast2
let acn=null; // ast2
let ab3=0;
let ab4=false;
(abp)=((Ld)());
(abq)=(null);
(abr)=((wH)());
if((abr)===(0x005B)){
(M2)((0x005D),(true));
(abu)=(new Au());
(wE)((abu),(66561),(abp),(null),(false));
((abu).Aw)=((MR)());
(abq)=(abu);
}
else{
(pH)=(abr);
(abw)=((wX)((true),(true)));
if((((((abw).S.length)>=(4))&&(((abw).S.charCodeAt(0))===(0x0062)))&&(((abw).S.charCodeAt(1))===(0x0069)))&&(((abw).S.charCodeAt(2))===(0x0074))){
(abz)=((p9)((abw),([129,2]),(3),(((abw).S.length)-(3))));
if(((((abz).S===({S:"8"}).S)||((abz).S===({S:"16"}).S))||((abz).S===({S:"32"}).S))||((abz).S===({S:"64"}).S)){
(ab2)=(new Ay());
(wE)((ab2),(1025),(abp),(null),(false));
((ab2).Az)=(~~(((ab3=(ca)((abz),(ab4={$:(ab5)},ab4)),(ab5)=ab4.$,ab3))/(8)));
(abq)=(ab2);
}
}
if((abq)===(null)){
ab9=abw;
if(ab9.S===({S:"func"}).S){
(M2)((0x003C),(true));
(M2)((0x0028),(true));
(abB)=(new A2());
(wE)((abB),(66562),(abp),(null),(false));
((abB).abC)=(0);
((abB).abD)=({L:0,H:null,T:null,P:null});
((abB).A9)=({L:0,H:null,T:null,P:null});
((abB).A4)=(null);
(abr)=((wH)());
if((abr)!==(0x0029)){
(pH)=(abr);
abH:
while(true){
(abI)=(new AC());
(abr)=((wH)());
if((abr)===(0x0000)){
break abH;
}
if((abr)===(0x0026)){
((abI).AK)=(true);
}
else{
((abI).AK)=(false);
(pH)=(abr);
}
((abI).AI)=((MR)());
(eN)(((abB).A9),([130,134]),(abI));
(abr)=((wH)());
if((abr)===(0x0029)){
break abH;
}
if((abr)!==(0x002C)){
(Mx)((0x002C),(abr));
break abH;
}
}
}
(abr)=((wH)());
if((abr)===(0x003A)){
((abB).A4)=((MR)());
(abr)=((wH)());
}
if((abr)!==(0x003E)){
(Mx)((0x003E),(abr));
}
(abq)=(abB);
}
else if(ab9.S===({S:"list"}).S){
(M2)((0x003C),(true));
(abX)=(new AP());
(wE)((abX),(66563),(abp),(null),(false));
((abX).AS)=(0);
((abX).AU)=((MR)());
(M2)((0x003E),(true));
(abq)=(abX);
}
else if(ab9.S===({S:"stack"}).S){
(M2)((0x003C),(true));
(abZ)=(new AP());
(wE)((abZ),(66563),(abp),(null),(false));
((abZ).AS)=(1);
((abZ).AU)=((MR)());
(M2)((0x003E),(true));
(abq)=(abZ);
}
else if(ab9.S===({S:"queue"}).S){
(M2)((0x003C),(true));
(acb)=(new AP());
(wE)((acb),(66563),(abp),(null),(false));
((acb).AS)=(2);
((acb).AU)=((MR)());
(M2)((0x003E),(true));
(abq)=(acb);
}
else if(ab9.S===({S:"dict"}).S){
(M2)((0x003C),(true));
(acd)=(new Ba());
(wE)((acd),(66564),(abp),(null),(false));
((acd).Bb)=((MR)());
(M2)((0x002C),(true));
((acd).Bc)=((MR)());
(M2)((0x003E),(true));
(abq)=(acd);
}
else if(ab9.S===({S:"int"}).S){
(acf)=(new xW());
(wE)((acf),(1026),(abp),(null),(false));
((acf).xX)=(0);
(abq)=(acf);
}
else if(ab9.S===({S:"float"}).S){
(ach)=(new xW());
(wE)((ach),(1026),(abp),(null),(false));
((ach).xX)=(1);
(abq)=(ach);
}
else if(ab9.S===({S:"char"}).S){
(acj)=(new xW());
(wE)((acj),(1026),(abp),(null),(false));
((acj).xX)=(2);
(abq)=(acj);
}
else if(ab9.S===({S:"bool"}).S){
(acl)=(new xW());
(wE)((acl),(1026),(abp),(null),(false));
((acl).xX)=(3);
(abq)=(acl);
}
else{(acn)=(new M9());
(wE)((acn),(66565),(abp),(null),(false));
(M1)((acn),(abw));
(abq)=(acn);
}
}
}
return abq;
}
// parseStat
function MX(aco /*block_*/){
let acr=0; // c
let acu=0; // row
let acv=0; // col
let acw=null; // id
let acy=null;
let ac0=null; // ast
do{
(acr)=((wH)());
if((acr)===(0x0000)){
(D)((65560),((Ld)()),(null));
return null;
}
}while((acr)===(0x000A));
(pH)=(acr);
(acu)=(pF);
(acv)=(pG);
(acw)=((wX)((true),(false)));
acy=acw;
if(acy.S===({S:"end"}).S){
(ac0)=((ac1)((acu),(acv),(aco)));
}
else if(acy.S===({S:"func"}).S){
(ac0)=((ac3)());
}
else if(acy.S===({S:"var"}).S){
(ac0)=((ac5)());
}
else if(acy.S===({S:"const"}).S){
(ac0)=((ac7)());
}
else if(acy.S===({S:"alias"}).S){
(ac0)=((ac9)());
}
else if(acy.S===({S:"class"}).S){
(ac0)=((acB)());
}
else if(acy.S===({S:"enum"}).S){
(ac0)=((acD)());
}
else if(acy.S===({S:"if"}).S){
(ac0)=((acF)());
}
else if(acy.S===({S:"elif"}).S){
(ac0)=((acH)((acu),(acv),(aco)));
}
else if(acy.S===({S:"else"}).S){
(ac0)=((acJ)((acu),(acv),(aco)));
}
else if(acy.S===({S:"switch"}).S){
(ac0)=((acL)((acu),(acv)));
}
else if(acy.S===({S:"case"}).S){
(ac0)=((acN)((acu),(acv),(aco)));
}
else if(acy.S===({S:"default"}).S){
(ac0)=((acP)((acu),(acv),(aco)));
}
else if(acy.S===({S:"while"}).S){
(ac0)=((acR)());
}
else if(acy.S===({S:"for"}).S){
(ac0)=((acT)((acu),(acv)));
}
else if(acy.S===({S:"try"}).S){
(ac0)=((acV)((acu),(acv)));
}
else if(acy.S===({S:"catch"}).S){
(ac0)=((acX)((acu),(acv),(aco)));
}
else if(acy.S===({S:"finally"}).S){
(ac0)=((acZ)((acu),(acv),(aco)));
}
else if(acy.S===({S:"throw"}).S){
(ac0)=((adb)());
}
else if(acy.S===({S:"block"}).S){
(ac0)=((add)());
}
else if(acy.S===({S:"ret"}).S){
(ac0)=((adf)());
}
else if(acy.S===({S:"do"}).S){
(ac0)=((adh)());
}
else if(acy.S===({S:"break"}).S){
(ac0)=((adj)());
}
else if(acy.S===({S:"skip"}).S){
(ac0)=((adl)());
}
else if(acy.S===({S:"assert"}).S){
(ac0)=((adn)());
}
else{(D)((65547),((wF)((ag),(acu),(acv))),([(acw)]));
(xs)(((xt)()));
return null;
}
if((ac0)===(null)){
return null;
}
((ac0).ql)=((wF)((ag),(acu),(acv)));
return ac0;
}
// parseExpr
function Os(){
let adr=null; // ast
let adt=0; // row
let adu=0; // col
let adv=0; // c
let ady=null; // ast2
let adz=0; // c2
let ad1=0;
(adr)=((ads)());
(adt)=(pF);
(adu)=(pG);
(adv)=((wH)());
if((adv)===(0x003A)){
(ady)=(new zI());
(Ox)((ady),(2050),((wF)((ag),(adt),(adu))));
(adz)=((xt)());
switch(adz){
case 0x003A:
((ady).zJ)=(0);
break;
case 0x002B:
((ady).zJ)=(1);
break;
case 0x002D:
((ady).zJ)=(2);
break;
case 0x002A:
((ady).zJ)=(3);
break;
case 0x002F:
((ady).zJ)=(4);
break;
case 0x0025:
((ady).zJ)=(5);
break;
case 0x005E:
((ady).zJ)=(6);
break;
case 0x007E:
((ady).zJ)=(7);
break;
case 0x0024:
((ady).zJ)=(25);
break;
default:
(D)((65569),((ady).ql),([((Le)((adz)))]));
(xs)((adz));
return null;
break;
}
((ady).zM)=(adr);
((ady).zN)=((Os)());
(adr)=(ady);
}
else{
(pH)=(adv);
}
return adr;
}
// initAstExpr
function Ox(adD /*ast*/,adE /*typeId*/,adF /*pos*/){
if(!((adD)instanceof yt)){throw 0xE9170000;}
(KA)((adD),(adE),(adF),(null),(false));
((adD).yI)=(null);
((adD).yE)=(0);
}
// readComment
function O6(){
let adG=0; // row
let adH=0; // col
let adJ=0; // c
let adO=false; // esc
let aed=false; // esc
(adG)=(pF);
(adH)=(pG);
do{
(adJ)=((xt)());
if((adJ)===(0x0000)){
(D)((65539),((wF)((ag),(adG),(adH))),(null));
return;
}
if((adJ)===(0x0022)){
(adO)=(false);
adQ:
while(true){
(adJ)=((adR)());
if((adJ)===(0x0000)){
(D)((65539),((wF)((ag),(adG),(adH))),(null));
return;
}
if(adO){
if((adJ)===(0x007B)){
(O6)();
}
(adO)=(false);
continue adQ;
}
if((adJ)===(0x0022)){
break adQ;
}
if((adJ)===(0x005C)){
(adO)=(true);
}
}
}
else if((adJ)===(0x0027)){
(aed)=(false);
aef:
while(true){
(adJ)=((adR)());
if((adJ)===(0x0000)){
(D)((65539),((wF)((ag),(adG),(adH))),(null));
return;
}
if(aed){
(aed)=(false);
continue aef;
}
if((adJ)===(0x0027)){
break aef;
}
if((adJ)===(0x005C)){
(aed)=(true);
}
}
}
else if((adJ)===(0x003B)){
aeq:
while(true){
(adJ)=((KS)());
if((adJ)===(0x0000)){
(D)((65539),((wF)((ag),(adG),(adH))),(null));
return;
}
if((adJ)===(0x000A)){
break aeq;
}
}
}
}while((adJ)!==(0x007D));
}
// initAstImpl
function OD(aev /*ast*/,aew /*typeId*/,aex /*pos*/){
((aev).qc)=(aew);
((aev).ql)=(aex);
((aev).qX)=(null);
((aev).qU)=(null);
((aev).pY)=(null);
((aev).q0)=(null);
((aev).qz)=(null);
((aev).zo)=(null);
((aev).r5)=(false);
}
// rebuildExprRef
function OW(aey /*ast*/){
let ae1=null; // refItem
let ae5=0;
let ae7=null; // func_
let ae9=null; // type
let aeB=null; // items
let aeD=null; // arg
let aeE=null; // arg2
let aeG=null; // arg
let aeI=0;
if(((aey).zo)!==(null)){
return (aey).zo;
}
((aey).zo)=(aey);
if(!(((aey).qc)===(2062))){throw 0xE9170000;}
(ae1)=((aey).qz);
if((ae1)===(null)){
return null;
}
switch((ae1).qc){
case 256:
(ae7)=((aey).qz);
(rD)((ae7));
(ae9)=(new A2());
(xM)((ae9),(66562),((aey).ql));
((ae9).abC)=((ae7).qi);
((ae9).abD)=((ae7).qj);
((ae9).A9)=({L:0,H:null,T:null,P:null});
(aeB)=((ae7).qg);
(qr)((aeB),([130,134]));
while(!((qt)((aeB),([130,134])))){
(aeD)=((qv)((aeB),([130,134])));
(aeE)=(new AC());
((aeE).AK)=((aeD).sJ);
((aeE).AI)=((aeD).s4);
(eN)(((ae9).A9),([130,134]),(aeE));
(r8)((aeB),([130,134]));
}
((ae9).A4)=((ae7).qh);
((aey).yI)=(ae9);
((aey).yE)=(1);
break;
case 7:
(aeG)=((aey).qz);
(zs)((aeG));
switch((aeG).rp){
case 1:
((aey).yI)=((aeG).s4);
((aey).yE)=(3);
break;
case 2:
((aey).yI)=((aeG).s4);
((aey).yE)=(((aeG).sJ)?(4):(2));
break;
case 3:
((aey).yI)=((aeG).s4);
((aey).yE)=(2);
break;
case 4:
if(((aeG).xY)===(null)){
return null;
}
if(!(((rt)((((aeG).xY).qc),([9]),(67584)))===(67584))){throw 0xE9170000;}
((aey).zo)=((aeG).xY);
return (aey).zo;
break;
case 5:
(D)((131075),((aey).ql),([((aey).q0)]));
return null;
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
break;
case 66050:
case 16843266:
case 66051:
if(!(((ae1).zo)!==(null))){throw 0xE9170000;}
((aey).qz)=((ae1).xZ);
((aey).yI)=(((ae1).xZ).s4);
((aey).yE)=(2);
break;
default:
if(((((rt)(((ae1).qc),([9]),(2048)))===(2048))&&(((ae1).zo)!==(null)))&&((EN)((((ae1).zo).yI)))){
((aey).zo)=((ae1).zo);
return (aey).zo;
}
(D)((131136),((aey).ql),([((aey).q0)]));
return null;
break;
}
return aey;
}
// cmpType
function Pm(aeV /*type1*/,aeW /*type2*/,aeX /*strict*/){
let afa=0; // typeId1
let afb=0; // typeId2
let afd=false; // nullable1
let afe=false; // nullable2
let afn=null; // func1
let afo=null; // func2
let afp=null; // args1
let afq=null; // args2
let afs=null; // arg1
let aft=null; // arg2
let af8=null; // dict1
let af9=null; // dict2
let afJ=null; // class1
let afK=null; // class2
let afL=null; // ptr
if(((aeV)===(null))||((aeW)===(null))){
return false;
}
(afa)=((aeV).qc);
(afb)=((aeW).qc);
(afd)=((((afa)===(66565))&&((((aeV).qz).qc)===(6)))?(false):(((rt)((afa),([9]),(66560)))===(66560)));
(afe)=((((afb)===(66565))&&((((aeW).qz).qc)===(6)))?(false):(((rt)((afb),([9]),(66560)))===(66560)));
if((((afd)&&((afb)===(1027)))||(((afa)===(1027))&&(afe)))||(((afa)===(1027))&&((afb)===(1027)))){
return true;
}
if(((afa)===(66561))&&((afb)===(66561))){
return (Pm)(((aeV).Aw),((aeW).Aw),(true));
}
if(((afa)===(1025))&&((afb)===(1025))){
return ((aeV).Az)===((aeW).Az);
}
if(((afa)===(66562))&&((afb)===(66562))){
(afn)=(aeV);
(afo)=(aeW);
(afp)=((afn).A9);
(afq)=((afo).A9);
(qr)((afp),([130,134]));
(qr)((afq),([130,134]));
while((!((qt)((afp),([130,134]))))&&(!((qt)((afq),([130,134]))))){
(afs)=((qv)((afp),([130,134])));
(aft)=((qv)((afq),([130,134])));
if((((afs).AK)!==((aft).AK))||(!((Pm)(((afs).AI),((aft).AI),(true))))){
return false;
}
(r8)((afp),([130,134]));
(r8)((afq),([130,134]));
}
if(!(((qt)((afp),([130,134])))&&((qt)((afq),([130,134]))))){
return false;
}
if((((afn).A4)===(null))&&(((afo).A4)===(null))){
return true;
}
if((((afn).A4)===(null))||(((afo).A4)===(null))){
return false;
}
return (Pm)(((afn).A4),((afo).A4),(true));
}
if(((afa)===(66563))&&((afb)===(66563))){
if(((aeV).AS)!==((aeW).AS)){
return false;
}
return (Pm)(((aeV).AU),((aeW).AU),(true));
}
if(((afa)===(66564))&&((afb)===(66564))){
(af8)=(aeV);
(af9)=(aeW);
return ((Pm)(((af8).Bb),((af9).Bb),(true)))&&((Pm)(((af8).Bc),((af9).Bc),(true)));
}
if(((afa)===(1026))&&((afb)===(1026))){
return ((aeV).xX)===((aeW).xX);
}
if(((afa)===(66565))&&((afb)===(66565))){
if(!(((((aeV).qz).qc)!==(4))&&((((aeW).qz).qc)!==(4)))){throw 0xE9170000;}
if(((((aeV).qz).qc)===(5))&&((((aeW).qz).qc)===(5))){
if(aeX){
return ((aeV).qz)===((aeW).qz);
}
else{
(afJ)=((aeV).qz);
(afK)=((aeW).qz);
(afL)=(afJ);
while((afL)!==(null)){
if((afL)===(afK)){
return true;
}
(afL)=((afL).qz);
}
return false;
}
}
return ((aeV).qz)===((aeW).qz);
}
if((((((afa)===(66565))&&((((aeV).qz).qc)===(6)))||((afa)===(1028)))&&((((afb)===(66565))&&((((aeW).qz).qc)===(6)))||((afb)===(1028))))&&(!(((afa)===(1028))&&((afb)===(1028))))){
return true;
}
return false;
}
// rebuildEnumElement
function Pp(afR /*enumElement*/,afS /*type*/){
let afT=null; // enumElement2
if(!(((afR).qc)===(67587))){throw 0xE9170000;}
if(!((EN)((afS)))){throw 0xE9170000;}
(afT)=(new yC());
(yu)((afT),(67585),((afR).ql));
((afT).yF)=((afU)((afR),((afS).qz)));
((afT).yI)=(afS);
(afT)=((Q9)((afT)));
return afT;
}
// rebuildClass
function P4(afV /*ast*/){
let afY=null; // dtor
let afZ=null; // copy
let aga=null; // toBin
let agb=null; // fromBin
let agd=null;
let age=null;
let agf=null;
let agg=null;
if(((afV).zo)!==(null)){
return;
}
((afV).zo)=(afV);
(afY)=(null);
(afZ)=(null);
(aga)=(null);
(agb)=(null);
((agc)((afV),(agd={$:(afY)},agd),(age={$:(afZ)},age),(agf={$:(aga)},agf),(agg={$:(agb)},agg)),(afY)=agd.$,(afZ)=age.$,(aga)=agf.$,(agb)=agg.$);
(agh)((afV),(afY),(afZ),(aga),(agb));
(rD)((afY));
(rD)((afZ));
(rD)((aga));
(rD)((agb));
}
// rebuildEnum
function P6(agi /*ast*/){
let agl=null; // type
let agm=0; // defaultNum
let agn=null; // enumValues
let ago=null; // items
let agr=null; // item
let ags=null; // itemName
let agx=null; // item2
let ag5=0; // value
let ag9=false;
let ag7=false;
let ag8=false;
if(((agi).zo)!==(null)){
return;
}
((agi).zo)=(agi);
(agl)=(new M9());
(xM)((agl),(66565),((agi).ql));
((agl).zo)=(agl);
((agl).qz)=(agi);
(agm)=(-1);
(agn)=(new Map());
(ago)=((agi).Ob);
(qr)((ago),([130,134]));
agq:
while(!((qt)((ago),([130,134])))){
(agr)=((qv)((ago),([130,134])));
(ags)=((agr).qX);
(agr)=((zE)((agr),(((agr).yI)===(null))));
if((agr)===(null)){
continue agq;
}
((agr).qX)=(ags);
(tw)((ago),([130,134]),(agr));
(tz)((ago),([130,134]));
if((((agr).qc)!==(67585))||((((agr).yI)!==(null))&&(!((s3)(((agr).yI)))))){
(D)((131087),((agi).ql),([((agi).qX),((agr).qX)]));
return;
}
(agx)=(agr);
if(((agr).yI)===(null)){
if((agm)===(9223372036854775807)){
(D)((131088),((agi).ql),([((agi).qX),((agr).qX)]));
return;
}
(agm)=((agm)+(1));
((agx).yF)=(agm);
}
else{
(agm)=((agx).yF);
}
(ag5)=((agx).yF);
if((ag7=(pR)((agn),([133,0,3]),(ag5),(ag8={$:(ag9)},ag8)),(ag9)=ag8.$,ag7)){
(D)((131089),((agi).ql),([((agi).qX),((agr).qX),((v)((ag5),([0])))]));
return;
}
(bE)((agn),([133,0,3]),(ag5),(true));
((agr).yI)=(agl);
}
}
// rebuildAlias
function P8(agB /*ast*/,agC /*parent*/){
if(cmp_((agB),(agC))==0){
(D)((131079),((agC).ql),([((agC).qX)]));
((agB).Nk)=(null);
return;
}
if(((agB).zo)!==(null)){
return;
}
((agB).zo)=(agB);
((agB).Nk)=((zv)(((agB).Nk),(agB)));
}
// rebuildExpr1
function Qc(agH /*ast*/){
let agN=null; // childType
let agP=0;
let ahe=null; // expr
let ahf=null; // expr
let ahn=null; // expr
let ahu=null; // type
if(((agH).zo)!==(null)){
return (agH).zo;
}
((agH).zo)=(agH);
((agH).agK)=((zE)(((agH).agK),(false)));
if(((agH).agK)===(null)){
return null;
}
if(!(((agH).yI)===(null))){throw 0xE9170000;}
(agN)=(((agH).agK).yI);
switch((agH).agQ){
case 0:
if((((s3)((agN)))||((agT)((agN))))||(((agN).qc)===(1025))){
if(((rt)((((agH).agK).qc),([9]),(67584)))===(67584)){
((agH).zo)=((agH).agK);
return (agH).zo;
}
((agH).yI)=(agN);
}
break;
case 1:
if(((s3)((agN)))||((agT)((agN)))){
if(((rt)((((agH).agK).qc),([9]),(67584)))===(67584)){
if((s3)((agN))){
(ahe)=(new yC());
(yu)((ahe),(67585),((agH).ql));
((ahe).yI)=(agN);
((ahe).yF)=(-(((agH).agK).yF));
(ahe)=((Q9)((ahe)));
((agH).zo)=(ahe);
return (agH).zo;
}
if(!((agT)((agN)))){throw 0xE9170000;}
(ahf)=(new QI());
(yu)((ahf),(67588),((agH).ql));
((ahf).yI)=(agN);
((ahf).ahg)=(-(((agH).agK).ahg));
(ahf)=((QH)((ahf)));
((agH).zo)=(ahf);
return (agH).zo;
}
((agH).yI)=(agN);
}
break;
case 2:
if((ahj)((agN))){
if((((agH).agK).qc)===(67585)){
(ahn)=(new yC());
(yu)((ahn),(67585),((agH).ql));
((ahn).yI)=(agN);
((ahn).yF)=(((((agH).agK).yF)!==(0x0000000000000000))?(0x0000000000000000):(0x0000000000000001));
(ahn)=((Q9)((ahn)));
((agH).zo)=(ahn);
return (agH).zo;
}
((agH).yI)=(agN);
}
break;
case 3:
if(((((RR)((agN)))||(((agN).qc)===(66561)))||(((agN).qc)===(66563)))||(((agN).qc)===(66564))){
((agH).yI)=(agN);
}
break;
case 4:
if(((((agN).qc)===(66561))||(((agN).qc)===(66563)))||(((agN).qc)===(66564))){
(ahu)=(new xW());
(xM)((ahu),(1026),((agH).ql));
((ahu).xX)=(0);
((agH).yI)=(ahu);
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
if(((agH).yI)===(null)){
(D)((131113),((agH).ql),(null));
return null;
}
((agH).yE)=(1);
return agH;
}
// rebuildExpr2
function Qf(ahy /*ast*/){
let ah8=false; // correct
let ahA=0;
let ahG=null; // ptr
let ahR=false; // value
let aib=null; // type
let aik=false; // value
let ail=null; // children0Type
let aio=0; // n1
let aip=0; // n2
let air=0;
let aiy=0; // n1
let aiz=0; // n2
let ai1=0;
let ai8=0; // n1
let ai9=0; // n2
let aiB=0;
let aiI=0; // cmp
let aiM=0;
let aiS=null; // expr
let aiY=null; // type
let ajg=false; // value
let ajh=null; // children0Type
let ajk=0; // n1
let ajl=0; // n2
let ajn=0;
let ajs=0; // cmp
let aju=0;
let ajy=null; // expr
let aj2=null; // type
let ajC=null; // s1
let ajD=null; // s2
let ajE=null; // expr
let ajM=0; // n1
let ajN=0; // n2
let ajP=0;
let akf=null; // expr
let aki=0; // n1
let akj=0; // n2
let akl=0;
let ak1=null; // expr
let ak3=0; // n1
let ak4=0; // n2
let ak6=0;
let akM=null; // expr
if(((ahy).zo)!==(null)){
return (ahy).zo;
}
((ahy).zo)=(ahy);
((ahy).zM)=((zE)(((ahy).zM),(false)));
if(((ahy).zM)===(null)){
return null;
}
((ahy).zN)=((zE)(((ahy).zN),(false)));
if(((ahy).zN)===(null)){
return null;
}
if(!((Pm)((((ahy).zN).yI),(((ahy).zM).yI),(false)))){
(D)((131113),((ahy).ql),(null));
return null;
}
(ah8)=(false);
switch((ahy).zJ){
case 0:
if((((ahy).zM).yE)===(1)){
(D)((131114),((ahy).ql),(null));
return null;
}
if(((RR)((((ahy).zM).yI)))&&((RR)((((ahy).zN).yI)))){
(ahG)=((((ahy).zN).yI).qz);
while(((((ahy).zM).yI).qz)!==(ahG)){
(ahG)=((ahG).qz);
if((ahG)===(null)){
(D)((131113),((ahy).ql),(null));
return null;
}
}
}
if(((((ahy).zN).yI).qc)===(1028)){
((ahy).zN)=((Pp)(((ahy).zN),(((ahy).zM).yI)));
}
((ahy).yI)=(null);
(ah8)=(true);
break;
case 8:
case 9:
if((ahj)((((ahy).zM).yI))){
if((((ahy).zM).qc)===(67585)){
(ahR)=((((ahy).zM).yF)!==(0x0000000000000000));
if(((ahy).zJ)===(8)){
((ahy).zo)=((ahR)?((ahy).zM):((ahy).zN));
}
else{
if(!(((ahy).zJ)===(9))){throw 0xE9170000;}
((ahy).zo)=((!(ahR))?((ahy).zM):((ahy).zN));
}
return (ahy).zo;
}
((ahy).yI)=(((ahy).zM).yI);
(ah8)=(true);
}
break;
case 10:
case 11:
case 12:
case 13:
if((((((ahy).zM).yI).qc)===(1027))||(((((ahy).zN).yI).qc)===(1027))){
(D)((131115),((ahy).ql),(null));
return null;
}
if((ahZ)((((ahy).zM).yI),(true))){
(aib)=(new xW());
(xM)((aib),(1026),((ahy).ql));
((aib).xX)=(3);
if(((((ahy).zM).yI).qc)===(1028)){
if(((((ahy).zN).yI).qc)===(1028)){
if(!((((ahy).zM).qc)===(67587))){throw 0xE9170000;}
(D)((131116),((ahy).ql),([(((ahy).zM).aig)]));
return null;
}
((ahy).zM)=((Pp)(((ahy).zM),(((ahy).zN).yI)));
}
else if(((((ahy).zN).yI).qc)===(1028)){
((ahy).zN)=((Pp)(((ahy).zN),(((ahy).zM).yI)));
}
if((((rt)((((ahy).zM).qc),([9]),(67584)))===(67584))&&(((rt)((((ahy).zN).qc),([9]),(67584)))===(67584))){
(aik)=(false);
(ail)=(((ahy).zM).yI);
if((((ail).qc)===(1025))||((Tk)((ail)))){
(aio)=(((ahy).zM).yF);
(aip)=(((ahy).zN).yF);
switch((ahy).zJ){
case 10:
(aik)=((aio)<(aip));
break;
case 11:
(aik)=((aio)>(aip));
break;
case 12:
(aik)=((aio)<=(aip));
break;
case 13:
(aik)=((aio)>=(aip));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else if(((s3)((ail)))||((EN)((ail)))){
(aiy)=(((ahy).zM).yF);
(aiz)=(((ahy).zN).yF);
switch((ahy).zJ){
case 10:
(aik)=((aiy)<(aiz));
break;
case 11:
(aik)=((aiy)>(aiz));
break;
case 12:
(aik)=((aiy)<=(aiz));
break;
case 13:
(aik)=((aiy)>=(aiz));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else if((agT)((ail))){
(ai8)=(((ahy).zM).ahg);
(ai9)=(((ahy).zN).ahg);
switch((ahy).zJ){
case 10:
(aik)=((ai8)<(ai9));
break;
case 11:
(aik)=((ai8)>(ai9));
break;
case 12:
(aik)=((ai8)<=(ai9));
break;
case 13:
(aik)=((ai8)>=(ai9));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{
if(!((XE)((ail)))){throw 0xE9170000;}
(aiI)=((aiJ)((((ahy).zM).aiK),(((ahy).zN).aiK)));
switch((ahy).zJ){
case 10:
(aik)=((aiI)<(0));
break;
case 11:
(aik)=((aiI)>(0));
break;
case 12:
(aik)=((aiI)<=(0));
break;
case 13:
(aik)=((aiI)>=(0));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
(aiS)=(new yC());
(yu)((aiS),(67585),((ahy).ql));
((aiS).yI)=(aib);
((aiS).yF)=((aik)?(0x0000000000000001):(0x0000000000000000));
(aiS)=((Q9)((aiS)));
((ahy).zo)=(aiS);
return (ahy).zo;
}
((ahy).yI)=(aib);
(ah8)=(true);
}
break;
case 14:
case 15:
if((((((ahy).zM).yI).qc)===(1027))||(((((ahy).zN).yI).qc)===(1027))){
(D)((131115),((ahy).ql),(null));
return null;
}
if((ahZ)((((ahy).zM).yI),(false))){
(aiY)=(new xW());
(xM)((aiY),(1026),((ahy).ql));
((aiY).xX)=(3);
if(((((ahy).zM).yI).qc)===(1028)){
if(((((ahy).zN).yI).qc)===(1028)){
if(!((((ahy).zM).qc)===(67587))){throw 0xE9170000;}
(D)((131116),((ahy).ql),([(((ahy).zM).aig)]));
return null;
}
((ahy).zM)=((Pp)(((ahy).zM),(((ahy).zN).yI)));
}
else if(((((ahy).zN).yI).qc)===(1028)){
((ahy).zN)=((Pp)(((ahy).zN),(((ahy).zM).yI)));
}
if((((rt)((((ahy).zM).qc),([9]),(67584)))===(67584))&&(((rt)((((ahy).zN).qc),([9]),(67584)))===(67584))){
(ajg)=(false);
(ajh)=(((ahy).zM).yI);
if((((((((ajh).qc)===(1025))||((s3)((ajh))))||((agT)((ajh))))||((Tk)((ajh))))||((ahj)((ajh))))||((EN)((ajh)))){
(ajk)=(((ahy).zM).yF);
(ajl)=(((ahy).zN).yF);
switch((ahy).zJ){
case 14:
(ajg)=((ajk)===(ajl));
break;
case 15:
(ajg)=((ajk)!==(ajl));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{
if(!((XE)((ajh)))){throw 0xE9170000;}
(ajs)=((aiJ)((((ahy).zM).aiK),(((ahy).zN).aiK)));
switch((ahy).zJ){
case 14:
(ajg)=((ajs)===(0));
break;
case 15:
(ajg)=((ajs)!==(0));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
(ajy)=(new yC());
(yu)((ajy),(67585),((ahy).ql));
((ajy).yI)=(aiY);
((ajy).yF)=((ajg)?(0x0000000000000001):(0x0000000000000000));
(ajy)=((Q9)((ajy)));
((ahy).zo)=(ajy);
return (ahy).zo;
}
((ahy).yI)=(aiY);
(ah8)=(true);
}
break;
case 16:
case 17:
if(((EI)((((ahy).zM).yI)))||(((((ahy).zM).yI).qc)===(1027))){
(aj2)=(new xW());
(xM)((aj2),(1026),((ahy).ql));
((aj2).xX)=(3);
((ahy).yI)=(aj2);
(ah8)=(true);
}
break;
case 18:
if((((((ahy).zM).yI).qc)===(1027))||(((((ahy).zN).yI).qc)===(1027))){
(D)((131117),((ahy).ql),(null));
return null;
}
if(((((ahy).zM).yI).qc)===(66561)){
if((((rt)((((ahy).zM).qc),([9]),(67584)))===(67584))&&(((rt)((((ahy).zN).qc),([9]),(67584)))===(67584))){
if((XE)((((ahy).zM).yI))){
(ajC)=(((ahy).zM).aiK);
(ajD)=(((ahy).zN).aiK);
(ajE)=(new QC());
(yu)((ajE),(67586),((ahy).ql));
((ajE).yI)=(((ahy).zM).yI);
((ajE).aiK)=({S:(ajC).S+(ajD).S});
(ajE)=((QB)((ajE)));
((ahy).zo)=(ajE);
return (ahy).zo;
}
}
((ahy).yI)=(((ahy).zM).yI);
(ah8)=(true);
}
break;
case 19:
case 20:
case 21:
case 22:
case 23:
if(((((((ahy).zM).yI).qc)===(1025))||((s3)((((ahy).zM).yI))))||((agT)((((ahy).zM).yI)))){
if((((rt)((((ahy).zM).qc),([9]),(67584)))===(67584))&&(((rt)((((ahy).zN).qc),([9]),(67584)))===(67584))){
if(((((ahy).zM).yI).qc)===(1025)){
(ajM)=(((ahy).zM).yF);
(ajN)=(((ahy).zN).yF);
switch((ahy).zJ){
case 19:
(ajM)=((ajM)+(ajN));
break;
case 20:
(ajM)=((ajM)-(ajN));
break;
case 21:
(ajM)=((ajM)*(ajN));
break;
case 22:
if((ajN)===(0x0000000000000000)){
(D)((131118),((ahy).ql),(null));
return null;
}
(ajM)=(~~((ajM)/(ajN)));
break;
case 23:
if((ajN)===(0x0000000000000000)){
(D)((131118),((ahy).ql),(null));
return null;
}
(ajM)=((ajM)%(ajN));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(akf)=(new yC());
(yu)((akf),(67585),((ahy).ql));
((akf).yI)=(((ahy).zM).yI);
((akf).yF)=((akg)(((((ahy).zM).yI).Az),(ajM)));
(akf)=((Q9)((akf)));
((ahy).zo)=(akf);
return (ahy).zo;
}
else if((s3)((((ahy).zM).yI))){
(aki)=(((ahy).zM).yF);
(akj)=(((ahy).zN).yF);
switch((ahy).zJ){
case 19:
(aki)=((aki)+(akj));
break;
case 20:
(aki)=((aki)-(akj));
break;
case 21:
(aki)=((aki)*(akj));
break;
case 22:
if((akj)===(0)){
(D)((131118),((ahy).ql),(null));
return null;
}
(aki)=(~~((aki)/(akj)));
break;
case 23:
if((akj)===(0)){
(D)((131118),((ahy).ql),(null));
return null;
}
(aki)=((aki)%(akj));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(ak1)=(new yC());
(yu)((ak1),(67585),((ahy).ql));
((ak1).yI)=(((ahy).zM).yI);
((ak1).yF)=(aki);
(ak1)=((Q9)((ak1)));
((ahy).zo)=(ak1);
return (ahy).zo;
}
else{
if(!((agT)((((ahy).zM).yI)))){throw 0xE9170000;}
(ak3)=(((ahy).zM).ahg);
(ak4)=(((ahy).zN).ahg);
switch((ahy).zJ){
case 19:
(ak3)=((ak3)+(ak4));
break;
case 20:
(ak3)=((ak3)-(ak4));
break;
case 21:
(ak3)=((ak3)*(ak4));
break;
case 22:
if(((ak3)===(0))&&((ak4)===(0))){
(D)((131118),((ahy).ql),(null));
return null;
}
(ak3)=((ak3)/(ak4));
break;
case 23:
if(((ak3)===(0))&&((ak4)===(0))){
(D)((131118),((ahy).ql),(null));
return null;
}
(ak3)=((ak3)%(ak4));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(akM)=(new QI());
(yu)((akM),(67588),((ahy).ql));
((akM).yI)=(((ahy).zM).yI);
((akM).ahg)=(ak3);
(akM)=((QH)((akM)));
((ahy).zo)=(akM);
return (ahy).zo;
}
}
((ahy).yI)=(((ahy).zM).yI);
(ah8)=(true);
}
break;
case 24:
if(((s3)((((ahy).zM).yI)))||((agT)((((ahy).zM).yI)))){
((ahy).yI)=(((ahy).zM).yI);
(ah8)=(true);
}
break;
case 25:
if(((((ahy).zM).yE)===(1))||((((ahy).zN).yE)===(1))){
(D)((131119),((ahy).ql),(null));
return null;
}
if((!((RR)((((ahy).zM).yI))))&&(((((ahy).zM).yI).qz)!==((((ahy).zN).yI).qz))){
((ahy).yI)=(((ahy).zM).yI);
(ah8)=(true);
}
break;
}
if(!(ah8)){
(D)((131113),((ahy).ql),(null));
return null;
}
((ahy).yE)=(1);
return ahy;
}
// rebuildExpr3
function Qh(akX /*ast*/){
if(((akX).zo)!==(null)){
return (akX).zo;
}
((akX).zo)=(akX);
((akX).ala)=((zE)(((akX).ala),(false)));
if(((akX).ala)===(null)){
return null;
}
((akX).ald)=((zE)(((akX).ald),(false)));
if(((akX).ald)===(null)){
return null;
}
((akX).alg)=((zE)(((akX).alg),(false)));
if(((akX).alg)===(null)){
return null;
}
if(!((ahj)((((akX).ala).yI)))){
(D)((131120),((akX).ql),(null));
return null;
}
if((!((Pm)((((akX).ald).yI),(((akX).alg).yI),(false))))&&(!((Pm)((((akX).alg).yI),(((akX).ald).yI),(false))))){
(D)((131121),((akX).ql),(null));
return null;
}
if((((akX).ala).qc)===(67585)){
((akX).zo)=(((((akX).ala).yF)!==(0x0000000000000000))?((akX).ald):((akX).alg));
return (akX).zo;
}
if(((((akX).ald).yI).qc)===(1028)){
if(((((akX).alg).yI).qc)===(1028)){
if(!((((akX).ald).qc)===(67587))){throw 0xE9170000;}
(D)((131116),((akX).ql),([(((akX).ald).aig)]));
return null;
}
((akX).ald)=((Pp)(((akX).ald),(((akX).alg).yI)));
}
else if(((((akX).alg).yI).qc)===(1028)){
((akX).alg)=((Pp)(((akX).alg),(((akX).ald).yI)));
}
if((Pm)((((akX).ald).yI),(((akX).alg).yI),(false))){
((akX).yI)=((((((akX).alg).yI).qc)===(1027))?(((akX).ald).yI):(((akX).alg).yI));
}
else{
((akX).yI)=((((((akX).ald).yI).qc)===(1027))?(((akX).alg).yI):(((akX).ald).yI));
}
((akX).yE)=(1);
return akX;
}
// rebuildExprNew
function Qk(alx /*ast*/){
if(((alx).zo)!==(null)){
return (alx).zo;
}
((alx).zo)=(alx);
((alx).al0)=((zv)(((alx).al0),(null)));
if(((alx).al0)===(null)){
return null;
}
if(((RR)(((alx).al0)))&&((((alx).al0).qz)===(null))){
return null;
}
if(!((((RR)(((alx).al0)))||((((alx).al0).qc)===(66563)))||((((alx).al0).qc)===(66564)))){
(D)((131122),((alx).ql),(null));
return null;
}
((alx).yI)=((alx).al0);
((alx).yE)=(1);
return alx;
}
// rebuildExprNewArray
function Qn(al7 /*ast*/){
let alB=null; // items
let alF=null; // data
let alO=null; // type
let alR=0;
let alT=null; // type2
let alS=0;
if(((al7).zo)!==(null)){
return (al7).zo;
}
((al7).zo)=(al7);
(alB)=((al7).alC);
(qr)((alB),([130,134]));
alE:
while(!((qt)((alB),([130,134])))){
(alF)=((qv)((alB),([130,134])));
(alF)=((zE)((alF),(false)));
if((alF)===(null)){
return null;
}
if(!((s3)(((alF).yI)))){
(D)((131123),((alF).ql),(null));
return null;
}
(tw)((alB),([130,134]),(alF));
(tz)((alB),([130,134]));
}
((al7).alK)=((zv)(((al7).alK),(null)));
if(((al7).alK)===(null)){
return null;
}
(alO)=((al7).alK);
alQ:
for(alR=(0),alS=((((al7).alC).L)-(1));alR<=alS;alR+=(1)){
(alT)=(new Au());
(xM)((alT),(66561),((al7).ql));
((alT).Aw)=(alO);
(alO)=(alT);
}
((al7).yI)=(alO);
((al7).yE)=(1);
return al7;
}
// rebuildExprAs
function Qq(alU /*ast*/){
let ame=0;
let amh=null; // t1
let ami=null; // t2
let amL=0; // n
let amO=null; // expr
let amQ=null; // expr
let amS=null; // expr
let amX=null; // expr
let amZ=null; // expr
let anb=null; // expr
let and=0; // n
let ang=null; // expr
let ani=null; // expr
let anm=null; // type
if(((alU).zo)!==(null)){
return (alU).zo;
}
((alU).zo)=(alU);
((alU).alX)=((zE)(((alU).alX),(false)));
if(((alU).alX)===(null)){
return null;
}
((alU).ama)=((zv)(((alU).ama),(null)));
if(((alU).ama)===(null)){
return null;
}
if(!(((alU).yI)===(null))){throw 0xE9170000;}
switch((alU).amf){
case 0:
(amh)=(((alU).alX).yI);
(ami)=((alU).ama);
if((((amh).qc)===(1025))||((s3)((amh)))){
if((((((((ami).qc)===(1025))||((s3)((ami))))||((agT)((ami))))||((Tk)((ami))))||((ahj)((ami))))||((EN)((ami)))){
if((Pm)((amh),(ami),(false))){
((alU).zo)=((alU).alX);
return (alU).zo;
}
((alU).yI)=(ami);
}
}
else if((agT)((amh))){
if(((((ami).qc)===(1025))||((s3)((ami))))||((agT)((ami)))){
if((Pm)((amh),(ami),(false))){
((alU).zo)=((alU).alX);
return (alU).zo;
}
((alU).yI)=(ami);
}
}
else if((Tk)((amh))){
if(((((ami).qc)===(1025))||((s3)((ami))))||((Tk)((ami)))){
if((Pm)((amh),(ami),(false))){
((alU).zo)=((alU).alX);
return (alU).zo;
}
((alU).yI)=(ami);
}
}
else if((ahj)((amh))){
if(((((ami).qc)===(1025))||((s3)((ami))))||((ahj)((ami)))){
if((Pm)((amh),(ami),(false))){
((alU).zo)=((alU).alX);
return (alU).zo;
}
((alU).yI)=(ami);
}
}
else if((RR)((amh))){
if((RR)((ami))){
((alU).yI)=(ami);
}
}
else if((EN)((amh))){
if(((((ami).qc)===(1025))||((s3)((ami))))||((EN)((ami)))){
if((Pm)((amh),(ami),(false))){
((alU).zo)=((alU).alX);
return (alU).zo;
}
((alU).yI)=(ami);
}
}
else if(((amh).qc)===(1028)){
if((EN)((ami))){
((alU).yI)=(ami);
}
}
if(((alU).yI)!==(null)){
if(((rt)((((alU).alX).qc),([9]),(67584)))===(67584)){
if(((((((amh).qc)===(1025))||((Tk)((amh))))||((ahj)((amh))))||((s3)((amh))))||((EN)((amh)))){
(amL)=(((alU).alX).yF);
if(((ami).qc)===(1025)){
(amO)=(new yC());
(yu)((amO),(67585),((alU).ql));
((amO).yI)=((alU).yI);
((amO).yF)=((akg)(((ami).Az),(amL)));
(amO)=((Q9)((amO)));
((alU).zo)=(amO);
return (alU).zo;
}
else if(((s3)((ami)))||((EN)((ami)))){
(amQ)=(new yC());
(yu)((amQ),(67585),((alU).ql));
((amQ).yI)=((alU).yI);
((amQ).yF)=(amL);
(amQ)=((Q9)((amQ)));
((alU).zo)=(amQ);
return (alU).zo;
}
else if((agT)((ami))){
(amS)=(new QI());
(yu)((amS),(67588),((alU).ql));
((amS).yI)=((alU).yI);
if(((s3)((amh)))||((EN)((amh)))){
((amS).ahg)=(amL);
}
else{
((amS).ahg)=(amL);
}
(amS)=((QH)((amS)));
((alU).zo)=(amS);
return (alU).zo;
}
else if((Tk)((ami))){
(amX)=(new yC());
(yu)((amX),(67585),((alU).ql));
((amX).yI)=((alU).yI);
((amX).yF)=((akg)((2),(amL)));
(amX)=((Q9)((amX)));
((alU).zo)=(amX);
return (alU).zo;
}
else{
if(!((ahj)((ami)))){throw 0xE9170000;}
(amZ)=(new yC());
(yu)((amZ),(67585),((alU).ql));
((amZ).yI)=((alU).yI);
((amZ).yF)=(((amL)!==(0x0000000000000000))?(0x0000000000000001):(0x0000000000000000));
(amZ)=((Q9)((amZ)));
((alU).zo)=(amZ);
return (alU).zo;
}
}
else if(((amh).qc)===(1028)){
if(!((((ami).qz).qc)===(6))){throw 0xE9170000;}
(anb)=(new yC());
(yu)((anb),(67585),((alU).ql));
((anb).yI)=((alU).yI);
((anb).yF)=((afU)(((alU).alX),((ami).qz)));
(anb)=((Q9)((anb)));
((alU).zo)=(anb);
return (alU).zo;
}
else{
if(!((agT)((amh)))){throw 0xE9170000;}
(and)=(((alU).alX).ahg);
if(((ami).qc)===(1025)){
(ang)=(new yC());
(yu)((ang),(67585),((alU).ql));
((ang).yI)=((alU).yI);
((ang).yF)=((akg)(((ami).Az),(~~(and))));
(ang)=((Q9)((ang)));
((alU).zo)=(ang);
return (alU).zo;
}
else{
if(!((s3)((ami)))){throw 0xE9170000;}
(ani)=(new yC());
(yu)((ani),(67585),((alU).ql));
((ani).yI)=((alU).yI);
((ani).yF)=(~~(and));
(ani)=((Q9)((ani)));
((alU).zo)=(ani);
return (alU).zo;
}
}
}
}
break;
case 1:
case 2:
if(((RR)((((alU).alX).yI)))&&((RR)(((alU).ama)))){
(anm)=(new xW());
(xM)((anm),(1026),((alU).ql));
((anm).xX)=(3);
((alU).yI)=(anm);
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
if(((alU).yI)===(null)){
(D)((131113),((alU).ql),(null));
return null;
}
((alU).yE)=(1);
return alU;
}
// rebuildExprToBin
function Qt(anq /*ast*/){
if(((anq).zo)!==(null)){
return (anq).zo;
}
((anq).zo)=(anq);
((anq).ant)=((zE)(((anq).ant),(false)));
if(((anq).ant)===(null)){
return null;
}
if((((((anq).ant).yI).qc)===(1027))||(((((anq).ant).yI).qc)===(1028))){
(D)((131113),((anq).ql),(null));
return null;
}
if((((((anq).anz).qc)!==(66561))||(((((anq).anz).Aw).qc)!==(1025)))||(((((anq).anz).Aw).Az)!==(1))){
(D)((131113),((anq).ql),(null));
return null;
}
((anq).yI)=((anq).anz);
((anq).yE)=(1);
return anq;
}
// rebuildExprFromBin
function Qw(an1 /*ast*/){
if(((an1).zo)!==(null)){
return (an1).zo;
}
((an1).zo)=(an1);
((an1).an4)=((zE)(((an1).an4),(false)));
if(((an1).an4)===(null)){
return null;
}
if(((((((an1).an4).yI).qc)!==(66561))||((((((an1).an4).yI).Aw).qc)!==(1025)))||((((((an1).an4).yI).Aw).Az)!==(1))){
(D)((131113),((an1).ql),(null));
return null;
}
((an1).yI)=((an1).an9);
((an1).yE)=(1);
((an1).anA)=((zE)(((an1).anA),(false)));
return an1;
}
// rebuildExprCall
function Qz(anB /*ast*/){
let anH=null; // type
let anK=null; // valueType
let anM=null; // expr
let anS=null; // me_
let anZ=null; // meType
let aob=null; // expr
let aoe=null; // value
let aog=null; // prim
let aor=0; // n
let aos=null; // itemsExpr
let aot=null; // itemsType
let aov=null; // argExpr
let aow=null; // argType
if(((anB).zo)!==(null)){
return (anB).zo;
}
((anB).zo)=(anB);
((anB).yy)=((zE)(((anB).yy),(false)));
if(((anB).yy)===(null)){
return null;
}
(anH)=(((anB).yy).yI);
if(((rt)(((anH).abC),([9]),(2048)))!==(0)){
(anK)=(new yX());
if(!(((anH).A4)!==(null))){throw 0xE9170000;}
(anM)=(new Ql());
(yu)((anM),(2052),((anB).ql));
((anM).al0)=((anH).A4);
((anK).zc)=((zE)((anM),(false)));
((anK).yY)=(false);
((anK).yZ)=(false);
if((((anB).yv).L)===(0)){
(eN)(((anB).yv),([130,134]),(anK));
}
else{
(qr)(((anB).yv),([130,134]));
(tw)(((anB).yv),([130,134]),(anK));
}
}
if(((((anB).yy).qc)===(2059))&&(((((anB).yy).yI).qc)===(66562))){
(anS)=(new yX());
((anS).zc)=(((anB).yy).anT);
((anS).yY)=(false);
((anS).yZ)=(false);
if((((anB).yv).L)===(0)){
(eN)(((anB).yv),([130,134]),(anS));
}
else{
(qr)(((anB).yv),([130,134]));
(tw)(((anB).yv),([130,134]),(anS));
}
if(((rt)(((anH).abC),([9]),(1)))!==(0)){
(anZ)=(new yX());
(aob)=(new QL());
(yu)((aob),(2060),((anB).ql));
((aob).aoc)=({L:0,H:null,T:null,P:null});
(aoe)=(new yC());
(yu)((aoe),(67585),((anB).ql));
((aoe).yF)=(0x0000000000000000);
(aog)=(new xW());
(xM)((aog),(1026),((anB).ql));
((aog).xX)=(0);
((aoe).yI)=(aog);
(eN)(((aob).aoc),([130,134]),(aoe));
((anZ).zc)=((zE)((aob),(false)));
((anZ).yY)=(false);
((anZ).yZ)=(false);
if((((anB).yv).L)===(1)){
(eN)(((anB).yv),([130,134]),(anZ));
}
else{
if(!((((anB).yv).L)>=(2))){throw 0xE9170000;}
(qr)(((anB).yv),([130,134]));
(r8)(((anB).yv),([130,134]));
(tw)(((anB).yv),([130,134]),(anZ));
}
}
}
else{
if(((anH).qc)!==(66562)){
(D)((131124),((anB).ql),(null));
return null;
}
(anH)=(((anB).yy).yI);
}
((anB).yI)=((anH).A4);
if((((anB).yv).L)!==(((anH).A9).L)){
(D)((131125),((anB).ql),([((v)((((anH).A9).L),([0]))),((v)((((anB).yv).L),([0]))),((aop)((anH)))]));
return null;
}
(aor)=(0);
(aos)=((anB).yv);
(aot)=((anH).A9);
(qr)((aos),([130,134]));
(qr)((aot),([130,134]));
while(!((qt)((aos),([130,134])))){
(aov)=((qv)((aos),([130,134])));
(aow)=((qv)((aot),([130,134])));
if((aov).yZ){
((((aov).zc).qz).s4)=((aow).AI);
}
((aov).zc)=((zE)(((aov).zc),(false)));
if(((aov).zc)!==(null)){
if((((aov).yY)&&(!((aov).yZ)))&&((((aov).zc).yE)===(1))){
(D)((131126),((anB).ql),([((v)(((aor)+(1)),([0])))]));
return null;
}
if((((aov).yY)!==((aow).AK))||(!((Pm)((((aov).zc).yI),((aow).AI),(false))))){
(D)((131127),((anB).ql),([((v)(((aor)+(1)),([0]))),({S:(((aow).AK)?({S:"&"}):({S:""})).S+((aop)(((aow).AI))).S}),({S:(((aov).yY)?({S:"&"}):({S:""})).S+((aop)((((aov).zc).yI))).S})]));
return null;
}
if(((((aov).zc).yI).qc)===(1028)){
((aov).zc)=((Pp)(((aov).zc),((aow).AI)));
}
}
(r8)((aos),([130,134]));
(r8)((aot),([130,134]));
(aor)=((aor)+(1));
}
((anB).yE)=(1);
return anB;
}
// rebuildExprArray
function Q1(ao8 /*ast*/){
if(((ao8).zo)!==(null)){
return (ao8).zo;
}
((ao8).zo)=(ao8);
((ao8).aoB)=((zE)(((ao8).aoB),(false)));
if(((ao8).aoB)===(null)){
return null;
}
if(((((ao8).aoB).yI).qc)!==(66561)){
(D)((131128),((ao8).ql),(null));
return null;
}
((ao8).aoG)=((zE)(((ao8).aoG),(false)));
if(((ao8).aoG)===(null)){
return null;
}
if(!((s3)((((ao8).aoG).yI)))){
(D)((131129),(((ao8).aoG).ql),(null));
return null;
}
((ao8).yI)=((((ao8).aoB).yI).Aw);
((ao8).yE)=(3);
return ao8;
}
// rebuildExprDot
function Q4(aoL /*ast*/){
let aoS=false; // found
let aoT=null; // ptr
let aoV=null; // items
let aoX=null; // item
let apc=null; // type
let ape=null; // items2
let apg=null; // arg
let aph=null; // arg2
let apo=null; // varType
let apr=null; // member
let apx=null; // expr
let ap1=null; // func_
let ap6=null; // argType
let apR=null; // type
let apT=null; // item
let apV=null; // item
let apX=null; // item
let aqo=null; // type
let aqt=null; // type
let aqy=null; // type
let apt=false;
let apv=null;
if(((aoL).zo)!==(null)){
return (aoL).zo;
}
((aoL).zo)=(aoL);
((aoL).anT)=((zE)(((aoL).anT),(false)));
if(((aoL).anT)===(null)){
return null;
}
if((RR)((((aoL).anT).yI))){
(aoS)=(false);
(aoT)=((((aoL).anT).yI).qz);
while((aoT)!==(null)){
(aoV)=((aoT).tg);
(qr)((aoV),([130,134]));
while(!((qt)((aoV),([130,134])))){
(aoX)=((qv)((aoV),([130,134])));
if(((((aoX).tS).qc)===(2))&&(((aoL).aoZ).S===((((aoX).tS).tX).qX).S)){
((aoL).yI)=((((aoX).tS).tX).s4);
((aoL).yE)=(3);
(aoS)=(true);
}
else if(((((aoX).tS).qc)===(256))&&(((aoL).aoZ).S===(((aoX).tS).qX).S)){
(apc)=(new A2());
(xM)((apc),(66562),((aoL).ql));
((apc).abC)=(((aoX).tS).qi);
((apc).abD)=(((aoX).tS).qj);
((apc).A9)=({L:0,H:null,T:null,P:null});
(ape)=(((aoX).tS).qg);
(qr)((ape),([130,134]));
while(!((qt)((ape),([130,134])))){
(apg)=((qv)((ape),([130,134])));
(aph)=(new AC());
((aph).AI)=((apg).s4);
((aph).AK)=((apg).sJ);
(eN)(((apc).A9),([130,134]),(aph));
(r8)((ape),([130,134]));
}
((apc).A4)=(((aoX).tS).qh);
((aoL).yI)=(apc);
((aoL).yE)=(1);
(aoS)=(true);
}
if(aoS){
if((!((aoX).N4))&&(((((aoL).anT).q0)===(null))||((((aoL).anT).q0).S!==({S:"me"}).S))){
(D)((131131),((aoL).ql),([((aoL).aoZ)]));
return null;
}
((aoL).apm)=(aoX);
return aoL;
}
(r8)((aoV),([130,134]));
}
(aoT)=((aoT).qz);
}
}
else{
(apo)=(((aoL).anT).yI);
if(((apo).qc)===(1028)){
if(!((((aoL).anT).qc)===(67587))){throw 0xE9170000;}
(D)((131116),((aoL).ql),([(((aoL).anT).aig)]));
return null;
}
(apr)=((aoL).aoZ);
if((apt=(apu)((apv={$:(apr)},apv),(apo)),(apr)=apv.$,apt)){
(apx)=((yl)(({S:"kuin"}),({S:({S:"_"}).S+(apr).S}),(true)));
if((apx)===(null)){
if(!(false)){throw 0xE9170000;}
return null;
}
(ap1)=((apx).yI);
if(((rt)(((ap1).abC),([9]),(1)))!==(0)){
if(!((((ap1).A9).L)>=(2))){throw 0xE9170000;}
(qr)(((ap1).A9),([130,134]));
if(!((s3)((((qv)(((ap1).A9),([130,134]))).AI)))){throw 0xE9170000;}
(r8)(((ap1).A9),([130,134]));
(ap6)=(((qv)(((ap1).A9),([130,134]))).AI);
if(!((((ap6).qc)===(66561))&&((s3)(((ap6).Aw))))){throw 0xE9170000;}
(qr)(((ap1).A9),([130,134]));
(((qv)(((ap1).A9),([130,134]))).AI)=(apo);
}
if(((rt)(((ap1).abC),([9]),(2)))!==(0)){
if(!(((rt)(((ap1).abC),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(8)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(32)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(256)))===(0))){throw 0xE9170000;}
if(!((((ap1).A9).L)>=(3))){throw 0xE9170000;}
(qr)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
if(!((s3)((((qv)(((ap1).A9),([130,134]))).AI)))){throw 0xE9170000;}
(qr)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
(((qv)(((ap1).A9),([130,134]))).AI)=(apo);
}
if(((rt)(((ap1).abC),([9]),(8)))!==(0)){
if(!(((rt)(((ap1).abC),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(2)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(32)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(256)))===(0))){throw 0xE9170000;}
if(!((((ap1).A9).L)>=(3))){throw 0xE9170000;}
(qr)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
if(!((s3)((((qv)(((ap1).A9),([130,134]))).AI)))){throw 0xE9170000;}
(qr)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
if(((apo).qc)===(66561)){
(((qv)(((ap1).A9),([130,134]))).AI)=((apo).Aw);
}
else if(((apo).qc)===(66563)){
(((qv)(((ap1).A9),([130,134]))).AI)=((apo).AU);
}
else{
if(!(((apo).qc)===(66564))){throw 0xE9170000;}
(((qv)(((ap1).A9),([130,134]))).AI)=((apo).Bb);
}
}
if(((rt)(((ap1).abC),([9]),(32)))!==(0)){
if(!(((rt)(((ap1).abC),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(2)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(8)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(256)))===(0))){throw 0xE9170000;}
if(!((((ap1).A9).L)>=(4))){throw 0xE9170000;}
(qr)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
if(!((s3)((((qv)(((ap1).A9),([130,134]))).AI)))){throw 0xE9170000;}
(r8)(((ap1).A9),([130,134]));
if(!((s3)((((qv)(((ap1).A9),([130,134]))).AI)))){throw 0xE9170000;}
if(!(((apo).qc)===(66564))){throw 0xE9170000;}
(qr)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
(((qv)(((ap1).A9),([130,134]))).AI)=((apo).Bb);
(r8)(((ap1).A9),([130,134]));
(((qv)(((ap1).A9),([130,134]))).AI)=((apo).Bc);
}
if(((rt)(((ap1).abC),([9]),(256)))!==(0)){
if(!(((rt)(((ap1).abC),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(2)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(8)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(32)))===(0))){throw 0xE9170000;}
if(!((((ap1).A9).L)>=(3))){throw 0xE9170000;}
(qr)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
if(!((s3)((((qv)(((ap1).A9),([130,134]))).AI)))){throw 0xE9170000;}
if(!(((apo).qc)===(66564))){throw 0xE9170000;}
(apR)=(new A2());
(xM)((apR),(66562),((aoL).ql));
((apR).abC)=(0);
((apR).abD)=({L:0,H:null,T:null,P:null});
((apR).A9)=({L:0,H:null,T:null,P:null});
(apT)=(new AC());
((apT).AI)=((apo).Bb);
((apT).AK)=(false);
(eN)(((apR).A9),([130,134]),(apT));
(apV)=(new AC());
((apV).AI)=((apo).Bc);
((apV).AK)=(false);
(eN)(((apR).A9),([130,134]),(apV));
(apX)=(new AC());
(qr)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
((apX).AI)=(((qv)(((ap1).A9),([130,134]))).AI);
((apX).AK)=(false);
(eN)(((apR).A9),([130,134]),(apX));
((apR).A4)=((ap1).A4);
(qr)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
(r8)(((ap1).A9),([130,134]));
(((qv)(((ap1).A9),([130,134]))).AI)=(apR);
}
if(((rt)(((ap1).abC),([9]),(4)))!==(0)){
if(!(((rt)(((ap1).abC),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(16)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(64)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(512)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(1024)))===(0))){throw 0xE9170000;}
if(!((s3)(((ap1).A4)))){throw 0xE9170000;}
((ap1).A4)=(apo);
}
if(((rt)(((ap1).abC),([9]),(16)))!==(0)){
if(!(((rt)(((ap1).abC),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(4)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(64)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(512)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(1024)))===(0))){throw 0xE9170000;}
if(!((s3)(((ap1).A4)))){throw 0xE9170000;}
if(((apo).qc)===(66561)){
((ap1).A4)=((apo).Aw);
}
else if(((apo).qc)===(66563)){
((ap1).A4)=((apo).AU);
}
else{
if(!(((apo).qc)===(66564))){throw 0xE9170000;}
((ap1).A4)=((apo).Bc);
}
}
if(((rt)(((ap1).abC),([9]),(64)))!==(0)){
if(!(((rt)(((ap1).abC),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(4)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(16)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(512)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(1024)))===(0))){throw 0xE9170000;}
if(!((s3)(((ap1).A4)))){throw 0xE9170000;}
if(!(((apo).qc)===(66563))){throw 0xE9170000;}
if(!(((apo).AS)===(0))){throw 0xE9170000;}
(aqo)=(new Au());
(xM)((aqo),(66561),((aoL).ql));
((aqo).Aw)=((apo).AU);
((ap1).A4)=(aqo);
}
if(((rt)(((ap1).abC),([9]),(512)))!==(0)){
if(!(((rt)(((ap1).abC),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(4)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(16)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(64)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(1024)))===(0))){throw 0xE9170000;}
if(!((s3)(((ap1).A4)))){throw 0xE9170000;}
if(!(((apo).qc)===(66564))){throw 0xE9170000;}
(aqt)=(new Au());
(xM)((aqt),(66561),((aoL).ql));
((aqt).Aw)=((apo).Bb);
((ap1).A4)=(aqt);
}
if(((rt)(((ap1).abC),([9]),(1024)))!==(0)){
if(!(((rt)(((ap1).abC),([9]),(1)))!==(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(4)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(16)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(64)))===(0))){throw 0xE9170000;}
if(!(((rt)(((ap1).abC),([9]),(512)))===(0))){throw 0xE9170000;}
if(!((s3)(((ap1).A4)))){throw 0xE9170000;}
if(!(((apo).qc)===(66564))){throw 0xE9170000;}
(aqy)=(new Au());
(xM)((aqy),(66561),((aoL).ql));
((aqy).Aw)=((apo).Bc);
((ap1).A4)=(aqy);
}
((aoL).qz)=(apx);
((aoL).yI)=((apx).yI);
((aoL).yE)=(1);
return aoL;
}
}
(D)((131130),((aoL).ql),([((aoL).aoZ)]));
return null;
}
// rebuildExprValue
function Q7(aqz /*ast*/){
if(((aqz).zo)!==(null)){
return (aqz).zo;
}
((aqz).zo)=(aqz);
if(!(((aqz).qc)===(67584))){throw 0xE9170000;}
((aqz).yE)=(1);
return aqz;
}
// rebuildExprValuePrim
function Q9(aq2 /*ast*/){
if(((aq2).zo)!==(null)){
return (aq2).zo;
}
((aq2).zo)=(aq2);
((aq2).yE)=(1);
return aq2;
}
// rebuildExprValueStr
function QB(aq5 /*ast*/){
if(((aq5).zo)!==(null)){
return (aq5).zo;
}
((aq5).zo)=(aq5);
((aq5).yE)=(1);
return aq5;
}
// rebuildExprValueEnumElement
function QE(aq8 /*ast*/){
if(((aq8).zo)!==(null)){
return (aq8).zo;
}
((aq8).zo)=(aq8);
((aq8).yE)=(1);
return aq8;
}
// rebuildExprValueFloat
function QH(aqB /*ast*/){
if(((aqB).zo)!==(null)){
return (aqB).zo;
}
((aqB).zo)=(aqB);
((aqB).yE)=(1);
return aqB;
}
// rebuildExprValueArray
function QK(aqE /*ast*/){
let aqI=false; // nullSet
let aqJ=false; // enumSet
let aqK=null; // items
let aqM=null; // data
let aqQ=null; // dataType
let arf=null; // type
let aro=null; // items
let arq=null; // item
let arw=false; // isConst
let ary=null; // items
let ar5=null; // ast2
let ar6=null; // s
let ar7=0; // idx
let ar8=null; // items
let arA=0;
let arB=0;
if(((aqE).zo)!==(null)){
return (aqE).zo;
}
((aqE).zo)=(aqE);
if(!(((aqE).yI)===(null))){throw 0xE9170000;}
(aqI)=(false);
(aqJ)=(false);
(aqK)=((aqE).aoc);
(qr)((aqK),([130,134]));
while(!((qt)((aqK),([130,134])))){
(aqM)=((qv)((aqK),([130,134])));
(aqM)=((zE)((aqM),(false)));
if((aqM)===(null)){
return null;
}
(aqQ)=((aqM).yI);
if(((aqE).yI)===(null)){
if(((aqQ).qc)===(1027)){
if(aqJ){
(D)((131132),((aqE).ql),(null));
return null;
}
(aqI)=(true);
}
else if(((aqQ).qc)===(1028)){
if(aqI){
(D)((131133),((aqE).ql),(null));
return null;
}
(aqJ)=(true);
}
else{
if((aqI)&&(!((EI)((aqQ))))){
(D)((131133),((aqE).ql),(null));
return null;
}
if((aqJ)&&(!((EN)((aqQ))))){
(D)((131132),((aqE).ql),(null));
return null;
}
(arf)=(new Au());
(xM)((arf),(66561),((aqQ).ql));
((arf).Aw)=(aqQ);
((aqE).yI)=(arf);
}
}
else if(!((Pm)((((aqE).yI).Aw),(aqQ),(false)))){
(D)((131132),((aqE).ql),(null));
return null;
}
(tw)((aqK),([130,134]),(aqM));
(tz)((aqK),([130,134]));
}
if(((aqE).yI)===(null)){
if(aqJ){
(D)((131134),((aqE).ql),(null));
return null;
}
else{
(D)((131135),((aqE).ql),(null));
return null;
}
}
if((EN)((((aqE).yI).Aw))){
(aro)=((aqE).aoc);
(qr)((aro),([130,134]));
while(!((qt)((aro),([130,134])))){
(arq)=((qv)((aro),([130,134])));
if((((arq).yI).qc)===(1028)){
(arq)=((Pp)((arq),(((aqE).yI).Aw)));
(tw)((aro),([130,134]),(arq));
(tz)((aro),([130,134]));
}
else{
(r8)((aro),([130,134]));
}
}
}
if((XE)(((aqE).yI))){
(arw)=(true);
(ary)=((aqE).aoc);
(qr)((ary),([130,134]));
ar0:
while(!((qt)((ary),([130,134])))){
if((((qv)((ary),([130,134]))).qc)!==(67584)){
(arw)=(false);
break ar0;
}
(r8)((ary),([130,134]));
}
if(arw){
(ar5)=(new QC());
(yu)((ar5),(67586),((aqE).ql));
((ar5).yI)=((aqE).yI);
(ar6)=({S:"\0".repeat(((aqE).aoc).L)});
(ar7)=(0);
(ar8)=((aqE).aoc);
(qr)((ar8),([130,134]));
while(!((qt)((ar8),([130,134])))){
(ar6).S=(arA=(ar7),(ar6).S.slice(0,arA)+String.fromCharCode(((qv)((ar8),([130,134]))).yF)+(ar6).S.slice(arA+1));
(r8)((ar8),([130,134]));
(ar7)=((ar7)+(1));
}
((ar5).aiK)=(ar6);
(ar5)=((QB)((ar5)));
((aqE).zo)=(aqE);
return (aqE).zo;
}
}
((aqE).yE)=(1);
return aqE;
}
// rebuildVar
function Rc(arD /*ast*/){
if(((arD).zo)!==(null)){
return;
}
((arD).zo)=(arD);
(zs)(((arD).tX));
}
// rebuildIf
function Rz(arG /*ast*/,arH /*retType*/,arI /*parentFunc*/){
let arO=null; // items
let arQ=null; // elIf
let arX=null; // stats
let ase=null; // items
let ash=null; // elIf
let asq=null; // block_
if(((arG).zo)!==(null)){
return (arG).zo;
}
((arG).zo)=(arG);
((arG).SG)=((zE)(((arG).SG),(false)));
if((((arG).SG)!==(null))&&(!((ahj)((((arG).SG).yI))))){
(D)((131094),(((arG).SG).ql),(null));
}
((arG).SI)=((RB)(((arG).SI),(arH),(arI)));
(arO)=((arG).SO);
(qr)((arO),([130,134]));
while(!((qt)((arO),([130,134])))){
(arQ)=((qv)((arO),([130,134])));
((arQ).SS)=((zE)(((arQ).SS),(false)));
if((((arQ).SS)!==(null))&&(!((ahj)((((arQ).SS).yI))))){
(D)((131095),(((arQ).SS).ql),(null));
}
((arQ).ST)=((RB)(((arQ).ST),(arH),(arI)));
(r8)((arO),([130,134]));
}
if(((arG).SV)!==(null)){
((arG).SV)=((RB)(((arG).SV),(arH),(arI)));
}
if(((arG).SG)!==(null)){
(arX)=(null);
if((((arG).SG).qc)!==(67585)){
return arG;
}
if((((arG).SG).yF)!==(0x0000000000000000)){
(arX)=((arG).SI);
}
if((arX)!==(null)){
(ase)=((arG).SO);
(qr)((ase),([130,134]));
asg:
while(!((qt)((ase),([130,134])))){
(ash)=((qv)((ase),([130,134])));
if((((ash).SS).qc)!==(67585)){
return arG;
}
if((((ash).SS).yF)!==(0x0000000000000000)){
(arX)=((ash).ST);
break asg;
}
(r8)((ase),([130,134]));
}
if((arX)===(null)){
if(((arG).SV)===(null)){
(asq)=(new yc());
(xM)((asq),(66052),((arG).ql));
((asq).qX)=({S:"$"});
((asq).yd)=({L:0,H:null,T:null,P:null});
(arX)=(asq);
}
else{
(arX)=((arG).SV);
}
}
}
((arG).SG)=(null);
((arG).SI)=(arX);
}
return arG;
}
// rebuildSwitch
function R1(ass /*ast*/,ast /*retType*/,asu /*parentFunc*/){
let as2=null; // items
let as4=null; // case_
let as5=null; // items2
let as7=null; // exprs
if(((ass).zo)!==(null)){
return (ass).zo;
}
((ass).zo)=(ass);
((ass).Tj)=((zE)(((ass).Tj),(false)));
if(((ass).Tj)!==(null)){
if(!((ahZ)((((ass).Tj).yI),(true)))){
(D)((131096),(((ass).Tj).ql),(null));
}
(((ass).xZ).s4)=(((ass).Tj).yI);
}
(as2)=((ass).Tn);
(qr)((as2),([130,134]));
while(!((qt)((as2),([130,134])))){
(as4)=((qv)((as2),([130,134])));
(as5)=((as4).Ts);
(qr)((as5),([130,134]));
while(!((qt)((as5),([130,134])))){
(as7)=((qv)((as5),([130,134])));
((as7).yJ)=((zE)(((as7).yJ),(false)));
if((((ass).Tj)!==(null))&&(((as7).yJ)!==(null))){
if(!((Pm)((((ass).Tj).yI),(((as7).yJ).yI),(false)))){
(D)((131097),(((as7).yJ).ql),(null));
}
else if(((((as7).yJ).yI).qc)===(1028)){
((as7).yJ)=((Pp)(((as7).yJ),(((ass).Tj).yI)));
}
}
if(((as7).yO)!==(null)){
((as7).yO)=((zE)(((as7).yO),(false)));
if((((ass).Tj)!==(null))&&(((as7).yO)!==(null))){
if(!((Pm)((((ass).Tj).yI),(((as7).yO).yI),(false)))){
(D)((131097),(((as7).yO).ql),(null));
}
else if(((((as7).yO).yI).qc)===(1028)){
((as7).yO)=((Pp)(((as7).yO),(((ass).Tj).yI)));
}
}
}
(r8)((as5),([130,134]));
}
((as4).T6)=((RB)(((as4).T6),(ast),(asu)));
(r8)((as2),([130,134]));
}
if(((ass).T8)!==(null)){
((ass).T8)=((RB)(((ass).T8),(ast),(asu)));
}
return ass;
}
// rebuildWhile
function R3(asM /*ast*/,asN /*retType*/,asO /*parentFunc*/){
if(((asM).zo)!==(null)){
return (asM).zo;
}
((asM).zo)=(asM);
if(((asM).Uf)!==(null)){
((asM).Uf)=((zE)(((asM).Uf),(false)));
if((((asM).Uf)!==(null))&&(!((ahj)((((asM).Uf).yI))))){
(D)((131098),(((asM).Uf).ql),(null));
}
}
((asM).Uh)=((zw)(((asM).Uh),(asN),(asO)));
return asM;
}
// rebuildFor
function R5(asV /*ast*/,asW /*retType*/,asX /*parentFunc*/){
if(((asV).zo)!==(null)){
return (asV).zo;
}
((asV).zo)=(asV);
((asV).U7)=((zE)(((asV).U7),(false)));
if(((asV).U7)!==(null)){
if(!((s3)((((asV).U7).yI)))){
(D)((131099),(((asV).U7).ql),(null));
}
(((asV).xZ).s4)=(((asV).U7).yI);
}
((asV).U6)=((zE)(((asV).U6),(false)));
if((((asV).U6)!==(null))&&(!((s3)((((asV).U6).yI))))){
(D)((131100),(((asV).U6).ql),(null));
}
((asV).U8)=((zE)(((asV).U8),(false)));
if(((asV).U8)!==(null)){
if(!((s3)((((asV).U8).yI)))){
(D)((131101),(((asV).U8).ql),(null));
}
if((((asV).U8).qc)!==(67585)){
(D)((131102),(((asV).U8).ql),(null));
}
if((((asV).U8).yF)===(0x0000000000000000)){
(D)((131103),(((asV).U8).ql),(null));
}
}
((asV).UG)=((zw)(((asV).UG),(asW),(asX)));
return asV;
}
// rebuildTry
function R7(ato /*ast*/,atp /*retType*/,atq /*parentFunc*/){
let atv=null; // items
let atx=null; // catch_
let aty=null; // items2
let at0=null; // exprs
if(((ato).zo)!==(null)){
return (ato).zo;
}
((ato).zo)=(ato);
(zs)(((ato).xZ));
((ato).ye)=((RB)(((ato).ye),(atp),(atq)));
if((((ato).yf).L)!==(0)){
(atv)=((ato).yf);
(qr)((atv),([130,134]));
while(!((qt)((atv),([130,134])))){
(atx)=((qv)((atv),([130,134])));
(aty)=((atx).y3);
(qr)((aty),([130,134]));
while(!((qt)((aty),([130,134])))){
(at0)=((qv)((aty),([130,134])));
((at0).yJ)=((zE)(((at0).yJ),(false)));
if((((at0).yJ)!==(null))&&((!((s3)((((at0).yJ).yI))))||((((at0).yJ).qc)!==(67585)))){
(D)((131104),(((at0).yJ).ql),(null));
}
if(((at0).yO)!==(null)){
((at0).yO)=((zE)(((at0).yO),(false)));
if((((at0).yO)!==(null))&&((!((s3)((((at0).yO).yI))))||((((at0).yO).qc)!==(67585)))){
(D)((131104),(((at0).yO).ql),(null));
}
}
(r8)((aty),([130,134]));
}
((atx).y6)=((RB)(((atx).y6),(atp),(atq)));
(r8)((atv),([130,134]));
}
}
if(((ato).yi)!==(null)){
((ato).yi)=((RB)(((ato).yi),(atp),(atq)));
}
return ato;
}
// rebuildThrow
function R9(at9 /*ast*/){
if(((at9).zo)!==(null)){
return (at9).zo;
}
((at9).zo)=(at9);
((at9).Vw)=((zE)(((at9).Vw),(false)));
if((((at9).Vw)!==(null))&&(!((s3)((((at9).Vw).yI))))){
(D)((131105),(((at9).Vw).ql),(null));
}
return at9;
}
// rebuildBlock
function RB(atE /*ast*/,atF /*retType*/,atG /*parentFunc*/){
if(((atE).zo)!==(null)){
return (atE).zo;
}
((atE).zo)=(atE);
((atE).yd)=((zw)(((atE).yd),(atF),(atG)));
return atE;
}
// rebuildRet
function RD(atJ /*ast*/,atK /*retType*/){
if(((atJ).zo)!==(null)){
return (atJ).zo;
}
((atJ).zo)=(atJ);
if(((atJ).V5)===(null)){
if((atK)!==(null)){
(D)((131106),((atJ).ql),(null));
}
}
else{
((atJ).V5)=((zE)(((atJ).V5),(false)));
if(((atJ).V5)!==(null)){
if(((atK)===(null))||(!((Pm)((((atJ).V5).yI),(atK),(false))))){
(D)((131107),((atJ).ql),(null));
}
else if(((((atJ).V5).yI).qc)===(1028)){
((atJ).V5)=((Pp)(((atJ).V5),(atK)));
}
}
}
return atJ;
}
// rebuildDo
function RF(atX /*ast*/){
let auc=null; // expr
let aud=0; // kind
let auf=0;
let aup=null; // block_
let aur=null; // lhs
let auw=null; // lhs2
let auz=null; // lhs2
let au0=null; // exprAssign
let au2=null; // exprOne
if(((atX).zo)!==(null)){
return (atX).zo;
}
((atX).zo)=(atX);
if((((atX).yz)!==(null))&&((((atX).yz).qc)===(2050))){
(auc)=((atX).yz);
(aud)=(0);
switch((auc).zJ){
case 1:
(aud)=(19);
break;
case 2:
(aud)=(20);
break;
case 3:
(aud)=(21);
break;
case 4:
(aud)=(22);
break;
case 5:
(aud)=(23);
break;
case 6:
(aud)=(24);
break;
case 7:
(aud)=(18);
break;
}
if((aud)!==(0)){
(aup)=(new yc());
(xM)((aup),(66052),((atX).ql));
((aup).zo)=(aup);
((aup).qX)=({S:"$"});
((aup).xZ)=(null);
((aup).yd)=({L:0,H:null,T:null,P:null});
(aur)=((zE)(((auc).zM),(false)));
if((aur)===(null)){
return null;
}
if(((aur).qc)===(2059)){
(auw)=(aur);
((auw).anT)=((aux)(((aup).yd),((auw).anT),((atX).ql)));
}
else if(((aur).qc)===(2058)){
(auz)=(aur);
((auz).aoB)=((aux)(((aup).yd),((auz).aoB),((atX).ql)));
((auz).aoG)=((aux)(((aup).yd),((auz).aoG),((atX).ql)));
}
(au0)=(new zI());
(yu)((au0),(2050),((atX).ql));
((au0).zJ)=(0);
((au0).zM)=(aur);
(au2)=(new zI());
(yu)((au2),(2050),((atX).ql));
((au2).zJ)=(aud);
((au2).zM)=(aur);
((au2).zN)=((auc).zN);
((au0).zN)=(au2);
((atX).yz)=((zE)((au0),(true)));
(eN)(((aup).yd),([130,134]),(atX));
return aup;
}
}
((atX).yz)=((zE)(((atX).yz),(true)));
if(((atX).yz)===(null)){
return null;
}
if(!((((((atX).yz).qc)===(2050))&&(((((atX).yz).zJ)===(0))||((((atX).yz).zJ)===(25))))||((((atX).yz).qc)===(2057)))){
(D)((131108),(((atX).yz).ql),(null));
}
return atX;
}
// rebuildBreak
function RH(au7 /*ast*/,au8 /*retType*/,au9 /*parentFunc*/){
if(((au7).zo)!==(null)){
return (au7).zo;
}
((au7).zo)=(au7);
if((((au7).qz)===(null))||(((rt)((((au7).qz).qc),([9]),(66048)))!==(66048))){
(D)((131109),((au7).ql),([({S:"break"})]));
return null;
}
((au7).qz)=((zO)(((au7).qz),(au8),(au9)));
return au7;
}
// rebuildSkip
function RJ(auE /*ast*/,auF /*retType*/,auG /*parentFunc*/){
if(((auE).zo)!==(null)){
return (auE).zo;
}
((auE).zo)=(auE);
if((((auE).qz)===(null))||(((rt)((((auE).qz).qc),([9]),(66048)))!==(66048))){
(D)((131109),((auE).ql),([({S:"skip"})]));
return null;
}
((auE).qz)=((zO)(((auE).qz),(auF),(auG)));
return auE;
}
// rebuildAssert
function RL(auL /*ast*/){
if(((auL).zo)!==(null)){
return (auL).zo;
}
if(aW){
return null;
}
((auL).zo)=(auL);
((auL).VM)=((zE)(((auL).VM),(false)));
if((((auL).VM)!==(null))&&(!((ahj)((((auL).VM).yI))))){
(D)((131110),(((auL).VM).ql),(null));
}
return auL;
}
// isClass
function RR(auS /*type*/){
return (((auS).qc)===(66565))&&((((auS).qz).qc)===(5));
}
// _fill
function Si(auT /*me_*/,auU /*type*/,auV /*value*/){
if(auU[0]===129&&auU[1]===2)
auT.S=String.fromCharCode(auV).repeat(auT.S.length);
else
auT.fill(auV);
}
// _offset
function Sq(auW /*me_*/,auX /*n*/){
return (auW)+(auX);
}
// buildExpr
function SL(auY /*ast*/){
let ava=0;
switch((auY).qc){
case 2049:
(avc)((auY));
break;
case 2050:
(ave)((auY));
break;
case 2051:
(avg)((auY));
break;
case 2052:
(avi)((auY));
break;
case 2053:
(avk)((auY));
break;
case 2054:
(avm)((auY));
break;
case 2055:
(avo)((auY));
break;
case 2056:
(avq)((auY));
break;
case 2057:
(avs)((auY));
break;
case 2058:
(avu)((auY));
break;
case 2059:
(avw)((auY));
break;
case 67584:
(avy)((auY));
break;
case 67585:
(av0)((auY));
break;
case 67586:
(av2)((auY));
break;
case 67588:
(av4)((auY));
break;
case 2060:
(av6)((auY));
break;
case 2062:
(av8)((auY));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// isChar
function Tk(avA /*type*/){
return (((avA).qc)===(1026))&&(((avA).xX)===(2));
}
// addTmpVar
function U5(avB /*type*/){
let avC=null; // tmpVar
(avC)=(new t2());
((avC).t4)=((Ad)());
((avC).t3)=(avB);
(eN)((R),([130,134]),(avC));
return (avC).t4;
}
// buildExpr
function WI(avD /*ast*/){
let avF=0;
switch((avD).qc){
case 2049:
(avH)((avD));
break;
case 2050:
(avJ)((avD));
break;
case 2051:
(avL)((avD));
break;
case 2052:
(avN)((avD));
break;
case 2053:
(avP)((avD));
break;
case 2054:
(avR)((avD));
break;
case 2055:
(avT)((avD));
break;
case 2056:
(avV)((avD));
break;
case 2057:
(avX)((avD));
break;
case 2058:
(avZ)((avD));
break;
case 2059:
(awb)((avD));
break;
case 67584:
(awd)((avD));
break;
case 67585:
(awf)((avD));
break;
case 67586:
(awh)((avD));
break;
case 67588:
(awj)((avD));
break;
case 2060:
(awl)((avD));
break;
case 2062:
(awn)((avD));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// isStr
function XE(awp /*type*/){
let aws=null; // itemType
if(((awp).qc)===(66561)){
(aws)=((awp).Aw);
if((((aws).qc)===(1026))&&(((aws).xX)===(2))){
return true;
}
}
return false;
}
// addTmpVar
function Yf(awv /*type*/){
let aww=null; // tmpVar
(aww)=(new v6());
((aww).v7)=((FR)());
((aww).v8)=(awv);
(eN)((an),([130,134]),(aww));
return (aww).v7;
}
// _peekStack
function Zr(awx /*me_*/,awy /*type*/){
return awx[awx.length-1];
}
// isReserved
function aao(awz /*name*/){
let aw6=0;
let aw7=0;
if((ac)===(null)){
(ac)=([({S:"alias"}),({S:"assert"}),({S:"bit16"}),({S:"bit32"}),({S:"bit64"}),({S:"bit8"}),({S:"block"}),({S:"bool"}),({S:"break"}),({S:"case"}),({S:"catch"}),({S:"char"}),({S:"class"}),({S:"const"}),({S:"dbg"}),({S:"default"}),({S:"dict"}),({S:"do"}),({S:"elif"}),({S:"else"}),({S:"end"}),({S:"enum"}),({S:"env"}),({S:"false"}),({S:"finally"}),({S:"float"}),({S:"for"}),({S:"func"}),({S:"if"}),({S:"include"}),({S:"inf"}),({S:"int"}),({S:"list"}),({S:"me"}),({S:"null"}),({S:"queue"}),({S:"ret"}),({S:"skip"}),({S:"stack"}),({S:"super"}),({S:"switch"}),({S:"throw"}),({S:"to"}),({S:"true"}),({S:"try"}),({S:"var"}),({S:"while"})]);
aw5:
for(aw6=(0),aw7=(((ac).length)-(2));aw6<=aw7;aw6+=(1)){
if(!(((ac)[aw6]).S<((ac)[(aw6)+(1)]).S)){throw 0xE9170000;}
}
}
return ((aw8)((ac),([129,129,2]),(awz)))!==(-1);
}
// parseStatEnd
function ac1(aw9 /*row*/,awA /*col*/,awB /*block_*/){
let awC=null; // ast
let awD=null; // id
let awE=false; // err
let awG=null;
(awC)=(new xR());
(wE)((awC),(513),((wF)((ag),(aw9),(awA))),(null),(false));
(awD)=((wX)((true),(false)));
(awE)=(false);
(M2)((0x000A),(true));
awG=awD;
if(awG.S===({S:"func"}).S){
if(((awB).qc)!==(256)){
(awE)=(true);
}
}
else if(awG.S===({S:"if"}).S){
if(((awB).qc)!==(66049)){
(awE)=(true);
}
}
else if(awG.S===({S:"switch"}).S){
if(((awB).qc)!==(66050)){
(awE)=(true);
}
}
else if(awG.S===({S:"while"}).S){
if(((awB).qc)!==(16843265)){
(awE)=(true);
}
}
else if(awG.S===({S:"for"}).S){
if(((awB).qc)!==(16843266)){
(awE)=(true);
}
}
else if(awG.S===({S:"try"}).S){
if(((awB).qc)!==(66051)){
(awE)=(true);
}
}
else if(awG.S===({S:"block"}).S){
if(((awB).qc)!==(66052)){
(awE)=(true);
}
}
else{(D)((65561),((wF)((ag),(aw9),(awA))),([(awD)]));
}
if(awE){
(D)((65562),((wF)((ag),(aw9),(awA))),([(awD)]));
}
return awC;
}
// parseStatFunc
function ac3(){
let axf=null; // ast
(axf)=(new axg());
(wE)((axf),(514),(null),(null),(false));
((axf).axh)=((xc)((null),(false)));
return axf;
}
// parseStatVar
function ac5(){
let axi=null; // ast
(axi)=(new Rb());
(wE)((axi),(515),(null),(null),(false));
((axi).Rd)=((xe)((3),(null)));
return axi;
}
// parseStatConst
function ac7(){
let axj=null; // ast
(axj)=(new axk());
(wE)((axj),(516),(null),(null),(false));
((axj).axl)=((xg)());
return axj;
}
// parseStatAlias
function ac9(){
let axm=null; // ast
(axm)=(new axn());
(wE)((axm),(517),(null),(null),(false));
((axm).axo)=((xj)());
return axm;
}
// parseStatClass
function acB(){
let axp=null; // ast
(axp)=(new axq());
(wE)((axp),(518),(null),(null),(false));
((axp).axr)=((xn)());
return axp;
}
// parseStatEnum
function acD(){
let axs=null; // ast
(axs)=(new axt());
(wE)((axs),(519),(null),(null),(false));
((axs).axu)=((xp)());
return axs;
}
// parseStatIf
function acF(){
let axv=null; // ast
let ax2=null; // stat
let ax4=0; // typeId
let ax6=null; // elIf
let axz=null;
let ax1=null;
let ax3=0;
let ax7=null;
let ax8=null;
let ax9=0;
let axB=null;
let axC=null;
let axD=0;
(axv)=(new Ef());
(wE)((axv),(66049),((Ld)()),(null),(false));
((axv).xZ)=(null);
((axv).SO)=({L:0,H:null,T:null,P:null});
((axv).SV)=(null);
(axw)((axv));
(axx)((axv));
((axv).SG)=((Os)());
(M2)((0x0029),(true));
(M2)((0x000A),(true));
((axv).SI)=((axz=(ax0)((ax1={$:(ax2)},ax1),(ax3={$:(ax4)},ax3),(66049),(axv)),(ax2)=ax1.$,(ax4)=ax3.$,axz));
while((ax4)===(520)){
(ax6)=(ax2);
((ax6).ST)=((ax7=(ax0)((ax8={$:(ax2)},ax8),(ax9={$:(ax4)},ax9),(520),(axv)),(ax2)=ax8.$,(ax4)=ax9.$,ax7));
(eN)(((axv).SO),([130,134]),(ax6));
}
while((ax4)===(521)){
((axv).SV)=((axB=(ax0)((axC={$:(ax2)},axC),(axD={$:(ax4)},axD),(521),(axv)),(ax2)=axC.$,(ax4)=axD.$,axB));
}
if(!((ax4)===(513))){throw 0xE9170000;}
(xz)((ah),([131,134]));
return axv;
}
// parseStatElIf
function acH(axE /*row*/,axF /*col*/,axG /*block_*/){
let axH=null; // ast
(axH)=(new SR());
(wE)((axH),(520),(null),(null),(false));
((axH).ST)=(null);
if(((axG).qc)!==(66049)){
(D)((65566),((wF)((ag),(axE),(axF))),([({S:"if"}),({S:"elif"})]));
(xs)(((xt)()));
return null;
}
(M2)((0x0028),(true));
((axH).SS)=((Os)());
(M2)((0x0029),(true));
(M2)((0x000A),(true));
return axH;
}
// parseStatElse
function acJ(axK /*row*/,axL /*col*/,axM /*block_*/){
let axN=null; // ast
(axN)=(new xR());
(wE)((axN),(521),(null),(null),(false));
if(((axM).qc)!==(66049)){
(D)((65566),((wF)((ag),(axK),(axL))),([({S:"if"}),({S:"else"})]));
(xs)(((xt)()));
return null;
}
(M2)((0x000A),(true));
return axN;
}
// parseStatSwitch
function acL(axQ /*row*/,axR /*col*/){
let axS=null; // ast
let axX=null; // stat
let ayd=0; // typeId
let ayh=null; // case_
let ayi=null;
let ayj=null;
let ayk=0;
let aym=null;
let ayn=null;
let ayo=0;
(axS)=(new Ei());
(wE)((axS),(66050),((Ld)()),(null),(false));
((axS).xZ)=((axT)(((axS).ql)));
((axS).Tn)=({L:0,H:null,T:null,P:null});
((axS).T8)=(null);
(axw)((axS));
(axx)((axS));
((axS).Tj)=((Os)());
(M2)((0x0029),(true));
(M2)((0x000A),(true));
axW:
while(true){
(axX)=((MX)((axS)));
if((axX)===(null)){
if(pJ){
return null;
}
else{
continue axW;
}
}
break axW;
}
(ayd)=((axX).qc);
if(!((((ayd)===(522))||((ayd)===(523)))||((ayd)===(513)))){
(D)((65567),((Ld)()),(null));
}
while((ayd)===(522)){
(ayh)=(axX);
((ayh).T6)=((ayi=(ax0)((ayj={$:(axX)},ayj),(ayk={$:(ayd)},ayk),(522),(axS)),(axX)=ayj.$,(ayd)=ayk.$,ayi));
(eN)(((axS).Tn),([130,134]),(ayh));
}
while((ayd)===(523)){
((axS).T8)=((aym=(ax0)((ayn={$:(axX)},ayn),(ayo={$:(ayd)},ayo),(523),(axS)),(axX)=ayn.$,(ayd)=ayo.$,aym));
}
if(!((ayd)===(513))){throw 0xE9170000;}
(xz)((ah),([131,134]));
return axS;
}
// parseStatCase
function acN(ayp /*row*/,ayq /*col*/,ayr /*block_*/){
let ays=null; // ast
let ayx=null; // exprs
let ayy=0; // c
let ay5=null; // id
(ays)=(new Tq());
(wE)((ays),(522),(null),(null),(false));
((ays).Ts)=({L:0,H:null,T:null,P:null});
((ays).T6)=(null);
if(((ayr).qc)!==(66050)){
(D)((65566),((wF)((ag),(ayp),(ayq))),([({S:"switch"}),({S:"case"})]));
(xs)(((xt)()));
return null;
}
ayw:
while(true){
(ayx)=(new y9());
((ayx).yJ)=((Os)());
((ayx).yO)=(null);
(ayy)=((wH)());
if((ayy)===(0x0000)){
break ayw;
}
if((ayy)===(0x000A)){
(eN)(((ays).Ts),([130,134]),(ayx));
break ayw;
}
if((ayy)===(0x002C)){
(eN)(((ays).Ts),([130,134]),(ayx));
continue ayw;
}
(pH)=(ayy);
(ay5)=((wX)((true),(false)));
if((ay5).S!==({S:"to"}).S){
(D)((65568),((Ld)()),([({S:"to"}),(ay5)]));
(xs)(((xt)()));
return null;
}
((ayx).yO)=((Os)());
(ayy)=((wH)());
if((ayy)===(0x0000)){
break ayw;
}
(eN)(((ays).Ts),([130,134]),(ayx));
if((ayy)===(0x000A)){
break ayw;
}
if((ayy)!==(0x002C)){
(Mx)((0x002C),(ayy));
}
}
return ays;
}
// parseStatDefault
function acP(ayE /*row*/,ayF /*col*/,ayG /*block_*/){
let ayH=null; // ast
(ayH)=(new xR());
(wE)((ayH),(523),(null),(null),(false));
if(((ayG).qc)!==(66050)){
(D)((65566),((wF)((ag),(ayE),(ayF))),([({S:"switch"}),({S:"default"})]));
(xs)(((xt)()));
return null;
}
(M2)((0x000A),(true));
return ayH;
}
// parseStatWhile
function acR(){
let ayK=null; // ast
let ayM=0; // c
let ayP=null; // id
let ayV=null; // stat
(ayK)=(new El());
(wE)((ayK),(16843265),((Ld)()),(null),(false));
((ayK).xZ)=(null);
((ayK).Un)=(false);
((ayK).Uh)=({L:0,H:null,T:null,P:null});
(axw)((ayK));
(axx)((ayK));
((ayK).Uf)=((Os)());
(ayM)=((wH)());
if((ayM)===(0x002C)){
(ayP)=((wX)((true),(false)));
if((ayP).S!==({S:"skip"}).S){
(D)((65568),((Ld)()),([({S:"skip"}),(ayP)]));
}
((ayK).Un)=(true);
}
else{
(pH)=(ayM);
}
(M2)((0x0029),(true));
(M2)((0x000A),(true));
ayU:
while(true){
(ayV)=((MX)((ayK)));
if((ayV)===(null)){
if(pJ){
return null;
}
else{
continue ayU;
}
}
if(((ayV).qc)===(513)){
break ayU;
}
(eN)(((ayK).Uh),([130,134]),(ayV));
}
(xz)((ah),([131,134]));
return ayK;
}
// parseStatFor
function acT(azd /*row*/,aze /*col*/){
let azf=null; // ast
let azh=0; // c
let azo=null; // stat
(azf)=(new Ep());
(wE)((azf),(16843266),((Ld)()),(null),(false));
((azf).xZ)=((axT)(((azf).ql)));
((azf).UG)=({L:0,H:null,T:null,P:null});
(axw)((azf));
(axx)((azf));
((azf).U7)=((Os)());
(M2)((0x002C),(true));
((azf).U6)=((Os)());
(azh)=((wH)());
if((azh)===(0x002C)){
((azf).U8)=((Os)());
(M2)((0x0029),(true));
(M2)((0x000A),(true));
}
else{
((azf).U8)=((azl)(((Ld)()),(0),(0x0000000000000001)));
(pH)=(azh);
(M2)((0x0029),(true));
(M2)((0x000A),(true));
}
azn:
while(true){
(azo)=((MX)((azf)));
if((azo)===(null)){
if(pJ){
return null;
}
else{
continue azn;
}
}
if(((azo).qc)===(513)){
break azn;
}
(eN)(((azf).UG),([130,134]),(azo));
}
(xz)((ah),([131,134]));
return azf;
}
// parseStatTry
function acV(azw /*row*/,azx /*col*/){
let azy=null; // ast
let az0=0; // c
let az5=null; // type
let az9=null; // stat
let azB=0; // typeId
let azD=null; // catch_
let az7=null;
let az8=null;
let azA=0;
let azE=null;
let azF=null;
let azG=0;
let azJ=null;
let azK=null;
let azL=0;
(azy)=(new xP());
(wE)((azy),(66051),((Ld)()),(null),(false));
((azy).xZ)=((axT)(((azy).ql)));
((azy).yf)=({L:0,H:null,T:null,P:null});
((azy).yi)=(null);
(axw)((azy));
(az0)=((wH)());
if((az0)!==(0x000A)){
(pH)=(az0);
((azy).qX)=((wX)((true),(false)));
(M6)((azy),(true));
(M2)((0x000A),(true));
}
else{
((azy).qX)=({S:"$"});
}
(az5)=(new xW());
(wE)((az5),(1026),((wF)((ag),(azw),(azx))),(null),(false));
((az5).xX)=(0);
(((azy).xZ).s4)=(az5);
((azy).ye)=((az7=(ax0)((az8={$:(az9)},az8),(azA={$:(azB)},azA),(66051),(azy)),(az9)=az8.$,(azB)=azA.$,az7));
while((azB)===(524)){
(azD)=(az9);
((azD).y6)=((azE=(ax0)((azF={$:(az9)},azF),(azG={$:(azB)},azG),(524),(azy)),(az9)=azF.$,(azB)=azG.$,azE));
(eN)(((azy).yf),([130,134]),(azD));
}
if((azB)===(525)){
((azy).yi)=((azJ=(ax0)((azK={$:(az9)},azK),(azL={$:(azB)},azL),(525),(azy)),(az9)=azK.$,(azB)=azL.$,azJ));
}
if(!((azB)===(513))){throw 0xE9170000;}
(xz)((ah),([131,134]));
return azy;
}
// parseStatCatch
function acX(azM /*row*/,azN /*col*/,azO /*block_*/){
let azP=null; // ast
let azT=0; // c
let azW=null; // exprs
let azX=null; // pos
let a0b=null; // exprs
let a0i=null; // id
(azP)=(new y2());
(wE)((azP),(524),(null),(null),(false));
((azP).y3)=({L:0,H:null,T:null,P:null});
((azP).y6)=(null);
if(((azO).qc)!==(66051)){
(D)((65566),((wF)((ag),(azM),(azN))),([({S:"try"}),({S:"catch"})]));
(xs)(((xt)()));
return null;
}
(azT)=((wH)());
if((azT)===(0x000A)){
(azW)=(new y9());
(azX)=((Ld)());
((azW).yJ)=((azl)((azX),(0),(0x0000000000000000)));
((azW).yO)=((azl)((azX),(0),(0x00000000FFFFFFFF)));
(eN)(((azP).y3),([130,134]),(azW));
}
else{
(pH)=(azT);
a0a:
while(true){
(a0b)=(new y9());
((a0b).yJ)=((Os)());
((a0b).yO)=(null);
(azT)=((wH)());
if((azT)===(0x0000)){
break a0a;
}
if((azT)===(0x000A)){
(eN)(((azP).y3),([130,134]),(a0b));
break a0a;
}
if((azT)===(0x002C)){
(eN)(((azP).y3),([130,134]),(a0b));
continue a0a;
}
(pH)=(azT);
(a0i)=((wX)((true),(false)));
if((a0i).S!==({S:"to"}).S){
(D)((65568),((Ld)()),([({S:"to"}),(a0i)]));
}
((a0b).yO)=((Os)());
(azT)=((wH)());
if((azT)===(0x0000)){
break a0a;
}
(eN)(((azP).y3),([130,134]),(a0b));
if((azT)===(0x000A)){
break a0a;
}
if((azT)!==(0x002C)){
(Mx)((0x002C),(azT));
}
}
}
return azP;
}
// parseStatFinally
function acZ(a0r /*row*/,a0s /*col*/,a0t /*block_*/){
let a0u=null; // ast
(a0u)=(new xR());
(wE)((a0u),(525),(null),(null),(false));
if(((a0t).qc)!==(66051)){
(D)((65566),((wF)((ag),(a0r),(a0s))),([({S:"try"}),({S:"finally"})]));
(xs)(((xt)()));
return null;
}
(M2)((0x000A),(true));
return a0u;
}
// parseStatThrow
function adb(){
let a0x=null; // ast
(a0x)=(new Eu());
(wE)((a0x),(526),((Ld)()),(null),(false));
((a0x).Vw)=((Os)());
(M2)((0x000A),(true));
return a0x;
}
// parseStatBlock
function add(){
let a0y=null; // ast
let a00=0; // c
let a06=null; // stat
(a0y)=(new yc());
(wE)((a0y),(66052),((Ld)()),(null),(false));
((a0y).xZ)=(null);
((a0y).yd)=({L:0,H:null,T:null,P:null});
(axw)((a0y));
(a00)=((wH)());
if((a00)!==(0x000A)){
(pH)=(a00);
((a0y).qX)=((wX)((true),(false)));
(M6)((a0y),(true));
(M2)((0x000A),(true));
}
else{
((a0y).qX)=({S:"$"});
}
a05:
while(true){
(a06)=((MX)((a0y)));
if((a06)===(null)){
if(pJ){
return null;
}
else{
continue a05;
}
}
if(((a06).qc)===(513)){
break a05;
}
(eN)(((a0y).yd),([130,134]),(a06));
}
(xz)((ah),([131,134]));
return a0y;
}
// parseStatRet
function adf(){
let a0E=null; // ast
let a0G=0; // c
(a0E)=(new Ez());
(wE)((a0E),(527),((Ld)()),(null),(false));
(a0G)=((wH)());
if((a0G)!==(0x000A)){
(pH)=(a0G);
((a0E).V5)=((Os)());
(M2)((0x000A),(true));
}
else{
((a0E).V5)=(null);
}
return a0E;
}
// parseStatDo
function adh(){
let a0K=null; // ast
(a0K)=(new yp());
(wE)((a0K),(528),((Ld)()),(null),(false));
((a0K).yz)=((Os)());
(M2)((0x000A),(true));
return a0K;
}
// parseStatBreak
function adj(){
let a0L=null; // ast
(a0L)=(new xR());
(wE)((a0L),(529),((Ld)()),(null),(false));
(M1)((a0L),((wX)((true),(false))));
(M2)((0x000A),(true));
return a0L;
}
// parseStatSkip
function adl(){
let a0M=null; // ast
(a0M)=(new xR());
(wE)((a0M),(530),((Ld)()),(null),(false));
(M1)((a0M),((wX)((true),(false))));
(M2)((0x000A),(true));
return a0M;
}
// parseStatAssert
function adn(){
let a0N=null; // ast
(a0N)=(new E8());
(wE)((a0N),(531),((Ld)()),(null),(false));
((a0N).VM)=((Os)());
(M2)((0x000A),(true));
return a0N;
}
// parseExprThree
function ads(){
let a0O=null; // ast
let a0S=0; // row
let a0T=0; // col
let a0U=0; // c
let a0X=null; // ast2
(a0O)=((a0P)());
a0R:
while(true){
(a0S)=(pF);
(a0T)=(pG);
(a0U)=((wH)());
if((a0U)===(0x003F)){
(M2)((0x0028),(false));
(a0X)=(new Qi());
(Ox)((a0X),(2051),((wF)((ag),(a0S),(a0T))));
((a0X).ala)=(a0O);
((a0X).ald)=((Os)());
(M2)((0x002C),(true));
((a0X).alg)=((Os)());
(a0O)=(a0X);
(M2)((0x0029),(true));
}
else{
(pH)=(a0U);
break a0R;
}
}
return a0O;
}
// readInStr
function adR(){
let a1b=0; // c
let a1d=0;
a1a:
while(true){
(a1b)=((KS)());
switch(a1b){
case 0x0009:
(D)((65540),((Ld)()),(null));
continue a1a;
break;
case 0x000A:
(D)((65541),((Ld)()),(null));
break;
}
return a1b;
}
}
// searchEnumElementValue
function afU(a1g /*ast*/,a1h /*enum_*/){
let a1i=null; // name
let a1j=null; // items
let a1l=null; // item
if(!((((a1g).yI).qc)===(1028))){throw 0xE9170000;}
(P6)((a1h));
(a1i)=((a1g).aig);
(a1j)=((a1h).Ob);
(qr)((a1j),([130,134]));
while(!((qt)((a1j),([130,134])))){
(a1l)=((qv)((a1j),([130,134])));
if((a1i).S===((a1l).qX).S){
if(((a1l).qc)!==(67585)){
return 0x0000000000000000;
}
return (a1l).yF;
}
(r8)((a1j),([130,134]));
}
(D)((131090),((a1g).ql),([(a1i)]));
return 0x0000000000000000;
}
// process1
function agc(a1q /*ast*/,a1r /*dtor*/,a1s /*copy*/,a1t /*toBin*/,a1u /*fromBin*/){
let a1x=null; // parent
let a12=null; // parent
let a13=null; // chk
let a18=false;
let a1B=null; // astItems
let a1D=null; // item
let a1F=null; // def
let a1I=null; // memberName
let a1L=null; // parentItem
let a1N=null; // parent
let a1P=null; // items
let a1R=null; // item2
let a1S=null; // def
let a1V=null; // parentName
let a2l=null; // func1
let a2m=null; // func2
let a2p=null; // items1
let a2q=null; // items2
let a2t=0;
let a2v=null; // arg1
let a2w=null; // arg2
let a20=null;
let a22=null; // func_
let a26=0;
let a2D=null; // def
let a2G=0; // idx
let a2N=null; // type
let a2Q=null; // type
let a2S=null; // type2
let a2W=null; // arg
let a2Y=null; // type
let a3a=null; // type2
let a3c=null; // arg
let a3e=null; // type
let a16=false;
let a17=false;
let a2u=0;
if(((a1q).qz)!==(null)){
(a1x)=((a1q).qz);
if(((a1x).qc)===(4)){
(P8)((a1x),(null));
((a1q).qz)=(((a1x).Nk).qz);
if(!((((a1q).qz).qc)===(5))){throw 0xE9170000;}
}
else{
if(!(((a1x).qc)===(5))){throw 0xE9170000;}
(P4)((a1x));
}
}
(a12)=(a1q);
(a13)=(new Map());
while((a12)!==(null)){
if((a16=(pR)((a13),([133,134,3]),(a12),(a17={$:(a18)},a17)),(a18)=a17.$,a16)){
(D)((131080),((a1q).ql),([((a1q).qX)]));
return;
}
(bE)((a13),([133,134,3]),(a12),(true));
(a12)=((a12).qz);
}
(a1B)=((a1q).tg);
(qr)((a1B),([130,134]));
while(!((qt)((a1B),([130,134])))){
(a1D)=((qv)((a1B),([130,134])));
(a1F)=((a1D).tS);
if(((a1F).qc)===(2)){
(a1I)=(((a1F).tX).qX);
}
else if(((a1F).qc)===(3)){
(a1I)=(((a1F).xx).qX);
}
else{
(a1I)=((a1F).qX);
}
(a1L)=(null);
(a1N)=((a1q).qz);
while(((a1L)===(null))&&((a1N)!==(null))){
(a1P)=((a1N).tg);
(qr)((a1P),([130,134]));
while(!((qt)((a1P),([130,134])))){
(a1R)=((qv)((a1P),([130,134])));
(a1S)=((a1R).tS);
if(((a1S).qc)===(2)){
(a1V)=(((a1S).tX).qX);
}
else if(((a1S).qc)===(3)){
(a1V)=(((a1S).xx).qX);
}
else{
(a1V)=((a1S).qX);
}
if((a1I).S===(a1V).S){
(a1L)=(a1R);
}
(r8)((a1P),([130,134]));
}
(a1N)=((a1N).qz);
}
if((a1L)===(null)){
if((a1D).N5){
(D)((131081),(((a1D).tS).ql),([(a1I)]));
return;
}
}
else{
if(!((a1D).N5)){
(D)((131082),(((a1D).tS).ql),([(a1I)]));
return;
}
if(!(((((a1D).tS).qc)===(256))&&((((a1L).tS).qc)===(256)))){
(D)((131083),(((a1D).tS).ql),([(a1I)]));
return;
}
if(((a1D).N4)!==((a1L).N4)){
(D)((131084),(((a1D).tS).ql),([(a1I)]));
return;
}
(a2l)=((a1D).tS);
(a2m)=((a1L).tS);
if(((((((a2l).qh)===(null))&&(((a2m).qh)!==(null)))||((((a2l).qh)!==(null))&&(((a2m).qh)===(null))))||(((((a2l).qh)!==(null))&&(((a2m).qh)!==(null)))&&(!((Pm)(((a2l).qh),((a2m).qh),(false))))))||((((a2l).qg).L)!==(((a2m).qg).L))){
(D)((131085),(((a1D).tS).ql),([(a1I)]));
return;
}
(a2p)=((a2l).qg);
(a2q)=((a2m).qg);
(qr)((a2p),([130,134]));
(qr)((a2q),([130,134]));
a2s:
for(a2t=(0),a2u=(((a2p).L)-(1));a2t<=a2u;a2t+=(1)){
(a2v)=((qv)((a2p),([130,134])));
(a2w)=((qv)((a2q),([130,134])));
if(((((((((a2v).s4).qc)===(66565))&&((((a2v).s4).qz)===(null)))||(((((a2w).s4).qc)===(66565))&&((((a2w).s4).qz)===(null))))||(!((Pm)(((a2v).s4),((a2w).s4),(false)))))||(((((a2v).qX)!==(null))&&(((a2w).qX)!==(null)))&&(((a2v).qX).S!==((a2w).qX).S)))||(((a2v).sJ)!==((a2w).sJ))){
(D)((131085),(((a1D).tS).ql),([(a1I)]));
return;
}
(r8)((a2p),([130,134]));
(r8)((a2q),([130,134]));
}
((a1D).N6)=(a1L);
}
a20=a1I;
if(a20.S===({S:"_dtor"}).S||a20.S===({S:"_copy"}).S||a20.S===({S:"_toBin"}).S||a20.S===({S:"_fromBin"}).S){
if(!((((a1D).tS).qc)===(256))){throw 0xE9170000;}
(a22)=((a1D).tS);
if(((a1D).N5)&&(((rt)((((a1D).tS).qi),([9]),(128)))===(0))){
(D)((131086),((a22).ql),([(a1I)]));
return;
}
switch((a1I).S.charCodeAt(1)){
case 0x0064:
(a1r.$)=(a22);
break;
case 0x0063:
(a1s.$)=(a22);
break;
case 0x0074:
(a1t.$)=(a22);
break;
case 0x0066:
(a1u.$)=(a22);
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{(a2D)=((a1D).tS);
if(((a2D).qc)===(256)){
(a2G)=((tn)((a1B),([130,134])));
if(!((a2G)!==(-1))){throw 0xE9170000;}
(rD)((a2D));
(qr)((a1B),([130,134]));
(tq)((a1B),([130,134]),(a2G));
}
else if(((a2D).qc)===(2)){
(Rc)((a2D));
}
}
(r8)((a1B),([130,134]));
}
if((a1r.$)===(null)){
(a1r.$)=((a2K)((a1q),({S:"_dtor"})));
}
if((a1s.$)===(null)){
(a1s.$)=((a2K)((a1q),({S:"_copy"})));
(a2N)=(new M9());
(xM)((a2N),(66565),((a1q).ql));
((a2N).qz)=(a1q);
((a1s.$).qh)=(a2N);
}
if((a1t.$)===(null)){
(a1t.$)=((a2K)((a1q),({S:"_toBin"})));
(a2Q)=(new Au());
(xM)((a2Q),(66561),((a1q).ql));
(a2S)=(new Ay());
(xM)((a2S),(1025),((a1q).ql));
((a2S).Az)=(1);
((a2Q).Aw)=(a2S);
((a1t.$).qh)=(a2Q);
}
if((a1u.$)===(null)){
(a1u.$)=((a2K)((a1q),({S:"_fromBin"})));
(a2W)=(new ro());
(xM)((a2W),(7),((a1q).ql));
((a2W).rp)=(2);
((a2W).sJ)=(false);
((a2W).xY)=(null);
(a2Y)=(new Au());
(xM)((a2Y),(66561),((a1q).ql));
(a3a)=(new Ay());
(xM)((a3a),(1025),((a1q).ql));
((a3a).Az)=(1);
((a2Y).Aw)=(a3a);
((a2W).s4)=(a2Y);
(eN)(((a1u.$).qg),([130,134]),(a2W));
(a3c)=(new ro());
(xM)((a3c),(7),((a1q).ql));
((a3c).rp)=(2);
((a3c).sJ)=(true);
((a3c).xY)=(null);
(a3e)=(new xW());
(xM)((a3e),(1026),((a1q).ql));
((a3e).xX)=(0);
((a3c).s4)=(a3e);
(eN)(((a1u.$).qg),([130,134]),(a3c));
(qr)(((a1u.$).qg),([130,134]));
((a1u.$).qh)=(((qv)(((a1u.$).qg),([130,134]))).s4);
}
}
// process2
function agh(a3f /*ast*/,a3g /*dtor*/,a3h /*copy*/,a3i /*toBin*/,a3j /*fromBin*/){
let a3l=null; // ptr
let a3n=null; // items
let a3p=null; // item
let a3s=null; // do_
let a3u=null; // assign
let a3y=null; // var_
let a30=null; // var2
let a32=null; // arg
let a34=null; // type
let a36=null; // new_
let a38=null; // result
let a3A=null; // type
let a3C=null; // ptr
let a3E=null; // items
let a3G=null; // item
let a3J=null; // member
let a3L=null; // do_
let a3N=null; // assign
let a3P=null; // dot
let a3S=null; // copy2
let a3V=null; // ret_
let a3X=null; // as
let a4a=null; // var_
let a4c=null; // var2
let a4e=null; // arg
let a4g=null; // new_
let a4i=null; // value
let a4k=null; // prim
let a4m=null; // type
let a4o=null; // type
let a4q=null; // type2
let a4s=null; // result
let a4u=null; // type
let a4w=null; // ptr
let a4y=null; // items
let a40=null; // item
let a43=null; // member
let a45=null; // do_
let a47=null; // assign
let a49=null; // expr
let a4B=null; // array_
let a4D=null; // bit
let a4F=null; // ret_
let a4I=null; // var_
let a4K=null; // var2
let a4M=null; // arg
let a4O=null; // new_
let a4Q=null; // result
let a4S=null; // type
let a4U=null; // ptr
let a4W=null; // items
let a4Y=null; // item
let a5b=null; // member
let a5d=null; // do_
let a5f=null; // assign
let a5h=null; // dot
let a5j=null; // expr
let a5l=null; // ref
let a5n=null; // ref
let a5p=null; // ret_
(a3l)=(a3f);
while((a3l)!==(null)){
(a3n)=((a3l).tg);
(qr)((a3n),([130,134]));
while(!((qt)((a3n),([130,134])))){
(a3p)=((qv)((a3n),([130,134])));
if(((((a3p).tS).qc)===(2))&&((zQ)(((((a3p).tS).tX).s4)))){
(a3s)=(new yp());
(xM)((a3s),(528),((a3f).ql));
(a3u)=(new zI());
(yu)((a3u),(2050),((a3f).ql));
((a3u).zJ)=(0);
(qr)(((a3g).qg),([130,134]));
((a3u).zM)=((a3v)((a3f),((qv)(((a3g).qg),([130,134]))),((((a3p).tS).tX).qX)));
((a3u).zN)=((zX)(((a3f).ql)));
((a3s).yz)=(a3u);
(eN)(((a3g).tp),([130,134]),((zO)((a3s),((a3g).qh),(a3g))));
}
(r8)((a3n),([130,134]));
}
(a3l)=((a3l).qz);
}
(a3y)=(new Rb());
(xM)((a3y),(515),((a3f).ql));
(a30)=(new tV());
(xM)((a30),(2),((a3f).ql));
(a32)=(new ro());
(xM)((a32),(7),((a3f).ql));
((a32).rp)=(3);
((a32).sJ)=(false);
(a34)=(new M9());
(xM)((a34),(66565),((a3f).ql));
((a34).qz)=(a3f);
((a32).s4)=(a34);
(a36)=(new Ql());
(yu)((a36),(2052),((a3f).ql));
((a36).al0)=((a32).s4);
((a32).xY)=(a36);
((a30).tX)=(a32);
((a3y).Rd)=(a30);
(eN)(((a3h).tp),([130,134]),((zO)((a3y),((a3h).qh),(a3h))));
(a38)=(new yt());
(yu)((a38),(2062),((a3f).ql));
((a38).q0)=({S:"me"});
((a38).qz)=(((a3y).Rd).tX);
(a3A)=(new M9());
(xM)((a3A),(66565),((a3f).ql));
((a3A).qz)=(a3f);
((a38).yI)=(a3A);
(a3C)=(a3f);
while((a3C)!==(null)){
(a3E)=((a3C).tg);
(qr)((a3E),([130,134]));
while(!((qt)((a3E),([130,134])))){
(a3G)=((qv)((a3E),([130,134])));
if((((a3G).tS).qc)===(2)){
(a3J)=(((a3G).tS).tX);
(a3L)=(new yp());
(xM)((a3L),(528),((a3f).ql));
(a3N)=(new zI());
(yu)((a3N),(2050),((a3f).ql));
((a3N).zJ)=(0);
(a3P)=(new Q5());
(yu)((a3P),(2059),((a3f).ql));
((a3P).anT)=(a38);
((a3P).aoZ)=((a3J).qX);
((a3P).apm)=(null);
((a3N).zM)=(a3P);
if((zQ)(((a3J).s4))){
(a3S)=(new Qd());
(yu)((a3S),(2049),((a3f).ql));
((a3S).agQ)=(3);
(qr)(((a3h).qg),([130,134]));
((a3S).agK)=((a3v)((a3f),((qv)(((a3h).qg),([130,134]))),((a3J).qX)));
((a3N).zN)=(a3S);
}
else{
(qr)(((a3h).qg),([130,134]));
((a3N).zN)=((a3v)((a3f),((qv)(((a3h).qg),([130,134]))),((a3J).qX)));
}
((a3L).yz)=(a3N);
(eN)(((a3h).tp),([130,134]),((zO)((a3L),((a3h).qh),(a3h))));
}
(r8)((a3E),([130,134]));
}
(a3C)=((a3C).qz);
}
(a3V)=(new Ez());
(xM)((a3V),(527),((a3f).ql));
(a3X)=(new Qr());
(yu)((a3X),(2054),((a3f).ql));
((a3X).amf)=(0);
((a3X).alX)=(a38);
((a3X).ama)=((a3h).qh);
((a3V).V5)=(a3X);
(eN)(((a3h).tp),([130,134]),((zO)((a3V),((a3h).qh),(a3h))));
(a4a)=(new Rb());
(xM)((a4a),(515),((a3f).ql));
(a4c)=(new tV());
(xM)((a4c),(2),((a3f).ql));
(a4e)=(new ro());
(xM)((a4e),(7),((a3f).ql));
((a4e).rp)=(3);
((a4e).sJ)=(false);
(a4g)=(new Qo());
(yu)((a4g),(2053),((a3f).ql));
((a4g).alC)=({L:0,H:null,T:null,P:null});
(a4i)=(new yC());
(yu)((a4i),(67585),((a3f).ql));
((a4i).yF)=(0x0000000000000008);
(a4k)=(new xW());
(xM)((a4k),(1026),((a3f).ql));
((a4k).xX)=(0);
((a4i).yI)=(a4k);
(eN)(((a4g).alC),([130,134]),(a4i));
(a4m)=(new Ay());
(xM)((a4m),(1025),((a3f).ql));
((a4m).Az)=(1);
((a4g).alK)=(a4m);
((a4e).xY)=(a4g);
(a4o)=(new Au());
(xM)((a4o),(66561),((a3f).ql));
(a4q)=(new Ay());
(xM)((a4q),(1025),((a3f).ql));
((a4q).Az)=(1);
((a4o).Aw)=(a4q);
((a4e).s4)=(a4o);
((a4c).tX)=(a4e);
((a4a).Rd)=(a4c);
(eN)(((a3i).tp),([130,134]),((zO)((a4a),((a3i).qh),(a3i))));
(a4s)=(new yt());
(yu)((a4s),(2062),((a3f).ql));
((a4s).qz)=(((a4a).Rd).tX);
(a4u)=(new M9());
(xM)((a4u),(66565),((a3f).ql));
((a4u).qz)=(a3f);
((a4s).yI)=(a4u);
(a4w)=(a3f);
while((a4w)!==(null)){
(a4y)=((a4w).tg);
(qr)((a4y),([130,134]));
while(!((qt)((a4y),([130,134])))){
(a40)=((qv)((a4y),([130,134])));
if((((a40).tS).qc)===(2)){
(a43)=(((a40).tS).tX);
(a45)=(new yp());
(xM)((a45),(528),((a3f).ql));
(a47)=(new zI());
(yu)((a47),(2050),((a3f).ql));
((a47).zJ)=(7);
((a47).zM)=(a4s);
(a49)=(new Qu());
(yu)((a49),(2055),((a3f).ql));
(qr)(((a3i).qg),([130,134]));
((a49).ant)=((a3v)((a3f),((qv)(((a3i).qg),([130,134]))),((a43).qX)));
(a4B)=(new Au());
(xM)((a4B),(66561),((a3f).ql));
(a4D)=(new Ay());
(xM)((a4D),(1025),((a3f).ql));
((a4D).Az)=(1);
((a4B).Aw)=(a4D);
((a49).anz)=(a4B);
((a47).zN)=(a49);
((a45).yz)=(a47);
(eN)(((a3i).tp),([130,134]),((zO)((a45),((a3i).qh),(a3i))));
}
(r8)((a4y),([130,134]));
}
(a4w)=((a4w).qz);
}
(a4F)=(new Ez());
(xM)((a4F),(527),((a3f).ql));
((a4F).V5)=(a4s);
(eN)(((a3i).tp),([130,134]),((zO)((a4F),((a3i).qh),(a3i))));
(a4I)=(new Rb());
(xM)((a4I),(515),((a3f).ql));
(a4K)=(new tV());
(xM)((a4K),(2),((a3f).ql));
(a4M)=(new ro());
(xM)((a4M),(7),((a3f).ql));
((a4M).rp)=(3);
((a4M).sJ)=(false);
(qr)(((a3j).qg),([130,134]));
((a4M).s4)=(((qv)(((a3j).qg),([130,134]))).s4);
(a4O)=(new Ql());
(yu)((a4O),(2052),((a3f).ql));
((a4O).al0)=((a4M).s4);
((a4M).xY)=(a4O);
((a4K).tX)=(a4M);
((a4I).Rd)=(a4K);
(eN)(((a3j).tp),([130,134]),((zO)((a4I),((a3j).qh),(a3j))));
(a4Q)=(new yt());
(yu)((a4Q),(2062),((a3f).ql));
((a4Q).qz)=(((a4I).Rd).tX);
((a4Q).q0)=({S:"me"});
(a4S)=(new M9());
(xM)((a4S),(66565),((a3f).ql));
((a4S).qz)=(a3f);
((a4Q).yI)=(a4S);
(a4U)=(a3f);
while((a4U)!==(null)){
(a4W)=((a4U).tg);
(qr)((a4W),([130,134]));
while(!((qt)((a4W),([130,134])))){
(a4Y)=((qv)((a4W),([130,134])));
if((((a4Y).tS).qc)===(2)){
(a5b)=(((a4Y).tS).tX);
(a5d)=(new yp());
(xM)((a5d),(528),((a3f).ql));
(a5f)=(new zI());
(yu)((a5f),(2050),((a3f).ql));
((a5f).zJ)=(0);
(a5h)=(new Q5());
(yu)((a5h),(2059),((a3f).ql));
((a5h).apm)=(null);
((a5h).anT)=(a4Q);
((a5h).aoZ)=((a5b).qX);
((a5f).zM)=(a5h);
(a5j)=(new Qx());
(yu)((a5j),(2056),((a3f).ql));
(a5l)=(new yt());
(yu)((a5l),(2062),((a3f).ql));
(qr)(((a3j).qg),([130,134]));
(r8)(((a3j).qg),([130,134]));
((a5l).qz)=((qv)(((a3j).qg),([130,134])));
if(!(((a5l).qz)!==(null))){throw 0xE9170000;}
((a5j).an4)=(a5l);
((a5j).an9)=((a5b).s4);
(a5n)=(new yt());
(yu)((a5n),(2062),((a3f).ql));
(qr)(((a3j).qg),([130,134]));
(r8)(((a3j).qg),([130,134]));
(r8)(((a3j).qg),([130,134]));
((a5n).qz)=((qv)(((a3j).qg),([130,134])));
if(!(((a5n).qz)!==(null))){throw 0xE9170000;}
((a5j).anA)=(a5n);
((a5f).zN)=(a5j);
((a5d).yz)=(a5f);
(eN)(((a3j).tp),([130,134]),((zO)((a5d),((a3j).qh),(a3j))));
}
(r8)((a4W),([130,134]));
}
(a4U)=((a4U).qz);
}
(a5p)=(new Ez());
(xM)((a5p),(527),((a3f).ql));
((a5p).V5)=(a4Q);
(eN)(((a3j).tp),([130,134]),((zO)((a5p),((a3j).qh),(a3j))));
}
// isFloat
function agT(a5q /*type*/){
return (((a5q).qc)===(1026))&&(((a5q).xX)===(1));
}
// isBool
function ahj(a5r /*type*/){
return (((a5r).qc)===(1026))&&(((a5r).xX)===(3));
}
// isComparable
function ahZ(a5s /*type*/,a5t /*lessOrGreater*/){
if((((((((((a5s).qc)===(1025))||((s3)((a5s))))||((agT)((a5s))))||((Tk)((a5s))))||((EN)((a5s))))||((RR)((a5s))))||((XE)((a5s))))||(((a5s).qc)===(1028))){
return true;
}
if((!(a5t))&&((ahj)((a5s)))){
return true;
}
return false;
}
// cmp
function aiJ(a5y /*s1*/,a5z /*s2*/){
let a50=0; // p
(a50)=(0);
while(((a50)<((a5y).S.length))&&((a50)<((a5z).S.length))){
if(((a5y).S.charCodeAt(a50))!==((a5z).S.charCodeAt(a50))){
return (((a5y).S.charCodeAt(a50))>((a5z).S.charCodeAt(a50)))?(1):((((a5y).S.charCodeAt(a50))<((a5z).S.charCodeAt(a50)))?(-1):(0));
}
(a50)=((a50)+(1));
}
return (((a5y).S.length)>((a5z).S.length))?(1):((((a5y).S.length)<((a5z).S.length))?(-1):(0));
}
// bitCast
function akg(a55 /*size*/,a56 /*n*/){
let a58=0;
switch(a55){
case 1:
return a56;
break;
case 2:
return a56;
break;
case 4:
return a56;
break;
case 8:
return a56;
if(!(false)){throw 0xE9170000;}
break;
}
return 0x0000000000000000;
}
// getTypeName
function aop(a5D /*type*/){
let a5H=0;
let a5L=null; // type2
let a5M=null; // s
let a5N=false; // first
let a5O=null; // items
let a5Q=null; // arg
let a6f=null; // type2
let a6h=0;
let a6j=null; // s
let a6o=null; // type2
let a6q=null; // type2
let a6s=0;
if((a5D)===(null)){
return {S:""};
}
switch((a5D).qc){
case 66561:
return {S:({S:"[]"}).S+((aop)(((a5D).Aw))).S};
break;
case 1025:
return {S:({S:"bit"}).S+((v)((((a5D).Az)*(8)),([0]))).S};
break;
case 66562:
(a5L)=(a5D);
(a5M)=({S:"func<("});
(a5N)=(true);
(a5O)=((a5L).A9);
(qr)((a5O),([130,134]));
while(!((qt)((a5O),([130,134])))){
(a5Q)=((qv)((a5O),([130,134])));
if(a5N){
(a5N)=(false);
}
else{
(a5M)=({S:(a5M).S+({S:", "}).S});
}
if((a5Q).AK){
(a5M)=({S:(a5M).S+({S:"&"}).S});
}
(a5M)=({S:(a5M).S+((aop)(((a5Q).AI))).S});
(r8)((a5O),([130,134]));
}
if(((a5L).A4)===(null)){
(a5M)=({S:(a5M).S+({S:")>"}).S});
}
else{
(a5M)=({S:(a5M).S+({S:({S:({S:"): "}).S+((aop)(((a5L).A4))).S}).S+({S:">"}).S}).S});
}
return a5M;
break;
case 66563:
(a6f)=(a5D);
switch((a6f).AS){
case 0:
(a6j)=({S:"list<"});
break;
case 1:
(a6j)=({S:"stack<"});
break;
case 2:
(a6j)=({S:"queue<"});
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
return {S:({S:(a6j).S+((aop)(((a6f).AU))).S}).S+({S:">"}).S};
break;
case 66564:
(a6o)=(a5D);
return {S:({S:({S:({S:({S:"dict<"}).S+((aop)(((a6o).Bb))).S}).S+({S:", "}).S}).S+((aop)(((a6o).Bc))).S}).S+({S:">"}).S};
break;
case 1026:
(a6q)=(a5D);
switch((a6q).xX){
case 0:
return {S:"int"};
break;
case 1:
return {S:"float"};
break;
case 2:
return {S:"char"};
break;
case 3:
return {S:"bool"};
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
break;
case 66565:
return {S:((((a5D).q0).S===({S:"@"}).S)?(((a5D).ql).dh):({S:""})).S+((a5D).q0).S};
break;
case 1028:
return {S:"(UNKNOWN)"};
break;
default:
if(!(false)){throw 0xE9170000;}
return {S:""};
break;
}
}
// chkBuiltinFuncType
function apu(a61 /*member*/,a62 /*type*/){
let a65=0; // kind
let a68=false; // found
let a6C=0;
let a6Z=0;
let a7k=0;
let a74=null;
let a7F=null;
let a7X=null;
let a8g=null;
let a66=0;
let a67=false;
if((J)===(null)){
(J)=(new Map());
(bE)((J),([133,129,2,9]),({S:"abs"}),(10));
(bE)((J),([133,129,2,9]),({S:"add"}),(6));
(bE)((J),([133,129,2,9]),({S:"and"}),(1));
(bE)((J),([133,129,2,9]),({S:"clamp"}),(10));
(bE)((J),([133,129,2,9]),({S:"clampMax"}),(10));
(bE)((J),([133,129,2,9]),({S:"clampMin"}),(10));
(bE)((J),([133,129,2,9]),({S:"del"}),(14));
(bE)((J),([133,129,2,9]),({S:"delNext"}),(8));
(bE)((J),([133,129,2,9]),({S:"endian"}),(3));
(bE)((J),([133,129,2,9]),({S:"exist"}),(12));
(bE)((J),([133,129,2,9]),({S:"fill"}),(4));
(bE)((J),([133,129,2,9]),({S:"find"}),(13));
(bE)((J),([133,129,2,9]),({S:"findBin"}),(4));
(bE)((J),([133,129,2,9]),({S:"findLast"}),(13));
(bE)((J),([133,129,2,9]),({S:"findStr"}),(5));
(bE)((J),([133,129,2,9]),({S:"findStrEx"}),(5));
(bE)((J),([133,129,2,9]),({S:"findStrLast"}),(5));
(bE)((J),([133,129,2,9]),({S:"forEach"}),(12));
(bE)((J),([133,129,2,9]),({S:"get"}),(7));
(bE)((J),([133,129,2,9]),({S:"getOffset"}),(8));
(bE)((J),([133,129,2,9]),({S:"head"}),(8));
(bE)((J),([133,129,2,9]),({S:"idx"}),(8));
(bE)((J),([133,129,2,9]),({S:"ins"}),(8));
(bE)((J),([133,129,2,9]),({S:"join"}),(11));
(bE)((J),([133,129,2,9]),({S:"lower"}),(5));
(bE)((J),([133,129,2,9]),({S:"max"}),(4));
(bE)((J),([133,129,2,9]),({S:"min"}),(4));
(bE)((J),([133,129,2,9]),({S:"moveOffset"}),(8));
(bE)((J),([133,129,2,9]),({S:"next"}),(8));
(bE)((J),([133,129,2,9]),({S:"not"}),(1));
(bE)((J),([133,129,2,9]),({S:"offset"}),(2));
(bE)((J),([133,129,2,9]),({S:"or"}),(1));
(bE)((J),([133,129,2,9]),({S:"peek"}),(9));
(bE)((J),([133,129,2,9]),({S:"prev"}),(8));
(bE)((J),([133,129,2,9]),({S:"repeat"}),(4));
(bE)((J),([133,129,2,9]),({S:"replace"}),(5));
(bE)((J),([133,129,2,9]),({S:"reverse"}),(4));
(bE)((J),([133,129,2,9]),({S:"sar"}),(3));
(bE)((J),([133,129,2,9]),({S:"shl"}),(3));
(bE)((J),([133,129,2,9]),({S:"shr"}),(3));
(bE)((J),([133,129,2,9]),({S:"shuffle"}),(4));
(bE)((J),([133,129,2,9]),({S:"sign"}),(10));
(bE)((J),([133,129,2,9]),({S:"sort"}),(13));
(bE)((J),([133,129,2,9]),({S:"sortDesc"}),(13));
(bE)((J),([133,129,2,9]),({S:"split"}),(5));
(bE)((J),([133,129,2,9]),({S:"sub"}),(4));
(bE)((J),([133,129,2,9]),({S:"tail"}),(8));
(bE)((J),([133,129,2,9]),({S:"term"}),(8));
(bE)((J),([133,129,2,9]),({S:"termOffset"}),(8));
(bE)((J),([133,129,2,9]),({S:"toArray"}),(8));
(bE)((J),([133,129,2,9]),({S:"toArrayKey"}),(12));
(bE)((J),([133,129,2,9]),({S:"toArrayValue"}),(12));
(bE)((J),([133,129,2,9]),({S:"toBit64"}),(5));
(bE)((J),([133,129,2,9]),({S:"toFloat"}),(5));
(bE)((J),([133,129,2,9]),({S:"toInt"}),(5));
(bE)((J),([133,129,2,9]),({S:"toStr"}),(0));
(bE)((J),([133,129,2,9]),({S:"toStrFmt"}),(10));
(bE)((J),([133,129,2,9]),({S:"trim"}),(5));
(bE)((J),([133,129,2,9]),({S:"trimLeft"}),(5));
(bE)((J),([133,129,2,9]),({S:"trimRight"}),(5));
(bE)((J),([133,129,2,9]),({S:"upper"}),(5));
(bE)((J),([133,129,2,9]),({S:"xor"}),(1));
}
(a65)=((a66=(pR)((J),([133,129,2,9]),(a61.$),(a67={$:(a68)},a67)),(a68)=a67.$,a66));
if(!(a68)){
return false;
}
switch(a65){
case 0:
if(((((((s3)((a62)))||((agT)((a62))))||((Tk)((a62))))||((ahj)((a62))))||(((a62).qc)===(1025)))||((XE)((a62)))){
return true;
}
break;
case 1:
if((((a62).qc)===(1025))||((EN)((a62)))){
return true;
}
break;
case 2:
if((Tk)((a62))){
return true;
}
break;
case 3:
if(((a62).qc)===(1025)){
return true;
}
break;
case 4:
if(((a62).qc)===(66561)){
return true;
}
break;
case 5:
if((XE)((a62))){
return true;
}
break;
case 6:
if(((a62).qc)===(66563)){
switch((a62).AS){
case 0:
(a61.$)=({S:"addList"});
break;
case 1:
(a61.$)=({S:"addStack"});
break;
case 2:
(a61.$)=({S:"addQueue"});
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
return true;
}
if(((a62).qc)===(66564)){
(a61.$)=({S:"addDict"});
return true;
}
break;
case 7:
if(((a62).qc)===(66563)){
switch((a62).AS){
case 0:
(a61.$)=({S:"getList"});
break;
case 1:
(a61.$)=({S:"getStack"});
break;
case 2:
(a61.$)=({S:"getQueue"});
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
return true;
}
if(((a62).qc)===(66564)){
(a61.$)=({S:"getDict"});
return true;
}
break;
case 8:
if((((a62).qc)===(66563))&&(((a62).AS)===(0))){
return true;
}
break;
case 9:
if(((a62).qc)===(66563)){
if(((a62).AS)===(1)){
(a61.$)=({S:"peekStack"});
return true;
}
else if(((a62).AS)===(2)){
(a61.$)=({S:"peekQueue"});
return true;
}
}
break;
case 10:
if((s3)((a62))){
a74=a61.$;
if(a74.S===({S:"abs"}).S){
(a61.$)=({S:"absInt"});
}
else if(a74.S===({S:"clamp"}).S){
(a61.$)=({S:"clampInt"});
}
else if(a74.S===({S:"clampMin"}).S){
(a61.$)=({S:"clampMinInt"});
}
else if(a74.S===({S:"clampMax"}).S){
(a61.$)=({S:"clampMaxInt"});
}
else if(a74.S===({S:"sign"}).S){
(a61.$)=({S:"signInt"});
}
else if(a74.S===({S:"toStrFmt"}).S){
(a61.$)=({S:"toStrFmtInt"});
}
else{if(!(false)){throw 0xE9170000;}
}
return true;
}
if((agT)((a62))){
a7F=a61.$;
if(a7F.S===({S:"abs"}).S){
(a61.$)=({S:"absFloat"});
}
else if(a7F.S===({S:"clamp"}).S){
(a61.$)=({S:"clampFloat"});
}
else if(a7F.S===({S:"clampMin"}).S){
(a61.$)=({S:"clampMinFloat"});
}
else if(a7F.S===({S:"clampMax"}).S){
(a61.$)=({S:"clampMaxFloat"});
}
else if(a7F.S===({S:"sign"}).S){
(a61.$)=({S:"signFloat"});
}
else if(a7F.S===({S:"toStrFmt"}).S){
(a61.$)=({S:"toStrFmtFloat"});
}
else{if(!(false)){throw 0xE9170000;}
}
return true;
}
break;
case 11:
if((((a62).qc)===(66561))&&((XE)(((a62).Aw)))){
return true;
}
break;
case 12:
if(((a62).qc)===(66564)){
return true;
}
break;
case 13:
if(((a62).qc)===(66561)){
a7X=a61.$;
if(a7X.S===({S:"sort"}).S){
(a61.$)=({S:"sortArray"});
}
else if(a7X.S===({S:"sortDesc"}).S){
(a61.$)=({S:"sortDescArray"});
}
else if(a7X.S===({S:"find"}).S){
(a61.$)=({S:"findArray"});
}
else if(a7X.S===({S:"findLast"}).S){
(a61.$)=({S:"findLastArray"});
}
else{if(!(false)){throw 0xE9170000;}
}
return true;
}
if((((a62).qc)===(66563))&&(((a62).AS)===(0))){
a8g=a61.$;
if(a8g.S===({S:"sort"}).S){
(a61.$)=({S:"sortList"});
}
else if(a8g.S===({S:"sortDesc"}).S){
(a61.$)=({S:"sortDescList"});
}
else if(a8g.S===({S:"find"}).S){
(a61.$)=({S:"findList"});
}
else if(a8g.S===({S:"findLast"}).S){
(a61.$)=({S:"findLastList"});
}
else{if(!(false)){throw 0xE9170000;}
}
return true;
}
break;
case 14:
if((((a62).qc)===(66563))&&(((a62).AS)===(0))){
return true;
}
if(((a62).qc)===(66564)){
(a61.$)=({S:"delDict"});
return true;
}
break;
}
return false;
}
// cacheSubExpr
function aux(a8r /*stats*/,a8s /*ast*/,a8t /*pos*/){
let a8y=null; // ref
let a80=null; // arg
let a82=null; // do_
let a84=null; // exprAssign
if((a8s)===(null)){
return null;
}
if((((a8s).qc)===(2062))||(((rt)(((a8s).qc),([9]),(67584)))===(67584))){
return a8s;
}
(a8y)=(new yt());
(yu)((a8y),(2062),(a8t));
((a8y).q0)=({S:"$"});
((a8y).yE)=(2);
((a8y).zo)=(a8y);
(a80)=(new ro());
(xM)((a80),(7),(a8t));
((a80).rp)=(3);
((a80).sJ)=(false);
((a80).s4)=((a8s).yI);
((a80).xY)=(null);
((a80).zo)=(a80);
((a8y).qz)=(a80);
((a8y).yI)=((a80).s4);
(a82)=(new yp());
(xM)((a82),(528),(a8t));
(a84)=(new zI());
(yu)((a84),(2050),(a8t));
((a84).zJ)=(0);
((a84).zM)=(a8y);
((a84).zN)=(a8s);
((a82).yz)=(a84);
(eN)((a8r),([130,134]),((RF)((a82))));
return a8y;
}
// buildExpr1
function avc(a85 /*ast*/){
let a87=0;
if(!(((a85).yE)!==(0))){throw 0xE9170000;}
switch((a85).agQ){
case 0:
(SL)(((a85).agK));
break;
case 1:
(eN)((P),([130,129,2]),({S:"-("}));
(SL)(((a85).agK));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 2:
(eN)((P),([130,129,2]),({S:"!("}));
(SL)(((a85).agK));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 3:
(eN)((P),([130,129,2]),({S:"copy_("}));
(SL)(((a85).agK));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 4:
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((a85).agK));
(eN)((P),([130,129,2]),({S:")->Len()"}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// buildExpr2
function ave(a8E /*ast*/){
let a8F=null; // type
let a8H=0;
let a9z=null; // tmpVar
if(!(((a8E).yE)!==(0))){throw 0xE9170000;}
(a8F)=(((a8E).zM).yI);
switch((a8E).zJ){
case 0:
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:") = ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 8:
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:") || ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 9:
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:") && ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 10:
if((zQ)((a8F))){
(eN)((P),([130,129,2]),({S:"cmp_(("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:"), ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")) < 0"}));
}
else{
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:") < ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")"}));
}
break;
case 11:
if((zQ)((a8F))){
(eN)((P),([130,129,2]),({S:"cmp_(("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:"), ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")) > 0"}));
}
else{
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:") > ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")"}));
}
break;
case 12:
if((zQ)((a8F))){
(eN)((P),([130,129,2]),({S:"cmp_(("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:"), ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")) <= 0"}));
}
else{
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:") <= ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")"}));
}
break;
case 13:
if((zQ)((a8F))){
(eN)((P),([130,129,2]),({S:"cmp_(("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:"), ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")) >= 0"}));
}
else{
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:") >= ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")"}));
}
break;
case 14:
if((zQ)((a8F))){
(eN)((P),([130,129,2]),({S:"cmp_(("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:"), ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")) == 0"}));
}
else{
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:") == ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")"}));
}
break;
case 15:
if((zQ)((a8F))){
(eN)((P),([130,129,2]),({S:"cmp_(("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:"), ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")) != 0"}));
}
else{
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:") != ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")"}));
}
break;
case 16:
(eN)((P),([130,129,2]),({S:"eqAddr_(("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:"), ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:"))"}));
break;
case 17:
(eN)((P),([130,129,2]),({S:"!eqAddr_(("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:"), ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:"))"}));
break;
case 18:
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:")->Cat("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 19:
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:") + ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 20:
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:") - ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 21:
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:") * ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 22:
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:") / ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")"}));
break;
case 23:
if(((s3)((a8F)))||(((rt)(((a8F).qc),([9]),(1025)))===(1025))){
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:") % ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:")"}));
}
else{
if(!((agT)((a8F)))){throw 0xE9170000;}
(eN)((P),([130,129,2]),({S:"fmod(("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:"), ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:"))"}));
}
break;
case 24:
if(((s3)((a8F)))||(((rt)(((a8F).qc),([9]),(1025)))===(1025))){
(eN)((P),([130,129,2]),({S:"powI_(("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:"), ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:"))"}));
}
else{
if(!((agT)((a8F)))){throw 0xE9170000;}
(eN)((P),([130,129,2]),({S:"pow(("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:"), ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:"))"}));
}
break;
case 25:
(a9z)=((U5)((a8F)));
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)((a9z),([129,2]))).S}).S+({S:" = ("}).S}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:"), ("}));
(SL)(((a8E).zM));
(eN)((P),([130,129,2]),({S:") = ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:"), ("}));
(SL)(((a8E).zN));
(eN)((P),([130,129,2]),({S:({S:({S:") = ("}).S+((v)((a9z),([129,2]))).S}).S+({S:")"}).S}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// buildExpr3
function avg(a91 /*ast*/){
if(!(((a91).yE)!==(0))){throw 0xE9170000;}
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((a91).ala));
(eN)((P),([130,129,2]),({S:") ? ("}));
(SL)(((a91).ald));
(eN)((P),([130,129,2]),({S:") : ("}));
(SL)(((a91).alg));
(eN)((P),([130,129,2]),({S:")"}));
}
// buildExprNew
function avi(a92 /*ast*/){
let a95=null; // class_
let a96=null; // id
let a9A=null; // gen
let a9C=0;
let a9I=null; // dict_
if(!(((a92).yE)!==(0))){throw 0xE9170000;}
if((RR)(((a92).al0))){
(a95)=(((a92).al0).qz);
(a96)=((t9)((a95)));
(eN)((P),([130,129,2]),({S:({S:({S:"new "}).S+((v)((a96),([129,2]))).S}).S+({S:"()"}).S}));
}
else{
if((((a92).al0).qc)===(66563)){
(a9A)=((a92).al0);
switch((a9A).AS){
case 0:
(eN)((P),([130,129,2]),({S:({S:({S:"new List_<"}).S+((v)(((sq)(((a9A).AU))),([129,2]))).S}).S+({S:">()"}).S}));
break;
case 1:
(eN)((P),([130,129,2]),({S:({S:({S:"new Stack_<"}).S+((v)(((sq)(((a9A).AU))),([129,2]))).S}).S+({S:">()"}).S}));
break;
case 2:
(eN)((P),([130,129,2]),({S:({S:({S:"new Queue_<"}).S+((v)(((sq)(((a9A).AU))),([129,2]))).S}).S+({S:">()"}).S}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{
if(!((((a92).al0).qc)===(66564))){throw 0xE9170000;}
(a9I)=((a92).al0);
(eN)((P),([130,129,2]),({S:({S:({S:"new Dict_<"}).S+((v)(((sq)(((a9I).Bb))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sq)(((a9I).Bc))),([129,2]))).S}).S+({S:">()"}).S}).S}));
}
}
}
// buildExprNewArray
function avk(a9J /*ast*/){
let a9L=null; // items
if(!(((a9J).yE)!==(0))){throw 0xE9170000;}
(eN)((P),([130,129,2]),({S:({S:({S:"newArray_<"}).S+((v)(((sq)(((a9J).alK))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sq)(((a9J).yI))),([129,2]))).S}).S+({S:({S:({S:">("}).S+((v)((((a9J).alC).L),([0]))).S}).S+({S:""}).S}).S}).S}));
(a9L)=((a9J).alC);
(qr)((a9L),([130,134]));
while(!((qt)((a9L),([130,134])))){
(eN)((P),([130,129,2]),({S:", ("}));
(SL)(((qv)((a9L),([130,134]))));
(eN)((P),([130,129,2]),({S:")"}));
(r8)((a9L),([130,134]));
}
(eN)((P),([130,129,2]),({S:")"}));
}
// buildExprAs
function avm(a9N /*ast*/){
let a9P=0;
let a9R=null; // t1
let a9S=null; // t2
let a9V=null; // id
let a9W=null; // info
let a9Z=null; // info
let aAb=null; // info
if(!(((a9N).yE)!==(0))){throw 0xE9170000;}
switch((a9N).amf){
case 0:
(a9R)=(((a9N).alX).yI);
(a9S)=((a9N).ama);
if((RR)((a9R))){
if(!((RR)((a9S)))){throw 0xE9170000;}
(a9V)=((t9)(((a9S).qz)));
(a9W)=((rU)(((a9S).qz)));
(eN)((P),([130,129,2]),({S:({S:({S:"as_<"}).S+((v)((a9V),([129,2]))).S}).S+({S:">(classTable_, ("}).S}));
(SL)(((a9N).alX));
(eN)((P),([130,129,2]),({S:({S:({S:"), "}).S+((v)((((a9W).tE)*(2)),([0]))).S}).S+({S:")"}).S}));
}
else{
(eN)((P),([130,129,2]),({S:({S:({S:"static_cast<"}).S+((v)(((sq)(((a9N).ama))),([129,2]))).S}).S+({S:">("}).S}));
(SL)(((a9N).alX));
(eN)((P),([130,129,2]),({S:")"}));
}
break;
case 1:
(t9)((((a9N).ama).qz));
(a9Z)=((rU)((((a9N).ama).qz)));
(eN)((P),([130,129,2]),({S:"is_(classTable_, ("}));
(SL)(((a9N).alX));
(eN)((P),([130,129,2]),({S:({S:({S:"), "}).S+((v)((((a9Z).tE)*(2)),([0]))).S}).S+({S:")"}).S}));
break;
case 2:
(t9)((((a9N).ama).qz));
(aAb)=((rU)((((a9N).ama).qz)));
(eN)((P),([130,129,2]),({S:"!is_(classTable_, ("}));
(SL)(((a9N).alX));
(eN)((P),([130,129,2]),({S:({S:({S:"), "}).S+((v)((((aAb).tE)*(2)),([0]))).S}).S+({S:")"}).S}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// buildExprToBin
function avo(aAd /*ast*/){
if(!(((aAd).yE)!==(0))){throw 0xE9170000;}
(eN)((P),([130,129,2]),({S:"toBin_("}));
(SL)(((aAd).ant));
(eN)((P),([130,129,2]),({S:")"}));
}
// buildExprFromBin
function avq(aAe /*ast*/){
if(!(((aAe).yE)!==(0))){throw 0xE9170000;}
(eN)((P),([130,129,2]),({S:({S:({S:"fromBin_<"}).S+((v)(((sq)(((aAe).an9))),([129,2]))).S}).S+({S:">(("}).S}));
(SL)(((aAe).an4));
(eN)((P),([130,129,2]),({S:"), ("}));
(SL)(((aAe).anA));
(eN)((P),([130,129,2]),({S:"))"}));
}
// buildExprCall
function avs(aAf /*ast*/){
let aAg=null; // funcType
let aAh=null; // template
let aAk=null; // items
let aAl=null; // meType
let aAC=false; // first
let aAD=null; // items
let aAF=null; // item
let aAM=null; // type
if(!(((aAf).yE)!==(0))){throw 0xE9170000;}
(aAg)=(((aAf).yy).yI);
(aAh)=(null);
if(((aAg)!==(null))&&(((rt)(((aAg).abC),([9]),(1)))===(1))){
(aAk)=((aAf).yv);
(qr)((aAk),([130,134]));
(aAl)=((((qv)((aAk),([130,134]))).zc).yI);
if(((rt)(((aAg).abC),([9]),(32)))===(32)){
(aAh)=({S:({S:({S:"<"}).S+((v)(((sq)((aAl))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sq)(((aAl).Bb))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sq)(((aAl).Bc))),([129,2]))).S}).S+({S:">"}).S}).S}).S});
}
else if(((rt)(((aAg).abC),([9]),(8)))===(8)){
if(((rt)(((aAg).abC),([9]),(16)))===(16)){
(aAh)=({S:({S:({S:"<"}).S+((v)(((sq)((aAl))),([129,2]))).S}).S+({S:", "}).S});
if(((aAl).qc)===(66563)){
(aAh)=({S:(aAh).S+({S:({S:({S:""}).S+((v)(((sq)(((aAl).AU))),([129,2]))).S}).S+({S:", "}).S}).S});
}
else{
if(!(((aAl).qc)===(66564))){throw 0xE9170000;}
(aAh)=({S:(aAh).S+({S:({S:({S:""}).S+((v)(((sq)(((aAl).Bb))),([129,2]))).S}).S+({S:", "}).S}).S});
}
(aAh)=({S:(aAh).S+({S:({S:({S:""}).S+((v)(((sq)(((aAg).A4))),([129,2]))).S}).S+({S:">"}).S}).S});
}
else{
(aAh)=({S:({S:({S:"<"}).S+((v)(((sq)((aAl))),([129,2]))).S}).S+({S:", "}).S});
if(((aAl).qc)===(66561)){
(aAh)=({S:(aAh).S+({S:({S:({S:""}).S+((v)(((sq)(((aAl).Aw))),([129,2]))).S}).S+({S:">"}).S}).S});
}
else if(((aAl).qc)===(66563)){
(aAh)=({S:(aAh).S+({S:({S:({S:""}).S+((v)(((sq)(((aAl).AU))),([129,2]))).S}).S+({S:">"}).S}).S});
}
else{
if(!(((aAl).qc)===(66564))){throw 0xE9170000;}
(aAh)=({S:(aAh).S+({S:({S:({S:""}).S+((v)(((sq)(((aAl).Bb))),([129,2]))).S}).S+({S:">"}).S}).S});
}
}
}
else if(((rt)(((aAg).abC),([9]),(16)))===(16)){
(aAh)=({S:({S:({S:"<"}).S+((v)(((sq)((aAl))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sq)(((aAg).A4))),([129,2]))).S}).S+({S:">"}).S}).S});
}
else if(((rt)(((aAg).abC),([9]),(256)))===(256)){
(aAh)=({S:({S:({S:"<"}).S+((v)(((sq)((aAl))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sq)(((aAl).Bb))),([129,2]))).S}).S+({S:({S:({S:", "}).S+((v)(((sq)(((aAl).Bc))),([129,2]))).S}).S+({S:">"}).S}).S}).S});
}
else{
(aAh)=({S:({S:({S:"<"}).S+((v)(((sq)((aAl))),([129,2]))).S}).S+({S:">"}).S});
}
}
if((aAh)===(null)){
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((aAf).yy));
(eN)((P),([130,129,2]),({S:")"}));
}
else{
(SL)(((aAf).yy));
(eN)((P),([130,129,2]),(aAh));
}
(eN)((P),([130,129,2]),({S:"("}));
(aAC)=(true);
(aAD)=((aAf).yv);
(qr)((aAD),([130,134]));
while(!((qt)((aAD),([130,134])))){
(aAF)=((qv)((aAD),([130,134])));
if(aAC){
(aAC)=(false);
(eN)((P),([130,129,2]),({S:"("}));
}
else{
(eN)((P),([130,129,2]),({S:", ("}));
}
if((aAF).yY){
(eN)((P),([130,129,2]),({S:"&"}));
}
(SL)(((aAF).zc));
(eN)((P),([130,129,2]),({S:")"}));
(r8)((aAD),([130,134]));
}
(eN)((P),([130,129,2]),({S:")"}));
(aAM)=((aAf).yI);
if((aAM)!==(null)){
if((RR)((aAM))){
(t9)(((aAM).qz));
}
}
}
// buildExprArray
function avu(aAR /*ast*/){
if(!(((aAR).yE)!==(0))){throw 0xE9170000;}
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((aAR).aoB));
(eN)((P),([130,129,2]),({S:")->At("}));
(SL)(((aAR).aoG));
(eN)((P),([130,129,2]),({S:")"}));
}
// buildExprDot
function avw(aAS /*ast*/){
let aAV=null; // classItem
let aAY=null; // info
if(!(((aAS).yE)!==(0))){throw 0xE9170000;}
if((RR)((((aAS).anT).yI))){
(aAV)=((aAS).apm);
if(!((aAV)!==(null))){throw 0xE9170000;}
(t9)(((((aAS).anT).yI).qz));
if((((aAV).tS).qc)===(2)){
(aAY)=((rU)((((aAV).tS).tX)));
(eN)((P),([130,129,2]),({S:"("}));
(SL)(((aAS).anT));
(eN)((P),([130,129,2]),({S:({S:({S:")->"}).S+((v)(((aAY).sN),([129,2]))).S}).S+({S:""}).S}));
}
else{
if(!((((aAV).tS).qc)===(256))){throw 0xE9170000;}
(aAY)=((rU)(((aAV).tS)));
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((aAY).sN),([129,2]))).S}).S+({S:""}).S}));
}
}
else{
if(!((((aAS).qz).qc)===(2062))){throw 0xE9170000;}
(av8)(((aAS).qz));
}
}
// buildExprValue
function avy(aBb /*ast*/){
if(!((((aBb).yI).qc)===(1027))){throw 0xE9170000;}
(eN)((P),([130,129,2]),({S:"nullptr"}));
}
// buildExprValuePrim
function av0(aBc /*ast*/){
let aBd=null; // type
let aBk=0;
(aBd)=((aBc).yI);
if(((s3)((aBd)))||((EN)((aBd)))){
(eN)((P),([130,129,2]),({S:((v)(((aBc).yF),([0]))).S+({S:"LL"}).S}));
}
else if((Tk)((aBd))){
(eN)((P),([130,129,2]),({S:({S:({S:"u\'\\u"}).S+((v)(((p9)(((v)(((aBc).yF),([5]))),([129,2]),(2),(-1))),([129,2]))).S}).S+({S:"\'"}).S}));
}
else if((ahj)((aBd))){
(eN)((P),([130,129,2]),((((aBc).yF)===(0x0000000000000000))?({S:"false"}):({S:"true"})));
}
else if(((aBd).qc)===(1025)){
switch((aBd).Az){
case 1:
(eN)((P),([130,129,2]),({S:({S:({S:"static_cast<uint8_t>("}).S+((v)(((aBc).yF),([4]))).S}).S+({S:"U)"}).S}));
break;
case 2:
(eN)((P),([130,129,2]),({S:({S:({S:"static_cast<uint16_t>("}).S+((v)(((aBc).yF),([5]))).S}).S+({S:"U)"}).S}));
break;
case 4:
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((aBc).yF),([6]))).S}).S+({S:"U"}).S}));
break;
case 8:
(eN)((P),([130,129,2]),({S:({S:({S:""}).S+((v)(((aBc).yF),([7]))).S}).S+({S:"ULL"}).S}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{
if(!(false)){throw 0xE9170000;}
}
}
// buildExprValueStr
function av2(aBr /*ast*/){
let aBs=null; // value
let aBt=null; // s
let aBw=0;
let aBx=0;
(aBs)=((aBr).aiK);
(aBt)=({S:({S:({S:"new Array_<char16_t>("}).S+((v)(((aBs).S.length),([0]))).S}).S+({S:""}).S});
aBv:
for(aBw=(0),aBx=(((aBs).S.length)-(1));aBw<=aBx;aBw+=(1)){
(aBt)=({S:(aBt).S+({S:({S:({S:", u\'\\u"}).S+((v)(((p9)(((v)(((aBs).S.charCodeAt(aBw)),([5]))),([129,2]),(2),(-1))),([129,2]))).S}).S+({S:"\'"}).S}).S});
}
(aBt)=({S:(aBt).S+({S:")"}).S});
(eN)((P),([130,129,2]),(aBt));
}
// buildExprValueFloat
function av4(aB0 /*ast*/){
let aB1=null; // value
(aB1)=((v)(((aB0).ahg),([1])));
if((aB1).S===({S:"inf"}).S){
(eN)((P),([130,129,2]),({S:"std::numeric_limits<double>::infinity()"}));
}
else if(((q3)((aB1),([129,2]),(0x002E),(-1)))===(-1)){
(eN)((P),([130,129,2]),({S:(aB1).S+({S:".0"}).S}));
}
else{
(eN)((P),([130,129,2]),(aB1));
}
}
// buildExprValueArray
function av6(aB6 /*ast*/){
let aB7=null; // items
(eN)((P),([130,129,2]),({S:({S:({S:"new Array_<"}).S+((v)(((sq)((((aB6).yI).Aw))),([129,2]))).S}).S+({S:({S:({S:">("}).S+((v)((((aB6).aoc).L),([0]))).S}).S+({S:""}).S}).S}));
(aB7)=((aB6).aoc);
(qr)((aB7),([130,134]));
while(!((qt)((aB7),([130,134])))){
(eN)((P),([130,129,2]),({S:", ("}));
(SL)(((qv)((aB7),([130,134]))));
(eN)((P),([130,129,2]),({S:")"}));
(r8)((aB7),([130,134]));
}
(eN)((P),([130,129,2]),({S:")"}));
}
// buildExprRef
function av8(aB9 /*ast*/){
let aBA=null; // ast2
let aBB=null; // info
let aBF=null; // arg
let aBH=0;
(aBA)=((aB9).qz);
(aBB)=((rU)((aBA)));
if(((aBA).qc)===(256)){
(eQ)((K),([132,134]),(aBA));
}
else{
if(!(((aBA).qc)===(7))){throw 0xE9170000;}
(aBF)=(aBA);
switch((aBF).rp){
case 1:
if(!((aBB).rX)){
((aBB).rX)=(true);
(eN)((S),([130,134]),(aBF));
}
break;
case 2:
break;
case 3:
if(!((aBB).rX)){
((aBB).rX)=(true);
(eN)((T),([130,134]),(aBF));
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
if((aBF).sJ){
(eN)((P),([130,129,2]),({S:"*"}));
}
}
(eN)((P),([130,129,2]),((aBB).sN));
}
// buildExpr1
function avH(aBS /*ast*/){
let aBU=0;
let aBZ=null; // typeId
let aCc=null; // type
let aCg=0;
if(!(((aBS).yE)!==(0))){throw 0xE9170000;}
switch((aBS).agQ){
case 0:
(WI)(((aBS).agK));
break;
case 1:
(eN)((am),([130,129,2]),({S:"-("}));
(WI)(((aBS).agK));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 2:
(eN)((am),([130,129,2]),({S:"!("}));
(WI)(((aBS).agK));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 3:
(aBZ)=((aCa)((((aBS).agK).yI)));
(eN)((am),([130,129,2]),({S:({S:({S:"C_("}).S+((v)((aBZ),([129,2]))).S}).S+({S:",("}).S}));
(WI)(((aBS).agK));
(eN)((am),([130,129,2]),({S:"))"}));
break;
case 4:
(aCc)=(((aBS).agK).yI);
if(((aCc).qc)===(66563)){
switch((aCc).AS){
case 0:
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aBS).agK));
(eN)((am),([130,129,2]),({S:").L"}));
break;
case 1:
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aBS).agK));
(eN)((am),([130,129,2]),({S:").length"}));
break;
case 2:
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aBS).agK));
(eN)((am),([130,129,2]),({S:").length"}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else if(((aCc).qc)===(66564)){
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aBS).agK));
(eN)((am),([130,129,2]),({S:").size"}));
}
else{
if(!(((aCc).qc)===(66561))){throw 0xE9170000;}
if((Tk)(((aCc).Aw))){
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aBS).agK));
(eN)((am),([130,129,2]),({S:").S.length"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aBS).agK));
(eN)((am),([130,129,2]),({S:").length"}));
}
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// buildExpr2
function avJ(aCr /*ast*/){
let aCs=null; // type
let aCu=0;
let aCy=null; // ast2
let aCz=null; // tmpIdx
let aC0=null; // tmpChar
let aDq=null; // tmpVar
if(!(((aCr).yE)!==(0))){throw 0xE9170000;}
(aCs)=(((aCr).zM).yI);
switch((aCr).zJ){
case 0:
if(((((aCr).zM).qc)===(2058))&&((Tk)((((aCr).zM).yI)))){
(aCy)=((aCr).zM);
(aCz)=((Yf)((((aCy).aoG).yI)));
(aC0)=((Yf)(((aCy).yI)));
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCy).aoB));
(eN)((am),([130,129,2]),({S:({S:({S:").S=("}).S+((v)((aCz),([129,2]))).S}).S+({S:"=("}).S}));
(WI)(((aCy).aoG));
(eN)((am),([130,129,2]),({S:"),("}));
(WI)(((aCy).aoB));
(eN)((am),([130,129,2]),({S:({S:({S:").S.slice(0,"}).S+((v)((aCz),([129,2]))).S}).S+({S:")+String.fromCharCode("}).S}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:")+("}));
(WI)(((aCy).aoB));
(eN)((am),([130,129,2]),({S:({S:({S:").S.slice("}).S+((v)((aCz),([129,2]))).S}).S+({S:"+1))"}).S}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:")=("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:")"}));
}
break;
case 8:
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:")||("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 9:
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:")&&("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 10:
if((XE)((aCs))){
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:").S<("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:").S"}));
}
else if((zQ)((aCs))){
(eN)((am),([130,129,2]),({S:"cmp_(("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:"),("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:"))<0"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:")<("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:")"}));
}
break;
case 11:
if((XE)((aCs))){
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:").S>("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:").S"}));
}
else if((zQ)((aCs))){
(eN)((am),([130,129,2]),({S:"cmp_(("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:"),("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:"))>0"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:")>("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:")"}));
}
break;
case 12:
if((XE)((aCs))){
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:").S<=("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:").S"}));
}
else if((zQ)((aCs))){
(eN)((am),([130,129,2]),({S:"cmp_(("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:"),("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:"))<=0"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:")<=("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:")"}));
}
break;
case 13:
if((XE)((aCs))){
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:").S>=("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:").S"}));
}
else if((zQ)((aCs))){
(eN)((am),([130,129,2]),({S:"cmp_(("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:"),("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:"))>=0"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:")>=("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:")"}));
}
break;
case 14:
if((XE)((aCs))){
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:").S===("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:").S"}));
}
else if((zQ)((aCs))){
(eN)((am),([130,129,2]),({S:"cmp_(("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:"),("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:"))==0"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:")===("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:")"}));
}
break;
case 15:
if((XE)((aCs))){
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:").S!==("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:").S"}));
}
else if((zQ)((aCs))){
(eN)((am),([130,129,2]),({S:"cmp_(("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:"),("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:"))!=0"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:")!==("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:")"}));
}
break;
case 16:
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:")===("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 17:
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:")!==("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 18:
if((XE)((aCs))){
(eN)((am),([130,129,2]),({S:"{S:("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:").S+("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:").S}"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:").concat("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:")"}));
}
break;
case 19:
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:")+("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 20:
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:")-("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 21:
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:")*("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 22:
if(!((agT)((aCs)))){
(eN)((am),([130,129,2]),({S:"~~("}));
}
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:")/("}));
(WI)(((aCr).zN));
if(!((agT)((aCs)))){
(eN)((am),([130,129,2]),({S:"))"}));
}
else{
(eN)((am),([130,129,2]),({S:")"}));
}
break;
case 23:
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:")%("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 24:
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:")**("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:")"}));
break;
case 25:
(aDq)=((Yf)((aCs)));
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)((aDq),([129,2]))).S}).S+({S:"=("}).S}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:"),("}));
(WI)(((aCr).zM));
(eN)((am),([130,129,2]),({S:")=("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:"),("}));
(WI)(((aCr).zN));
(eN)((am),([130,129,2]),({S:({S:({S:")=("}).S+((v)((aDq),([129,2]))).S}).S+({S:")"}).S}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// buildExpr3
function avL(aDs /*ast*/){
if(!(((aDs).yE)!==(0))){throw 0xE9170000;}
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aDs).ala));
(eN)((am),([130,129,2]),({S:")?("}));
(WI)(((aDs).ald));
(eN)((am),([130,129,2]),({S:"):("}));
(WI)(((aDs).alg));
(eN)((am),([130,129,2]),({S:")"}));
}
// buildExprNew
function avN(aDt /*ast*/){
let aDw=null; // class_
let aDx=null; // id
let aD1=null; // gen
let aD3=0;
if(!(((aDt).yE)!==(0))){throw 0xE9170000;}
if((RR)(((aDt).al0))){
(aDw)=(((aDt).al0).qz);
(aDx)=((vD)((aDw)));
(eN)((am),([130,129,2]),({S:({S:({S:"new "}).S+((v)((aDx),([129,2]))).S}).S+({S:"()"}).S}));
}
else{
if((((aDt).al0).qc)===(66563)){
(aD1)=((aDt).al0);
switch((aD1).AS){
case 0:
(eN)((am),([130,129,2]),({S:"{L:0,H:null,T:null,P:null}"}));
break;
case 1:
(eN)((am),([130,129,2]),({S:"[]"}));
break;
case 2:
(eN)((am),([130,129,2]),({S:"[]"}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{
if(!((((aDt).al0).qc)===(66564))){throw 0xE9170000;}
(eN)((am),([130,129,2]),({S:"new Map()"}));
}
}
}
// buildExprNewArray
function avP(aD9 /*ast*/){
let aDB=null; // items
let aDH=false; // first
let aDQ=false; // first
if(!(((aD9).yE)!==(0))){throw 0xE9170000;}
(aDB)=((aD9).alC);
(qr)((aDB),([130,134]));
if((Tk)(((aD9).alK))){
if(((aDB).L)===(1)){
(eN)((am),([130,129,2]),({S:"{S:\"\\0\".repeat("}));
(WI)(((qv)((aDB),([130,134]))));
(eN)((am),([130,129,2]),({S:")}"}));
}
else{
(eN)((am),([130,129,2]),({S:({S:({S:"(function A_(n){if(n.length===1)return{S:\"\\0\".repeat("}).S+((v)(((v2)(((aD9).alK))),([129,2]))).S}).S+({S:")}else{let a=new Array(n[0]),m=n.shift(),i;for(i=0;i<n[0];i++)a[i]=A_(m);return a}})(["}).S}));
(aDH)=(true);
while(!((qt)((aDB),([130,134])))){
if(aDH){
(aDH)=(false);
}
else{
(eN)((am),([130,129,2]),({S:",("}));
}
(WI)(((qv)((aDB),([130,134]))));
(eN)((am),([130,129,2]),({S:")"}));
(r8)((aDB),([130,134]));
}
(eN)((am),([130,129,2]),({S:"])"}));
}
}
else{
if(((aDB).L)===(1)){
(eN)((am),([130,129,2]),({S:"new Array("}));
(WI)(((qv)((aDB),([130,134]))));
(eN)((am),([130,129,2]),({S:({S:({S:").fill("}).S+((v)(((v2)(((aD9).alK))),([129,2]))).S}).S+({S:")"}).S}));
}
else{
(eN)((am),([130,129,2]),({S:({S:({S:"(function A_(n){if(n.length===1)return new Array(n[0]).fill("}).S+((v)(((v2)(((aD9).alK))),([129,2]))).S}).S+({S:")else{let a=new Array(n[0]),m=n.shift(),i;for(i=0;i<n[0];i++)a[i]=A_(m);return a}})(["}).S}));
(aDQ)=(true);
while(!((qt)((aDB),([130,134])))){
if(aDQ){
(aDQ)=(false);
}
else{
(eN)((am),([130,129,2]),({S:",("}));
}
(WI)(((qv)((aDB),([130,134]))));
(eN)((am),([130,129,2]),({S:")"}));
(r8)((aDB),([130,134]));
}
(eN)((am),([130,129,2]),({S:"])"}));
}
}
}
// buildExprAs
function avR(aDV /*ast*/){
let aDX=0;
let aDZ=null; // t1
let aEa=null; // t2
let aEs=null; // info
let aEu=null; // info
if(!(((aDV).yE)!==(0))){throw 0xE9170000;}
switch((aDV).amf){
case 0:
(aDZ)=(((aDV).alX).yI);
(aEa)=((aDV).ama);
if((RR)((aDZ))){
if(!((RR)((aEa)))){throw 0xE9170000;}
(vD)(((aEa).qz));
(WI)(((aDV).alX));
}
else{
if((((((aDZ).qc)===(1025))||((s3)((aDZ))))||((Tk)((aDZ))))||((EN)((aDZ)))){
if(((((((aEa).qc)===(1025))||((s3)((aEa))))||((Tk)((aEa))))||((EN)((aEa))))||((agT)((aEa)))){
(WI)(((aDV).alX));
}
else{
if(!((ahj)((aEa)))){throw 0xE9170000;}
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aDV).alX));
(eN)((am),([130,129,2]),({S:")!=0"}));
}
}
else if((agT)((aDZ))){
if((((aEa).qc)===(1025))||((s3)((aEa)))){
(eN)((am),([130,129,2]),({S:"~~("}));
(WI)(((aDV).alX));
(eN)((am),([130,129,2]),({S:")"}));
}
else{
if(!((agT)((aEa)))){throw 0xE9170000;}
(WI)(((aDV).alX));
}
}
else{
if(!((ahj)((aDZ)))){throw 0xE9170000;}
if((((aEa).qc)===(1025))||((s3)((aEa)))){
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aDV).alX));
(eN)((am),([130,129,2]),({S:")?1:0"}));
}
else{
if(!((ahj)((aEa)))){throw 0xE9170000;}
(WI)(((aDV).alX));
}
}
}
break;
case 1:
(vD)((((aDV).ama).qz));
(aEs)=((uJ)((((aDV).ama).qz)));
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aDV).alX));
(eN)((am),([130,129,2]),({S:({S:({S:")instanceof "}).S+((v)(((aEs).va),([129,2]))).S}).S+({S:""}).S}));
break;
case 2:
(vD)((((aDV).ama).qz));
(aEu)=((uJ)((((aDV).ama).qz)));
(eN)((am),([130,129,2]),({S:"!(("}));
(WI)(((aDV).alX));
(eN)((am),([130,129,2]),({S:({S:({S:")instanceof "}).S+((v)(((aEu).va),([129,2]))).S}).S+({S:")"}).S}));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
// buildExprToBin
function avT(aEw /*ast*/){
if(!(((aEw).yE)!==(0))){throw 0xE9170000;}
(eN)((am),([130,129,2]),({S:"toBin_("}));
(WI)(((aEw).ant));
(eN)((am),([130,129,2]),({S:")"}));
}
// buildExprFromBin
function avV(aEx /*ast*/){
if(!(((aEx).yE)!==(0))){throw 0xE9170000;}
(eN)((am),([130,129,2]),({S:"fromBin_(("}));
(WI)(((aEx).an4));
(eN)((am),([130,129,2]),({S:"),("}));
(WI)(((aEx).anA));
(eN)((am),([130,129,2]),({S:"))"}));
}
// buildExprCall
function avX(aEy /*ast*/){
let aEz=null; // funcType
let aE0=null; // meTypeId
let aE3=null; // items
let aE4=0; // refNum
let aE6=null; // items
let aEB=null; // resultVar
let aEC=null; // refVar
let aEI=0; // idx
let aEJ=0; // refCnt
let aEK=false; // first
let aEL=null; // items
let aEN=null; // item
let aFa=0; // idx
let aFb=0; // refCnt
let aFc=null; // items
let aFe=null; // item
let aFn=null; // type
if(!(((aEy).yE)!==(0))){throw 0xE9170000;}
(aEz)=(((aEy).yy).yI);
(aE0)=(null);
if(((aEz)!==(null))&&(((rt)(((aEz).abC),([9]),(1)))===(1))){
(aE3)=((aEy).yv);
(qr)((aE3),([130,134]));
(aE0)=((aCa)(((((qv)((aE3),([130,134]))).zc).yI)));
}
(aE4)=(0);
(aE6)=((aEy).yv);
(qr)((aE6),([130,134]));
while(!((qt)((aE6),([130,134])))){
if(((qv)((aE6),([130,134]))).yY){
(aE4)=((aE4)+(1));
}
(r8)((aE6),([130,134]));
}
(aEB)=(null);
(aEC)=(null);
if((aE4)>(0)){
(eN)((am),([130,129,2]),({S:"("}));
if(((aEy).yI)!==(null)){
(aEB)=((Yf)(((aEy).yI)));
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)((aEB),([129,2]))).S}).S+({S:"="}).S}));
}
(aEC)=(new Array(aE4).fill(null));
}
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aEy).yy));
(eN)((am),([130,129,2]),({S:")("}));
(aEI)=(0);
(aEJ)=(0);
(aEK)=(true);
(aEL)=((aEy).yv);
(qr)((aEL),([130,134]));
while(!((qt)((aEL),([130,134])))){
(aEN)=((qv)((aEL),([130,134])));
if(aEK){
(aEK)=(false);
(eN)((am),([130,129,2]),({S:"("}));
}
else{
(eN)((am),([130,129,2]),({S:",("}));
}
if(((aE0)!==(null))&&((aEI)===(1))){
(eN)((am),([130,129,2]),(aE0));
}
else if((aEN).yY){
((aEC)[aEJ])=((Yf)((((aEN).zc).yI)));
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((aEC)[aEJ]),([129,2]))).S}).S+({S:"={$:("}).S}));
(WI)(((aEN).zc));
(eN)((am),([130,129,2]),({S:({S:({S:")},"}).S+((v)(((aEC)[aEJ]),([129,2]))).S}).S+({S:""}).S}));
(aEJ)=((aEJ)+(1));
}
else{
(WI)(((aEN).zc));
}
(eN)((am),([130,129,2]),({S:")"}));
(aEI)=((aEI)+(1));
(r8)((aEL),([130,134]));
}
(eN)((am),([130,129,2]),({S:")"}));
if((aE4)>(0)){
(aFa)=(0);
(aFb)=(0);
(aFc)=((aEy).yv);
(qr)((aFc),([130,134]));
while(!((qt)((aFc),([130,134])))){
(aFe)=((qv)((aFc),([130,134])));
if(((aE0)!==(null))&&((aFa)===(1))){
}
else if((aFe).yY){
(eN)((am),([130,129,2]),({S:",("}));
(WI)(((aFe).zc));
(eN)((am),([130,129,2]),({S:({S:({S:")="}).S+((v)(((aEC)[aFb]),([129,2]))).S}).S+({S:".$"}).S}));
(aFb)=((aFb)+(1));
}
(aFa)=((aFa)+(1));
(r8)((aFc),([130,134]));
}
if(((aEy).yI)!==(null)){
(eN)((am),([130,129,2]),({S:({S:({S:","}).S+((v)((aEB),([129,2]))).S}).S+({S:""}).S}));
}
(eN)((am),([130,129,2]),({S:")"}));
}
(aFn)=((aEy).yI);
if((aFn)!==(null)){
if((RR)((aFn))){
(vD)(((aFn).qz));
}
}
}
// buildExprArray
function avZ(aFs /*ast*/){
if(!(((aFs).yE)!==(0))){throw 0xE9170000;}
if((Tk)(((aFs).yI))){
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aFs).aoB));
(eN)((am),([130,129,2]),({S:").S.charCodeAt("}));
(WI)(((aFs).aoG));
(eN)((am),([130,129,2]),({S:")"}));
}
else{
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aFs).aoB));
(eN)((am),([130,129,2]),({S:")["}));
(WI)(((aFs).aoG));
(eN)((am),([130,129,2]),({S:"]"}));
}
}
// buildExprDot
function awb(aFw /*ast*/){
let aFz=null; // classItem
let aF2=null; // info
if(!(((aFw).yE)!==(0))){throw 0xE9170000;}
if((RR)((((aFw).anT).yI))){
(aFz)=((aFw).apm);
if(!((aFz)!==(null))){throw 0xE9170000;}
(vD)(((((aFw).anT).yI).qz));
if((((aFz).tS).qc)===(2)){
(aF2)=((uJ)((((aFz).tS).tX)));
(eN)((am),([130,129,2]),({S:"("}));
(WI)(((aFw).anT));
(eN)((am),([130,129,2]),({S:({S:({S:")."}).S+((v)(((aF2).va),([129,2]))).S}).S+({S:""}).S}));
}
else{
if(!((((aFz).tS).qc)===(256))){throw 0xE9170000;}
(aF2)=((uJ)(((aFz).tS)));
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((aF2).va),([129,2]))).S}).S+({S:""}).S}));
}
}
else{
if(!((((aFw).qz).qc)===(2062))){throw 0xE9170000;}
(awn)(((aFw).qz));
}
}
// buildExprValue
function awd(aF5 /*ast*/){
if(!((((aF5).yI).qc)===(1027))){throw 0xE9170000;}
(eN)((am),([130,129,2]),({S:"null"}));
}
// buildExprValuePrim
function awf(aF6 /*ast*/){
let aF7=null; // type
let aFE=0;
(aF7)=((aF6).yI);
if(((s3)((aF7)))||((EN)((aF7)))){
(eN)((am),([130,129,2]),((v)(((aF6).yF),([0]))));
}
else if((Tk)((aF7))){
(eN)((am),([130,129,2]),((v)(((aF6).yF),([5]))));
}
else if((ahj)((aF7))){
(eN)((am),([130,129,2]),((((aF6).yF)===(0x0000000000000000))?({S:"false"}):({S:"true"})));
}
else if(((aF7).qc)===(1025)){
switch((aF7).Az){
case 1:
(eN)((am),([130,129,2]),((v)(((aF6).yF),([4]))));
break;
case 2:
(eN)((am),([130,129,2]),((v)(((aF6).yF),([5]))));
break;
case 4:
(eN)((am),([130,129,2]),((v)(((aF6).yF),([6]))));
break;
case 8:
(eN)((am),([130,129,2]),((v)(((aF6).yF),([7]))));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
}
else{
if(!(false)){throw 0xE9170000;}
}
}
// buildExprValueStr
function awh(aFL /*ast*/){
let aFM=null; // value
let aFN=null; // s
let aFQ=0;
let aFR=0;
(aFM)=((aFL).aiK);
(aFN)=({S:"{S:\""});
aFP:
for(aFQ=(0),aFR=(((aFM).S.length)-(1));aFQ<=aFR;aFQ+=(1)){
(aFN)=({S:(aFN).S+((Kd)(((aFM).S.charCodeAt(aFQ)))).S});
}
(aFN)=({S:(aFN).S+({S:"\"}"}).S});
(eN)((am),([130,129,2]),(aFN));
}
// buildExprValueFloat
function awj(aFU /*ast*/){
let aFV=null; // value
(aFV)=((v)(((aFU).ahg),([1])));
if((aFV).S===({S:"inf"}).S){
(eN)((am),([130,129,2]),({S:"Infinity"}));
}
else{
(eN)((am),([130,129,2]),(aFV));
}
}
// buildExprValueArray
function awl(aFZ /*ast*/){
let aGa=false; // first
let aGb=null; // items
(eN)((am),([130,129,2]),({S:"["}));
(aGa)=(true);
(aGb)=((aFZ).aoc);
(qr)((aGb),([130,134]));
while(!((qt)((aGb),([130,134])))){
if(aGa){
(aGa)=(false);
(eN)((am),([130,129,2]),({S:"("}));
}
else{
(eN)((am),([130,129,2]),({S:",("}));
}
(WI)(((qv)((aGb),([130,134]))));
(eN)((am),([130,129,2]),({S:")"}));
(r8)((aGb),([130,134]));
}
(eN)((am),([130,129,2]),({S:"]"}));
}
// buildExprRef
function awn(aGg /*ast*/){
let aGh=null; // ast2
let aGi=null; // info
let aGm=null; // arg
let aGo=0;
(aGh)=((aGg).qz);
(aGi)=((uJ)((aGh)));
if(((aGh).qc)===(256)){
(eQ)((aj),([132,134]),(aGh));
(eN)((am),([130,129,2]),((aGi).va));
}
else{
if(!(((aGh).qc)===(7))){throw 0xE9170000;}
(aGm)=(aGh);
switch((aGm).rp){
case 1:
if(!((aGi).uM)){
((aGi).uM)=(true);
(eN)((ao),([130,134]),(aGm));
}
break;
case 2:
break;
case 3:
if(!((aGi).uM)){
((aGi).uM)=(true);
(eN)((ap),([130,134]),(aGm));
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
if((aGm).sJ){
(eN)((am),([130,129,2]),({S:({S:({S:""}).S+((v)(((aGi).va),([129,2]))).S}).S+({S:".$"}).S}));
}
else{
(eN)((am),([130,129,2]),((aGi).va));
}
}
}
// _findBin
function aw8(aG0 /*me_*/,aG1 /*type*/,aG2 /*item*/){
let a_=0,b_=aG0.length-1,c_,m_,f_;
switch(aG1[0]){
case 0:
case 1:
case 2:
case 4:
case 5:
case 6:
case 7:
case 9:
f_=function(a,b){return a>b?1:a<b?-1:0};
break;
case 129:
f_=function(a,b){return a.S>b.S?1:a.S<b.S?-1:0};
break;
default:
break;
}
while (a_<=b_){
c_=~~((a_+b_)/2);
m_=f_(aG2,aG0[c_]);
if(m_<0)b_=c_-1;
else if(m_>0)a_=c_+1;
else return c_;
}
return -1;
}
// pushDummyScope
function axw(aG3 /*ast*/){
let aG4=null; // dummy
(aG4)=(new c8());
(wE)((aG4),(0),(null),(null),(true));
(bE)((((Zr)((ah),([131,134]))).pY),([133,129,2,134]),({S:({S:"$"}).S+((v)((pK),([0]))).S}),(aG4));
(pK)=((pK)+(1));
((aG4).pY)=(new Map());
(wG)((ah),([131,134]),(aG4));
((aG3).qU)=(aG4);
}
// obtainBlockName
function axx(aG6 /*ast*/){
let aG7=0; // c
(aG7)=((wH)());
if((aG7)!==(0x0028)){
(pH)=(aG7);
((aG6).qX)=((wX)((true),(false)));
(M6)((aG6),(true));
(M2)((0x0028),(true));
}
else{
((aG6).qX)=({S:"$"});
}
}
// parseDummyBlock
function ax0(aGB /*outStat*/,aGC /*outTypeId*/,aGD /*typeId*/,aGE /*block_*/){
let aGF=null; // ast
let aGI=null; // stat
let aGO=false; // endFlag
let aGQ=0;
let aGT=0;
let aGX=0;
let aHb=0;
let aHg=0;
let aHk=0;
let aHp=0;
let aHt=0;
let aHx=0;
(aGF)=(new yc());
(wE)((aGF),(66052),((Ld)()),(null),(false));
((aGF).xZ)=(null);
((aGF).yd)=({L:0,H:null,T:null,P:null});
(axw)((aGF));
((aGF).qX)=({S:"$"});
aGH:
while(true){
(aGI)=((MX)((aGE)));
if((aGI)===(null)){
if(pJ){
(aGB.$)=(null);
(aGC.$)=(513);
break aGH;
}
else{
continue aGH;
}
}
(aGO)=(false);
switch(aGD){
case 66049:
switch((aGI).qc){
case 520:
case 521:
case 513:
(aGO)=(true);
break;
}
break;
case 520:
switch((aGI).qc){
case 520:
case 521:
case 513:
(aGO)=(true);
break;
}
break;
case 521:
switch((aGI).qc){
case 520:
case 521:
(D)((65563),((Ld)()),(null));
continue aGH;
break;
case 513:
(aGO)=(true);
break;
}
break;
case 522:
switch((aGI).qc){
case 522:
case 523:
case 513:
(aGO)=(true);
break;
}
break;
case 523:
switch((aGI).qc){
case 522:
case 523:
(D)((65564),((Ld)()),(null));
continue aGH;
break;
case 513:
(aGO)=(true);
break;
}
break;
case 66051:
switch((aGI).qc){
case 524:
case 525:
(aGO)=(true);
break;
}
break;
case 524:
switch((aGI).qc){
case 524:
case 525:
case 520:
(aGO)=(true);
break;
}
break;
case 525:
switch((aGI).qc){
case 524:
case 525:
(D)((65565),((Ld)()),(null));
continue aGH;
break;
case 513:
(aGO)=(true);
break;
}
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
if(aGO){
(aGB.$)=(aGI);
(aGC.$)=((aGI).qc);
break aGH;
}
(eN)(((aGF).yd),([130,134]),(aGI));
}
(xz)((ah),([131,134]));
return aGF;
}
// makeBlockVar
function axT(aH3 /*pos*/){
let aH4=null; // arg
(aH4)=(new ro());
(wE)((aH4),(7),(aH3),(null),(false));
((aH4).rp)=(3);
((aH4).sJ)=(false);
((aH4).s4)=(null);
((aH4).xY)=(null);
return aH4;
}
// makePrimValue
function azl(aH5 /*pos*/,aH6 /*kind*/,aH7 /*value*/){
let aH8=null; // expr
let aHA=null; // type
(aH8)=(new yC());
(Ox)((aH8),(67585),(aH5));
(aHA)=(new xW());
(wE)((aHA),(1026),(aH5),(null),(false));
((aHA).xX)=(aH6);
((aH8).yI)=(aHA);
((aH8).yF)=(aH7);
return aH8;
}
// parseExprOr
function a0P(){
let aHB=null; // ast
let aHF=0; // row
let aHG=0; // col
let aHH=0; // c
let aHK=null; // ast2
(aHB)=((aHC)());
aHE:
while(true){
(aHF)=(pF);
(aHG)=(pG);
(aHH)=((wH)());
if((aHH)===(0x007C)){
(aHK)=(new zI());
(Ox)((aHK),(2050),((wF)((ag),(aHF),(aHG))));
((aHK).zJ)=(8);
((aHK).zM)=(aHB);
((aHK).zN)=((aHC)());
(aHB)=(aHK);
}
else{
(pH)=(aHH);
break aHE;
}
}
return aHB;
}
// addSpecialFunc
function a2K(aHM /*class_*/,aHN /*name*/){
let aHO=null; // ast
let aHQ=null; // me_
let aHS=null; // type
let aHU=null; // item
let aHV=null; // ptr
let aHX=null; // items
let aIa=null; // item2
(aHO)=(new c7());
(xM)((aHO),(256),((aHM).ql));
((aHO).qX)=(aHN);
((aHO).qi)=(0);
((aHO).qj)=({L:0,H:null,T:null,P:null});
((aHO).qg)=({L:0,H:null,T:null,P:null});
((aHO).qh)=(null);
((aHO).tp)=({L:0,H:null,T:null,P:null});
(aHQ)=(new ro());
(xM)((aHQ),(7),((aHM).ql));
((aHQ).rp)=(2);
((aHQ).sJ)=(false);
((aHQ).xY)=(null);
(aHS)=(new M9());
(xM)((aHS),(66565),((aHM).ql));
((aHS).qz)=(aHM);
((aHQ).s4)=(aHS);
(eN)(((aHO).qg),([130,134]),(aHQ));
(aHU)=(new tQ());
((aHU).N5)=(true);
((aHU).tS)=(aHO);
((aHU).N6)=(null);
(aHV)=((aHM).qz);
while(((aHV).qz)!==(null)){
(aHV)=((aHV).qz);
}
(aHX)=((aHV).tg);
(qr)((aHX),([130,134]));
aHZ:
while(!((qt)((aHX),([130,134])))){
(aIa)=((qv)((aHX),([130,134])));
if((((aIa).tS).qX).S===(aHN).S){
((aHU).N6)=(aIa);
break aHZ;
}
(r8)((aHX),([130,134]));
}
if(!(((aHU).N6)!==(null))){throw 0xE9170000;}
((aHU).N4)=(((aHU).N6).N4);
(eN)(((aHM).tg),([130,134]),(aHU));
return aHO;
}
// makeMeDot
function a3v(aId /*class_*/,aIe /*arg*/,aIf /*name*/){
let aIg=null; // ast
let aIi=null; // me_
let aIk=null; // type
(aIg)=(new Q5());
(yu)((aIg),(2059),((aId).ql));
((aIg).aoZ)=(aIf);
((aIg).apm)=(null);
(aIi)=(new yt());
(yu)((aIi),(2062),((aId).ql));
((aIi).q0)=({S:"me"});
((aIi).qz)=(aIe);
(aIk)=(new M9());
(xM)((aIk),(66565),((aId).ql));
((aIk).qz)=(aId);
((aIi).yI)=(aIk);
((aIg).anT)=(aIi);
return aIg;
}
// makeTypeId
function aCa(aIl /*type*/){
let aIm=null; // result
let aIn=false; // first
let aIo=null; // items
(aIm)=({S:"["});
(aIn)=(true);
(aIo)=((aIp)((aIl)));
(qr)((aIo),([130,0]));
while(!((qt)((aIo),([130,0])))){
if(aIn){
(aIn)=(false);
}
else{
(aIm)=({S:(aIm).S+({S:","}).S});
}
(aIm)=({S:(aIm).S+((v)(((qv)((aIo),([130,0]))),([0]))).S});
(r8)((aIo),([130,0]));
}
(aIm)=({S:(aIm).S+({S:"]"}).S});
return aIm;
}
// parseExprAnd
function aHC(){
let aIx=null; // ast
let aI1=0; // row
let aI2=0; // col
let aI3=0; // c
let aI6=null; // ast2
(aIx)=((aIy)());
aI0:
while(true){
(aI1)=(pF);
(aI2)=(pG);
(aI3)=((wH)());
if((aI3)===(0x0026)){
(aI6)=(new zI());
(Ox)((aI6),(2050),((wF)((ag),(aI1),(aI2))));
((aI6).zJ)=(9);
((aI6).zM)=(aIx);
((aI6).zN)=((aIy)());
(aIx)=(aI6);
}
else{
(pH)=(aI3);
break aI0;
}
}
return aIx;
}
// getTypeId
function aIp(aI8 /*type*/){
let aI9=null; // result
(aI9)=({L:0,H:null,T:null,P:null});
(aIA)((aI8),(aI9));
return aI9;
}
// parseExprCmp
function aIy(){
let aIB=null; // ast
let aIF=0; // row
let aIG=0; // col
let aIH=0; // c
let aIJ=0;
let aIM=0;
let aIO=null; // ast2
let aIR=0;
let aIT=null; // ast2
let aIV=null; // ast2
let aIX=null; // ast2
let aIZ=null; // ast2
let aJb=null; // ast2
let aJh=0;
let aJj=null; // ast2
let aJl=null; // ast2
let aJn=null; // ast2
(aIB)=((aIC)());
aIE:
while(true){
(aIF)=(pF);
(aIG)=(pG);
(aIH)=((wH)());
switch(aIH){
case 0x003C:
(aIH)=((xt)());
switch(aIH){
case 0x003D:
(aIO)=(new zI());
(Ox)((aIO),(2050),((wF)((ag),(aIF),(aIG))));
((aIO).zJ)=(12);
((aIO).zM)=(aIB);
((aIO).zN)=((aIC)());
(aIB)=(aIO);
break;
case 0x003E:
(aIH)=((xt)());
switch(aIH){
case 0x0026:
(aIT)=(new zI());
(Ox)((aIT),(2050),((wF)((ag),(aIF),(aIG))));
((aIT).zJ)=(17);
((aIT).zM)=(aIB);
((aIT).zN)=((aIC)());
(aIB)=(aIT);
break;
case 0x0024:
(aIV)=(new Qr());
(Ox)((aIV),(2054),((wF)((ag),(aIF),(aIG))));
((aIV).amf)=(2);
((aIV).alX)=(aIB);
((aIV).ama)=((MR)());
(aIB)=(aIV);
break;
default:
(pH)=(aIH);
(aIX)=(new zI());
(Ox)((aIX),(2050),((wF)((ag),(aIF),(aIG))));
((aIX).zJ)=(15);
((aIX).zM)=(aIB);
((aIX).zN)=((aIC)());
(aIB)=(aIX);
break;
}
break;
default:
(pH)=(aIH);
(aIZ)=(new zI());
(Ox)((aIZ),(2050),((wF)((ag),(aIF),(aIG))));
((aIZ).zJ)=(10);
((aIZ).zM)=(aIB);
((aIZ).zN)=((aIC)());
(aIB)=(aIZ);
break;
}
break;
case 0x003E:
(aJb)=(new zI());
(Ox)((aJb),(2050),((wF)((ag),(aIF),(aIG))));
(aIH)=((xt)());
if((aIH)===(0x003D)){
((aJb).zJ)=(13);
}
else{
(pH)=(aIH);
((aJb).zJ)=(11);
}
((aJb).zM)=(aIB);
((aJb).zN)=((aIC)());
(aIB)=(aJb);
break;
case 0x003D:
(aIH)=((xt)());
switch(aIH){
case 0x0026:
(aJj)=(new zI());
(Ox)((aJj),(2050),((wF)((ag),(aIF),(aIG))));
((aJj).zJ)=(16);
((aJj).zM)=(aIB);
((aJj).zN)=((aIC)());
(aIB)=(aJj);
break;
case 0x0024:
(aJl)=(new Qr());
(Ox)((aJl),(2054),((wF)((ag),(aIF),(aIG))));
((aJl).amf)=(1);
((aJl).alX)=(aIB);
((aJl).ama)=((MR)());
(aIB)=(aJl);
break;
default:
(pH)=(aIH);
(aJn)=(new zI());
(Ox)((aJn),(2050),((wF)((ag),(aIF),(aIG))));
((aJn).zJ)=(14);
((aJn).zM)=(aIB);
((aJn).zN)=((aIC)());
(aIB)=(aJn);
break;
}
break;
default:
(pH)=(aIH);
break aIE;
break;
}
}
return aIB;
}
// makeTypeIdRecursion
function aIA(aJp /*type*/,aJq /*output*/){
let aJ2=0;
let aJH=0;
if((s3)((aJp))){
(eN)((aJq),([130,0]),(0));
return;
}
if((agT)((aJp))){
(eN)((aJq),([130,0]),(1));
return;
}
if((Tk)((aJp))){
(eN)((aJq),([130,0]),(2));
return;
}
if((ahj)((aJp))){
(eN)((aJq),([130,0]),(3));
return;
}
if(((aJp).qc)===(1025)){
switch((aJp).Az){
case 1:
(eN)((aJq),([130,0]),(4));
break;
case 2:
(eN)((aJq),([130,0]),(5));
break;
case 4:
(eN)((aJq),([130,0]),(6));
break;
case 8:
(eN)((aJq),([130,0]),(7));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
return;
}
if(((aJp).qc)===(66562)){
(eN)((aJq),([130,0]),(8));
return;
}
if((EN)((aJp))){
(eN)((aJq),([130,0]),(9));
return;
}
if(((aJp).qc)===(66561)){
(eN)((aJq),([130,0]),(129));
(aIA)(((aJp).Aw),(aJq));
return;
}
if(((aJp).qc)===(66563)){
switch((aJp).AS){
case 0:
(eN)((aJq),([130,0]),(130));
break;
case 1:
(eN)((aJq),([130,0]),(131));
break;
case 2:
(eN)((aJq),([130,0]),(132));
break;
default:
if(!(false)){throw 0xE9170000;}
break;
}
(aIA)(((aJp).AU),(aJq));
return;
}
if(((aJp).qc)===(66564)){
(eN)((aJq),([130,0]),(133));
(aIA)(((aJp).Bb),(aJq));
(aIA)(((aJp).Bc),(aJq));
return;
}
if(!((RR)((aJp)))){throw 0xE9170000;}
(eN)((aJq),([130,0]),(134));
}
// parseExprCat
function aIC(){
let aJO=null; // ast
let aJS=0; // row
let aJT=0; // col
let aJU=0; // c
let aJX=null; // ast2
(aJO)=((aJP)());
aJR:
while(true){
(aJS)=(pF);
(aJT)=(pG);
(aJU)=((wH)());
if((aJU)===(0x007E)){
(aJX)=(new zI());
(Ox)((aJX),(2050),((wF)((ag),(aJS),(aJT))));
((aJX).zJ)=(18);
((aJX).zM)=(aJO);
((aJX).zN)=((aJP)());
(aJO)=(aJX);
}
else{
(pH)=(aJU);
break aJR;
}
}
return aJO;
}
// parseExprAdd
function aJP(){
let aJZ=null; // ast
let aKd=0; // row
let aKe=0; // col
let aKf=0; // c
let aKh=0;
let aKj=null; // ast2
let aKl=null; // ast2
(aJZ)=((aKa)());
aKc:
while(true){
(aKd)=(pF);
(aKe)=(pG);
(aKf)=((wH)());
switch(aKf){
case 0x002B:
(aKj)=(new zI());
(Ox)((aKj),(2050),((wF)((ag),(aKd),(aKe))));
((aKj).zJ)=(19);
((aKj).zM)=(aJZ);
((aKj).zN)=((aKa)());
(aJZ)=(aKj);
break;
case 0x002D:
(aKl)=(new zI());
(Ox)((aKl),(2050),((wF)((ag),(aKd),(aKe))));
((aKl).zJ)=(20);
((aKl).zM)=(aJZ);
((aKl).zN)=((aKa)());
(aJZ)=(aKl);
break;
default:
(pH)=(aKf);
break aKc;
break;
}
}
return aJZ;
}
// parseExprMul
function aKa(){
let aKn=null; // ast
let aKr=0; // row
let aKs=0; // col
let aKt=0; // c
let aKv=0;
let aKx=null; // ast2
let aKz=null; // ast2
let aK1=null; // ast2
(aKn)=((aKo)());
aKq:
while(true){
(aKr)=(pF);
(aKs)=(pG);
(aKt)=((wH)());
switch(aKt){
case 0x002A:
(aKx)=(new zI());
(Ox)((aKx),(2050),((wF)((ag),(aKr),(aKs))));
((aKx).zJ)=(21);
((aKx).zM)=(aKn);
((aKx).zN)=((aKo)());
(aKn)=(aKx);
break;
case 0x002F:
(aKz)=(new zI());
(Ox)((aKz),(2050),((wF)((ag),(aKr),(aKs))));
((aKz).zJ)=(22);
((aKz).zM)=(aKn);
((aKz).zN)=((aKo)());
(aKn)=(aKz);
break;
case 0x0025:
(aK1)=(new zI());
(Ox)((aK1),(2050),((wF)((ag),(aKr),(aKs))));
((aK1).zJ)=(23);
((aK1).zM)=(aKn);
((aK1).zN)=((aKo)());
(aKn)=(aK1);
break;
default:
(pH)=(aKt);
break aKq;
break;
}
}
return aKn;
}
// parseExprPlus
function aKo(){
let aK3=null; // ast
let aK7=0; // row
let aK8=0; // col
let aK9=0; // c
let aKD=0;
let aKF=null; // ast2
let aKP=null; // ast2
let aKR=null; // ast2
let aKT=null; // ast2
let aKV=0;
(aK3)=((aK4)());
if((aK3)!==(null)){
return aK3;
}
(aK7)=(pF);
(aK8)=(pG);
(aK9)=((wH)());
if((aK9)===(0x0023)){
(aK9)=((xt)());
switch(aK9){
case 0x005B:
(aKF)=(new Qo());
(Ox)((aKF),(2053),((wF)((ag),(aK7),(aK8))));
((aKF).alC)=({L:0,H:null,T:null,P:null});
aKH:
while(true){
(eN)(((aKF).alC),([130,134]),((Os)()));
(aK9)=((wH)());
if((aK9)===(0x0000)){
break aKH;
}
if((aK9)===(0x005D)){
break aKH;
}
if((aK9)!==(0x002C)){
(Mx)((0x002C),(aK9));
return null;
}
}
((aKF).alK)=((MR)());
(aK3)=(aKF);
break;
case 0x0023:
(aKP)=(new Qd());
(Ox)((aKP),(2049),((wF)((ag),(aK7),(aK8))));
((aKP).agQ)=(3);
((aKP).agK)=((aKo)());
(aK3)=(aKP);
break;
default:
(pH)=(aK9);
(aKR)=(new Ql());
(Ox)((aKR),(2052),((wF)((ag),(aK7),(aK8))));
((aKR).al0)=((MR)());
(aK3)=(aKR);
break;
}
}
else{
(aKT)=(new Qd());
(Ox)((aKT),(2049),((wF)((ag),(aK7),(aK8))));
switch(aK9){
case 0x002B:
((aKT).agQ)=(0);
break;
case 0x002D:
((aKT).agQ)=(1);
break;
case 0x0021:
((aKT).agQ)=(2);
break;
case 0x005E:
((aKT).agQ)=(4);
break;
default:
(D)((65569),((aKT).ql),([((Le)((aK9)))]));
(xs)((aK9));
return null;
break;
}
((aKT).agK)=((aKo)());
(aK3)=(aKT);
}
return aK3;
}
// parseExprPow
function aK4(){
let aLb=null; // ast
let aLf=0; // row
let aLg=0; // col
let aLh=0; // c
let aLk=null; // ast2
(aLb)=((aLc)());
if((aLb)===(null)){
return aLb;
}
(aLf)=(pF);
(aLg)=(pG);
(aLh)=((wH)());
if((aLh)===(0x005E)){
(aLk)=(new zI());
(Ox)((aLk),(2050),((wF)((ag),(aLf),(aLg))));
((aLk).zJ)=(24);
((aLk).zM)=(aLb);
((aLk).zN)=((aKo)());
(aLb)=(aLk);
}
else{
(pH)=(aLh);
}
return aLb;
}
// parseExprCall
function aLc(){
let aLm=null; // ast
let aLs=0; // row
let aLt=0; // col
let aLu=0; // c
let aLw=0;
let aLy=null; // ast2
let aL3=null; // arg
let aLB=null; // ast3
let aLK=null; // ast2
let aLM=null; // ast2
let aLP=0;
let aLR=null; // ast2
let aLT=null; // ast2
let aLV=null; // ast2
(aLm)=((aLn)());
if((aLm)===(null)){
return aLm;
}
aLr:
while(true){
(aLs)=(pF);
(aLt)=(pG);
(aLu)=((wH)());
switch(aLu){
case 0x0028:
if(!((aLm)!==(null))){throw 0xE9170000;}
(aLy)=(new ys());
(Ox)((aLy),(2057),((wF)((ag),(aLs),(aLt))));
((aLy).yy)=(aLm);
((aLy).yv)=({L:0,H:null,T:null,P:null});
(aLu)=((wH)());
if((aLu)!==(0x0029)){
(pH)=(aLu);
aL2:
while(true){
(aL3)=(new yX());
((aL3).yZ)=(false);
(aLu)=((wH)());
if((aLu)===(0x0026)){
((aL3).yY)=(true);
(aLu)=((wH)());
if(((aLu)===(0x002C))||((aLu)===(0x0029))){
((aL3).yZ)=(true);
}
}
else{
((aL3).yY)=(false);
}
(pH)=(aLu);
if((aL3).yZ){
(aLB)=(new yt());
(Ox)((aLB),(2062),((aLy).ql));
((aLB).q0)=({S:"$"});
((aLB).qz)=((axT)(((aLB).ql)));
((aL3).zc)=(aLB);
}
else{
((aL3).zc)=((Os)());
}
(eN)(((aLy).yv),([130,134]),(aL3));
(aLu)=((wH)());
if((aLu)===(0x0000)){
break aL2;
}
if((aLu)===(0x0029)){
break aL2;
}
if((aLu)!==(0x002C)){
(Mx)((0x002C),(aLu));
return null;
}
}
}
(aLm)=(aLy);
break;
case 0x005B:
if(!((aLm)!==(null))){throw 0xE9170000;}
(aLK)=(new Q2());
(Ox)((aLK),(2058),((wF)((ag),(aLs),(aLt))));
((aLK).aoB)=(aLm);
((aLK).aoG)=((Os)());
(M2)((0x005D),(true));
(aLm)=(aLK);
break;
case 0x002E:
if(!((aLm)!==(null))){throw 0xE9170000;}
(aLM)=(new Q5());
(Ox)((aLM),(2059),((wF)((ag),(aLs),(aLt))));
((aLM).anT)=(aLm);
((aLM).aoZ)=((wX)((true),(false)));
((aLM).apm)=(null);
(aLm)=(aLM);
break;
case 0x0024:
if(!((aLm)!==(null))){throw 0xE9170000;}
(aLu)=((xt)());
switch(aLu){
case 0x003E:
(aLR)=(new Qu());
(Ox)((aLR),(2055),((wF)((ag),(aLs),(aLt))));
((aLR).ant)=(aLm);
((aLR).anz)=((MR)());
(aLm)=(aLR);
break;
case 0x003C:
(aLT)=(new Qx());
(Ox)((aLT),(2056),((wF)((ag),(aLs),(aLt))));
((aLT).an4)=(aLm);
((aLT).an9)=((MR)());
((aLT).anA)=((azl)(((aLT).ql),(0),(0x0000000000000000)));
(aLm)=(aLT);
break;
default:
(pH)=(aLu);
(aLV)=(new Qr());
(Ox)((aLV),(2054),((wF)((ag),(aLs),(aLt))));
((aLV).amf)=(0);
((aLV).alX)=(aLm);
((aLV).ama)=((MR)());
(aLm)=(aLV);
break;
}
break;
default:
(pH)=(aLu);
break aLr;
break;
}
}
return aLm;
}
// parseExprValue
function aLn(){
let aLX=0; // row
let aLY=0; // col
let aLZ=0; // c
let aMa=null; // pos
let aMc=0;
let aMe=null; // buf
let aMf=0; // len
let aMg=false; // esc
let aMp=null; // cat
let aMr=null; // cat2
let aMu=null; // call
let aMw=null; // dot
let aMD=0; // buf
let aME=false; // set
let aMF=false; // esc
let aMX=null; // ast
let aNb=null; // ast
let aNg=null; // expr
let aNq=null; // id
let aNr=null; // expr
let aNt=null; // type
let aN1=null; // id
let aN3=null;
let aN9=null; // ast
let aNB=null; // type
let aNF=null; // ast
let aMz=0;
let aM0=0;
let aM9=0;
let aMA=0;
(aLX)=(pF);
(aLY)=(pG);
(aLZ)=((wH)());
(aMa)=((wF)((ag),(aLX),(aLY)));
switch(aLZ){
case 0x0022:
(aMe)=({S:"\0".repeat(1024)});
(aMf)=(0);
(aMg)=(false);
aMi:
while(true){
(aLZ)=((adR)());
if((aLZ)===(0x0000)){
(D)((65573),(aMa),(null));
return null;
}
if(aMg){
if((aLZ)===(0x007B)){
(aMp)=(new zI());
(Ox)((aMp),(2050),(aMa));
((aMp).zJ)=(18);
(aMr)=(new zI());
(Ox)((aMr),(2050),(aMa));
((aMr).zJ)=(18);
((aMr).zM)=((aMs)((aMa),((p9)((aMe),([129,2]),(0),(aMf)))));
(aMu)=(new ys());
(Ox)((aMu),(2057),(aMa));
((aMu).yv)=({L:0,H:null,T:null,P:null});
(aMw)=(new Q5());
(Ox)((aMw),(2059),(aMa));
((aMw).anT)=((Os)());
((aMw).aoZ)=({S:"toStr"});
((aMw).apm)=(null);
((aMu).yy)=(aMw);
((aMr).zN)=(aMu);
(M2)((0x007D),(false));
((aMp).zM)=(aMr);
(pH)=(0x0022);
((aMp).zN)=((aLn)());
return aMp;
}
if((aMf)===(1024)){
(D)((65570),(aMa),([(aMe)]));
(xs)((aLZ));
return null;
}
(aMe).S=(aMz=(aMf),(aMe).S.slice(0,aMz)+String.fromCharCode((aM1)((aLZ)))+(aMe).S.slice(aMz+1));
(aMf)=((aMf)+(1));
(aMg)=(false);
continue aMi;
}
if((aLZ)===(0x0022)){
break aMi;
}
if((aLZ)===(0x005C)){
(aMg)=(true);
continue aMi;
}
if((aMf)===(1024)){
(D)((65570),(aMa),([(aMe)]));
(xs)((aLZ));
return null;
}
(aMe).S=(aM9=(aMf),(aMe).S.slice(0,aM9)+String.fromCharCode(aLZ)+(aMe).S.slice(aM9+1));
(aMf)=((aMf)+(1));
}
return (aMs)((aMa),((p9)((aMe),([129,2]),(0),(aMf))));
break;
case 0x0027:
(aMD)=(0x0000);
(aME)=(false);
(aMF)=(false);
aMH:
while(true){
(aLZ)=((adR)());
if((aLZ)===(0x0000)){
(D)((65573),(aMa),(null));
return null;
}
if(aMF){
if(aME){
(D)((65574),(aMa),([((Le)((aMD)))]));
(xs)((aLZ));
return null;
}
(aMD)=((aM1)((aLZ)));
(aME)=(true);
(aMF)=(false);
continue aMH;
}
if((aLZ)===(0x0027)){
break aMH;
}
if((aLZ)===(0x005C)){
(aMF)=(true);
continue aMH;
}
if(aME){
(D)((65574),(aMa),([((Le)((aMD)))]));
(xs)((aLZ));
return null;
}
(aMD)=(aLZ);
(aME)=(true);
}
if(!(aME)){
(D)((65575),(aMa),(null));
(xs)((aLZ));
return null;
}
return (azl)((aMa),(2),(aMD));
break;
case 0x0028:
(aMX)=((Os)());
(aLZ)=((wH)());
if((aLZ)!==(0x0029)){
(D)((65576),(aMa),(null));
(xs)((aLZ));
return null;
}
return aMX;
break;
case 0x005B:
(aNb)=(new QL());
(Ox)((aNb),(2060),(aMa));
((aNb).aoc)=({L:0,H:null,T:null,P:null});
(aLZ)=((wH)());
if((aLZ)!==(0x005D)){
(pH)=(aLZ);
aNf:
while(true){
(aNg)=((Os)());
if((aNg)!==(null)){
(eN)(((aNb).aoc),([130,134]),(aNg));
}
(aLZ)=((wH)());
if((aLZ)===(0x0000)){
break aNf;
}
if((aLZ)===(0x005D)){
break aNf;
}
if((aLZ)!==(0x002C)){
(Mx)((0x002C),(aLZ));
return null;
}
}
}
return aNb;
break;
case 0x0025:
(aNq)=((wX)((false),(false)));
(aNr)=(new QF());
(Ox)((aNr),(67587),(aMa));
(aNt)=(new aNu());
(wE)((aNt),(1028),(aMa),(null),(false));
((aNr).yI)=(aNt);
((aNr).aig)=(aNq);
return aNr;
break;
default:
if(((0x0030)<=(aLZ))&&((aLZ)<=(0x0039))){
return (aNy)((aLX),(aLY),(aLZ));
}
if(((((((0x0061)<=(aLZ))&&((aLZ)<=(0x007A)))||(((0x0041)<=(aLZ))&&((aLZ)<=(0x005A))))||((aLZ)===(0x005F)))||((aLZ)===(0x0040)))||((aLZ)===(0x005C))){
(pH)=(aLZ);
(aN1)=((wX)((true),(true)));
aN3=aN1;
if(aN3.S===({S:"false"}).S){
return (azl)((aMa),(3),(0x0000000000000000));
}
else if(aN3.S===({S:"true"}).S){
return (azl)((aMa),(3),(0x0000000000000001));
}
else if(aN3.S===({S:"inf"}).S){
return (aN7)((aMa),(Infinity));
}
else if(aN3.S===({S:"null"}).S){
(aN9)=(new yD());
(Ox)((aN9),(67584),(aMa));
(aNB)=(new RW());
(wE)((aNB),(1027),(aMa),(null),(false));
((aN9).yI)=(aNB);
return aN9;
}
else if(aN3.S===({S:"dbg"}).S){
return (azl)((aMa),(3),((aW)?(0x0000000000000000):(0x0000000000000001)));
}
else if(aN3.S===({S:"env"}).S){
return (azl)((aMa),(0),(bL));
}
else{(aNF)=(new yt());
(Ox)((aNF),(2062),(aMa));
(M1)((aNF),(aN1));
return aNF;
}
}
break;
}
(pH)=(aLZ);
return null;
}
// makeStrValue
function aMs(aNG /*pos*/,aNH /*value*/){
let aNI=null; // expr
let aNK=null; // type
let aNM=null; // type2
(aNI)=(new QC());
(Ox)((aNI),(67586),(aNG));
(aNK)=(new Au());
(wE)((aNK),(66561),(aNG),(null),(false));
(aNM)=(new xW());
(wE)((aNM),(1026),(aNG),(null),(false));
((aNM).xX)=(2);
((aNK).Aw)=(aNM);
((aNI).yI)=(aNK);
((aNI).aiK)=(aNH);
return aNI;
}
// escChar
function aM1(aNN /*c*/){
let aNP=0;
let aNV=null; // buf
let aOc=0;
let aOk=false;
let aNW=0;
let aNX=0;
let aNY=0;
let aNZ=0;
let aOd=0;
let aOg=0;
let aOh=0;
let aOi=0;
let aOj=false;
switch(aNN){
case 0x0022:
case 0x0027:
case 0x005C:
return aNN;
break;
case 0x0030:
return 0x0000;
break;
case 0x006E:
return 0x000A;
break;
case 0x0074:
return 0x0009;
break;
case 0x0075:
(aNV)=({S:"\0".repeat(6)});
(aNV).S=(aNW=(0),(aNV).S.slice(0,aNW)+String.fromCharCode(0x0030)+(aNV).S.slice(aNW+1));
(aNV).S=(aNY=(1),(aNV).S.slice(0,aNY)+String.fromCharCode(0x0078)+(aNV).S.slice(aNY+1));
aOb:
for(aOc=(0),aOd=(3);aOc<=aOd;aOc+=(1)){
(aNN)=((adR)());
if(!((((0x0030)<=(aNN))&&((aNN)<=(0x0039)))||(((0x0041)<=(aNN))&&((aNN)<=(0x0046))))){
(D)((65572),((Ld)()),(null));
return 0x0075;
}
(aNV).S=(aOg=((2)+(aOc)),(aNV).S.slice(0,aOg)+String.fromCharCode(aNN)+(aNV).S.slice(aOg+1));
}
return (aOi=(ca)((aNV),(aOj={$:(aOk)},aOj)),(aOk)=aOj.$,aOi);
break;
default:
(D)((65571),((Ld)()),([((Le)((aNN)))]));
return aNN;
break;
}
}
// parseExprNumber
function aNy(aOm /*row*/,aOn /*col*/,aOo /*c*/){
let aOp=null; // pos
let aOq=null; // buf
let aOr=0; // len
let aOs=0; // base
let aOt=false; // changeBase
let aOu=false; // floatType
let aOv=0; // byteSize
let aOz=0;
let aPl=0; // value
let aPp=false; // success
let aPs=null; // ast2
let aPt=null; // ast
let aPy=0;
let aP8=0; // value
let aPC=false; // success
let aPK=null; // ast2
let aPN=null; // type
let aPS=null; // type
let aOA=0;
let aOB=0;
let aOG=0;
let aOH=0;
let aOS=0;
let aOT=0;
let aOZ=0;
let aPa=0;
let aPh=0;
let aPi=0;
let aPm=0;
let aPo=false;
let aP9=0;
let aPB=false;
let aPE=0;
let aPF=false;
(aOp)=((wF)((ag),(aOm),(aOn)));
(aOq)=({S:"\0".repeat(1024)});
(aOr)=(0);
(aOs)=(10);
(aOt)=(false);
(aOu)=(false);
(aOv)=(0);
aOx:
while(true){
aOz=aOo;
if(aOz===(0x0078)){
if((aOt)||(aOu)){
(D)((65577),(aOp),([({S:"x"})]));
(xs)((aOo));
return null;
}
if(((aOr)!==(1))||(((aOq).S.charCodeAt(0))!==(0x0030))){
(D)((65579),(aOp),(null));
(xs)((aOo));
return null;
}
(aOr)=(0);
(aOs)=(16);
(aOt)=(true);
}
else if(aOz===(0x002E)){
if((aOt)||(aOu)){
(D)((65577),(aOp),([({S:"."})]));
(xs)((aOo));
return null;
}
if((aOr)===(1024)){
(D)((65578),(aOp),([((p9)((aOq),([129,2]),(0),(aOr)))]));
(xs)((aOo));
return null;
}
(aOq).S=(aOA=(aOr),(aOq).S.slice(0,aOA)+String.fromCharCode(aOo)+(aOq).S.slice(aOA+1));
(aOr)=((aOr)+(1));
(aOu)=(true);
}
else if((0x0030)<=aOz&&aOz<=(0x0039)||(0x0041)<=aOz&&aOz<=(0x0046)){
if((aOr)===(1024)){
(D)((65578),(aOp),([((p9)((aOq),([129,2]),(0),(aOr)))]));
(xs)((aOo));
return null;
}
(aOq).S=(aOG=(aOr),(aOq).S.slice(0,aOG)+String.fromCharCode(aOo)+(aOq).S.slice(aOG+1));
(aOr)=((aOr)+(1));
}
else{(pH)=(aOo);
break aOx;
}
(aOo)=((xt)());
}
if(((aOr)===(0))||(((aOq).S.charCodeAt((aOr)-(1)))===(0x002E))){
(D)((65577),(aOp),([({S:"."})]));
(xs)(((xt)()));
return null;
}
if(aOu){
(aOo)=((xt)());
if((aOo)===(0x0065)){
if((aOr)===(1024)){
(D)((65578),(aOp),([((p9)((aOq),([129,2]),(0),(aOr)))]));
(xs)((aOo));
return null;
}
(aOq).S=(aOS=(aOr),(aOq).S.slice(0,aOS)+String.fromCharCode(aOo)+(aOq).S.slice(aOS+1));
(aOr)=((aOr)+(1));
(aOo)=((xt)());
if(((aOo)!==(0x002B))&&((aOo)!==(0x002D))){
(D)((65580),(aOp),(null));
(xs)((aOo));
return null;
}
if((aOr)===(1024)){
(D)((65578),(aOp),([((p9)((aOq),([129,2]),(0),(aOr)))]));
(xs)((aOo));
return null;
}
(aOq).S=(aOZ=(aOr),(aOq).S.slice(0,aOZ)+String.fromCharCode(aOo)+(aOq).S.slice(aOZ+1));
(aOr)=((aOr)+(1));
(aOo)=((xt)());
if(!(((0x0030)<=(aOo))&&((aOo)<=(0x0039)))){
(D)((65580),(aOp),(null));
(xs)((aOo));
return null;
}
do{
if((aOr)===(1024)){
(D)((65578),(aOp),([((p9)((aOq),([129,2]),(0),(aOr)))]));
(xs)((aOo));
return null;
}
(aOq).S=(aPh=(aOr),(aOq).S.slice(0,aPh)+String.fromCharCode(aOo)+(aOq).S.slice(aPh+1));
(aOr)=((aOr)+(1));
(aOo)=((xt)());
}while(((0x0030)<=(aOo))&&((aOo)<=(0x0039)));
}
(pH)=(aOo);
(aPl)=((aPm=(aPn)(((p9)((aOq),([129,2]),(0),(aOr))),(aPo={$:(aPp)},aPo)),(aPp)=aPo.$,aPm));
if(!(aPp)){
(D)((65581),(aOp),([((p9)((aOq),([129,2]),(0),(aOr)))]));
(xs)(((xt)()));
return null;
}
(aPs)=(new QI());
(Ox)((aPs),(67588),(aOp));
((aPs).ahg)=(aPl);
(aPt)=(aPs);
}
else{
(aOo)=((xt)());
if((aOo)===(0x0062)){
(aOo)=((xt)());
switch(aOo){
case 0x0038:
(aOv)=(1);
break;
case 0x0031:
(M2)((0x0036),(false));
(aOv)=(2);
break;
case 0x0033:
(M2)((0x0032),(false));
(aOv)=(4);
break;
case 0x0036:
(M2)((0x0034),(false));
(aOv)=(8);
break;
default:
(D)((65582),(aOp),([((p9)((aOq),([129,2]),(0),(aOr)))]));
(xs)((aOo));
break;
}
}
else{
(pH)=(aOo);
}
if((aOs)===(10)){
(aP8)=((aP9=(aPA)(((p9)((aOq),([129,2]),(0),(aOr))),(aPB={$:(aPC)},aPB)),(aPC)=aPB.$,aP9));
}
else{
if(!((aOs)===(16))){throw 0xE9170000;}
(aP8)=((aPE=(aPA)(({S:({S:"0x"}).S+((p9)((aOq),([129,2]),(0),(aOr))).S}),(aPF={$:(aPC)},aPF)),(aPC)=aPF.$,aPE));
}
if(!(aPC)){
(D)((65583),(aOp),([((p9)((aOq),([129,2]),(0),(aOr)))]));
(xs)(((xt)()));
return null;
}
if((((((aOv)===(1))&&((aP8)>(0x00000000000000FF)))||(((aOv)===(2))&&((aP8)>(0x000000000000FFFF))))||(((aOv)===(4))&&((aP8)>(0x00000000FFFFFFFF))))||(((aOv)===(0))&&((aP8)>(0x7FFFFFFFFFFFFFFF)))){
(D)((65583),(aOp),([((p9)((aOq),([129,2]),(0),(aOr)))]));
(xs)(((xt)()));
return null;
}
(aPK)=(new yC());
(Ox)((aPK),(67585),(aOp));
((aPK).yF)=(aP8);
(aPt)=(aPK);
}
if((aOv)===(0)){
(aPN)=(new xW());
(wE)((aPN),(1026),(aOp),(null),(false));
if(aOu){
((aPN).xX)=(1);
}
else{
((aPN).xX)=(0);
}
((aPt).yI)=(aPN);
}
else{
(aPS)=(new Ay());
(wE)((aPS),(1025),(aOp),(null),(false));
((aPS).Az)=(aOv);
((aPt).yI)=(aPS);
}
return aPt;
}
// makeFloatValue
function aN7(aPT /*pos*/,aPU /*value*/){
let aPV=null; // expr
let aPX=null; // type
(aPV)=(new QI());
(Ox)((aPV),(67588),(aPT));
(aPX)=(new xW());
(wE)((aPX),(1026),(aPT),(null),(false));
((aPX).xX)=(1);
((aPV).yI)=(aPX);
((aPV).ahg)=(aPU);
return aPV;
}
// _toFloat
function aPn(aPY /*me_*/,aPZ /*success*/){
let r_=Number(aPY.S);
aPZ.$=!isNaN(r_);
return r_;
}
// _toBit64
function aPA(aQa /*me_*/,aQb /*success*/){
if(aQa.S.length>=2&&aQa.S[0]==="0"&&aQa.S[1]==="x"){
let s_=aQa.S.slice(2),r_=Number(aQa.S);
aQb.$=!isNaN(r_);
return parseInt(s_,16);
}else{
let r_=Number(aQa.S);
aQb.$=!isNaN(r_);
return parseInt(aQa.S,10);
}
}
// Class
function cA(){
Object.call(this);
aQc(this);
}
cA.prototype = Object.create(Object.prototype);
// HasType
function c9(){
cA.call(this);
}
c9.prototype = Object.create(cA.prototype);
// Ast
function c8(){
c9.call(this);
}
c8.prototype = Object.create(c9.prototype);
// AstFunc
function c7(){
c8.call(this);
}
c7.prototype = Object.create(c8.prototype);
// ResFiles
function cF(){
cA.call(this);
}
cF.prototype = Object.create(cA.prototype);
// Pos
function dg(){
cA.call(this);
}
dg.prototype = Object.create(cA.prototype);
// Bool
function e2(){
cA.call(this);
}
e2.prototype = Object.create(cA.prototype);
// AstClass
function eZ(){
c8.call(this);
}
eZ.prototype = Object.create(c8.prototype);
// Reader
function pC(){
cA.call(this);
}
pC.prototype = Object.create(cA.prototype);
// AstRoot
function pN(){
c8.call(this);
}
pN.prototype = Object.create(c8.prototype);
// ScopeRefedItem
function qw(){
cA.call(this);
}
qw.prototype = Object.create(cA.prototype);
// AstArg
function ro(){
c8.call(this);
}
ro.prototype = Object.create(c8.prototype);
// CppInfo
function rV(){
c9.call(this);
}
rV.prototype = Object.create(c9.prototype);
// AstType
function td(){
c8.call(this);
}
td.prototype = Object.create(c8.prototype);
// TmpVar
function t2(){
cA.call(this);
}
t2.prototype = Object.create(cA.prototype);
// AstClassItem
function tQ(){
cA.call(this);
}
tQ.prototype = Object.create(cA.prototype);
// AstVar
function tV(){
c8.call(this);
}
tV.prototype = Object.create(c8.prototype);
// Writer
function u5(){
cA.call(this);
}
u5.prototype = Object.create(cA.prototype);
// WebInfo
function uK(){
c9.call(this);
}
uK.prototype = Object.create(c9.prototype);
// TmpVar
function v6(){
cA.call(this);
}
v6.prototype = Object.create(cA.prototype);
// AstConst
function xh(){
c8.call(this);
}
xh.prototype = Object.create(c8.prototype);
// AstAlias
function xk(){
c8.call(this);
}
xk.prototype = Object.create(c8.prototype);
// AstEnum
function xq(){
c8.call(this);
}
xq.prototype = Object.create(c8.prototype);
// AstStat
function xR(){
c8.call(this);
}
xR.prototype = Object.create(c8.prototype);
// AstStatBreakable
function xQ(){
xR.call(this);
}
xQ.prototype = Object.create(xR.prototype);
// AstStatTry
function xP(){
xQ.call(this);
}
xP.prototype = Object.create(xQ.prototype);
// AstTypePrim
function xW(){
td.call(this);
}
xW.prototype = Object.create(td.prototype);
// AstStatBlock
function yc(){
xQ.call(this);
}
yc.prototype = Object.create(xQ.prototype);
// AstStatDo
function yp(){
xR.call(this);
}
yp.prototype = Object.create(xR.prototype);
// AstExpr
function yt(){
c8.call(this);
}
yt.prototype = Object.create(c8.prototype);
// AstExprCall
function ys(){
yt.call(this);
}
ys.prototype = Object.create(yt.prototype);
// AstStatCatch
function y2(){
xR.call(this);
}
y2.prototype = Object.create(xR.prototype);
// ExprPair
function y9(){
cA.call(this);
}
y9.prototype = Object.create(cA.prototype);
// AstExprValue
function yD(){
yt.call(this);
}
yD.prototype = Object.create(yt.prototype);
// AstExprValuePrim
function yC(){
yD.call(this);
}
yC.prototype = Object.create(yD.prototype);
// AstExprCallArg
function yX(){
cA.call(this);
}
yX.prototype = Object.create(cA.prototype);
// AstExpr2
function zI(){
yt.call(this);
}
zI.prototype = Object.create(yt.prototype);
// AstTypeNullable
function Av(){
td.call(this);
}
Av.prototype = Object.create(td.prototype);
// AstTypeArray
function Au(){
Av.call(this);
}
Au.prototype = Object.create(Av.prototype);
// AstTypeBit
function Ay(){
td.call(this);
}
Ay.prototype = Object.create(td.prototype);
// AstTypeFunc
function A2(){
Av.call(this);
}
A2.prototype = Object.create(Av.prototype);
// AstTypeFuncArg
function AC(){
cA.call(this);
}
AC.prototype = Object.create(cA.prototype);
// AstTypeGen
function AP(){
Av.call(this);
}
AP.prototype = Object.create(Av.prototype);
// AstTypeDict
function Ba(){
Av.call(this);
}
Ba.prototype = Object.create(Av.prototype);
// AstStatIf
function Ef(){
xQ.call(this);
}
Ef.prototype = Object.create(xQ.prototype);
// AstStatSwitch
function Ei(){
xQ.call(this);
}
Ei.prototype = Object.create(xQ.prototype);
// AstStatSkipable
function Em(){
xQ.call(this);
}
Em.prototype = Object.create(xQ.prototype);
// AstStatWhile
function El(){
Em.call(this);
}
El.prototype = Object.create(Em.prototype);
// AstStatFor
function Ep(){
Em.call(this);
}
Ep.prototype = Object.create(Em.prototype);
// AstStatThrow
function Eu(){
xR.call(this);
}
Eu.prototype = Object.create(xR.prototype);
// AstStatRet
function Ez(){
xR.call(this);
}
Ez.prototype = Object.create(xR.prototype);
// AstStatAssert
function E8(){
xR.call(this);
}
E8.prototype = Object.create(xR.prototype);
// AstTypeUser
function M9(){
Av.call(this);
}
M9.prototype = Object.create(Av.prototype);
// AstExpr1
function Qd(){
yt.call(this);
}
Qd.prototype = Object.create(yt.prototype);
// AstExpr3
function Qi(){
yt.call(this);
}
Qi.prototype = Object.create(yt.prototype);
// AstExprNew
function Ql(){
yt.call(this);
}
Ql.prototype = Object.create(yt.prototype);
// AstExprNewArray
function Qo(){
yt.call(this);
}
Qo.prototype = Object.create(yt.prototype);
// AstExprAs
function Qr(){
yt.call(this);
}
Qr.prototype = Object.create(yt.prototype);
// AstExprToBin
function Qu(){
yt.call(this);
}
Qu.prototype = Object.create(yt.prototype);
// AstExprFromBin
function Qx(){
yt.call(this);
}
Qx.prototype = Object.create(yt.prototype);
// AstExprArray
function Q2(){
yt.call(this);
}
Q2.prototype = Object.create(yt.prototype);
// AstExprDot
function Q5(){
yt.call(this);
}
Q5.prototype = Object.create(yt.prototype);
// AstExprValueStr
function QC(){
yD.call(this);
}
QC.prototype = Object.create(yD.prototype);
// AstExprValueEnumElement
function QF(){
yD.call(this);
}
QF.prototype = Object.create(yD.prototype);
// AstExprValueFloat
function QI(){
yD.call(this);
}
QI.prototype = Object.create(yD.prototype);
// AstExprValueArray
function QL(){
yt.call(this);
}
QL.prototype = Object.create(yt.prototype);
// AstStatVar
function Rb(){
xR.call(this);
}
Rb.prototype = Object.create(xR.prototype);
// AstTypeNull
function RW(){
td.call(this);
}
RW.prototype = Object.create(td.prototype);
// AstStatElIf
function SR(){
xR.call(this);
}
SR.prototype = Object.create(xR.prototype);
// AstStatCase
function Tq(){
xR.call(this);
}
Tq.prototype = Object.create(xR.prototype);
// AstStatFunc
function axg(){
xR.call(this);
}
axg.prototype = Object.create(xR.prototype);
// AstStatConst
function axk(){
xR.call(this);
}
axk.prototype = Object.create(xR.prototype);
// AstStatAlias
function axn(){
xR.call(this);
}
axn.prototype = Object.create(xR.prototype);
// AstStatClass
function axq(){
xR.call(this);
}
axq.prototype = Object.create(xR.prototype);
// AstStatEnum
function axt(){
xR.call(this);
}
axt.prototype = Object.create(xR.prototype);
// AstTypeEnumElement
function aNu(){
td.call(this);
}
aNu.prototype = Object.create(td.prototype);
// ctor
function aQc(aQd /*me*/){
}
// _dtor
function aQe(aQf /*me*/){
}
// cmp
function aQg(aQh /*me*/,aQi /*t*/){
throw 3910598660;
}
// _copy
function aQj(aQk /*me*/){
let aQl=null;
(aQl)=(new cA());
return aQl;
}
// _toBin
function aQm(aQn /*me*/){
let aQo=null;
(aQo)=(new Array(8).fill(0));
return aQo;
}
// _fromBin
function aQp(aQq /*me*/,aQr /*bin*/,aQs /*idx*/){
let aQt=null;
(aQt)=(new cA());
return aQt;
}
// toStr
function aQu(aQv /*me*/){
return {S:""};
}
// _dtor
function aQw(aQx){
}
// _copy
function aQy(aQz){
let aQ0=null;
(aQ0)=(new c9());
((aQ0).qc)=((aQz).qc);
return aQ0;
}
// _toBin
function aQ1(aQ2){
let aQ3=null;
(aQ3)=(new Array(8).fill(0));
(aQ3)=((aQ3).concat(toBin_((aQ2).qc)));
return aQ3;
}
// _fromBin
function aQ5(aQ6,aQ7,aQ8){
let aQ9=null;
(aQ9)=(new c9());
((aQ9).qc)=(fromBin_((aQ7),(aQ8.$)));
return aQ9;
}
// cmp
function aQA(aQB /*me*/,aQC /*t*/){
let aQD=0; // meAddr
let aQF=0; // tAddr
(aQD)=((aQE)((aQB)));
(aQF)=((aQE)((aQC)));
return ((aQD)>(aQF))?(1):(((aQD)<(aQF))?(-1):(0));
}
// _dtor
function aQG(aQH){
((aQH).ql)=(null);
((aQH).qX)=(null);
((aQH).qU)=(null);
((aQH).pY)=(null);
((aQH).q0)=(null);
((aQH).qz)=(null);
((aQH).zo)=(null);
}
// _copy
function aQI(aQJ){
let aQK=null;
(aQK)=(new c8());
((aQK).ql)=(C_([134],((aQJ).ql)));
((aQK).qX)=(C_([129,2],((aQJ).qX)));
((aQK).qU)=(C_([134],((aQJ).qU)));
((aQK).pY)=(C_([133,129,2,134],((aQJ).pY)));
((aQK).q0)=(C_([129,2],((aQJ).q0)));
((aQK).qz)=(C_([134],((aQJ).qz)));
((aQK).zo)=(C_([134],((aQJ).zo)));
((aQK).r5)=((aQJ).r5);
((aQK).qc)=((aQJ).qc);
return aQK;
}
// _toBin
function aQL(aQM){
let aQN=null;
(aQN)=(new Array(8).fill(0));
(aQN)=((aQN).concat(toBin_((aQM).ql)));
(aQN)=((aQN).concat(toBin_((aQM).qX)));
(aQN)=((aQN).concat(toBin_((aQM).qU)));
(aQN)=((aQN).concat(toBin_((aQM).pY)));
(aQN)=((aQN).concat(toBin_((aQM).q0)));
(aQN)=((aQN).concat(toBin_((aQM).qz)));
(aQN)=((aQN).concat(toBin_((aQM).zo)));
(aQN)=((aQN).concat(toBin_((aQM).r5)));
(aQN)=((aQN).concat(toBin_((aQM).qc)));
return aQN;
}
// _fromBin
function aQX(aQY,aQZ,aRa){
let aRb=null;
(aRb)=(new c8());
((aRb).ql)=(fromBin_((aQZ),(aRa.$)));
((aRb).qX)=(fromBin_((aQZ),(aRa.$)));
((aRb).qU)=(fromBin_((aQZ),(aRa.$)));
((aRb).pY)=(fromBin_((aQZ),(aRa.$)));
((aRb).q0)=(fromBin_((aQZ),(aRa.$)));
((aRb).qz)=(fromBin_((aQZ),(aRa.$)));
((aRb).zo)=(fromBin_((aQZ),(aRa.$)));
((aRb).r5)=(fromBin_((aQZ),(aRa.$)));
((aRb).qc)=(fromBin_((aQZ),(aRa.$)));
return aRb;
}
// _dtor
function aRc(aRd){
((aRd).qj)=(null);
((aRd).qg)=(null);
((aRd).qh)=(null);
((aRd).tp)=(null);
((aRd).ql)=(null);
((aRd).qX)=(null);
((aRd).qU)=(null);
((aRd).pY)=(null);
((aRd).q0)=(null);
((aRd).qz)=(null);
((aRd).zo)=(null);
}
// _copy
function aRe(aRf){
let aRg=null;
(aRg)=(new c7());
((aRg).qi)=((aRf).qi);
((aRg).qj)=(C_([130,129,2],((aRf).qj)));
((aRg).qg)=(C_([130,134],((aRf).qg)));
((aRg).qh)=(C_([134],((aRf).qh)));
((aRg).tp)=(C_([130,134],((aRf).tp)));
((aRg).ql)=(C_([134],((aRf).ql)));
((aRg).qX)=(C_([129,2],((aRf).qX)));
((aRg).qU)=(C_([134],((aRf).qU)));
((aRg).pY)=(C_([133,129,2,134],((aRf).pY)));
((aRg).q0)=(C_([129,2],((aRf).q0)));
((aRg).qz)=(C_([134],((aRf).qz)));
((aRg).zo)=(C_([134],((aRf).zo)));
((aRg).r5)=((aRf).r5);
((aRg).qc)=((aRf).qc);
return aRg;
}
// _toBin
function aRh(aRi){
let aRj=null;
(aRj)=(new Array(8).fill(0));
(aRj)=((aRj).concat(toBin_((aRi).qi)));
(aRj)=((aRj).concat(toBin_((aRi).qj)));
(aRj)=((aRj).concat(toBin_((aRi).qg)));
(aRj)=((aRj).concat(toBin_((aRi).qh)));
(aRj)=((aRj).concat(toBin_((aRi).tp)));
(aRj)=((aRj).concat(toBin_((aRi).ql)));
(aRj)=((aRj).concat(toBin_((aRi).qX)));
(aRj)=((aRj).concat(toBin_((aRi).qU)));
(aRj)=((aRj).concat(toBin_((aRi).pY)));
(aRj)=((aRj).concat(toBin_((aRi).q0)));
(aRj)=((aRj).concat(toBin_((aRi).qz)));
(aRj)=((aRj).concat(toBin_((aRi).zo)));
(aRj)=((aRj).concat(toBin_((aRi).r5)));
(aRj)=((aRj).concat(toBin_((aRi).qc)));
return aRj;
}
// _fromBin
function aRy(aRz,aR0,aR1){
let aR2=null;
(aR2)=(new c7());
((aR2).qi)=(fromBin_((aR0),(aR1.$)));
((aR2).qj)=(fromBin_((aR0),(aR1.$)));
((aR2).qg)=(fromBin_((aR0),(aR1.$)));
((aR2).qh)=(fromBin_((aR0),(aR1.$)));
((aR2).tp)=(fromBin_((aR0),(aR1.$)));
((aR2).ql)=(fromBin_((aR0),(aR1.$)));
((aR2).qX)=(fromBin_((aR0),(aR1.$)));
((aR2).qU)=(fromBin_((aR0),(aR1.$)));
((aR2).pY)=(fromBin_((aR0),(aR1.$)));
((aR2).q0)=(fromBin_((aR0),(aR1.$)));
((aR2).qz)=(fromBin_((aR0),(aR1.$)));
((aR2).zo)=(fromBin_((aR0),(aR1.$)));
((aR2).r5)=(fromBin_((aR0),(aR1.$)));
((aR2).qc)=(fromBin_((aR0),(aR1.$)));
return aR2;
}
// _dtor
function aR3(aR4){
((aR4).cG)=(null);
}
// _copy
function aR5(aR6){
let aR7=null;
(aR7)=(new cF());
((aR7).cG)=(C_([130,129,2],((aR6).cG)));
return aR7;
}
// _toBin
function aR8(aR9){
let aRA=null;
(aRA)=(new Array(8).fill(0));
(aRA)=((aRA).concat(toBin_((aR9).cG)));
return aRA;
}
// _fromBin
function aRC(aRD,aRE,aRF){
let aRG=null;
(aRG)=(new cF());
((aRG).cG)=(fromBin_((aRE),(aRF.$)));
return aRG;
}
// _dtor
function aRH(aRI){
((aRI).dh)=(null);
}
// _copy
function aRJ(aRK){
let aRL=null;
(aRL)=(new dg());
((aRL).dh)=(C_([129,2],((aRK).dh)));
((aRL).di)=((aRK).di);
((aRL).dj)=((aRK).dj);
return aRL;
}
// _toBin
function aRM(aRN){
let aRO=null;
(aRO)=(new Array(8).fill(0));
(aRO)=((aRO).concat(toBin_((aRN).dh)));
(aRO)=((aRO).concat(toBin_((aRN).di)));
(aRO)=((aRO).concat(toBin_((aRN).dj)));
return aRO;
}
// _fromBin
function aRS(aRT,aRU,aRV){
let aRW=null;
(aRW)=(new dg());
((aRW).dh)=(fromBin_((aRU),(aRV.$)));
((aRW).di)=(fromBin_((aRU),(aRV.$)));
((aRW).dj)=(fromBin_((aRU),(aRV.$)));
return aRW;
}
// cmp
function aRX(aRY /*me*/,aRZ /*t*/){
return (aSa)(((((aRY).e3)?1:0)-(((aRZ).e3)?1:0)));
}
// toStr
function aSb(aSc /*me*/){
return (v)(((aSc).e3),([3]));
}
// _dtor
function aSd(aSe){
}
// _copy
function aSf(aSg){
let aSh=null;
(aSh)=(new e2());
((aSh).e3)=((aSg).e3);
return aSh;
}
// _toBin
function aSi(aSj){
let aSk=null;
(aSk)=(new Array(8).fill(0));
(aSk)=((aSk).concat(toBin_((aSj).e3)));
return aSk;
}
// _fromBin
function aSm(aSn,aSo,aSp){
let aSq=null;
(aSq)=(new e2());
((aSq).e3)=(fromBin_((aSo),(aSp.$)));
return aSq;
}
// _dtor
function aSr(aSs){
((aSs).tg)=(null);
((aSs).ql)=(null);
((aSs).qX)=(null);
((aSs).qU)=(null);
((aSs).pY)=(null);
((aSs).q0)=(null);
((aSs).qz)=(null);
((aSs).zo)=(null);
}
// _copy
function aSt(aSu){
let aSv=null;
(aSv)=(new eZ());
((aSv).tg)=(C_([130,134],((aSu).tg)));
((aSv).ql)=(C_([134],((aSu).ql)));
((aSv).qX)=(C_([129,2],((aSu).qX)));
((aSv).qU)=(C_([134],((aSu).qU)));
((aSv).pY)=(C_([133,129,2,134],((aSu).pY)));
((aSv).q0)=(C_([129,2],((aSu).q0)));
((aSv).qz)=(C_([134],((aSu).qz)));
((aSv).zo)=(C_([134],((aSu).zo)));
((aSv).r5)=((aSu).r5);
((aSv).qc)=((aSu).qc);
return aSv;
}
// _toBin
function aSw(aSx){
let aSy=null;
(aSy)=(new Array(8).fill(0));
(aSy)=((aSy).concat(toBin_((aSx).tg)));
(aSy)=((aSy).concat(toBin_((aSx).ql)));
(aSy)=((aSy).concat(toBin_((aSx).qX)));
(aSy)=((aSy).concat(toBin_((aSx).qU)));
(aSy)=((aSy).concat(toBin_((aSx).pY)));
(aSy)=((aSy).concat(toBin_((aSx).q0)));
(aSy)=((aSy).concat(toBin_((aSx).qz)));
(aSy)=((aSy).concat(toBin_((aSx).zo)));
(aSy)=((aSy).concat(toBin_((aSx).r5)));
(aSy)=((aSy).concat(toBin_((aSx).qc)));
return aSy;
}
// _fromBin
function aS9(aSA,aSB,aSC){
let aSD=null;
(aSD)=(new eZ());
((aSD).tg)=(fromBin_((aSB),(aSC.$)));
((aSD).ql)=(fromBin_((aSB),(aSC.$)));
((aSD).qX)=(fromBin_((aSB),(aSC.$)));
((aSD).qU)=(fromBin_((aSB),(aSC.$)));
((aSD).pY)=(fromBin_((aSB),(aSC.$)));
((aSD).q0)=(fromBin_((aSB),(aSC.$)));
((aSD).qz)=(fromBin_((aSB),(aSC.$)));
((aSD).zo)=(fromBin_((aSB),(aSC.$)));
((aSD).r5)=(fromBin_((aSB),(aSC.$)));
((aSD).qc)=(fromBin_((aSB),(aSC.$)));
return aSD;
}
// _dtor
function aSE(aSF /*me*/){
}
// fin
function pO(aSG /*me*/){
aSG.wC.F=null;
}
// setPos
function aSH(aSI /*me*/,aSJ /*origin*/,aSK /*pos*/){
aSI.wC.I=aSK;
}
// getPos
function aSL(aSM /*me*/){
return aSM.wC.I;
}
// delimiter
function aSN(aSO /*me*/,aSP /*delimiters*/){
}
// read
function aSQ(aSR /*me*/,aSS /*size*/){
}
// readLetter
function Zy(aST /*me*/){
return aST.wC.F.charCodeAt(aST.wC.I++);
}
// readInt
function aSU(aSV /*me*/){
}
// readFloat
function aSW(aSX /*me*/){
}
// readChar
function aSY(aSZ /*me*/){
}
// readStr
function aTa(aTb /*me*/){
}
// readLine
function uA(aTc /*me*/){
let aTd=null; // buf
let aTg=0; // c
(aTd)=({S:""});
aTf:
while(!((u8)((aTc)))){
(aTg)=((Zy)((aTc)));
if((aTg)===(0x000D)){
continue aTf;
}
if((aTg)===(0x000A)){
break aTf;
}
(aTd)=({S:(aTd).S+((v)((aTg),([2]))).S});
}
return aTd;
}
// fileSize
function aTm(aTn /*me*/){
}
// term
function u8(aTo /*me*/){
return aTo.wC.I>=aTo.wC.F.length;
}
// _copy
function aTp(aTq){
let aTr=null;
(aTr)=(new pC());
((aTr).wC)=((aTq).wC);
((aTr).aTs)=((aTq).aTs);
((aTr).aTt)=((aTq).aTt);
((aTr).aTu)=((aTq).aTu);
return aTr;
}
// _toBin
function aTv(aTw){
let aTx=null;
(aTx)=(new Array(8).fill(0));
(aTx)=((aTx).concat(toBin_((aTw).wC)));
(aTx)=((aTx).concat(toBin_((aTw).aTs)));
(aTx)=((aTx).concat(toBin_((aTw).aTt)));
(aTx)=((aTx).concat(toBin_((aTw).aTu)));
return aTx;
}
// _fromBin
function aT2(aT3,aT4,aT5){
let aT6=null;
(aT6)=(new pC());
((aT6).wC)=(fromBin_((aT4),(aT5.$)));
((aT6).aTs)=(fromBin_((aT4),(aT5.$)));
((aT6).aTt)=(fromBin_((aT4),(aT5.$)));
((aT6).aTu)=(fromBin_((aT4),(aT5.$)));
return aT6;
}
// _dtor
function aT7(aT8){
((aT8).rI)=(null);
((aT8).qq)=(null);
((aT8).ql)=(null);
((aT8).qX)=(null);
((aT8).qU)=(null);
((aT8).pY)=(null);
((aT8).q0)=(null);
((aT8).qz)=(null);
((aT8).zo)=(null);
}
// _copy
function aT9(aTA){
let aTB=null;
(aTB)=(new pN());
((aTB).rI)=(C_([130,134],((aTA).rI)));
((aTB).qq)=(C_([130,134],((aTA).qq)));
((aTB).ql)=(C_([134],((aTA).ql)));
((aTB).qX)=(C_([129,2],((aTA).qX)));
((aTB).qU)=(C_([134],((aTA).qU)));
((aTB).pY)=(C_([133,129,2,134],((aTA).pY)));
((aTB).q0)=(C_([129,2],((aTA).q0)));
((aTB).qz)=(C_([134],((aTA).qz)));
((aTB).zo)=(C_([134],((aTA).zo)));
((aTB).r5)=((aTA).r5);
((aTB).qc)=((aTA).qc);
return aTB;
}
// _toBin
function aTC(aTD){
let aTE=null;
(aTE)=(new Array(8).fill(0));
(aTE)=((aTE).concat(toBin_((aTD).rI)));
(aTE)=((aTE).concat(toBin_((aTD).qq)));
(aTE)=((aTE).concat(toBin_((aTD).ql)));
(aTE)=((aTE).concat(toBin_((aTD).qX)));
(aTE)=((aTE).concat(toBin_((aTD).qU)));
(aTE)=((aTE).concat(toBin_((aTD).pY)));
(aTE)=((aTE).concat(toBin_((aTD).q0)));
(aTE)=((aTE).concat(toBin_((aTD).qz)));
(aTE)=((aTE).concat(toBin_((aTD).zo)));
(aTE)=((aTE).concat(toBin_((aTD).r5)));
(aTE)=((aTE).concat(toBin_((aTD).qc)));
return aTE;
}
// _fromBin
function aTQ(aTR,aTS,aTT){
let aTU=null;
(aTU)=(new pN());
((aTU).rI)=(fromBin_((aTS),(aTT.$)));
((aTU).qq)=(fromBin_((aTS),(aTT.$)));
((aTU).ql)=(fromBin_((aTS),(aTT.$)));
((aTU).qX)=(fromBin_((aTS),(aTT.$)));
((aTU).qU)=(fromBin_((aTS),(aTT.$)));
((aTU).pY)=(fromBin_((aTS),(aTT.$)));
((aTU).q0)=(fromBin_((aTS),(aTT.$)));
((aTU).qz)=(fromBin_((aTS),(aTT.$)));
((aTU).zo)=(fromBin_((aTS),(aTT.$)));
((aTU).r5)=(fromBin_((aTS),(aTT.$)));
((aTU).qc)=(fromBin_((aTS),(aTT.$)));
return aTU;
}
// _dtor
function aTV(aTW){
((aTW).qy)=(null);
((aTW).qP)=(null);
}
// _copy
function aTX(aTY){
let aTZ=null;
(aTZ)=(new qw());
((aTZ).qy)=(C_([134],((aTY).qy)));
((aTZ).qP)=(C_([134],((aTY).qP)));
return aTZ;
}
// _toBin
function aUa(aUb){
let aUc=null;
(aUc)=(new Array(8).fill(0));
(aUc)=((aUc).concat(toBin_((aUb).qy)));
(aUc)=((aUc).concat(toBin_((aUb).qP)));
return aUc;
}
// _fromBin
function aUf(aUg,aUh,aUi){
let aUj=null;
(aUj)=(new qw());
((aUj).qy)=(fromBin_((aUh),(aUi.$)));
((aUj).qP)=(fromBin_((aUh),(aUi.$)));
return aUj;
}
// _dtor
function aUk(aUl){
((aUl).s4)=(null);
((aUl).xY)=(null);
((aUl).ql)=(null);
((aUl).qX)=(null);
((aUl).qU)=(null);
((aUl).pY)=(null);
((aUl).q0)=(null);
((aUl).qz)=(null);
((aUl).zo)=(null);
}
// _copy
function aUm(aUn){
let aUo=null;
(aUo)=(new ro());
((aUo).rp)=((aUn).rp);
((aUo).sJ)=((aUn).sJ);
((aUo).s4)=(C_([134],((aUn).s4)));
((aUo).xY)=(C_([134],((aUn).xY)));
((aUo).ql)=(C_([134],((aUn).ql)));
((aUo).qX)=(C_([129,2],((aUn).qX)));
((aUo).qU)=(C_([134],((aUn).qU)));
((aUo).pY)=(C_([133,129,2,134],((aUn).pY)));
((aUo).q0)=(C_([129,2],((aUn).q0)));
((aUo).qz)=(C_([134],((aUn).qz)));
((aUo).zo)=(C_([134],((aUn).zo)));
((aUo).r5)=((aUn).r5);
((aUo).qc)=((aUn).qc);
return aUo;
}
// _toBin
function aUp(aUq){
let aUr=null;
(aUr)=(new Array(8).fill(0));
(aUr)=((aUr).concat(toBin_((aUq).rp)));
(aUr)=((aUr).concat(toBin_((aUq).sJ)));
(aUr)=((aUr).concat(toBin_((aUq).s4)));
(aUr)=((aUr).concat(toBin_((aUq).xY)));
(aUr)=((aUr).concat(toBin_((aUq).ql)));
(aUr)=((aUr).concat(toBin_((aUq).qX)));
(aUr)=((aUr).concat(toBin_((aUq).qU)));
(aUr)=((aUr).concat(toBin_((aUq).pY)));
(aUr)=((aUr).concat(toBin_((aUq).q0)));
(aUr)=((aUr).concat(toBin_((aUq).qz)));
(aUr)=((aUr).concat(toBin_((aUq).zo)));
(aUr)=((aUr).concat(toBin_((aUq).r5)));
(aUr)=((aUr).concat(toBin_((aUq).qc)));
return aUr;
}
// _fromBin
function aU5(aU6,aU7,aU8){
let aU9=null;
(aU9)=(new ro());
((aU9).rp)=(fromBin_((aU7),(aU8.$)));
((aU9).sJ)=(fromBin_((aU7),(aU8.$)));
((aU9).s4)=(fromBin_((aU7),(aU8.$)));
((aU9).xY)=(fromBin_((aU7),(aU8.$)));
((aU9).ql)=(fromBin_((aU7),(aU8.$)));
((aU9).qX)=(fromBin_((aU7),(aU8.$)));
((aU9).qU)=(fromBin_((aU7),(aU8.$)));
((aU9).pY)=(fromBin_((aU7),(aU8.$)));
((aU9).q0)=(fromBin_((aU7),(aU8.$)));
((aU9).qz)=(fromBin_((aU7),(aU8.$)));
((aU9).zo)=(fromBin_((aU7),(aU8.$)));
((aU9).r5)=(fromBin_((aU7),(aU8.$)));
((aU9).qc)=(fromBin_((aU7),(aU8.$)));
return aU9;
}
// _dtor
function aUA(aUB){
((aUB).sN)=(null);
((aUB).Ag)=(null);
((aUB).Aj)=(null);
}
// _copy
function aUC(aUD){
let aUE=null;
(aUE)=(new rV());
((aUE).sN)=(C_([129,2],((aUD).sN)));
((aUE).Ag)=(C_([129,2],((aUD).Ag)));
((aUE).Aj)=(C_([129,2],((aUD).Aj)));
((aUE).tE)=((aUD).tE);
((aUE).rX)=((aUD).rX);
((aUE).Am)=((aUD).Am);
((aUE).An)=((aUD).An);
((aUE).qc)=((aUD).qc);
return aUE;
}
// _toBin
function aUF(aUG){
let aUH=null;
(aUH)=(new Array(8).fill(0));
(aUH)=((aUH).concat(toBin_((aUG).sN)));
(aUH)=((aUH).concat(toBin_((aUG).Ag)));
(aUH)=((aUH).concat(toBin_((aUG).Aj)));
(aUH)=((aUH).concat(toBin_((aUG).tE)));
(aUH)=((aUH).concat(toBin_((aUG).rX)));
(aUH)=((aUH).concat(toBin_((aUG).Am)));
(aUH)=((aUH).concat(toBin_((aUG).An)));
(aUH)=((aUH).concat(toBin_((aUG).qc)));
return aUH;
}
// _fromBin
function aUQ(aUR,aUS,aUT){
let aUU=null;
(aUU)=(new rV());
((aUU).sN)=(fromBin_((aUS),(aUT.$)));
((aUU).Ag)=(fromBin_((aUS),(aUT.$)));
((aUU).Aj)=(fromBin_((aUS),(aUT.$)));
((aUU).tE)=(fromBin_((aUS),(aUT.$)));
((aUU).rX)=(fromBin_((aUS),(aUT.$)));
((aUU).Am)=(fromBin_((aUS),(aUT.$)));
((aUU).An)=(fromBin_((aUS),(aUT.$)));
((aUU).qc)=(fromBin_((aUS),(aUT.$)));
return aUU;
}
// _dtor
function aUV(aUW){
((aUW).ql)=(null);
((aUW).qX)=(null);
((aUW).qU)=(null);
((aUW).pY)=(null);
((aUW).q0)=(null);
((aUW).qz)=(null);
((aUW).zo)=(null);
}
// _copy
function aUX(aUY){
let aUZ=null;
(aUZ)=(new td());
((aUZ).ql)=(C_([134],((aUY).ql)));
((aUZ).qX)=(C_([129,2],((aUY).qX)));
((aUZ).qU)=(C_([134],((aUY).qU)));
((aUZ).pY)=(C_([133,129,2,134],((aUY).pY)));
((aUZ).q0)=(C_([129,2],((aUY).q0)));
((aUZ).qz)=(C_([134],((aUY).qz)));
((aUZ).zo)=(C_([134],((aUY).zo)));
((aUZ).r5)=((aUY).r5);
((aUZ).qc)=((aUY).qc);
return aUZ;
}
// _toBin
function aVa(aVb){
let aVc=null;
(aVc)=(new Array(8).fill(0));
(aVc)=((aVc).concat(toBin_((aVb).ql)));
(aVc)=((aVc).concat(toBin_((aVb).qX)));
(aVc)=((aVc).concat(toBin_((aVb).qU)));
(aVc)=((aVc).concat(toBin_((aVb).pY)));
(aVc)=((aVc).concat(toBin_((aVb).q0)));
(aVc)=((aVc).concat(toBin_((aVb).qz)));
(aVc)=((aVc).concat(toBin_((aVb).zo)));
(aVc)=((aVc).concat(toBin_((aVb).r5)));
(aVc)=((aVc).concat(toBin_((aVb).qc)));
return aVc;
}
// _fromBin
function aVm(aVn,aVo,aVp){
let aVq=null;
(aVq)=(new td());
((aVq).ql)=(fromBin_((aVo),(aVp.$)));
((aVq).qX)=(fromBin_((aVo),(aVp.$)));
((aVq).qU)=(fromBin_((aVo),(aVp.$)));
((aVq).pY)=(fromBin_((aVo),(aVp.$)));
((aVq).q0)=(fromBin_((aVo),(aVp.$)));
((aVq).qz)=(fromBin_((aVo),(aVp.$)));
((aVq).zo)=(fromBin_((aVo),(aVp.$)));
((aVq).r5)=(fromBin_((aVo),(aVp.$)));
((aVq).qc)=(fromBin_((aVo),(aVp.$)));
return aVq;
}
// _dtor
function aVr(aVs){
((aVs).t4)=(null);
((aVs).t3)=(null);
}
// _copy
function aVt(aVu){
let aVv=null;
(aVv)=(new t2());
((aVv).t4)=(C_([129,2],((aVu).t4)));
((aVv).t3)=(C_([134],((aVu).t3)));
return aVv;
}
// _toBin
function aVw(aVx){
let aVy=null;
(aVy)=(new Array(8).fill(0));
(aVy)=((aVy).concat(toBin_((aVx).t4)));
(aVy)=((aVy).concat(toBin_((aVx).t3)));
return aVy;
}
// _fromBin
function aV1(aV2,aV3,aV4){
let aV5=null;
(aV5)=(new t2());
((aV5).t4)=(fromBin_((aV3),(aV4.$)));
((aV5).t3)=(fromBin_((aV3),(aV4.$)));
return aV5;
}
// _dtor
function aV6(aV7){
((aV7).tS)=(null);
((aV7).N6)=(null);
}
// _copy
function aV8(aV9){
let aVA=null;
(aVA)=(new tQ());
((aVA).N4)=((aV9).N4);
((aVA).N5)=((aV9).N5);
((aVA).tS)=(C_([134],((aV9).tS)));
((aVA).N6)=(C_([134],((aV9).N6)));
return aVA;
}
// _toBin
function aVB(aVC){
let aVD=null;
(aVD)=(new Array(8).fill(0));
(aVD)=((aVD).concat(toBin_((aVC).N4)));
(aVD)=((aVD).concat(toBin_((aVC).N5)));
(aVD)=((aVD).concat(toBin_((aVC).tS)));
(aVD)=((aVD).concat(toBin_((aVC).N6)));
return aVD;
}
// _fromBin
function aVI(aVJ,aVK,aVL){
let aVM=null;
(aVM)=(new tQ());
((aVM).N4)=(fromBin_((aVK),(aVL.$)));
((aVM).N5)=(fromBin_((aVK),(aVL.$)));
((aVM).tS)=(fromBin_((aVK),(aVL.$)));
((aVM).N6)=(fromBin_((aVK),(aVL.$)));
return aVM;
}
// _dtor
function aVN(aVO){
((aVO).tX)=(null);
((aVO).ql)=(null);
((aVO).qX)=(null);
((aVO).qU)=(null);
((aVO).pY)=(null);
((aVO).q0)=(null);
((aVO).qz)=(null);
((aVO).zo)=(null);
}
// _copy
function aVP(aVQ){
let aVR=null;
(aVR)=(new tV());
((aVR).tX)=(C_([134],((aVQ).tX)));
((aVR).ql)=(C_([134],((aVQ).ql)));
((aVR).qX)=(C_([129,2],((aVQ).qX)));
((aVR).qU)=(C_([134],((aVQ).qU)));
((aVR).pY)=(C_([133,129,2,134],((aVQ).pY)));
((aVR).q0)=(C_([129,2],((aVQ).q0)));
((aVR).qz)=(C_([134],((aVQ).qz)));
((aVR).zo)=(C_([134],((aVQ).zo)));
((aVR).r5)=((aVQ).r5);
((aVR).qc)=((aVQ).qc);
return aVR;
}
// _toBin
function aVS(aVT){
let aVU=null;
(aVU)=(new Array(8).fill(0));
(aVU)=((aVU).concat(toBin_((aVT).tX)));
(aVU)=((aVU).concat(toBin_((aVT).ql)));
(aVU)=((aVU).concat(toBin_((aVT).qX)));
(aVU)=((aVU).concat(toBin_((aVT).qU)));
(aVU)=((aVU).concat(toBin_((aVT).pY)));
(aVU)=((aVU).concat(toBin_((aVT).q0)));
(aVU)=((aVU).concat(toBin_((aVT).qz)));
(aVU)=((aVU).concat(toBin_((aVT).zo)));
(aVU)=((aVU).concat(toBin_((aVT).r5)));
(aVU)=((aVU).concat(toBin_((aVT).qc)));
return aVU;
}
// _fromBin
function aWf(aWg,aWh,aWi){
let aWj=null;
(aWj)=(new tV());
((aWj).tX)=(fromBin_((aWh),(aWi.$)));
((aWj).ql)=(fromBin_((aWh),(aWi.$)));
((aWj).qX)=(fromBin_((aWh),(aWi.$)));
((aWj).qU)=(fromBin_((aWh),(aWi.$)));
((aWj).pY)=(fromBin_((aWh),(aWi.$)));
((aWj).q0)=(fromBin_((aWh),(aWi.$)));
((aWj).qz)=(fromBin_((aWh),(aWi.$)));
((aWj).zo)=(fromBin_((aWh),(aWi.$)));
((aWj).r5)=(fromBin_((aWh),(aWi.$)));
((aWj).qc)=(fromBin_((aWh),(aWi.$)));
return aWj;
}
// _dtor
function aWk(aWl /*me*/){
}
// fin
function uD(aWm /*me*/){
var d_=aWm.F6.F.replace("\n", "\u000D\n");
if(O_&&O_.writeFile){O_.writeFile(aWm.F6.P,d_);return;}
let b_=new Blob([d_]);
let l_=document.createElement("a");
l_.download=aWm.F6.P;
l_.href=(URL||webkitURL).createObjectURL(b_);
l_.setAttribute("style","display:none");
document.body.appendChild(l_);
l_.click();
document.body.removeChild(l_);
aWm.F6.F=null;
}
// setPos
function aWn(aWo /*me*/,aWp /*origin*/,aWq /*pos*/){
aWo.F6.I=aWq;
}
// getPos
function aWr(aWs /*me*/){
return aWs.F6.I;
}
// write
function aWt(aWu /*me*/,aWv /*bin*/){
}
// writeInt
function aWw(aWx /*me*/,aWy /*n*/){
let aWz=null; // s
let aW2=0;
let aW3=0;
(aWz)=((v)((aWy),([0])));
aW1:
for(aW2=(0),aW3=(((aWz).S.length)-(1));aW2<=aW3;aW2+=(1)){
(aW4)((aWx),((aWz).S.charCodeAt(aW2)));
}
}
// writeFloat
function aW5(aW6 /*me*/,aW7 /*n*/){
let aW8=null; // s
let aWB=0;
let aWC=0;
(aW8)=((v)((aW7),([1])));
aWA:
for(aWB=(0),aWC=(((aW8).S.length)-(1));aWB<=aWC;aWB+=(1)){
(aW4)((aW6),((aW8).S.charCodeAt(aWB)));
}
}
// writeChar
function aW4(aWD /*me*/,aWE /*n*/){
if(aWD.F6.I<aWD.F6.F.length)
aWD.F6.F=aWD.F6.F.slice(0,aWD.F6.I)+String.fromCharCode(aWE)+aWD.F6.F.slice(aWD.F6.I+1);
else{
aWD.F6.F+=String.fromCharCode(aWE);
}
aWD.F6.I++;
}
// writeStr
function uB(aWF /*me*/,aWG /*n*/){
let aWJ=0;
let aWK=0;
aWI:
for(aWJ=(0),aWK=(((aWG).S.length)-(1));aWJ<=aWK;aWJ+=(1)){
(aW4)((aWF),((aWG).S.charCodeAt(aWJ)));
}
}
// _copy
function aWL(aWM){
let aWN=null;
(aWN)=(new u5());
((aWN).F6)=((aWM).F6);
return aWN;
}
// _toBin
function aWO(aWP){
let aWQ=null;
(aWQ)=(new Array(8).fill(0));
(aWQ)=((aWQ).concat(toBin_((aWP).F6)));
return aWQ;
}
// _fromBin
function aWS(aWT,aWU,aWV){
let aWW=null;
(aWW)=(new u5());
((aWW).F6)=(fromBin_((aWU),(aWV.$)));
return aWW;
}
// _dtor
function aWX(aWY){
((aWY).va)=(null);
((aWY).FU)=(null);
}
// _copy
function aWZ(aXa){
let aXb=null;
(aXb)=(new uK());
((aXb).va)=(C_([129,2],((aXa).va)));
((aXb).FU)=(C_([129,2],((aXa).FU)));
((aXb).uM)=((aXa).uM);
((aXb).qc)=((aXa).qc);
return aXb;
}
// _toBin
function aXc(aXd){
let aXe=null;
(aXe)=(new Array(8).fill(0));
(aXe)=((aXe).concat(toBin_((aXd).va)));
(aXe)=((aXe).concat(toBin_((aXd).FU)));
(aXe)=((aXe).concat(toBin_((aXd).uM)));
(aXe)=((aXe).concat(toBin_((aXd).qc)));
return aXe;
}
// _fromBin
function aXj(aXk,aXl,aXm){
let aXn=null;
(aXn)=(new uK());
((aXn).va)=(fromBin_((aXl),(aXm.$)));
((aXn).FU)=(fromBin_((aXl),(aXm.$)));
((aXn).uM)=(fromBin_((aXl),(aXm.$)));
((aXn).qc)=(fromBin_((aXl),(aXm.$)));
return aXn;
}
// _dtor
function aXo(aXp){
((aXp).v7)=(null);
((aXp).v8)=(null);
}
// _copy
function aXq(aXr){
let aXs=null;
(aXs)=(new v6());
((aXs).v7)=(C_([129,2],((aXr).v7)));
((aXs).v8)=(C_([134],((aXr).v8)));
return aXs;
}
// _toBin
function aXt(aXu){
let aXv=null;
(aXv)=(new Array(8).fill(0));
(aXv)=((aXv).concat(toBin_((aXu).v7)));
(aXv)=((aXv).concat(toBin_((aXu).v8)));
return aXv;
}
// _fromBin
function aXy(aXz,aX0,aX1){
let aX2=null;
(aX2)=(new v6());
((aX2).v7)=(fromBin_((aX0),(aX1.$)));
((aX2).v8)=(fromBin_((aX0),(aX1.$)));
return aX2;
}
// _dtor
function aX3(aX4){
((aX4).xx)=(null);
((aX4).ql)=(null);
((aX4).qX)=(null);
((aX4).qU)=(null);
((aX4).pY)=(null);
((aX4).q0)=(null);
((aX4).qz)=(null);
((aX4).zo)=(null);
}
// _copy
function aX5(aX6){
let aX7=null;
(aX7)=(new xh());
((aX7).xx)=(C_([134],((aX6).xx)));
((aX7).ql)=(C_([134],((aX6).ql)));
((aX7).qX)=(C_([129,2],((aX6).qX)));
((aX7).qU)=(C_([134],((aX6).qU)));
((aX7).pY)=(C_([133,129,2,134],((aX6).pY)));
((aX7).q0)=(C_([129,2],((aX6).q0)));
((aX7).qz)=(C_([134],((aX6).qz)));
((aX7).zo)=(C_([134],((aX6).zo)));
((aX7).r5)=((aX6).r5);
((aX7).qc)=((aX6).qc);
return aX7;
}
// _toBin
function aX8(aX9){
let aXA=null;
(aXA)=(new Array(8).fill(0));
(aXA)=((aXA).concat(toBin_((aX9).xx)));
(aXA)=((aXA).concat(toBin_((aX9).ql)));
(aXA)=((aXA).concat(toBin_((aX9).qX)));
(aXA)=((aXA).concat(toBin_((aX9).qU)));
(aXA)=((aXA).concat(toBin_((aX9).pY)));
(aXA)=((aXA).concat(toBin_((aX9).q0)));
(aXA)=((aXA).concat(toBin_((aX9).qz)));
(aXA)=((aXA).concat(toBin_((aX9).zo)));
(aXA)=((aXA).concat(toBin_((aX9).r5)));
(aXA)=((aXA).concat(toBin_((aX9).qc)));
return aXA;
}
// _fromBin
function aXL(aXM,aXN,aXO){
let aXP=null;
(aXP)=(new xh());
((aXP).xx)=(fromBin_((aXN),(aXO.$)));
((aXP).ql)=(fromBin_((aXN),(aXO.$)));
((aXP).qX)=(fromBin_((aXN),(aXO.$)));
((aXP).qU)=(fromBin_((aXN),(aXO.$)));
((aXP).pY)=(fromBin_((aXN),(aXO.$)));
((aXP).q0)=(fromBin_((aXN),(aXO.$)));
((aXP).qz)=(fromBin_((aXN),(aXO.$)));
((aXP).zo)=(fromBin_((aXN),(aXO.$)));
((aXP).r5)=(fromBin_((aXN),(aXO.$)));
((aXP).qc)=(fromBin_((aXN),(aXO.$)));
return aXP;
}
// _dtor
function aXQ(aXR){
((aXR).Nk)=(null);
((aXR).ql)=(null);
((aXR).qX)=(null);
((aXR).qU)=(null);
((aXR).pY)=(null);
((aXR).q0)=(null);
((aXR).qz)=(null);
((aXR).zo)=(null);
}
// _copy
function aXS(aXT){
let aXU=null;
(aXU)=(new xk());
((aXU).Nk)=(C_([134],((aXT).Nk)));
((aXU).ql)=(C_([134],((aXT).ql)));
((aXU).qX)=(C_([129,2],((aXT).qX)));
((aXU).qU)=(C_([134],((aXT).qU)));
((aXU).pY)=(C_([133,129,2,134],((aXT).pY)));
((aXU).q0)=(C_([129,2],((aXT).q0)));
((aXU).qz)=(C_([134],((aXT).qz)));
((aXU).zo)=(C_([134],((aXT).zo)));
((aXU).r5)=((aXT).r5);
((aXU).qc)=((aXT).qc);
return aXU;
}
// _toBin
function aXV(aXW){
let aXX=null;
(aXX)=(new Array(8).fill(0));
(aXX)=((aXX).concat(toBin_((aXW).Nk)));
(aXX)=((aXX).concat(toBin_((aXW).ql)));
(aXX)=((aXX).concat(toBin_((aXW).qX)));
(aXX)=((aXX).concat(toBin_((aXW).qU)));
(aXX)=((aXX).concat(toBin_((aXW).pY)));
(aXX)=((aXX).concat(toBin_((aXW).q0)));
(aXX)=((aXX).concat(toBin_((aXW).qz)));
(aXX)=((aXX).concat(toBin_((aXW).zo)));
(aXX)=((aXX).concat(toBin_((aXW).r5)));
(aXX)=((aXX).concat(toBin_((aXW).qc)));
return aXX;
}
// _fromBin
function aYi(aYj,aYk,aYl){
let aYm=null;
(aYm)=(new xk());
((aYm).Nk)=(fromBin_((aYk),(aYl.$)));
((aYm).ql)=(fromBin_((aYk),(aYl.$)));
((aYm).qX)=(fromBin_((aYk),(aYl.$)));
((aYm).qU)=(fromBin_((aYk),(aYl.$)));
((aYm).pY)=(fromBin_((aYk),(aYl.$)));
((aYm).q0)=(fromBin_((aYk),(aYl.$)));
((aYm).qz)=(fromBin_((aYk),(aYl.$)));
((aYm).zo)=(fromBin_((aYk),(aYl.$)));
((aYm).r5)=(fromBin_((aYk),(aYl.$)));
((aYm).qc)=(fromBin_((aYk),(aYl.$)));
return aYm;
}
// _dtor
function aYn(aYo){
((aYo).Ob)=(null);
((aYo).ql)=(null);
((aYo).qX)=(null);
((aYo).qU)=(null);
((aYo).pY)=(null);
((aYo).q0)=(null);
((aYo).qz)=(null);
((aYo).zo)=(null);
}
// _copy
function aYp(aYq){
let aYr=null;
(aYr)=(new xq());
((aYr).Ob)=(C_([130,134],((aYq).Ob)));
((aYr).ql)=(C_([134],((aYq).ql)));
((aYr).qX)=(C_([129,2],((aYq).qX)));
((aYr).qU)=(C_([134],((aYq).qU)));
((aYr).pY)=(C_([133,129,2,134],((aYq).pY)));
((aYr).q0)=(C_([129,2],((aYq).q0)));
((aYr).qz)=(C_([134],((aYq).qz)));
((aYr).zo)=(C_([134],((aYq).zo)));
((aYr).r5)=((aYq).r5);
((aYr).qc)=((aYq).qc);
return aYr;
}
// _toBin
function aYs(aYt){
let aYu=null;
(aYu)=(new Array(8).fill(0));
(aYu)=((aYu).concat(toBin_((aYt).Ob)));
(aYu)=((aYu).concat(toBin_((aYt).ql)));
(aYu)=((aYu).concat(toBin_((aYt).qX)));
(aYu)=((aYu).concat(toBin_((aYt).qU)));
(aYu)=((aYu).concat(toBin_((aYt).pY)));
(aYu)=((aYu).concat(toBin_((aYt).q0)));
(aYu)=((aYu).concat(toBin_((aYt).qz)));
(aYu)=((aYu).concat(toBin_((aYt).zo)));
(aYu)=((aYu).concat(toBin_((aYt).r5)));
(aYu)=((aYu).concat(toBin_((aYt).qc)));
return aYu;
}
// _fromBin
function aY5(aY6,aY7,aY8){
let aY9=null;
(aY9)=(new xq());
((aY9).Ob)=(fromBin_((aY7),(aY8.$)));
((aY9).ql)=(fromBin_((aY7),(aY8.$)));
((aY9).qX)=(fromBin_((aY7),(aY8.$)));
((aY9).qU)=(fromBin_((aY7),(aY8.$)));
((aY9).pY)=(fromBin_((aY7),(aY8.$)));
((aY9).q0)=(fromBin_((aY7),(aY8.$)));
((aY9).qz)=(fromBin_((aY7),(aY8.$)));
((aY9).zo)=(fromBin_((aY7),(aY8.$)));
((aY9).r5)=(fromBin_((aY7),(aY8.$)));
((aY9).qc)=(fromBin_((aY7),(aY8.$)));
return aY9;
}
// _dtor
function aYA(aYB){
((aYB).ql)=(null);
((aYB).qX)=(null);
((aYB).qU)=(null);
((aYB).pY)=(null);
((aYB).q0)=(null);
((aYB).qz)=(null);
((aYB).zo)=(null);
}
// _copy
function aYC(aYD){
let aYE=null;
(aYE)=(new xR());
((aYE).ql)=(C_([134],((aYD).ql)));
((aYE).qX)=(C_([129,2],((aYD).qX)));
((aYE).qU)=(C_([134],((aYD).qU)));
((aYE).pY)=(C_([133,129,2,134],((aYD).pY)));
((aYE).q0)=(C_([129,2],((aYD).q0)));
((aYE).qz)=(C_([134],((aYD).qz)));
((aYE).zo)=(C_([134],((aYD).zo)));
((aYE).r5)=((aYD).r5);
((aYE).qc)=((aYD).qc);
return aYE;
}
// _toBin
function aYF(aYG){
let aYH=null;
(aYH)=(new Array(8).fill(0));
(aYH)=((aYH).concat(toBin_((aYG).ql)));
(aYH)=((aYH).concat(toBin_((aYG).qX)));
(aYH)=((aYH).concat(toBin_((aYG).qU)));
(aYH)=((aYH).concat(toBin_((aYG).pY)));
(aYH)=((aYH).concat(toBin_((aYG).q0)));
(aYH)=((aYH).concat(toBin_((aYG).qz)));
(aYH)=((aYH).concat(toBin_((aYG).zo)));
(aYH)=((aYH).concat(toBin_((aYG).r5)));
(aYH)=((aYH).concat(toBin_((aYG).qc)));
return aYH;
}
// _fromBin
function aYR(aYS,aYT,aYU){
let aYV=null;
(aYV)=(new xR());
((aYV).ql)=(fromBin_((aYT),(aYU.$)));
((aYV).qX)=(fromBin_((aYT),(aYU.$)));
((aYV).qU)=(fromBin_((aYT),(aYU.$)));
((aYV).pY)=(fromBin_((aYT),(aYU.$)));
((aYV).q0)=(fromBin_((aYT),(aYU.$)));
((aYV).qz)=(fromBin_((aYT),(aYU.$)));
((aYV).zo)=(fromBin_((aYT),(aYU.$)));
((aYV).r5)=(fromBin_((aYT),(aYU.$)));
((aYV).qc)=(fromBin_((aYT),(aYU.$)));
return aYV;
}
// _dtor
function aYW(aYX){
((aYX).xZ)=(null);
((aYX).ql)=(null);
((aYX).qX)=(null);
((aYX).qU)=(null);
((aYX).pY)=(null);
((aYX).q0)=(null);
((aYX).qz)=(null);
((aYX).zo)=(null);
}
// _copy
function aYY(aYZ){
let aZa=null;
(aZa)=(new xQ());
((aZa).xZ)=(C_([134],((aYZ).xZ)));
((aZa).ql)=(C_([134],((aYZ).ql)));
((aZa).qX)=(C_([129,2],((aYZ).qX)));
((aZa).qU)=(C_([134],((aYZ).qU)));
((aZa).pY)=(C_([133,129,2,134],((aYZ).pY)));
((aZa).q0)=(C_([129,2],((aYZ).q0)));
((aZa).qz)=(C_([134],((aYZ).qz)));
((aZa).zo)=(C_([134],((aYZ).zo)));
((aZa).r5)=((aYZ).r5);
((aZa).qc)=((aYZ).qc);
return aZa;
}
// _toBin
function aZb(aZc){
let aZd=null;
(aZd)=(new Array(8).fill(0));
(aZd)=((aZd).concat(toBin_((aZc).xZ)));
(aZd)=((aZd).concat(toBin_((aZc).ql)));
(aZd)=((aZd).concat(toBin_((aZc).qX)));
(aZd)=((aZd).concat(toBin_((aZc).qU)));
(aZd)=((aZd).concat(toBin_((aZc).pY)));
(aZd)=((aZd).concat(toBin_((aZc).q0)));
(aZd)=((aZd).concat(toBin_((aZc).qz)));
(aZd)=((aZd).concat(toBin_((aZc).zo)));
(aZd)=((aZd).concat(toBin_((aZc).r5)));
(aZd)=((aZd).concat(toBin_((aZc).qc)));
return aZd;
}
// _fromBin
function aZo(aZp,aZq,aZr){
let aZs=null;
(aZs)=(new xQ());
((aZs).xZ)=(fromBin_((aZq),(aZr.$)));
((aZs).ql)=(fromBin_((aZq),(aZr.$)));
((aZs).qX)=(fromBin_((aZq),(aZr.$)));
((aZs).qU)=(fromBin_((aZq),(aZr.$)));
((aZs).pY)=(fromBin_((aZq),(aZr.$)));
((aZs).q0)=(fromBin_((aZq),(aZr.$)));
((aZs).qz)=(fromBin_((aZq),(aZr.$)));
((aZs).zo)=(fromBin_((aZq),(aZr.$)));
((aZs).r5)=(fromBin_((aZq),(aZr.$)));
((aZs).qc)=(fromBin_((aZq),(aZr.$)));
return aZs;
}
// _dtor
function aZt(aZu){
((aZu).ye)=(null);
((aZu).yf)=(null);
((aZu).yi)=(null);
((aZu).xZ)=(null);
((aZu).ql)=(null);
((aZu).qX)=(null);
((aZu).qU)=(null);
((aZu).pY)=(null);
((aZu).q0)=(null);
((aZu).qz)=(null);
((aZu).zo)=(null);
}
// _copy
function aZv(aZw){
let aZx=null;
(aZx)=(new xP());
((aZx).ye)=(C_([134],((aZw).ye)));
((aZx).yf)=(C_([130,134],((aZw).yf)));
((aZx).yi)=(C_([134],((aZw).yi)));
((aZx).xZ)=(C_([134],((aZw).xZ)));
((aZx).ql)=(C_([134],((aZw).ql)));
((aZx).qX)=(C_([129,2],((aZw).qX)));
((aZx).qU)=(C_([134],((aZw).qU)));
((aZx).pY)=(C_([133,129,2,134],((aZw).pY)));
((aZx).q0)=(C_([129,2],((aZw).q0)));
((aZx).qz)=(C_([134],((aZw).qz)));
((aZx).zo)=(C_([134],((aZw).zo)));
((aZx).r5)=((aZw).r5);
((aZx).qc)=((aZw).qc);
return aZx;
}
// _toBin
function aZy(aZz){
let aZ0=null;
(aZ0)=(new Array(8).fill(0));
(aZ0)=((aZ0).concat(toBin_((aZz).ye)));
(aZ0)=((aZ0).concat(toBin_((aZz).yf)));
(aZ0)=((aZ0).concat(toBin_((aZz).yi)));
(aZ0)=((aZ0).concat(toBin_((aZz).xZ)));
(aZ0)=((aZ0).concat(toBin_((aZz).ql)));
(aZ0)=((aZ0).concat(toBin_((aZz).qX)));
(aZ0)=((aZ0).concat(toBin_((aZz).qU)));
(aZ0)=((aZ0).concat(toBin_((aZz).pY)));
(aZ0)=((aZ0).concat(toBin_((aZz).q0)));
(aZ0)=((aZ0).concat(toBin_((aZz).qz)));
(aZ0)=((aZ0).concat(toBin_((aZz).zo)));
(aZ0)=((aZ0).concat(toBin_((aZz).r5)));
(aZ0)=((aZ0).concat(toBin_((aZz).qc)));
return aZ0;
}
// _fromBin
function aZE(aZF,aZG,aZH){
let aZI=null;
(aZI)=(new xP());
((aZI).ye)=(fromBin_((aZG),(aZH.$)));
((aZI).yf)=(fromBin_((aZG),(aZH.$)));
((aZI).yi)=(fromBin_((aZG),(aZH.$)));
((aZI).xZ)=(fromBin_((aZG),(aZH.$)));
((aZI).ql)=(fromBin_((aZG),(aZH.$)));
((aZI).qX)=(fromBin_((aZG),(aZH.$)));
((aZI).qU)=(fromBin_((aZG),(aZH.$)));
((aZI).pY)=(fromBin_((aZG),(aZH.$)));
((aZI).q0)=(fromBin_((aZG),(aZH.$)));
((aZI).qz)=(fromBin_((aZG),(aZH.$)));
((aZI).zo)=(fromBin_((aZG),(aZH.$)));
((aZI).r5)=(fromBin_((aZG),(aZH.$)));
((aZI).qc)=(fromBin_((aZG),(aZH.$)));
return aZI;
}
// _dtor
function aZJ(aZK){
((aZK).ql)=(null);
((aZK).qX)=(null);
((aZK).qU)=(null);
((aZK).pY)=(null);
((aZK).q0)=(null);
((aZK).qz)=(null);
((aZK).zo)=(null);
}
// _copy
function aZL(aZM){
let aZN=null;
(aZN)=(new xW());
((aZN).xX)=((aZM).xX);
((aZN).ql)=(C_([134],((aZM).ql)));
((aZN).qX)=(C_([129,2],((aZM).qX)));
((aZN).qU)=(C_([134],((aZM).qU)));
((aZN).pY)=(C_([133,129,2,134],((aZM).pY)));
((aZN).q0)=(C_([129,2],((aZM).q0)));
((aZN).qz)=(C_([134],((aZM).qz)));
((aZN).zo)=(C_([134],((aZM).zo)));
((aZN).r5)=((aZM).r5);
((aZN).qc)=((aZM).qc);
return aZN;
}
// _toBin
function aZO(aZP){
let aZQ=null;
(aZQ)=(new Array(8).fill(0));
(aZQ)=((aZQ).concat(toBin_((aZP).xX)));
(aZQ)=((aZQ).concat(toBin_((aZP).ql)));
(aZQ)=((aZQ).concat(toBin_((aZP).qX)));
(aZQ)=((aZQ).concat(toBin_((aZP).qU)));
(aZQ)=((aZQ).concat(toBin_((aZP).pY)));
(aZQ)=((aZQ).concat(toBin_((aZP).q0)));
(aZQ)=((aZQ).concat(toBin_((aZP).qz)));
(aZQ)=((aZQ).concat(toBin_((aZP).zo)));
(aZQ)=((aZQ).concat(toBin_((aZP).r5)));
(aZQ)=((aZQ).concat(toBin_((aZP).qc)));
return aZQ;
}
// _fromBin
function bab(bac,bad,bae){
let baf=null;
(baf)=(new xW());
((baf).xX)=(fromBin_((bad),(bae.$)));
((baf).ql)=(fromBin_((bad),(bae.$)));
((baf).qX)=(fromBin_((bad),(bae.$)));
((baf).qU)=(fromBin_((bad),(bae.$)));
((baf).pY)=(fromBin_((bad),(bae.$)));
((baf).q0)=(fromBin_((bad),(bae.$)));
((baf).qz)=(fromBin_((bad),(bae.$)));
((baf).zo)=(fromBin_((bad),(bae.$)));
((baf).r5)=(fromBin_((bad),(bae.$)));
((baf).qc)=(fromBin_((bad),(bae.$)));
return baf;
}
// _dtor
function bag(bah){
((bah).yd)=(null);
((bah).xZ)=(null);
((bah).ql)=(null);
((bah).qX)=(null);
((bah).qU)=(null);
((bah).pY)=(null);
((bah).q0)=(null);
((bah).qz)=(null);
((bah).zo)=(null);
}
// _copy
function bai(baj){
let bak=null;
(bak)=(new yc());
((bak).yd)=(C_([130,134],((baj).yd)));
((bak).xZ)=(C_([134],((baj).xZ)));
((bak).ql)=(C_([134],((baj).ql)));
((bak).qX)=(C_([129,2],((baj).qX)));
((bak).qU)=(C_([134],((baj).qU)));
((bak).pY)=(C_([133,129,2,134],((baj).pY)));
((bak).q0)=(C_([129,2],((baj).q0)));
((bak).qz)=(C_([134],((baj).qz)));
((bak).zo)=(C_([134],((baj).zo)));
((bak).r5)=((baj).r5);
((bak).qc)=((baj).qc);
return bak;
}
// _toBin
function bal(bam){
let ban=null;
(ban)=(new Array(8).fill(0));
(ban)=((ban).concat(toBin_((bam).yd)));
(ban)=((ban).concat(toBin_((bam).xZ)));
(ban)=((ban).concat(toBin_((bam).ql)));
(ban)=((ban).concat(toBin_((bam).qX)));
(ban)=((ban).concat(toBin_((bam).qU)));
(ban)=((ban).concat(toBin_((bam).pY)));
(ban)=((ban).concat(toBin_((bam).q0)));
(ban)=((ban).concat(toBin_((bam).qz)));
(ban)=((ban).concat(toBin_((bam).zo)));
(ban)=((ban).concat(toBin_((bam).r5)));
(ban)=((ban).concat(toBin_((bam).qc)));
return ban;
}
// _fromBin
function baz(ba0,ba1,ba2){
let ba3=null;
(ba3)=(new yc());
((ba3).yd)=(fromBin_((ba1),(ba2.$)));
((ba3).xZ)=(fromBin_((ba1),(ba2.$)));
((ba3).ql)=(fromBin_((ba1),(ba2.$)));
((ba3).qX)=(fromBin_((ba1),(ba2.$)));
((ba3).qU)=(fromBin_((ba1),(ba2.$)));
((ba3).pY)=(fromBin_((ba1),(ba2.$)));
((ba3).q0)=(fromBin_((ba1),(ba2.$)));
((ba3).qz)=(fromBin_((ba1),(ba2.$)));
((ba3).zo)=(fromBin_((ba1),(ba2.$)));
((ba3).r5)=(fromBin_((ba1),(ba2.$)));
((ba3).qc)=(fromBin_((ba1),(ba2.$)));
return ba3;
}
// _dtor
function ba4(ba5){
((ba5).yz)=(null);
((ba5).ql)=(null);
((ba5).qX)=(null);
((ba5).qU)=(null);
((ba5).pY)=(null);
((ba5).q0)=(null);
((ba5).qz)=(null);
((ba5).zo)=(null);
}
// _copy
function ba6(ba7){
let ba8=null;
(ba8)=(new yp());
((ba8).yz)=(C_([134],((ba7).yz)));
((ba8).ql)=(C_([134],((ba7).ql)));
((ba8).qX)=(C_([129,2],((ba7).qX)));
((ba8).qU)=(C_([134],((ba7).qU)));
((ba8).pY)=(C_([133,129,2,134],((ba7).pY)));
((ba8).q0)=(C_([129,2],((ba7).q0)));
((ba8).qz)=(C_([134],((ba7).qz)));
((ba8).zo)=(C_([134],((ba7).zo)));
((ba8).r5)=((ba7).r5);
((ba8).qc)=((ba7).qc);
return ba8;
}
// _toBin
function ba9(baA){
let baB=null;
(baB)=(new Array(8).fill(0));
(baB)=((baB).concat(toBin_((baA).yz)));
(baB)=((baB).concat(toBin_((baA).ql)));
(baB)=((baB).concat(toBin_((baA).qX)));
(baB)=((baB).concat(toBin_((baA).qU)));
(baB)=((baB).concat(toBin_((baA).pY)));
(baB)=((baB).concat(toBin_((baA).q0)));
(baB)=((baB).concat(toBin_((baA).qz)));
(baB)=((baB).concat(toBin_((baA).zo)));
(baB)=((baB).concat(toBin_((baA).r5)));
(baB)=((baB).concat(toBin_((baA).qc)));
return baB;
}
// _fromBin
function baM(baN,baO,baP){
let baQ=null;
(baQ)=(new yp());
((baQ).yz)=(fromBin_((baO),(baP.$)));
((baQ).ql)=(fromBin_((baO),(baP.$)));
((baQ).qX)=(fromBin_((baO),(baP.$)));
((baQ).qU)=(fromBin_((baO),(baP.$)));
((baQ).pY)=(fromBin_((baO),(baP.$)));
((baQ).q0)=(fromBin_((baO),(baP.$)));
((baQ).qz)=(fromBin_((baO),(baP.$)));
((baQ).zo)=(fromBin_((baO),(baP.$)));
((baQ).r5)=(fromBin_((baO),(baP.$)));
((baQ).qc)=(fromBin_((baO),(baP.$)));
return baQ;
}
// _dtor
function baR(baS){
((baS).yI)=(null);
((baS).ql)=(null);
((baS).qX)=(null);
((baS).qU)=(null);
((baS).pY)=(null);
((baS).q0)=(null);
((baS).qz)=(null);
((baS).zo)=(null);
}
// _copy
function baT(baU){
let baV=null;
(baV)=(new yt());
((baV).yI)=(C_([134],((baU).yI)));
((baV).yE)=((baU).yE);
((baV).ql)=(C_([134],((baU).ql)));
((baV).qX)=(C_([129,2],((baU).qX)));
((baV).qU)=(C_([134],((baU).qU)));
((baV).pY)=(C_([133,129,2,134],((baU).pY)));
((baV).q0)=(C_([129,2],((baU).q0)));
((baV).qz)=(C_([134],((baU).qz)));
((baV).zo)=(C_([134],((baU).zo)));
((baV).r5)=((baU).r5);
((baV).qc)=((baU).qc);
return baV;
}
// _toBin
function baW(baX){
let baY=null;
(baY)=(new Array(8).fill(0));
(baY)=((baY).concat(toBin_((baX).yI)));
(baY)=((baY).concat(toBin_((baX).yE)));
(baY)=((baY).concat(toBin_((baX).ql)));
(baY)=((baY).concat(toBin_((baX).qX)));
(baY)=((baY).concat(toBin_((baX).qU)));
(baY)=((baY).concat(toBin_((baX).pY)));
(baY)=((baY).concat(toBin_((baX).q0)));
(baY)=((baY).concat(toBin_((baX).qz)));
(baY)=((baY).concat(toBin_((baX).zo)));
(baY)=((baY).concat(toBin_((baX).r5)));
(baY)=((baY).concat(toBin_((baX).qc)));
return baY;
}
// _fromBin
function bbk(bbl,bbm,bbn){
let bbo=null;
(bbo)=(new yt());
((bbo).yI)=(fromBin_((bbm),(bbn.$)));
((bbo).yE)=(fromBin_((bbm),(bbn.$)));
((bbo).ql)=(fromBin_((bbm),(bbn.$)));
((bbo).qX)=(fromBin_((bbm),(bbn.$)));
((bbo).qU)=(fromBin_((bbm),(bbn.$)));
((bbo).pY)=(fromBin_((bbm),(bbn.$)));
((bbo).q0)=(fromBin_((bbm),(bbn.$)));
((bbo).qz)=(fromBin_((bbm),(bbn.$)));
((bbo).zo)=(fromBin_((bbm),(bbn.$)));
((bbo).r5)=(fromBin_((bbm),(bbn.$)));
((bbo).qc)=(fromBin_((bbm),(bbn.$)));
return bbo;
}
// _dtor
function bbp(bbq){
((bbq).yy)=(null);
((bbq).yv)=(null);
((bbq).yI)=(null);
((bbq).ql)=(null);
((bbq).qX)=(null);
((bbq).qU)=(null);
((bbq).pY)=(null);
((bbq).q0)=(null);
((bbq).qz)=(null);
((bbq).zo)=(null);
}
// _copy
function bbr(bbs){
let bbt=null;
(bbt)=(new ys());
((bbt).yy)=(C_([134],((bbs).yy)));
((bbt).yv)=(C_([130,134],((bbs).yv)));
((bbt).yI)=(C_([134],((bbs).yI)));
((bbt).yE)=((bbs).yE);
((bbt).ql)=(C_([134],((bbs).ql)));
((bbt).qX)=(C_([129,2],((bbs).qX)));
((bbt).qU)=(C_([134],((bbs).qU)));
((bbt).pY)=(C_([133,129,2,134],((bbs).pY)));
((bbt).q0)=(C_([129,2],((bbs).q0)));
((bbt).qz)=(C_([134],((bbs).qz)));
((bbt).zo)=(C_([134],((bbs).zo)));
((bbt).r5)=((bbs).r5);
((bbt).qc)=((bbs).qc);
return bbt;
}
// _toBin
function bbu(bbv){
let bbw=null;
(bbw)=(new Array(8).fill(0));
(bbw)=((bbw).concat(toBin_((bbv).yy)));
(bbw)=((bbw).concat(toBin_((bbv).yv)));
(bbw)=((bbw).concat(toBin_((bbv).yI)));
(bbw)=((bbw).concat(toBin_((bbv).yE)));
(bbw)=((bbw).concat(toBin_((bbv).ql)));
(bbw)=((bbw).concat(toBin_((bbv).qX)));
(bbw)=((bbw).concat(toBin_((bbv).qU)));
(bbw)=((bbw).concat(toBin_((bbv).pY)));
(bbw)=((bbw).concat(toBin_((bbv).q0)));
(bbw)=((bbw).concat(toBin_((bbv).qz)));
(bbw)=((bbw).concat(toBin_((bbv).zo)));
(bbw)=((bbw).concat(toBin_((bbv).r5)));
(bbw)=((bbw).concat(toBin_((bbv).qc)));
return bbw;
}
// _fromBin
function bbA(bbB,bbC,bbD){
let bbE=null;
(bbE)=(new ys());
((bbE).yy)=(fromBin_((bbC),(bbD.$)));
((bbE).yv)=(fromBin_((bbC),(bbD.$)));
((bbE).yI)=(fromBin_((bbC),(bbD.$)));
((bbE).yE)=(fromBin_((bbC),(bbD.$)));
((bbE).ql)=(fromBin_((bbC),(bbD.$)));
((bbE).qX)=(fromBin_((bbC),(bbD.$)));
((bbE).qU)=(fromBin_((bbC),(bbD.$)));
((bbE).pY)=(fromBin_((bbC),(bbD.$)));
((bbE).q0)=(fromBin_((bbC),(bbD.$)));
((bbE).qz)=(fromBin_((bbC),(bbD.$)));
((bbE).zo)=(fromBin_((bbC),(bbD.$)));
((bbE).r5)=(fromBin_((bbC),(bbD.$)));
((bbE).qc)=(fromBin_((bbC),(bbD.$)));
return bbE;
}
// _dtor
function bbF(bbG){
((bbG).y3)=(null);
((bbG).y6)=(null);
((bbG).ql)=(null);
((bbG).qX)=(null);
((bbG).qU)=(null);
((bbG).pY)=(null);
((bbG).q0)=(null);
((bbG).qz)=(null);
((bbG).zo)=(null);
}
// _copy
function bbH(bbI){
let bbJ=null;
(bbJ)=(new y2());
((bbJ).y3)=(C_([130,134],((bbI).y3)));
((bbJ).y6)=(C_([134],((bbI).y6)));
((bbJ).ql)=(C_([134],((bbI).ql)));
((bbJ).qX)=(C_([129,2],((bbI).qX)));
((bbJ).qU)=(C_([134],((bbI).qU)));
((bbJ).pY)=(C_([133,129,2,134],((bbI).pY)));
((bbJ).q0)=(C_([129,2],((bbI).q0)));
((bbJ).qz)=(C_([134],((bbI).qz)));
((bbJ).zo)=(C_([134],((bbI).zo)));
((bbJ).r5)=((bbI).r5);
((bbJ).qc)=((bbI).qc);
return bbJ;
}
// _toBin
function bbK(bbL){
let bbM=null;
(bbM)=(new Array(8).fill(0));
(bbM)=((bbM).concat(toBin_((bbL).y3)));
(bbM)=((bbM).concat(toBin_((bbL).y6)));
(bbM)=((bbM).concat(toBin_((bbL).ql)));
(bbM)=((bbM).concat(toBin_((bbL).qX)));
(bbM)=((bbM).concat(toBin_((bbL).qU)));
(bbM)=((bbM).concat(toBin_((bbL).pY)));
(bbM)=((bbM).concat(toBin_((bbL).q0)));
(bbM)=((bbM).concat(toBin_((bbL).qz)));
(bbM)=((bbM).concat(toBin_((bbL).zo)));
(bbM)=((bbM).concat(toBin_((bbL).r5)));
(bbM)=((bbM).concat(toBin_((bbL).qc)));
return bbM;
}
// _fromBin
function bbY(bbZ,bca,bcb){
let bcc=null;
(bcc)=(new y2());
((bcc).y3)=(fromBin_((bca),(bcb.$)));
((bcc).y6)=(fromBin_((bca),(bcb.$)));
((bcc).ql)=(fromBin_((bca),(bcb.$)));
((bcc).qX)=(fromBin_((bca),(bcb.$)));
((bcc).qU)=(fromBin_((bca),(bcb.$)));
((bcc).pY)=(fromBin_((bca),(bcb.$)));
((bcc).q0)=(fromBin_((bca),(bcb.$)));
((bcc).qz)=(fromBin_((bca),(bcb.$)));
((bcc).zo)=(fromBin_((bca),(bcb.$)));
((bcc).r5)=(fromBin_((bca),(bcb.$)));
((bcc).qc)=(fromBin_((bca),(bcb.$)));
return bcc;
}
// _dtor
function bcd(bce){
((bce).yJ)=(null);
((bce).yO)=(null);
}
// _copy
function bcf(bcg){
let bch=null;
(bch)=(new y9());
((bch).yJ)=(C_([134],((bcg).yJ)));
((bch).yO)=(C_([134],((bcg).yO)));
return bch;
}
// _toBin
function bci(bcj){
let bck=null;
(bck)=(new Array(8).fill(0));
(bck)=((bck).concat(toBin_((bcj).yJ)));
(bck)=((bck).concat(toBin_((bcj).yO)));
return bck;
}
// _fromBin
function bcn(bco,bcp,bcq){
let bcr=null;
(bcr)=(new y9());
((bcr).yJ)=(fromBin_((bcp),(bcq.$)));
((bcr).yO)=(fromBin_((bcp),(bcq.$)));
return bcr;
}
// _dtor
function bcs(bct){
((bct).yI)=(null);
((bct).ql)=(null);
((bct).qX)=(null);
((bct).qU)=(null);
((bct).pY)=(null);
((bct).q0)=(null);
((bct).qz)=(null);
((bct).zo)=(null);
}
// _copy
function bcu(bcv){
let bcw=null;
(bcw)=(new yD());
((bcw).yI)=(C_([134],((bcv).yI)));
((bcw).yE)=((bcv).yE);
((bcw).ql)=(C_([134],((bcv).ql)));
((bcw).qX)=(C_([129,2],((bcv).qX)));
((bcw).qU)=(C_([134],((bcv).qU)));
((bcw).pY)=(C_([133,129,2,134],((bcv).pY)));
((bcw).q0)=(C_([129,2],((bcv).q0)));
((bcw).qz)=(C_([134],((bcv).qz)));
((bcw).zo)=(C_([134],((bcv).zo)));
((bcw).r5)=((bcv).r5);
((bcw).qc)=((bcv).qc);
return bcw;
}
// _toBin
function bcx(bcy){
let bcz=null;
(bcz)=(new Array(8).fill(0));
(bcz)=((bcz).concat(toBin_((bcy).yI)));
(bcz)=((bcz).concat(toBin_((bcy).yE)));
(bcz)=((bcz).concat(toBin_((bcy).ql)));
(bcz)=((bcz).concat(toBin_((bcy).qX)));
(bcz)=((bcz).concat(toBin_((bcy).qU)));
(bcz)=((bcz).concat(toBin_((bcy).pY)));
(bcz)=((bcz).concat(toBin_((bcy).q0)));
(bcz)=((bcz).concat(toBin_((bcy).qz)));
(bcz)=((bcz).concat(toBin_((bcy).zo)));
(bcz)=((bcz).concat(toBin_((bcy).r5)));
(bcz)=((bcz).concat(toBin_((bcy).qc)));
return bcz;
}
// _fromBin
function bcB(bcC,bcD,bcE){
let bcF=null;
(bcF)=(new yD());
((bcF).yI)=(fromBin_((bcD),(bcE.$)));
((bcF).yE)=(fromBin_((bcD),(bcE.$)));
((bcF).ql)=(fromBin_((bcD),(bcE.$)));
((bcF).qX)=(fromBin_((bcD),(bcE.$)));
((bcF).qU)=(fromBin_((bcD),(bcE.$)));
((bcF).pY)=(fromBin_((bcD),(bcE.$)));
((bcF).q0)=(fromBin_((bcD),(bcE.$)));
((bcF).qz)=(fromBin_((bcD),(bcE.$)));
((bcF).zo)=(fromBin_((bcD),(bcE.$)));
((bcF).r5)=(fromBin_((bcD),(bcE.$)));
((bcF).qc)=(fromBin_((bcD),(bcE.$)));
return bcF;
}
// _dtor
function bcG(bcH){
((bcH).yI)=(null);
((bcH).ql)=(null);
((bcH).qX)=(null);
((bcH).qU)=(null);
((bcH).pY)=(null);
((bcH).q0)=(null);
((bcH).qz)=(null);
((bcH).zo)=(null);
}
// _copy
function bcI(bcJ){
let bcK=null;
(bcK)=(new yC());
((bcK).yF)=((bcJ).yF);
((bcK).yI)=(C_([134],((bcJ).yI)));
((bcK).yE)=((bcJ).yE);
((bcK).ql)=(C_([134],((bcJ).ql)));
((bcK).qX)=(C_([129,2],((bcJ).qX)));
((bcK).qU)=(C_([134],((bcJ).qU)));
((bcK).pY)=(C_([133,129,2,134],((bcJ).pY)));
((bcK).q0)=(C_([129,2],((bcJ).q0)));
((bcK).qz)=(C_([134],((bcJ).qz)));
((bcK).zo)=(C_([134],((bcJ).zo)));
((bcK).r5)=((bcJ).r5);
((bcK).qc)=((bcJ).qc);
return bcK;
}
// _toBin
function bcL(bcM){
let bcN=null;
(bcN)=(new Array(8).fill(0));
(bcN)=((bcN).concat(toBin_((bcM).yF)));
(bcN)=((bcN).concat(toBin_((bcM).yI)));
(bcN)=((bcN).concat(toBin_((bcM).yE)));
(bcN)=((bcN).concat(toBin_((bcM).ql)));
(bcN)=((bcN).concat(toBin_((bcM).qX)));
(bcN)=((bcN).concat(toBin_((bcM).qU)));
(bcN)=((bcN).concat(toBin_((bcM).pY)));
(bcN)=((bcN).concat(toBin_((bcM).q0)));
(bcN)=((bcN).concat(toBin_((bcM).qz)));
(bcN)=((bcN).concat(toBin_((bcM).zo)));
(bcN)=((bcN).concat(toBin_((bcM).r5)));
(bcN)=((bcN).concat(toBin_((bcM).qc)));
return bcN;
}
// _fromBin
function bda(bdb,bdc,bdd){
let bde=null;
(bde)=(new yC());
((bde).yF)=(fromBin_((bdc),(bdd.$)));
((bde).yI)=(fromBin_((bdc),(bdd.$)));
((bde).yE)=(fromBin_((bdc),(bdd.$)));
((bde).ql)=(fromBin_((bdc),(bdd.$)));
((bde).qX)=(fromBin_((bdc),(bdd.$)));
((bde).qU)=(fromBin_((bdc),(bdd.$)));
((bde).pY)=(fromBin_((bdc),(bdd.$)));
((bde).q0)=(fromBin_((bdc),(bdd.$)));
((bde).qz)=(fromBin_((bdc),(bdd.$)));
((bde).zo)=(fromBin_((bdc),(bdd.$)));
((bde).r5)=(fromBin_((bdc),(bdd.$)));
((bde).qc)=(fromBin_((bdc),(bdd.$)));
return bde;
}
// _dtor
function bdf(bdg){
((bdg).zc)=(null);
}
// _copy
function bdh(bdi){
let bdj=null;
(bdj)=(new yX());
((bdj).zc)=(C_([134],((bdi).zc)));
((bdj).yY)=((bdi).yY);
((bdj).yZ)=((bdi).yZ);
return bdj;
}
// _toBin
function bdk(bdl){
let bdm=null;
(bdm)=(new Array(8).fill(0));
(bdm)=((bdm).concat(toBin_((bdl).zc)));
(bdm)=((bdm).concat(toBin_((bdl).yY)));
(bdm)=((bdm).concat(toBin_((bdl).yZ)));
return bdm;
}
// _fromBin
function bdq(bdr,bds,bdt){
let bdu=null;
(bdu)=(new yX());
((bdu).zc)=(fromBin_((bds),(bdt.$)));
((bdu).yY)=(fromBin_((bds),(bdt.$)));
((bdu).yZ)=(fromBin_((bds),(bdt.$)));
return bdu;
}
// _dtor
function bdv(bdw){
((bdw).zM)=(null);
((bdw).zN)=(null);
((bdw).yI)=(null);
((bdw).ql)=(null);
((bdw).qX)=(null);
((bdw).qU)=(null);
((bdw).pY)=(null);
((bdw).q0)=(null);
((bdw).qz)=(null);
((bdw).zo)=(null);
}
// _copy
function bdx(bdy){
let bdz=null;
(bdz)=(new zI());
((bdz).zJ)=((bdy).zJ);
((bdz).zM)=(C_([134],((bdy).zM)));
((bdz).zN)=(C_([134],((bdy).zN)));
((bdz).yI)=(C_([134],((bdy).yI)));
((bdz).yE)=((bdy).yE);
((bdz).ql)=(C_([134],((bdy).ql)));
((bdz).qX)=(C_([129,2],((bdy).qX)));
((bdz).qU)=(C_([134],((bdy).qU)));
((bdz).pY)=(C_([133,129,2,134],((bdy).pY)));
((bdz).q0)=(C_([129,2],((bdy).q0)));
((bdz).qz)=(C_([134],((bdy).qz)));
((bdz).zo)=(C_([134],((bdy).zo)));
((bdz).r5)=((bdy).r5);
((bdz).qc)=((bdy).qc);
return bdz;
}
// _toBin
function bd0(bd1){
let bd2=null;
(bd2)=(new Array(8).fill(0));
(bd2)=((bd2).concat(toBin_((bd1).zJ)));
(bd2)=((bd2).concat(toBin_((bd1).zM)));
(bd2)=((bd2).concat(toBin_((bd1).zN)));
(bd2)=((bd2).concat(toBin_((bd1).yI)));
(bd2)=((bd2).concat(toBin_((bd1).yE)));
(bd2)=((bd2).concat(toBin_((bd1).ql)));
(bd2)=((bd2).concat(toBin_((bd1).qX)));
(bd2)=((bd2).concat(toBin_((bd1).qU)));
(bd2)=((bd2).concat(toBin_((bd1).pY)));
(bd2)=((bd2).concat(toBin_((bd1).q0)));
(bd2)=((bd2).concat(toBin_((bd1).qz)));
(bd2)=((bd2).concat(toBin_((bd1).zo)));
(bd2)=((bd2).concat(toBin_((bd1).r5)));
(bd2)=((bd2).concat(toBin_((bd1).qc)));
return bd2;
}
// _fromBin
function bdH(bdI,bdJ,bdK){
let bdL=null;
(bdL)=(new zI());
((bdL).zJ)=(fromBin_((bdJ),(bdK.$)));
((bdL).zM)=(fromBin_((bdJ),(bdK.$)));
((bdL).zN)=(fromBin_((bdJ),(bdK.$)));
((bdL).yI)=(fromBin_((bdJ),(bdK.$)));
((bdL).yE)=(fromBin_((bdJ),(bdK.$)));
((bdL).ql)=(fromBin_((bdJ),(bdK.$)));
((bdL).qX)=(fromBin_((bdJ),(bdK.$)));
((bdL).qU)=(fromBin_((bdJ),(bdK.$)));
((bdL).pY)=(fromBin_((bdJ),(bdK.$)));
((bdL).q0)=(fromBin_((bdJ),(bdK.$)));
((bdL).qz)=(fromBin_((bdJ),(bdK.$)));
((bdL).zo)=(fromBin_((bdJ),(bdK.$)));
((bdL).r5)=(fromBin_((bdJ),(bdK.$)));
((bdL).qc)=(fromBin_((bdJ),(bdK.$)));
return bdL;
}
// _dtor
function bdM(bdN){
((bdN).ql)=(null);
((bdN).qX)=(null);
((bdN).qU)=(null);
((bdN).pY)=(null);
((bdN).q0)=(null);
((bdN).qz)=(null);
((bdN).zo)=(null);
}
// _copy
function bdO(bdP){
let bdQ=null;
(bdQ)=(new Av());
((bdQ).ql)=(C_([134],((bdP).ql)));
((bdQ).qX)=(C_([129,2],((bdP).qX)));
((bdQ).qU)=(C_([134],((bdP).qU)));
((bdQ).pY)=(C_([133,129,2,134],((bdP).pY)));
((bdQ).q0)=(C_([129,2],((bdP).q0)));
((bdQ).qz)=(C_([134],((bdP).qz)));
((bdQ).zo)=(C_([134],((bdP).zo)));
((bdQ).r5)=((bdP).r5);
((bdQ).qc)=((bdP).qc);
return bdQ;
}
// _toBin
function bdR(bdS){
let bdT=null;
(bdT)=(new Array(8).fill(0));
(bdT)=((bdT).concat(toBin_((bdS).ql)));
(bdT)=((bdT).concat(toBin_((bdS).qX)));
(bdT)=((bdT).concat(toBin_((bdS).qU)));
(bdT)=((bdT).concat(toBin_((bdS).pY)));
(bdT)=((bdT).concat(toBin_((bdS).q0)));
(bdT)=((bdT).concat(toBin_((bdS).qz)));
(bdT)=((bdT).concat(toBin_((bdS).zo)));
(bdT)=((bdT).concat(toBin_((bdS).r5)));
(bdT)=((bdT).concat(toBin_((bdS).qc)));
return bdT;
}
// _fromBin
function bed(bee,bef,beg){
let beh=null;
(beh)=(new Av());
((beh).ql)=(fromBin_((bef),(beg.$)));
((beh).qX)=(fromBin_((bef),(beg.$)));
((beh).qU)=(fromBin_((bef),(beg.$)));
((beh).pY)=(fromBin_((bef),(beg.$)));
((beh).q0)=(fromBin_((bef),(beg.$)));
((beh).qz)=(fromBin_((bef),(beg.$)));
((beh).zo)=(fromBin_((bef),(beg.$)));
((beh).r5)=(fromBin_((bef),(beg.$)));
((beh).qc)=(fromBin_((bef),(beg.$)));
return beh;
}
// _dtor
function bei(bej){
((bej).Aw)=(null);
((bej).ql)=(null);
((bej).qX)=(null);
((bej).qU)=(null);
((bej).pY)=(null);
((bej).q0)=(null);
((bej).qz)=(null);
((bej).zo)=(null);
}
// _copy
function bek(bel){
let bem=null;
(bem)=(new Au());
((bem).Aw)=(C_([134],((bel).Aw)));
((bem).ql)=(C_([134],((bel).ql)));
((bem).qX)=(C_([129,2],((bel).qX)));
((bem).qU)=(C_([134],((bel).qU)));
((bem).pY)=(C_([133,129,2,134],((bel).pY)));
((bem).q0)=(C_([129,2],((bel).q0)));
((bem).qz)=(C_([134],((bel).qz)));
((bem).zo)=(C_([134],((bel).zo)));
((bem).r5)=((bel).r5);
((bem).qc)=((bel).qc);
return bem;
}
// _toBin
function ben(beo){
let bep=null;
(bep)=(new Array(8).fill(0));
(bep)=((bep).concat(toBin_((beo).Aw)));
(bep)=((bep).concat(toBin_((beo).ql)));
(bep)=((bep).concat(toBin_((beo).qX)));
(bep)=((bep).concat(toBin_((beo).qU)));
(bep)=((bep).concat(toBin_((beo).pY)));
(bep)=((bep).concat(toBin_((beo).q0)));
(bep)=((bep).concat(toBin_((beo).qz)));
(bep)=((bep).concat(toBin_((beo).zo)));
(bep)=((bep).concat(toBin_((beo).r5)));
(bep)=((bep).concat(toBin_((beo).qc)));
return bep;
}
// _fromBin
function be0(be1,be2,be3){
let be4=null;
(be4)=(new Au());
((be4).Aw)=(fromBin_((be2),(be3.$)));
((be4).ql)=(fromBin_((be2),(be3.$)));
((be4).qX)=(fromBin_((be2),(be3.$)));
((be4).qU)=(fromBin_((be2),(be3.$)));
((be4).pY)=(fromBin_((be2),(be3.$)));
((be4).q0)=(fromBin_((be2),(be3.$)));
((be4).qz)=(fromBin_((be2),(be3.$)));
((be4).zo)=(fromBin_((be2),(be3.$)));
((be4).r5)=(fromBin_((be2),(be3.$)));
((be4).qc)=(fromBin_((be2),(be3.$)));
return be4;
}
// _dtor
function be5(be6){
((be6).ql)=(null);
((be6).qX)=(null);
((be6).qU)=(null);
((be6).pY)=(null);
((be6).q0)=(null);
((be6).qz)=(null);
((be6).zo)=(null);
}
// _copy
function be7(be8){
let be9=null;
(be9)=(new Ay());
((be9).Az)=((be8).Az);
((be9).ql)=(C_([134],((be8).ql)));
((be9).qX)=(C_([129,2],((be8).qX)));
((be9).qU)=(C_([134],((be8).qU)));
((be9).pY)=(C_([133,129,2,134],((be8).pY)));
((be9).q0)=(C_([129,2],((be8).q0)));
((be9).qz)=(C_([134],((be8).qz)));
((be9).zo)=(C_([134],((be8).zo)));
((be9).r5)=((be8).r5);
((be9).qc)=((be8).qc);
return be9;
}
// _toBin
function beA(beB){
let beC=null;
(beC)=(new Array(8).fill(0));
(beC)=((beC).concat(toBin_((beB).Az)));
(beC)=((beC).concat(toBin_((beB).ql)));
(beC)=((beC).concat(toBin_((beB).qX)));
(beC)=((beC).concat(toBin_((beB).qU)));
(beC)=((beC).concat(toBin_((beB).pY)));
(beC)=((beC).concat(toBin_((beB).q0)));
(beC)=((beC).concat(toBin_((beB).qz)));
(beC)=((beC).concat(toBin_((beB).zo)));
(beC)=((beC).concat(toBin_((beB).r5)));
(beC)=((beC).concat(toBin_((beB).qc)));
return beC;
}
// _fromBin
function beN(beO,beP,beQ){
let beR=null;
(beR)=(new Ay());
((beR).Az)=(fromBin_((beP),(beQ.$)));
((beR).ql)=(fromBin_((beP),(beQ.$)));
((beR).qX)=(fromBin_((beP),(beQ.$)));
((beR).qU)=(fromBin_((beP),(beQ.$)));
((beR).pY)=(fromBin_((beP),(beQ.$)));
((beR).q0)=(fromBin_((beP),(beQ.$)));
((beR).qz)=(fromBin_((beP),(beQ.$)));
((beR).zo)=(fromBin_((beP),(beQ.$)));
((beR).r5)=(fromBin_((beP),(beQ.$)));
((beR).qc)=(fromBin_((beP),(beQ.$)));
return beR;
}
// _dtor
function beS(beT){
((beT).abD)=(null);
((beT).A9)=(null);
((beT).A4)=(null);
((beT).ql)=(null);
((beT).qX)=(null);
((beT).qU)=(null);
((beT).pY)=(null);
((beT).q0)=(null);
((beT).qz)=(null);
((beT).zo)=(null);
}
// _copy
function beU(beV){
let beW=null;
(beW)=(new A2());
((beW).abC)=((beV).abC);
((beW).abD)=(C_([130,129,2],((beV).abD)));
((beW).A9)=(C_([130,134],((beV).A9)));
((beW).A4)=(C_([134],((beV).A4)));
((beW).ql)=(C_([134],((beV).ql)));
((beW).qX)=(C_([129,2],((beV).qX)));
((beW).qU)=(C_([134],((beV).qU)));
((beW).pY)=(C_([133,129,2,134],((beV).pY)));
((beW).q0)=(C_([129,2],((beV).q0)));
((beW).qz)=(C_([134],((beV).qz)));
((beW).zo)=(C_([134],((beV).zo)));
((beW).r5)=((beV).r5);
((beW).qc)=((beV).qc);
return beW;
}
// _toBin
function beX(beY){
let beZ=null;
(beZ)=(new Array(8).fill(0));
(beZ)=((beZ).concat(toBin_((beY).abC)));
(beZ)=((beZ).concat(toBin_((beY).abD)));
(beZ)=((beZ).concat(toBin_((beY).A9)));
(beZ)=((beZ).concat(toBin_((beY).A4)));
(beZ)=((beZ).concat(toBin_((beY).ql)));
(beZ)=((beZ).concat(toBin_((beY).qX)));
(beZ)=((beZ).concat(toBin_((beY).qU)));
(beZ)=((beZ).concat(toBin_((beY).pY)));
(beZ)=((beZ).concat(toBin_((beY).q0)));
(beZ)=((beZ).concat(toBin_((beY).qz)));
(beZ)=((beZ).concat(toBin_((beY).zo)));
(beZ)=((beZ).concat(toBin_((beY).r5)));
(beZ)=((beZ).concat(toBin_((beY).qc)));
return beZ;
}
// _fromBin
function bfn(bfo,bfp,bfq){
let bfr=null;
(bfr)=(new A2());
((bfr).abC)=(fromBin_((bfp),(bfq.$)));
((bfr).abD)=(fromBin_((bfp),(bfq.$)));
((bfr).A9)=(fromBin_((bfp),(bfq.$)));
((bfr).A4)=(fromBin_((bfp),(bfq.$)));
((bfr).ql)=(fromBin_((bfp),(bfq.$)));
((bfr).qX)=(fromBin_((bfp),(bfq.$)));
((bfr).qU)=(fromBin_((bfp),(bfq.$)));
((bfr).pY)=(fromBin_((bfp),(bfq.$)));
((bfr).q0)=(fromBin_((bfp),(bfq.$)));
((bfr).qz)=(fromBin_((bfp),(bfq.$)));
((bfr).zo)=(fromBin_((bfp),(bfq.$)));
((bfr).r5)=(fromBin_((bfp),(bfq.$)));
((bfr).qc)=(fromBin_((bfp),(bfq.$)));
return bfr;
}
// _dtor
function bfs(bft){
((bft).AI)=(null);
}
// _copy
function bfu(bfv){
let bfw=null;
(bfw)=(new AC());
((bfw).AI)=(C_([134],((bfv).AI)));
((bfw).AK)=((bfv).AK);
return bfw;
}
// _toBin
function bfx(bfy){
let bfz=null;
(bfz)=(new Array(8).fill(0));
(bfz)=((bfz).concat(toBin_((bfy).AI)));
(bfz)=((bfz).concat(toBin_((bfy).AK)));
return bfz;
}
// _fromBin
function bf2(bf3,bf4,bf5){
let bf6=null;
(bf6)=(new AC());
((bf6).AI)=(fromBin_((bf4),(bf5.$)));
((bf6).AK)=(fromBin_((bf4),(bf5.$)));
return bf6;
}
// _dtor
function bf7(bf8){
((bf8).AU)=(null);
((bf8).ql)=(null);
((bf8).qX)=(null);
((bf8).qU)=(null);
((bf8).pY)=(null);
((bf8).q0)=(null);
((bf8).qz)=(null);
((bf8).zo)=(null);
}
// _copy
function bf9(bfA){
let bfB=null;
(bfB)=(new AP());
((bfB).AS)=((bfA).AS);
((bfB).AU)=(C_([134],((bfA).AU)));
((bfB).ql)=(C_([134],((bfA).ql)));
((bfB).qX)=(C_([129,2],((bfA).qX)));
((bfB).qU)=(C_([134],((bfA).qU)));
((bfB).pY)=(C_([133,129,2,134],((bfA).pY)));
((bfB).q0)=(C_([129,2],((bfA).q0)));
((bfB).qz)=(C_([134],((bfA).qz)));
((bfB).zo)=(C_([134],((bfA).zo)));
((bfB).r5)=((bfA).r5);
((bfB).qc)=((bfA).qc);
return bfB;
}
// _toBin
function bfC(bfD){
let bfE=null;
(bfE)=(new Array(8).fill(0));
(bfE)=((bfE).concat(toBin_((bfD).AS)));
(bfE)=((bfE).concat(toBin_((bfD).AU)));
(bfE)=((bfE).concat(toBin_((bfD).ql)));
(bfE)=((bfE).concat(toBin_((bfD).qX)));
(bfE)=((bfE).concat(toBin_((bfD).qU)));
(bfE)=((bfE).concat(toBin_((bfD).pY)));
(bfE)=((bfE).concat(toBin_((bfD).q0)));
(bfE)=((bfE).concat(toBin_((bfD).qz)));
(bfE)=((bfE).concat(toBin_((bfD).zo)));
(bfE)=((bfE).concat(toBin_((bfD).r5)));
(bfE)=((bfE).concat(toBin_((bfD).qc)));
return bfE;
}
// _fromBin
function bfQ(bfR,bfS,bfT){
let bfU=null;
(bfU)=(new AP());
((bfU).AS)=(fromBin_((bfS),(bfT.$)));
((bfU).AU)=(fromBin_((bfS),(bfT.$)));
((bfU).ql)=(fromBin_((bfS),(bfT.$)));
((bfU).qX)=(fromBin_((bfS),(bfT.$)));
((bfU).qU)=(fromBin_((bfS),(bfT.$)));
((bfU).pY)=(fromBin_((bfS),(bfT.$)));
((bfU).q0)=(fromBin_((bfS),(bfT.$)));
((bfU).qz)=(fromBin_((bfS),(bfT.$)));
((bfU).zo)=(fromBin_((bfS),(bfT.$)));
((bfU).r5)=(fromBin_((bfS),(bfT.$)));
((bfU).qc)=(fromBin_((bfS),(bfT.$)));
return bfU;
}
// _dtor
function bfV(bfW){
((bfW).Bb)=(null);
((bfW).Bc)=(null);
((bfW).ql)=(null);
((bfW).qX)=(null);
((bfW).qU)=(null);
((bfW).pY)=(null);
((bfW).q0)=(null);
((bfW).qz)=(null);
((bfW).zo)=(null);
}
// _copy
function bfX(bfY){
let bfZ=null;
(bfZ)=(new Ba());
((bfZ).Bb)=(C_([134],((bfY).Bb)));
((bfZ).Bc)=(C_([134],((bfY).Bc)));
((bfZ).ql)=(C_([134],((bfY).ql)));
((bfZ).qX)=(C_([129,2],((bfY).qX)));
((bfZ).qU)=(C_([134],((bfY).qU)));
((bfZ).pY)=(C_([133,129,2,134],((bfY).pY)));
((bfZ).q0)=(C_([129,2],((bfY).q0)));
((bfZ).qz)=(C_([134],((bfY).qz)));
((bfZ).zo)=(C_([134],((bfY).zo)));
((bfZ).r5)=((bfY).r5);
((bfZ).qc)=((bfY).qc);
return bfZ;
}
// _toBin
function bga(bgb){
let bgc=null;
(bgc)=(new Array(8).fill(0));
(bgc)=((bgc).concat(toBin_((bgb).Bb)));
(bgc)=((bgc).concat(toBin_((bgb).Bc)));
(bgc)=((bgc).concat(toBin_((bgb).ql)));
(bgc)=((bgc).concat(toBin_((bgb).qX)));
(bgc)=((bgc).concat(toBin_((bgb).qU)));
(bgc)=((bgc).concat(toBin_((bgb).pY)));
(bgc)=((bgc).concat(toBin_((bgb).q0)));
(bgc)=((bgc).concat(toBin_((bgb).qz)));
(bgc)=((bgc).concat(toBin_((bgb).zo)));
(bgc)=((bgc).concat(toBin_((bgb).r5)));
(bgc)=((bgc).concat(toBin_((bgb).qc)));
return bgc;
}
// _fromBin
function bgo(bgp,bgq,bgr){
let bgs=null;
(bgs)=(new Ba());
((bgs).Bb)=(fromBin_((bgq),(bgr.$)));
((bgs).Bc)=(fromBin_((bgq),(bgr.$)));
((bgs).ql)=(fromBin_((bgq),(bgr.$)));
((bgs).qX)=(fromBin_((bgq),(bgr.$)));
((bgs).qU)=(fromBin_((bgq),(bgr.$)));
((bgs).pY)=(fromBin_((bgq),(bgr.$)));
((bgs).q0)=(fromBin_((bgq),(bgr.$)));
((bgs).qz)=(fromBin_((bgq),(bgr.$)));
((bgs).zo)=(fromBin_((bgq),(bgr.$)));
((bgs).r5)=(fromBin_((bgq),(bgr.$)));
((bgs).qc)=(fromBin_((bgq),(bgr.$)));
return bgs;
}
// _dtor
function bgt(bgu){
((bgu).SG)=(null);
((bgu).SI)=(null);
((bgu).SO)=(null);
((bgu).SV)=(null);
((bgu).xZ)=(null);
((bgu).ql)=(null);
((bgu).qX)=(null);
((bgu).qU)=(null);
((bgu).pY)=(null);
((bgu).q0)=(null);
((bgu).qz)=(null);
((bgu).zo)=(null);
}
// _copy
function bgv(bgw){
let bgx=null;
(bgx)=(new Ef());
((bgx).SG)=(C_([134],((bgw).SG)));
((bgx).SI)=(C_([134],((bgw).SI)));
((bgx).SO)=(C_([130,134],((bgw).SO)));
((bgx).SV)=(C_([134],((bgw).SV)));
((bgx).xZ)=(C_([134],((bgw).xZ)));
((bgx).ql)=(C_([134],((bgw).ql)));
((bgx).qX)=(C_([129,2],((bgw).qX)));
((bgx).qU)=(C_([134],((bgw).qU)));
((bgx).pY)=(C_([133,129,2,134],((bgw).pY)));
((bgx).q0)=(C_([129,2],((bgw).q0)));
((bgx).qz)=(C_([134],((bgw).qz)));
((bgx).zo)=(C_([134],((bgw).zo)));
((bgx).r5)=((bgw).r5);
((bgx).qc)=((bgw).qc);
return bgx;
}
// _toBin
function bgy(bgz){
let bg0=null;
(bg0)=(new Array(8).fill(0));
(bg0)=((bg0).concat(toBin_((bgz).SG)));
(bg0)=((bg0).concat(toBin_((bgz).SI)));
(bg0)=((bg0).concat(toBin_((bgz).SO)));
(bg0)=((bg0).concat(toBin_((bgz).SV)));
(bg0)=((bg0).concat(toBin_((bgz).xZ)));
(bg0)=((bg0).concat(toBin_((bgz).ql)));
(bg0)=((bg0).concat(toBin_((bgz).qX)));
(bg0)=((bg0).concat(toBin_((bgz).qU)));
(bg0)=((bg0).concat(toBin_((bgz).pY)));
(bg0)=((bg0).concat(toBin_((bgz).q0)));
(bg0)=((bg0).concat(toBin_((bgz).qz)));
(bg0)=((bg0).concat(toBin_((bgz).zo)));
(bg0)=((bg0).concat(toBin_((bgz).r5)));
(bg0)=((bg0).concat(toBin_((bgz).qc)));
return bg0;
}
// _fromBin
function bgF(bgG,bgH,bgI){
let bgJ=null;
(bgJ)=(new Ef());
((bgJ).SG)=(fromBin_((bgH),(bgI.$)));
((bgJ).SI)=(fromBin_((bgH),(bgI.$)));
((bgJ).SO)=(fromBin_((bgH),(bgI.$)));
((bgJ).SV)=(fromBin_((bgH),(bgI.$)));
((bgJ).xZ)=(fromBin_((bgH),(bgI.$)));
((bgJ).ql)=(fromBin_((bgH),(bgI.$)));
((bgJ).qX)=(fromBin_((bgH),(bgI.$)));
((bgJ).qU)=(fromBin_((bgH),(bgI.$)));
((bgJ).pY)=(fromBin_((bgH),(bgI.$)));
((bgJ).q0)=(fromBin_((bgH),(bgI.$)));
((bgJ).qz)=(fromBin_((bgH),(bgI.$)));
((bgJ).zo)=(fromBin_((bgH),(bgI.$)));
((bgJ).r5)=(fromBin_((bgH),(bgI.$)));
((bgJ).qc)=(fromBin_((bgH),(bgI.$)));
return bgJ;
}
// _dtor
function bgK(bgL){
((bgL).Tj)=(null);
((bgL).Tn)=(null);
((bgL).T8)=(null);
((bgL).xZ)=(null);
((bgL).ql)=(null);
((bgL).qX)=(null);
((bgL).qU)=(null);
((bgL).pY)=(null);
((bgL).q0)=(null);
((bgL).qz)=(null);
((bgL).zo)=(null);
}
// _copy
function bgM(bgN){
let bgO=null;
(bgO)=(new Ei());
((bgO).Tj)=(C_([134],((bgN).Tj)));
((bgO).Tn)=(C_([130,134],((bgN).Tn)));
((bgO).T8)=(C_([134],((bgN).T8)));
((bgO).xZ)=(C_([134],((bgN).xZ)));
((bgO).ql)=(C_([134],((bgN).ql)));
((bgO).qX)=(C_([129,2],((bgN).qX)));
((bgO).qU)=(C_([134],((bgN).qU)));
((bgO).pY)=(C_([133,129,2,134],((bgN).pY)));
((bgO).q0)=(C_([129,2],((bgN).q0)));
((bgO).qz)=(C_([134],((bgN).qz)));
((bgO).zo)=(C_([134],((bgN).zo)));
((bgO).r5)=((bgN).r5);
((bgO).qc)=((bgN).qc);
return bgO;
}
// _toBin
function bgP(bgQ){
let bgR=null;
(bgR)=(new Array(8).fill(0));
(bgR)=((bgR).concat(toBin_((bgQ).Tj)));
(bgR)=((bgR).concat(toBin_((bgQ).Tn)));
(bgR)=((bgR).concat(toBin_((bgQ).T8)));
(bgR)=((bgR).concat(toBin_((bgQ).xZ)));
(bgR)=((bgR).concat(toBin_((bgQ).ql)));
(bgR)=((bgR).concat(toBin_((bgQ).qX)));
(bgR)=((bgR).concat(toBin_((bgQ).qU)));
(bgR)=((bgR).concat(toBin_((bgQ).pY)));
(bgR)=((bgR).concat(toBin_((bgQ).q0)));
(bgR)=((bgR).concat(toBin_((bgQ).qz)));
(bgR)=((bgR).concat(toBin_((bgQ).zo)));
(bgR)=((bgR).concat(toBin_((bgQ).r5)));
(bgR)=((bgR).concat(toBin_((bgQ).qc)));
return bgR;
}
// _fromBin
function bhf(bhg,bhh,bhi){
let bhj=null;
(bhj)=(new Ei());
((bhj).Tj)=(fromBin_((bhh),(bhi.$)));
((bhj).Tn)=(fromBin_((bhh),(bhi.$)));
((bhj).T8)=(fromBin_((bhh),(bhi.$)));
((bhj).xZ)=(fromBin_((bhh),(bhi.$)));
((bhj).ql)=(fromBin_((bhh),(bhi.$)));
((bhj).qX)=(fromBin_((bhh),(bhi.$)));
((bhj).qU)=(fromBin_((bhh),(bhi.$)));
((bhj).pY)=(fromBin_((bhh),(bhi.$)));
((bhj).q0)=(fromBin_((bhh),(bhi.$)));
((bhj).qz)=(fromBin_((bhh),(bhi.$)));
((bhj).zo)=(fromBin_((bhh),(bhi.$)));
((bhj).r5)=(fromBin_((bhh),(bhi.$)));
((bhj).qc)=(fromBin_((bhh),(bhi.$)));
return bhj;
}
// _dtor
function bhk(bhl){
((bhl).xZ)=(null);
((bhl).ql)=(null);
((bhl).qX)=(null);
((bhl).qU)=(null);
((bhl).pY)=(null);
((bhl).q0)=(null);
((bhl).qz)=(null);
((bhl).zo)=(null);
}
// _copy
function bhm(bhn){
let bho=null;
(bho)=(new Em());
((bho).xZ)=(C_([134],((bhn).xZ)));
((bho).ql)=(C_([134],((bhn).ql)));
((bho).qX)=(C_([129,2],((bhn).qX)));
((bho).qU)=(C_([134],((bhn).qU)));
((bho).pY)=(C_([133,129,2,134],((bhn).pY)));
((bho).q0)=(C_([129,2],((bhn).q0)));
((bho).qz)=(C_([134],((bhn).qz)));
((bho).zo)=(C_([134],((bhn).zo)));
((bho).r5)=((bhn).r5);
((bho).qc)=((bhn).qc);
return bho;
}
// _toBin
function bhp(bhq){
let bhr=null;
(bhr)=(new Array(8).fill(0));
(bhr)=((bhr).concat(toBin_((bhq).xZ)));
(bhr)=((bhr).concat(toBin_((bhq).ql)));
(bhr)=((bhr).concat(toBin_((bhq).qX)));
(bhr)=((bhr).concat(toBin_((bhq).qU)));
(bhr)=((bhr).concat(toBin_((bhq).pY)));
(bhr)=((bhr).concat(toBin_((bhq).q0)));
(bhr)=((bhr).concat(toBin_((bhq).qz)));
(bhr)=((bhr).concat(toBin_((bhq).zo)));
(bhr)=((bhr).concat(toBin_((bhq).r5)));
(bhr)=((bhr).concat(toBin_((bhq).qc)));
return bhr;
}
// _fromBin
function bh2(bh3,bh4,bh5){
let bh6=null;
(bh6)=(new Em());
((bh6).xZ)=(fromBin_((bh4),(bh5.$)));
((bh6).ql)=(fromBin_((bh4),(bh5.$)));
((bh6).qX)=(fromBin_((bh4),(bh5.$)));
((bh6).qU)=(fromBin_((bh4),(bh5.$)));
((bh6).pY)=(fromBin_((bh4),(bh5.$)));
((bh6).q0)=(fromBin_((bh4),(bh5.$)));
((bh6).qz)=(fromBin_((bh4),(bh5.$)));
((bh6).zo)=(fromBin_((bh4),(bh5.$)));
((bh6).r5)=(fromBin_((bh4),(bh5.$)));
((bh6).qc)=(fromBin_((bh4),(bh5.$)));
return bh6;
}
// _dtor
function bh7(bh8){
((bh8).Uf)=(null);
((bh8).Uh)=(null);
((bh8).xZ)=(null);
((bh8).ql)=(null);
((bh8).qX)=(null);
((bh8).qU)=(null);
((bh8).pY)=(null);
((bh8).q0)=(null);
((bh8).qz)=(null);
((bh8).zo)=(null);
}
// _copy
function bh9(bhA){
let bhB=null;
(bhB)=(new El());
((bhB).Uf)=(C_([134],((bhA).Uf)));
((bhB).Un)=((bhA).Un);
((bhB).Uh)=(C_([130,134],((bhA).Uh)));
((bhB).xZ)=(C_([134],((bhA).xZ)));
((bhB).ql)=(C_([134],((bhA).ql)));
((bhB).qX)=(C_([129,2],((bhA).qX)));
((bhB).qU)=(C_([134],((bhA).qU)));
((bhB).pY)=(C_([133,129,2,134],((bhA).pY)));
((bhB).q0)=(C_([129,2],((bhA).q0)));
((bhB).qz)=(C_([134],((bhA).qz)));
((bhB).zo)=(C_([134],((bhA).zo)));
((bhB).r5)=((bhA).r5);
((bhB).qc)=((bhA).qc);
return bhB;
}
// _toBin
function bhC(bhD){
let bhE=null;
(bhE)=(new Array(8).fill(0));
(bhE)=((bhE).concat(toBin_((bhD).Uf)));
(bhE)=((bhE).concat(toBin_((bhD).Un)));
(bhE)=((bhE).concat(toBin_((bhD).Uh)));
(bhE)=((bhE).concat(toBin_((bhD).xZ)));
(bhE)=((bhE).concat(toBin_((bhD).ql)));
(bhE)=((bhE).concat(toBin_((bhD).qX)));
(bhE)=((bhE).concat(toBin_((bhD).qU)));
(bhE)=((bhE).concat(toBin_((bhD).pY)));
(bhE)=((bhE).concat(toBin_((bhD).q0)));
(bhE)=((bhE).concat(toBin_((bhD).qz)));
(bhE)=((bhE).concat(toBin_((bhD).zo)));
(bhE)=((bhE).concat(toBin_((bhD).r5)));
(bhE)=((bhE).concat(toBin_((bhD).qc)));
return bhE;
}
// _fromBin
function bhS(bhT,bhU,bhV){
let bhW=null;
(bhW)=(new El());
((bhW).Uf)=(fromBin_((bhU),(bhV.$)));
((bhW).Un)=(fromBin_((bhU),(bhV.$)));
((bhW).Uh)=(fromBin_((bhU),(bhV.$)));
((bhW).xZ)=(fromBin_((bhU),(bhV.$)));
((bhW).ql)=(fromBin_((bhU),(bhV.$)));
((bhW).qX)=(fromBin_((bhU),(bhV.$)));
((bhW).qU)=(fromBin_((bhU),(bhV.$)));
((bhW).pY)=(fromBin_((bhU),(bhV.$)));
((bhW).q0)=(fromBin_((bhU),(bhV.$)));
((bhW).qz)=(fromBin_((bhU),(bhV.$)));
((bhW).zo)=(fromBin_((bhU),(bhV.$)));
((bhW).r5)=(fromBin_((bhU),(bhV.$)));
((bhW).qc)=(fromBin_((bhU),(bhV.$)));
return bhW;
}
// _dtor
function bhX(bhY){
((bhY).U7)=(null);
((bhY).U6)=(null);
((bhY).U8)=(null);
((bhY).UG)=(null);
((bhY).xZ)=(null);
((bhY).ql)=(null);
((bhY).qX)=(null);
((bhY).qU)=(null);
((bhY).pY)=(null);
((bhY).q0)=(null);
((bhY).qz)=(null);
((bhY).zo)=(null);
}
// _copy
function bhZ(bia){
let bib=null;
(bib)=(new Ep());
((bib).U7)=(C_([134],((bia).U7)));
((bib).U6)=(C_([134],((bia).U6)));
((bib).U8)=(C_([134],((bia).U8)));
((bib).UG)=(C_([130,134],((bia).UG)));
((bib).xZ)=(C_([134],((bia).xZ)));
((bib).ql)=(C_([134],((bia).ql)));
((bib).qX)=(C_([129,2],((bia).qX)));
((bib).qU)=(C_([134],((bia).qU)));
((bib).pY)=(C_([133,129,2,134],((bia).pY)));
((bib).q0)=(C_([129,2],((bia).q0)));
((bib).qz)=(C_([134],((bia).qz)));
((bib).zo)=(C_([134],((bia).zo)));
((bib).r5)=((bia).r5);
((bib).qc)=((bia).qc);
return bib;
}
// _toBin
function bic(bid){
let bie=null;
(bie)=(new Array(8).fill(0));
(bie)=((bie).concat(toBin_((bid).U7)));
(bie)=((bie).concat(toBin_((bid).U6)));
(bie)=((bie).concat(toBin_((bid).U8)));
(bie)=((bie).concat(toBin_((bid).UG)));
(bie)=((bie).concat(toBin_((bid).xZ)));
(bie)=((bie).concat(toBin_((bid).ql)));
(bie)=((bie).concat(toBin_((bid).qX)));
(bie)=((bie).concat(toBin_((bid).qU)));
(bie)=((bie).concat(toBin_((bid).pY)));
(bie)=((bie).concat(toBin_((bid).q0)));
(bie)=((bie).concat(toBin_((bid).qz)));
(bie)=((bie).concat(toBin_((bid).zo)));
(bie)=((bie).concat(toBin_((bid).r5)));
(bie)=((bie).concat(toBin_((bid).qc)));
return bie;
}
// _fromBin
function bit(biu,biv,biw){
let bix=null;
(bix)=(new Ep());
((bix).U7)=(fromBin_((biv),(biw.$)));
((bix).U6)=(fromBin_((biv),(biw.$)));
((bix).U8)=(fromBin_((biv),(biw.$)));
((bix).UG)=(fromBin_((biv),(biw.$)));
((bix).xZ)=(fromBin_((biv),(biw.$)));
((bix).ql)=(fromBin_((biv),(biw.$)));
((bix).qX)=(fromBin_((biv),(biw.$)));
((bix).qU)=(fromBin_((biv),(biw.$)));
((bix).pY)=(fromBin_((biv),(biw.$)));
((bix).q0)=(fromBin_((biv),(biw.$)));
((bix).qz)=(fromBin_((biv),(biw.$)));
((bix).zo)=(fromBin_((biv),(biw.$)));
((bix).r5)=(fromBin_((biv),(biw.$)));
((bix).qc)=(fromBin_((biv),(biw.$)));
return bix;
}
// _dtor
function biy(biz){
((biz).Vw)=(null);
((biz).ql)=(null);
((biz).qX)=(null);
((biz).qU)=(null);
((biz).pY)=(null);
((biz).q0)=(null);
((biz).qz)=(null);
((biz).zo)=(null);
}
// _copy
function bi0(bi1){
let bi2=null;
(bi2)=(new Eu());
((bi2).Vw)=(C_([134],((bi1).Vw)));
((bi2).ql)=(C_([134],((bi1).ql)));
((bi2).qX)=(C_([129,2],((bi1).qX)));
((bi2).qU)=(C_([134],((bi1).qU)));
((bi2).pY)=(C_([133,129,2,134],((bi1).pY)));
((bi2).q0)=(C_([129,2],((bi1).q0)));
((bi2).qz)=(C_([134],((bi1).qz)));
((bi2).zo)=(C_([134],((bi1).zo)));
((bi2).r5)=((bi1).r5);
((bi2).qc)=((bi1).qc);
return bi2;
}
// _toBin
function bi3(bi4){
let bi5=null;
(bi5)=(new Array(8).fill(0));
(bi5)=((bi5).concat(toBin_((bi4).Vw)));
(bi5)=((bi5).concat(toBin_((bi4).ql)));
(bi5)=((bi5).concat(toBin_((bi4).qX)));
(bi5)=((bi5).concat(toBin_((bi4).qU)));
(bi5)=((bi5).concat(toBin_((bi4).pY)));
(bi5)=((bi5).concat(toBin_((bi4).q0)));
(bi5)=((bi5).concat(toBin_((bi4).qz)));
(bi5)=((bi5).concat(toBin_((bi4).zo)));
(bi5)=((bi5).concat(toBin_((bi4).r5)));
(bi5)=((bi5).concat(toBin_((bi4).qc)));
return bi5;
}
// _fromBin
function biG(biH,biI,biJ){
let biK=null;
(biK)=(new Eu());
((biK).Vw)=(fromBin_((biI),(biJ.$)));
((biK).ql)=(fromBin_((biI),(biJ.$)));
((biK).qX)=(fromBin_((biI),(biJ.$)));
((biK).qU)=(fromBin_((biI),(biJ.$)));
((biK).pY)=(fromBin_((biI),(biJ.$)));
((biK).q0)=(fromBin_((biI),(biJ.$)));
((biK).qz)=(fromBin_((biI),(biJ.$)));
((biK).zo)=(fromBin_((biI),(biJ.$)));
((biK).r5)=(fromBin_((biI),(biJ.$)));
((biK).qc)=(fromBin_((biI),(biJ.$)));
return biK;
}
// _dtor
function biL(biM){
((biM).V5)=(null);
((biM).ql)=(null);
((biM).qX)=(null);
((biM).qU)=(null);
((biM).pY)=(null);
((biM).q0)=(null);
((biM).qz)=(null);
((biM).zo)=(null);
}
// _copy
function biN(biO){
let biP=null;
(biP)=(new Ez());
((biP).V5)=(C_([134],((biO).V5)));
((biP).ql)=(C_([134],((biO).ql)));
((biP).qX)=(C_([129,2],((biO).qX)));
((biP).qU)=(C_([134],((biO).qU)));
((biP).pY)=(C_([133,129,2,134],((biO).pY)));
((biP).q0)=(C_([129,2],((biO).q0)));
((biP).qz)=(C_([134],((biO).qz)));
((biP).zo)=(C_([134],((biO).zo)));
((biP).r5)=((biO).r5);
((biP).qc)=((biO).qc);
return biP;
}
// _toBin
function biQ(biR){
let biS=null;
(biS)=(new Array(8).fill(0));
(biS)=((biS).concat(toBin_((biR).V5)));
(biS)=((biS).concat(toBin_((biR).ql)));
(biS)=((biS).concat(toBin_((biR).qX)));
(biS)=((biS).concat(toBin_((biR).qU)));
(biS)=((biS).concat(toBin_((biR).pY)));
(biS)=((biS).concat(toBin_((biR).q0)));
(biS)=((biS).concat(toBin_((biR).qz)));
(biS)=((biS).concat(toBin_((biR).zo)));
(biS)=((biS).concat(toBin_((biR).r5)));
(biS)=((biS).concat(toBin_((biR).qc)));
return biS;
}
// _fromBin
function bjd(bje,bjf,bjg){
let bjh=null;
(bjh)=(new Ez());
((bjh).V5)=(fromBin_((bjf),(bjg.$)));
((bjh).ql)=(fromBin_((bjf),(bjg.$)));
((bjh).qX)=(fromBin_((bjf),(bjg.$)));
((bjh).qU)=(fromBin_((bjf),(bjg.$)));
((bjh).pY)=(fromBin_((bjf),(bjg.$)));
((bjh).q0)=(fromBin_((bjf),(bjg.$)));
((bjh).qz)=(fromBin_((bjf),(bjg.$)));
((bjh).zo)=(fromBin_((bjf),(bjg.$)));
((bjh).r5)=(fromBin_((bjf),(bjg.$)));
((bjh).qc)=(fromBin_((bjf),(bjg.$)));
return bjh;
}
// _dtor
function bji(bjj){
((bjj).VM)=(null);
((bjj).ql)=(null);
((bjj).qX)=(null);
((bjj).qU)=(null);
((bjj).pY)=(null);
((bjj).q0)=(null);
((bjj).qz)=(null);
((bjj).zo)=(null);
}
// _copy
function bjk(bjl){
let bjm=null;
(bjm)=(new E8());
((bjm).VM)=(C_([134],((bjl).VM)));
((bjm).ql)=(C_([134],((bjl).ql)));
((bjm).qX)=(C_([129,2],((bjl).qX)));
((bjm).qU)=(C_([134],((bjl).qU)));
((bjm).pY)=(C_([133,129,2,134],((bjl).pY)));
((bjm).q0)=(C_([129,2],((bjl).q0)));
((bjm).qz)=(C_([134],((bjl).qz)));
((bjm).zo)=(C_([134],((bjl).zo)));
((bjm).r5)=((bjl).r5);
((bjm).qc)=((bjl).qc);
return bjm;
}
// _toBin
function bjn(bjo){
let bjp=null;
(bjp)=(new Array(8).fill(0));
(bjp)=((bjp).concat(toBin_((bjo).VM)));
(bjp)=((bjp).concat(toBin_((bjo).ql)));
(bjp)=((bjp).concat(toBin_((bjo).qX)));
(bjp)=((bjp).concat(toBin_((bjo).qU)));
(bjp)=((bjp).concat(toBin_((bjo).pY)));
(bjp)=((bjp).concat(toBin_((bjo).q0)));
(bjp)=((bjp).concat(toBin_((bjo).qz)));
(bjp)=((bjp).concat(toBin_((bjo).zo)));
(bjp)=((bjp).concat(toBin_((bjo).r5)));
(bjp)=((bjp).concat(toBin_((bjo).qc)));
return bjp;
}
// _fromBin
function bj0(bj1,bj2,bj3){
let bj4=null;
(bj4)=(new E8());
((bj4).VM)=(fromBin_((bj2),(bj3.$)));
((bj4).ql)=(fromBin_((bj2),(bj3.$)));
((bj4).qX)=(fromBin_((bj2),(bj3.$)));
((bj4).qU)=(fromBin_((bj2),(bj3.$)));
((bj4).pY)=(fromBin_((bj2),(bj3.$)));
((bj4).q0)=(fromBin_((bj2),(bj3.$)));
((bj4).qz)=(fromBin_((bj2),(bj3.$)));
((bj4).zo)=(fromBin_((bj2),(bj3.$)));
((bj4).r5)=(fromBin_((bj2),(bj3.$)));
((bj4).qc)=(fromBin_((bj2),(bj3.$)));
return bj4;
}
// _dtor
function bj5(bj6){
((bj6).ql)=(null);
((bj6).qX)=(null);
((bj6).qU)=(null);
((bj6).pY)=(null);
((bj6).q0)=(null);
((bj6).qz)=(null);
((bj6).zo)=(null);
}
// _copy
function bj7(bj8){
let bj9=null;
(bj9)=(new M9());
((bj9).ql)=(C_([134],((bj8).ql)));
((bj9).qX)=(C_([129,2],((bj8).qX)));
((bj9).qU)=(C_([134],((bj8).qU)));
((bj9).pY)=(C_([133,129,2,134],((bj8).pY)));
((bj9).q0)=(C_([129,2],((bj8).q0)));
((bj9).qz)=(C_([134],((bj8).qz)));
((bj9).zo)=(C_([134],((bj8).zo)));
((bj9).r5)=((bj8).r5);
((bj9).qc)=((bj8).qc);
return bj9;
}
// _toBin
function bjA(bjB){
let bjC=null;
(bjC)=(new Array(8).fill(0));
(bjC)=((bjC).concat(toBin_((bjB).ql)));
(bjC)=((bjC).concat(toBin_((bjB).qX)));
(bjC)=((bjC).concat(toBin_((bjB).qU)));
(bjC)=((bjC).concat(toBin_((bjB).pY)));
(bjC)=((bjC).concat(toBin_((bjB).q0)));
(bjC)=((bjC).concat(toBin_((bjB).qz)));
(bjC)=((bjC).concat(toBin_((bjB).zo)));
(bjC)=((bjC).concat(toBin_((bjB).r5)));
(bjC)=((bjC).concat(toBin_((bjB).qc)));
return bjC;
}
// _fromBin
function bjM(bjN,bjO,bjP){
let bjQ=null;
(bjQ)=(new M9());
((bjQ).ql)=(fromBin_((bjO),(bjP.$)));
((bjQ).qX)=(fromBin_((bjO),(bjP.$)));
((bjQ).qU)=(fromBin_((bjO),(bjP.$)));
((bjQ).pY)=(fromBin_((bjO),(bjP.$)));
((bjQ).q0)=(fromBin_((bjO),(bjP.$)));
((bjQ).qz)=(fromBin_((bjO),(bjP.$)));
((bjQ).zo)=(fromBin_((bjO),(bjP.$)));
((bjQ).r5)=(fromBin_((bjO),(bjP.$)));
((bjQ).qc)=(fromBin_((bjO),(bjP.$)));
return bjQ;
}
// _dtor
function bjR(bjS){
((bjS).agK)=(null);
((bjS).yI)=(null);
((bjS).ql)=(null);
((bjS).qX)=(null);
((bjS).qU)=(null);
((bjS).pY)=(null);
((bjS).q0)=(null);
((bjS).qz)=(null);
((bjS).zo)=(null);
}
// _copy
function bjT(bjU){
let bjV=null;
(bjV)=(new Qd());
((bjV).agQ)=((bjU).agQ);
((bjV).agK)=(C_([134],((bjU).agK)));
((bjV).yI)=(C_([134],((bjU).yI)));
((bjV).yE)=((bjU).yE);
((bjV).ql)=(C_([134],((bjU).ql)));
((bjV).qX)=(C_([129,2],((bjU).qX)));
((bjV).qU)=(C_([134],((bjU).qU)));
((bjV).pY)=(C_([133,129,2,134],((bjU).pY)));
((bjV).q0)=(C_([129,2],((bjU).q0)));
((bjV).qz)=(C_([134],((bjU).qz)));
((bjV).zo)=(C_([134],((bjU).zo)));
((bjV).r5)=((bjU).r5);
((bjV).qc)=((bjU).qc);
return bjV;
}
// _toBin
function bjW(bjX){
let bjY=null;
(bjY)=(new Array(8).fill(0));
(bjY)=((bjY).concat(toBin_((bjX).agQ)));
(bjY)=((bjY).concat(toBin_((bjX).agK)));
(bjY)=((bjY).concat(toBin_((bjX).yI)));
(bjY)=((bjY).concat(toBin_((bjX).yE)));
(bjY)=((bjY).concat(toBin_((bjX).ql)));
(bjY)=((bjY).concat(toBin_((bjX).qX)));
(bjY)=((bjY).concat(toBin_((bjX).qU)));
(bjY)=((bjY).concat(toBin_((bjX).pY)));
(bjY)=((bjY).concat(toBin_((bjX).q0)));
(bjY)=((bjY).concat(toBin_((bjX).qz)));
(bjY)=((bjY).concat(toBin_((bjX).zo)));
(bjY)=((bjY).concat(toBin_((bjX).r5)));
(bjY)=((bjY).concat(toBin_((bjX).qc)));
return bjY;
}
// _fromBin
function bkm(bkn,bko,bkp){
let bkq=null;
(bkq)=(new Qd());
((bkq).agQ)=(fromBin_((bko),(bkp.$)));
((bkq).agK)=(fromBin_((bko),(bkp.$)));
((bkq).yI)=(fromBin_((bko),(bkp.$)));
((bkq).yE)=(fromBin_((bko),(bkp.$)));
((bkq).ql)=(fromBin_((bko),(bkp.$)));
((bkq).qX)=(fromBin_((bko),(bkp.$)));
((bkq).qU)=(fromBin_((bko),(bkp.$)));
((bkq).pY)=(fromBin_((bko),(bkp.$)));
((bkq).q0)=(fromBin_((bko),(bkp.$)));
((bkq).qz)=(fromBin_((bko),(bkp.$)));
((bkq).zo)=(fromBin_((bko),(bkp.$)));
((bkq).r5)=(fromBin_((bko),(bkp.$)));
((bkq).qc)=(fromBin_((bko),(bkp.$)));
return bkq;
}
// _dtor
function bkr(bks){
((bks).ala)=(null);
((bks).ald)=(null);
((bks).alg)=(null);
((bks).yI)=(null);
((bks).ql)=(null);
((bks).qX)=(null);
((bks).qU)=(null);
((bks).pY)=(null);
((bks).q0)=(null);
((bks).qz)=(null);
((bks).zo)=(null);
}
// _copy
function bkt(bku){
let bkv=null;
(bkv)=(new Qi());
((bkv).ala)=(C_([134],((bku).ala)));
((bkv).ald)=(C_([134],((bku).ald)));
((bkv).alg)=(C_([134],((bku).alg)));
((bkv).yI)=(C_([134],((bku).yI)));
((bkv).yE)=((bku).yE);
((bkv).ql)=(C_([134],((bku).ql)));
((bkv).qX)=(C_([129,2],((bku).qX)));
((bkv).qU)=(C_([134],((bku).qU)));
((bkv).pY)=(C_([133,129,2,134],((bku).pY)));
((bkv).q0)=(C_([129,2],((bku).q0)));
((bkv).qz)=(C_([134],((bku).qz)));
((bkv).zo)=(C_([134],((bku).zo)));
((bkv).r5)=((bku).r5);
((bkv).qc)=((bku).qc);
return bkv;
}
// _toBin
function bkw(bkx){
let bky=null;
(bky)=(new Array(8).fill(0));
(bky)=((bky).concat(toBin_((bkx).ala)));
(bky)=((bky).concat(toBin_((bkx).ald)));
(bky)=((bky).concat(toBin_((bkx).alg)));
(bky)=((bky).concat(toBin_((bkx).yI)));
(bky)=((bky).concat(toBin_((bkx).yE)));
(bky)=((bky).concat(toBin_((bkx).ql)));
(bky)=((bky).concat(toBin_((bkx).qX)));
(bky)=((bky).concat(toBin_((bkx).qU)));
(bky)=((bky).concat(toBin_((bkx).pY)));
(bky)=((bky).concat(toBin_((bkx).q0)));
(bky)=((bky).concat(toBin_((bkx).qz)));
(bky)=((bky).concat(toBin_((bkx).zo)));
(bky)=((bky).concat(toBin_((bkx).r5)));
(bky)=((bky).concat(toBin_((bkx).qc)));
return bky;
}
// _fromBin
function bkD(bkE,bkF,bkG){
let bkH=null;
(bkH)=(new Qi());
((bkH).ala)=(fromBin_((bkF),(bkG.$)));
((bkH).ald)=(fromBin_((bkF),(bkG.$)));
((bkH).alg)=(fromBin_((bkF),(bkG.$)));
((bkH).yI)=(fromBin_((bkF),(bkG.$)));
((bkH).yE)=(fromBin_((bkF),(bkG.$)));
((bkH).ql)=(fromBin_((bkF),(bkG.$)));
((bkH).qX)=(fromBin_((bkF),(bkG.$)));
((bkH).qU)=(fromBin_((bkF),(bkG.$)));
((bkH).pY)=(fromBin_((bkF),(bkG.$)));
((bkH).q0)=(fromBin_((bkF),(bkG.$)));
((bkH).qz)=(fromBin_((bkF),(bkG.$)));
((bkH).zo)=(fromBin_((bkF),(bkG.$)));
((bkH).r5)=(fromBin_((bkF),(bkG.$)));
((bkH).qc)=(fromBin_((bkF),(bkG.$)));
return bkH;
}
// _dtor
function bkI(bkJ){
((bkJ).al0)=(null);
((bkJ).yI)=(null);
((bkJ).ql)=(null);
((bkJ).qX)=(null);
((bkJ).qU)=(null);
((bkJ).pY)=(null);
((bkJ).q0)=(null);
((bkJ).qz)=(null);
((bkJ).zo)=(null);
}
// _copy
function bkK(bkL){
let bkM=null;
(bkM)=(new Ql());
((bkM).al0)=(C_([134],((bkL).al0)));
((bkM).yI)=(C_([134],((bkL).yI)));
((bkM).yE)=((bkL).yE);
((bkM).ql)=(C_([134],((bkL).ql)));
((bkM).qX)=(C_([129,2],((bkL).qX)));
((bkM).qU)=(C_([134],((bkL).qU)));
((bkM).pY)=(C_([133,129,2,134],((bkL).pY)));
((bkM).q0)=(C_([129,2],((bkL).q0)));
((bkM).qz)=(C_([134],((bkL).qz)));
((bkM).zo)=(C_([134],((bkL).zo)));
((bkM).r5)=((bkL).r5);
((bkM).qc)=((bkL).qc);
return bkM;
}
// _toBin
function bkN(bkO){
let bkP=null;
(bkP)=(new Array(8).fill(0));
(bkP)=((bkP).concat(toBin_((bkO).al0)));
(bkP)=((bkP).concat(toBin_((bkO).yI)));
(bkP)=((bkP).concat(toBin_((bkO).yE)));
(bkP)=((bkP).concat(toBin_((bkO).ql)));
(bkP)=((bkP).concat(toBin_((bkO).qX)));
(bkP)=((bkP).concat(toBin_((bkO).qU)));
(bkP)=((bkP).concat(toBin_((bkO).pY)));
(bkP)=((bkP).concat(toBin_((bkO).q0)));
(bkP)=((bkP).concat(toBin_((bkO).qz)));
(bkP)=((bkP).concat(toBin_((bkO).zo)));
(bkP)=((bkP).concat(toBin_((bkO).r5)));
(bkP)=((bkP).concat(toBin_((bkO).qc)));
return bkP;
}
// _fromBin
function blc(bld,ble,blf){
let blg=null;
(blg)=(new Ql());
((blg).al0)=(fromBin_((ble),(blf.$)));
((blg).yI)=(fromBin_((ble),(blf.$)));
((blg).yE)=(fromBin_((ble),(blf.$)));
((blg).ql)=(fromBin_((ble),(blf.$)));
((blg).qX)=(fromBin_((ble),(blf.$)));
((blg).qU)=(fromBin_((ble),(blf.$)));
((blg).pY)=(fromBin_((ble),(blf.$)));
((blg).q0)=(fromBin_((ble),(blf.$)));
((blg).qz)=(fromBin_((ble),(blf.$)));
((blg).zo)=(fromBin_((ble),(blf.$)));
((blg).r5)=(fromBin_((ble),(blf.$)));
((blg).qc)=(fromBin_((ble),(blf.$)));
return blg;
}
// _dtor
function blh(bli){
((bli).alC)=(null);
((bli).alK)=(null);
((bli).yI)=(null);
((bli).ql)=(null);
((bli).qX)=(null);
((bli).qU)=(null);
((bli).pY)=(null);
((bli).q0)=(null);
((bli).qz)=(null);
((bli).zo)=(null);
}
// _copy
function blj(blk){
let bll=null;
(bll)=(new Qo());
((bll).alC)=(C_([130,134],((blk).alC)));
((bll).alK)=(C_([134],((blk).alK)));
((bll).yI)=(C_([134],((blk).yI)));
((bll).yE)=((blk).yE);
((bll).ql)=(C_([134],((blk).ql)));
((bll).qX)=(C_([129,2],((blk).qX)));
((bll).qU)=(C_([134],((blk).qU)));
((bll).pY)=(C_([133,129,2,134],((blk).pY)));
((bll).q0)=(C_([129,2],((blk).q0)));
((bll).qz)=(C_([134],((blk).qz)));
((bll).zo)=(C_([134],((blk).zo)));
((bll).r5)=((blk).r5);
((bll).qc)=((blk).qc);
return bll;
}
// _toBin
function blm(bln){
let blo=null;
(blo)=(new Array(8).fill(0));
(blo)=((blo).concat(toBin_((bln).alC)));
(blo)=((blo).concat(toBin_((bln).alK)));
(blo)=((blo).concat(toBin_((bln).yI)));
(blo)=((blo).concat(toBin_((bln).yE)));
(blo)=((blo).concat(toBin_((bln).ql)));
(blo)=((blo).concat(toBin_((bln).qX)));
(blo)=((blo).concat(toBin_((bln).qU)));
(blo)=((blo).concat(toBin_((bln).pY)));
(blo)=((blo).concat(toBin_((bln).q0)));
(blo)=((blo).concat(toBin_((bln).qz)));
(blo)=((blo).concat(toBin_((bln).zo)));
(blo)=((blo).concat(toBin_((bln).r5)));
(blo)=((blo).concat(toBin_((bln).qc)));
return blo;
}
// _fromBin
function bl2(bl3,bl4,bl5){
let bl6=null;
(bl6)=(new Qo());
((bl6).alC)=(fromBin_((bl4),(bl5.$)));
((bl6).alK)=(fromBin_((bl4),(bl5.$)));
((bl6).yI)=(fromBin_((bl4),(bl5.$)));
((bl6).yE)=(fromBin_((bl4),(bl5.$)));
((bl6).ql)=(fromBin_((bl4),(bl5.$)));
((bl6).qX)=(fromBin_((bl4),(bl5.$)));
((bl6).qU)=(fromBin_((bl4),(bl5.$)));
((bl6).pY)=(fromBin_((bl4),(bl5.$)));
((bl6).q0)=(fromBin_((bl4),(bl5.$)));
((bl6).qz)=(fromBin_((bl4),(bl5.$)));
((bl6).zo)=(fromBin_((bl4),(bl5.$)));
((bl6).r5)=(fromBin_((bl4),(bl5.$)));
((bl6).qc)=(fromBin_((bl4),(bl5.$)));
return bl6;
}
// _dtor
function bl7(bl8){
((bl8).alX)=(null);
((bl8).ama)=(null);
((bl8).yI)=(null);
((bl8).ql)=(null);
((bl8).qX)=(null);
((bl8).qU)=(null);
((bl8).pY)=(null);
((bl8).q0)=(null);
((bl8).qz)=(null);
((bl8).zo)=(null);
}
// _copy
function bl9(blA){
let blB=null;
(blB)=(new Qr());
((blB).amf)=((blA).amf);
((blB).alX)=(C_([134],((blA).alX)));
((blB).ama)=(C_([134],((blA).ama)));
((blB).yI)=(C_([134],((blA).yI)));
((blB).yE)=((blA).yE);
((blB).ql)=(C_([134],((blA).ql)));
((blB).qX)=(C_([129,2],((blA).qX)));
((blB).qU)=(C_([134],((blA).qU)));
((blB).pY)=(C_([133,129,2,134],((blA).pY)));
((blB).q0)=(C_([129,2],((blA).q0)));
((blB).qz)=(C_([134],((blA).qz)));
((blB).zo)=(C_([134],((blA).zo)));
((blB).r5)=((blA).r5);
((blB).qc)=((blA).qc);
return blB;
}
// _toBin
function blC(blD){
let blE=null;
(blE)=(new Array(8).fill(0));
(blE)=((blE).concat(toBin_((blD).amf)));
(blE)=((blE).concat(toBin_((blD).alX)));
(blE)=((blE).concat(toBin_((blD).ama)));
(blE)=((blE).concat(toBin_((blD).yI)));
(blE)=((blE).concat(toBin_((blD).yE)));
(blE)=((blE).concat(toBin_((blD).ql)));
(blE)=((blE).concat(toBin_((blD).qX)));
(blE)=((blE).concat(toBin_((blD).qU)));
(blE)=((blE).concat(toBin_((blD).pY)));
(blE)=((blE).concat(toBin_((blD).q0)));
(blE)=((blE).concat(toBin_((blD).qz)));
(blE)=((blE).concat(toBin_((blD).zo)));
(blE)=((blE).concat(toBin_((blD).r5)));
(blE)=((blE).concat(toBin_((blD).qc)));
return blE;
}
// _fromBin
function blT(blU,blV,blW){
let blX=null;
(blX)=(new Qr());
((blX).amf)=(fromBin_((blV),(blW.$)));
((blX).alX)=(fromBin_((blV),(blW.$)));
((blX).ama)=(fromBin_((blV),(blW.$)));
((blX).yI)=(fromBin_((blV),(blW.$)));
((blX).yE)=(fromBin_((blV),(blW.$)));
((blX).ql)=(fromBin_((blV),(blW.$)));
((blX).qX)=(fromBin_((blV),(blW.$)));
((blX).qU)=(fromBin_((blV),(blW.$)));
((blX).pY)=(fromBin_((blV),(blW.$)));
((blX).q0)=(fromBin_((blV),(blW.$)));
((blX).qz)=(fromBin_((blV),(blW.$)));
((blX).zo)=(fromBin_((blV),(blW.$)));
((blX).r5)=(fromBin_((blV),(blW.$)));
((blX).qc)=(fromBin_((blV),(blW.$)));
return blX;
}
// _dtor
function blY(blZ){
((blZ).ant)=(null);
((blZ).anz)=(null);
((blZ).yI)=(null);
((blZ).ql)=(null);
((blZ).qX)=(null);
((blZ).qU)=(null);
((blZ).pY)=(null);
((blZ).q0)=(null);
((blZ).qz)=(null);
((blZ).zo)=(null);
}
// _copy
function bma(bmb){
let bmc=null;
(bmc)=(new Qu());
((bmc).ant)=(C_([134],((bmb).ant)));
((bmc).anz)=(C_([134],((bmb).anz)));
((bmc).yI)=(C_([134],((bmb).yI)));
((bmc).yE)=((bmb).yE);
((bmc).ql)=(C_([134],((bmb).ql)));
((bmc).qX)=(C_([129,2],((bmb).qX)));
((bmc).qU)=(C_([134],((bmb).qU)));
((bmc).pY)=(C_([133,129,2,134],((bmb).pY)));
((bmc).q0)=(C_([129,2],((bmb).q0)));
((bmc).qz)=(C_([134],((bmb).qz)));
((bmc).zo)=(C_([134],((bmb).zo)));
((bmc).r5)=((bmb).r5);
((bmc).qc)=((bmb).qc);
return bmc;
}
// _toBin
function bmd(bme){
let bmf=null;
(bmf)=(new Array(8).fill(0));
(bmf)=((bmf).concat(toBin_((bme).ant)));
(bmf)=((bmf).concat(toBin_((bme).anz)));
(bmf)=((bmf).concat(toBin_((bme).yI)));
(bmf)=((bmf).concat(toBin_((bme).yE)));
(bmf)=((bmf).concat(toBin_((bme).ql)));
(bmf)=((bmf).concat(toBin_((bme).qX)));
(bmf)=((bmf).concat(toBin_((bme).qU)));
(bmf)=((bmf).concat(toBin_((bme).pY)));
(bmf)=((bmf).concat(toBin_((bme).q0)));
(bmf)=((bmf).concat(toBin_((bme).qz)));
(bmf)=((bmf).concat(toBin_((bme).zo)));
(bmf)=((bmf).concat(toBin_((bme).r5)));
(bmf)=((bmf).concat(toBin_((bme).qc)));
return bmf;
}
// _fromBin
function bmt(bmu,bmv,bmw){
let bmx=null;
(bmx)=(new Qu());
((bmx).ant)=(fromBin_((bmv),(bmw.$)));
((bmx).anz)=(fromBin_((bmv),(bmw.$)));
((bmx).yI)=(fromBin_((bmv),(bmw.$)));
((bmx).yE)=(fromBin_((bmv),(bmw.$)));
((bmx).ql)=(fromBin_((bmv),(bmw.$)));
((bmx).qX)=(fromBin_((bmv),(bmw.$)));
((bmx).qU)=(fromBin_((bmv),(bmw.$)));
((bmx).pY)=(fromBin_((bmv),(bmw.$)));
((bmx).q0)=(fromBin_((bmv),(bmw.$)));
((bmx).qz)=(fromBin_((bmv),(bmw.$)));
((bmx).zo)=(fromBin_((bmv),(bmw.$)));
((bmx).r5)=(fromBin_((bmv),(bmw.$)));
((bmx).qc)=(fromBin_((bmv),(bmw.$)));
return bmx;
}
// _dtor
function bmy(bmz){
((bmz).an4)=(null);
((bmz).an9)=(null);
((bmz).anA)=(null);
((bmz).yI)=(null);
((bmz).ql)=(null);
((bmz).qX)=(null);
((bmz).qU)=(null);
((bmz).pY)=(null);
((bmz).q0)=(null);
((bmz).qz)=(null);
((bmz).zo)=(null);
}
// _copy
function bm0(bm1){
let bm2=null;
(bm2)=(new Qx());
((bm2).an4)=(C_([134],((bm1).an4)));
((bm2).an9)=(C_([134],((bm1).an9)));
((bm2).anA)=(C_([134],((bm1).anA)));
((bm2).yI)=(C_([134],((bm1).yI)));
((bm2).yE)=((bm1).yE);
((bm2).ql)=(C_([134],((bm1).ql)));
((bm2).qX)=(C_([129,2],((bm1).qX)));
((bm2).qU)=(C_([134],((bm1).qU)));
((bm2).pY)=(C_([133,129,2,134],((bm1).pY)));
((bm2).q0)=(C_([129,2],((bm1).q0)));
((bm2).qz)=(C_([134],((bm1).qz)));
((bm2).zo)=(C_([134],((bm1).zo)));
((bm2).r5)=((bm1).r5);
((bm2).qc)=((bm1).qc);
return bm2;
}
// _toBin
function bm3(bm4){
let bm5=null;
(bm5)=(new Array(8).fill(0));
(bm5)=((bm5).concat(toBin_((bm4).an4)));
(bm5)=((bm5).concat(toBin_((bm4).an9)));
(bm5)=((bm5).concat(toBin_((bm4).anA)));
(bm5)=((bm5).concat(toBin_((bm4).yI)));
(bm5)=((bm5).concat(toBin_((bm4).yE)));
(bm5)=((bm5).concat(toBin_((bm4).ql)));
(bm5)=((bm5).concat(toBin_((bm4).qX)));
(bm5)=((bm5).concat(toBin_((bm4).qU)));
(bm5)=((bm5).concat(toBin_((bm4).pY)));
(bm5)=((bm5).concat(toBin_((bm4).q0)));
(bm5)=((bm5).concat(toBin_((bm4).qz)));
(bm5)=((bm5).concat(toBin_((bm4).zo)));
(bm5)=((bm5).concat(toBin_((bm4).r5)));
(bm5)=((bm5).concat(toBin_((bm4).qc)));
return bm5;
}
// _fromBin
function bmK(bmL,bmM,bmN){
let bmO=null;
(bmO)=(new Qx());
((bmO).an4)=(fromBin_((bmM),(bmN.$)));
((bmO).an9)=(fromBin_((bmM),(bmN.$)));
((bmO).anA)=(fromBin_((bmM),(bmN.$)));
((bmO).yI)=(fromBin_((bmM),(bmN.$)));
((bmO).yE)=(fromBin_((bmM),(bmN.$)));
((bmO).ql)=(fromBin_((bmM),(bmN.$)));
((bmO).qX)=(fromBin_((bmM),(bmN.$)));
((bmO).qU)=(fromBin_((bmM),(bmN.$)));
((bmO).pY)=(fromBin_((bmM),(bmN.$)));
((bmO).q0)=(fromBin_((bmM),(bmN.$)));
((bmO).qz)=(fromBin_((bmM),(bmN.$)));
((bmO).zo)=(fromBin_((bmM),(bmN.$)));
((bmO).r5)=(fromBin_((bmM),(bmN.$)));
((bmO).qc)=(fromBin_((bmM),(bmN.$)));
return bmO;
}
// _dtor
function bmP(bmQ){
((bmQ).aoB)=(null);
((bmQ).aoG)=(null);
((bmQ).yI)=(null);
((bmQ).ql)=(null);
((bmQ).qX)=(null);
((bmQ).qU)=(null);
((bmQ).pY)=(null);
((bmQ).q0)=(null);
((bmQ).qz)=(null);
((bmQ).zo)=(null);
}
// _copy
function bmR(bmS){
let bmT=null;
(bmT)=(new Q2());
((bmT).aoB)=(C_([134],((bmS).aoB)));
((bmT).aoG)=(C_([134],((bmS).aoG)));
((bmT).yI)=(C_([134],((bmS).yI)));
((bmT).yE)=((bmS).yE);
((bmT).ql)=(C_([134],((bmS).ql)));
((bmT).qX)=(C_([129,2],((bmS).qX)));
((bmT).qU)=(C_([134],((bmS).qU)));
((bmT).pY)=(C_([133,129,2,134],((bmS).pY)));
((bmT).q0)=(C_([129,2],((bmS).q0)));
((bmT).qz)=(C_([134],((bmS).qz)));
((bmT).zo)=(C_([134],((bmS).zo)));
((bmT).r5)=((bmS).r5);
((bmT).qc)=((bmS).qc);
return bmT;
}
// _toBin
function bmU(bmV){
let bmW=null;
(bmW)=(new Array(8).fill(0));
(bmW)=((bmW).concat(toBin_((bmV).aoB)));
(bmW)=((bmW).concat(toBin_((bmV).aoG)));
(bmW)=((bmW).concat(toBin_((bmV).yI)));
(bmW)=((bmW).concat(toBin_((bmV).yE)));
(bmW)=((bmW).concat(toBin_((bmV).ql)));
(bmW)=((bmW).concat(toBin_((bmV).qX)));
(bmW)=((bmW).concat(toBin_((bmV).qU)));
(bmW)=((bmW).concat(toBin_((bmV).pY)));
(bmW)=((bmW).concat(toBin_((bmV).q0)));
(bmW)=((bmW).concat(toBin_((bmV).qz)));
(bmW)=((bmW).concat(toBin_((bmV).zo)));
(bmW)=((bmW).concat(toBin_((bmV).r5)));
(bmW)=((bmW).concat(toBin_((bmV).qc)));
return bmW;
}
// _fromBin
function bnk(bnl,bnm,bnn){
let bno=null;
(bno)=(new Q2());
((bno).aoB)=(fromBin_((bnm),(bnn.$)));
((bno).aoG)=(fromBin_((bnm),(bnn.$)));
((bno).yI)=(fromBin_((bnm),(bnn.$)));
((bno).yE)=(fromBin_((bnm),(bnn.$)));
((bno).ql)=(fromBin_((bnm),(bnn.$)));
((bno).qX)=(fromBin_((bnm),(bnn.$)));
((bno).qU)=(fromBin_((bnm),(bnn.$)));
((bno).pY)=(fromBin_((bnm),(bnn.$)));
((bno).q0)=(fromBin_((bnm),(bnn.$)));
((bno).qz)=(fromBin_((bnm),(bnn.$)));
((bno).zo)=(fromBin_((bnm),(bnn.$)));
((bno).r5)=(fromBin_((bnm),(bnn.$)));
((bno).qc)=(fromBin_((bnm),(bnn.$)));
return bno;
}
// _dtor
function bnp(bnq){
((bnq).anT)=(null);
((bnq).aoZ)=(null);
((bnq).apm)=(null);
((bnq).yI)=(null);
((bnq).ql)=(null);
((bnq).qX)=(null);
((bnq).qU)=(null);
((bnq).pY)=(null);
((bnq).q0)=(null);
((bnq).qz)=(null);
((bnq).zo)=(null);
}
// _copy
function bnr(bns){
let bnt=null;
(bnt)=(new Q5());
((bnt).anT)=(C_([134],((bns).anT)));
((bnt).aoZ)=(C_([129,2],((bns).aoZ)));
((bnt).apm)=(C_([134],((bns).apm)));
((bnt).yI)=(C_([134],((bns).yI)));
((bnt).yE)=((bns).yE);
((bnt).ql)=(C_([134],((bns).ql)));
((bnt).qX)=(C_([129,2],((bns).qX)));
((bnt).qU)=(C_([134],((bns).qU)));
((bnt).pY)=(C_([133,129,2,134],((bns).pY)));
((bnt).q0)=(C_([129,2],((bns).q0)));
((bnt).qz)=(C_([134],((bns).qz)));
((bnt).zo)=(C_([134],((bns).zo)));
((bnt).r5)=((bns).r5);
((bnt).qc)=((bns).qc);
return bnt;
}
// _toBin
function bnu(bnv){
let bnw=null;
(bnw)=(new Array(8).fill(0));
(bnw)=((bnw).concat(toBin_((bnv).anT)));
(bnw)=((bnw).concat(toBin_((bnv).aoZ)));
(bnw)=((bnw).concat(toBin_((bnv).apm)));
(bnw)=((bnw).concat(toBin_((bnv).yI)));
(bnw)=((bnw).concat(toBin_((bnv).yE)));
(bnw)=((bnw).concat(toBin_((bnv).ql)));
(bnw)=((bnw).concat(toBin_((bnv).qX)));
(bnw)=((bnw).concat(toBin_((bnv).qU)));
(bnw)=((bnw).concat(toBin_((bnv).pY)));
(bnw)=((bnw).concat(toBin_((bnv).q0)));
(bnw)=((bnw).concat(toBin_((bnv).qz)));
(bnw)=((bnw).concat(toBin_((bnv).zo)));
(bnw)=((bnw).concat(toBin_((bnv).r5)));
(bnw)=((bnw).concat(toBin_((bnv).qc)));
return bnw;
}
// _fromBin
function bnB(bnC,bnD,bnE){
let bnF=null;
(bnF)=(new Q5());
((bnF).anT)=(fromBin_((bnD),(bnE.$)));
((bnF).aoZ)=(fromBin_((bnD),(bnE.$)));
((bnF).apm)=(fromBin_((bnD),(bnE.$)));
((bnF).yI)=(fromBin_((bnD),(bnE.$)));
((bnF).yE)=(fromBin_((bnD),(bnE.$)));
((bnF).ql)=(fromBin_((bnD),(bnE.$)));
((bnF).qX)=(fromBin_((bnD),(bnE.$)));
((bnF).qU)=(fromBin_((bnD),(bnE.$)));
((bnF).pY)=(fromBin_((bnD),(bnE.$)));
((bnF).q0)=(fromBin_((bnD),(bnE.$)));
((bnF).qz)=(fromBin_((bnD),(bnE.$)));
((bnF).zo)=(fromBin_((bnD),(bnE.$)));
((bnF).r5)=(fromBin_((bnD),(bnE.$)));
((bnF).qc)=(fromBin_((bnD),(bnE.$)));
return bnF;
}
// _dtor
function bnG(bnH){
((bnH).aiK)=(null);
((bnH).yI)=(null);
((bnH).ql)=(null);
((bnH).qX)=(null);
((bnH).qU)=(null);
((bnH).pY)=(null);
((bnH).q0)=(null);
((bnH).qz)=(null);
((bnH).zo)=(null);
}
// _copy
function bnI(bnJ){
let bnK=null;
(bnK)=(new QC());
((bnK).aiK)=(C_([129,2],((bnJ).aiK)));
((bnK).yI)=(C_([134],((bnJ).yI)));
((bnK).yE)=((bnJ).yE);
((bnK).ql)=(C_([134],((bnJ).ql)));
((bnK).qX)=(C_([129,2],((bnJ).qX)));
((bnK).qU)=(C_([134],((bnJ).qU)));
((bnK).pY)=(C_([133,129,2,134],((bnJ).pY)));
((bnK).q0)=(C_([129,2],((bnJ).q0)));
((bnK).qz)=(C_([134],((bnJ).qz)));
((bnK).zo)=(C_([134],((bnJ).zo)));
((bnK).r5)=((bnJ).r5);
((bnK).qc)=((bnJ).qc);
return bnK;
}
// _toBin
function bnL(bnM){
let bnN=null;
(bnN)=(new Array(8).fill(0));
(bnN)=((bnN).concat(toBin_((bnM).aiK)));
(bnN)=((bnN).concat(toBin_((bnM).yI)));
(bnN)=((bnN).concat(toBin_((bnM).yE)));
(bnN)=((bnN).concat(toBin_((bnM).ql)));
(bnN)=((bnN).concat(toBin_((bnM).qX)));
(bnN)=((bnN).concat(toBin_((bnM).qU)));
(bnN)=((bnN).concat(toBin_((bnM).pY)));
(bnN)=((bnN).concat(toBin_((bnM).q0)));
(bnN)=((bnN).concat(toBin_((bnM).qz)));
(bnN)=((bnN).concat(toBin_((bnM).zo)));
(bnN)=((bnN).concat(toBin_((bnM).r5)));
(bnN)=((bnN).concat(toBin_((bnM).qc)));
return bnN;
}
// _fromBin
function boa(bob,boc,bod){
let boe=null;
(boe)=(new QC());
((boe).aiK)=(fromBin_((boc),(bod.$)));
((boe).yI)=(fromBin_((boc),(bod.$)));
((boe).yE)=(fromBin_((boc),(bod.$)));
((boe).ql)=(fromBin_((boc),(bod.$)));
((boe).qX)=(fromBin_((boc),(bod.$)));
((boe).qU)=(fromBin_((boc),(bod.$)));
((boe).pY)=(fromBin_((boc),(bod.$)));
((boe).q0)=(fromBin_((boc),(bod.$)));
((boe).qz)=(fromBin_((boc),(bod.$)));
((boe).zo)=(fromBin_((boc),(bod.$)));
((boe).r5)=(fromBin_((boc),(bod.$)));
((boe).qc)=(fromBin_((boc),(bod.$)));
return boe;
}
// _dtor
function bof(bog){
((bog).aig)=(null);
((bog).yI)=(null);
((bog).ql)=(null);
((bog).qX)=(null);
((bog).qU)=(null);
((bog).pY)=(null);
((bog).q0)=(null);
((bog).qz)=(null);
((bog).zo)=(null);
}
// _copy
function boh(boi){
let boj=null;
(boj)=(new QF());
((boj).aig)=(C_([129,2],((boi).aig)));
((boj).yI)=(C_([134],((boi).yI)));
((boj).yE)=((boi).yE);
((boj).ql)=(C_([134],((boi).ql)));
((boj).qX)=(C_([129,2],((boi).qX)));
((boj).qU)=(C_([134],((boi).qU)));
((boj).pY)=(C_([133,129,2,134],((boi).pY)));
((boj).q0)=(C_([129,2],((boi).q0)));
((boj).qz)=(C_([134],((boi).qz)));
((boj).zo)=(C_([134],((boi).zo)));
((boj).r5)=((boi).r5);
((boj).qc)=((boi).qc);
return boj;
}
// _toBin
function bok(bol){
let bom=null;
(bom)=(new Array(8).fill(0));
(bom)=((bom).concat(toBin_((bol).aig)));
(bom)=((bom).concat(toBin_((bol).yI)));
(bom)=((bom).concat(toBin_((bol).yE)));
(bom)=((bom).concat(toBin_((bol).ql)));
(bom)=((bom).concat(toBin_((bol).qX)));
(bom)=((bom).concat(toBin_((bol).qU)));
(bom)=((bom).concat(toBin_((bol).pY)));
(bom)=((bom).concat(toBin_((bol).q0)));
(bom)=((bom).concat(toBin_((bol).qz)));
(bom)=((bom).concat(toBin_((bol).zo)));
(bom)=((bom).concat(toBin_((bol).r5)));
(bom)=((bom).concat(toBin_((bol).qc)));
return bom;
}
// _fromBin
function boz(bo0,bo1,bo2){
let bo3=null;
(bo3)=(new QF());
((bo3).aig)=(fromBin_((bo1),(bo2.$)));
((bo3).yI)=(fromBin_((bo1),(bo2.$)));
((bo3).yE)=(fromBin_((bo1),(bo2.$)));
((bo3).ql)=(fromBin_((bo1),(bo2.$)));
((bo3).qX)=(fromBin_((bo1),(bo2.$)));
((bo3).qU)=(fromBin_((bo1),(bo2.$)));
((bo3).pY)=(fromBin_((bo1),(bo2.$)));
((bo3).q0)=(fromBin_((bo1),(bo2.$)));
((bo3).qz)=(fromBin_((bo1),(bo2.$)));
((bo3).zo)=(fromBin_((bo1),(bo2.$)));
((bo3).r5)=(fromBin_((bo1),(bo2.$)));
((bo3).qc)=(fromBin_((bo1),(bo2.$)));
return bo3;
}
// _dtor
function bo4(bo5){
((bo5).yI)=(null);
((bo5).ql)=(null);
((bo5).qX)=(null);
((bo5).qU)=(null);
((bo5).pY)=(null);
((bo5).q0)=(null);
((bo5).qz)=(null);
((bo5).zo)=(null);
}
// _copy
function bo6(bo7){
let bo8=null;
(bo8)=(new QI());
((bo8).ahg)=((bo7).ahg);
((bo8).yI)=(C_([134],((bo7).yI)));
((bo8).yE)=((bo7).yE);
((bo8).ql)=(C_([134],((bo7).ql)));
((bo8).qX)=(C_([129,2],((bo7).qX)));
((bo8).qU)=(C_([134],((bo7).qU)));
((bo8).pY)=(C_([133,129,2,134],((bo7).pY)));
((bo8).q0)=(C_([129,2],((bo7).q0)));
((bo8).qz)=(C_([134],((bo7).qz)));
((bo8).zo)=(C_([134],((bo7).zo)));
((bo8).r5)=((bo7).r5);
((bo8).qc)=((bo7).qc);
return bo8;
}
// _toBin
function bo9(boA){
let boB=null;
(boB)=(new Array(8).fill(0));
(boB)=((boB).concat(toBin_((boA).ahg)));
(boB)=((boB).concat(toBin_((boA).yI)));
(boB)=((boB).concat(toBin_((boA).yE)));
(boB)=((boB).concat(toBin_((boA).ql)));
(boB)=((boB).concat(toBin_((boA).qX)));
(boB)=((boB).concat(toBin_((boA).qU)));
(boB)=((boB).concat(toBin_((boA).pY)));
(boB)=((boB).concat(toBin_((boA).q0)));
(boB)=((boB).concat(toBin_((boA).qz)));
(boB)=((boB).concat(toBin_((boA).zo)));
(boB)=((boB).concat(toBin_((boA).r5)));
(boB)=((boB).concat(toBin_((boA).qc)));
return boB;
}
// _fromBin
function boO(boP,boQ,boR){
let boS=null;
(boS)=(new QI());
((boS).ahg)=(fromBin_((boQ),(boR.$)));
((boS).yI)=(fromBin_((boQ),(boR.$)));
((boS).yE)=(fromBin_((boQ),(boR.$)));
((boS).ql)=(fromBin_((boQ),(boR.$)));
((boS).qX)=(fromBin_((boQ),(boR.$)));
((boS).qU)=(fromBin_((boQ),(boR.$)));
((boS).pY)=(fromBin_((boQ),(boR.$)));
((boS).q0)=(fromBin_((boQ),(boR.$)));
((boS).qz)=(fromBin_((boQ),(boR.$)));
((boS).zo)=(fromBin_((boQ),(boR.$)));
((boS).r5)=(fromBin_((boQ),(boR.$)));
((boS).qc)=(fromBin_((boQ),(boR.$)));
return boS;
}
// _dtor
function boT(boU){
((boU).aoc)=(null);
((boU).yI)=(null);
((boU).ql)=(null);
((boU).qX)=(null);
((boU).qU)=(null);
((boU).pY)=(null);
((boU).q0)=(null);
((boU).qz)=(null);
((boU).zo)=(null);
}
// _copy
function boV(boW){
let boX=null;
(boX)=(new QL());
((boX).aoc)=(C_([130,134],((boW).aoc)));
((boX).yI)=(C_([134],((boW).yI)));
((boX).yE)=((boW).yE);
((boX).ql)=(C_([134],((boW).ql)));
((boX).qX)=(C_([129,2],((boW).qX)));
((boX).qU)=(C_([134],((boW).qU)));
((boX).pY)=(C_([133,129,2,134],((boW).pY)));
((boX).q0)=(C_([129,2],((boW).q0)));
((boX).qz)=(C_([134],((boW).qz)));
((boX).zo)=(C_([134],((boW).zo)));
((boX).r5)=((boW).r5);
((boX).qc)=((boW).qc);
return boX;
}
// _toBin
function boY(boZ){
let bpa=null;
(bpa)=(new Array(8).fill(0));
(bpa)=((bpa).concat(toBin_((boZ).aoc)));
(bpa)=((bpa).concat(toBin_((boZ).yI)));
(bpa)=((bpa).concat(toBin_((boZ).yE)));
(bpa)=((bpa).concat(toBin_((boZ).ql)));
(bpa)=((bpa).concat(toBin_((boZ).qX)));
(bpa)=((bpa).concat(toBin_((boZ).qU)));
(bpa)=((bpa).concat(toBin_((boZ).pY)));
(bpa)=((bpa).concat(toBin_((boZ).q0)));
(bpa)=((bpa).concat(toBin_((boZ).qz)));
(bpa)=((bpa).concat(toBin_((boZ).zo)));
(bpa)=((bpa).concat(toBin_((boZ).r5)));
(bpa)=((bpa).concat(toBin_((boZ).qc)));
return bpa;
}
// _fromBin
function bpn(bpo,bpp,bpq){
let bpr=null;
(bpr)=(new QL());
((bpr).aoc)=(fromBin_((bpp),(bpq.$)));
((bpr).yI)=(fromBin_((bpp),(bpq.$)));
((bpr).yE)=(fromBin_((bpp),(bpq.$)));
((bpr).ql)=(fromBin_((bpp),(bpq.$)));
((bpr).qX)=(fromBin_((bpp),(bpq.$)));
((bpr).qU)=(fromBin_((bpp),(bpq.$)));
((bpr).pY)=(fromBin_((bpp),(bpq.$)));
((bpr).q0)=(fromBin_((bpp),(bpq.$)));
((bpr).qz)=(fromBin_((bpp),(bpq.$)));
((bpr).zo)=(fromBin_((bpp),(bpq.$)));
((bpr).r5)=(fromBin_((bpp),(bpq.$)));
((bpr).qc)=(fromBin_((bpp),(bpq.$)));
return bpr;
}
// _dtor
function bps(bpt){
((bpt).Rd)=(null);
((bpt).ql)=(null);
((bpt).qX)=(null);
((bpt).qU)=(null);
((bpt).pY)=(null);
((bpt).q0)=(null);
((bpt).qz)=(null);
((bpt).zo)=(null);
}
// _copy
function bpu(bpv){
let bpw=null;
(bpw)=(new Rb());
((bpw).Rd)=(C_([134],((bpv).Rd)));
((bpw).ql)=(C_([134],((bpv).ql)));
((bpw).qX)=(C_([129,2],((bpv).qX)));
((bpw).qU)=(C_([134],((bpv).qU)));
((bpw).pY)=(C_([133,129,2,134],((bpv).pY)));
((bpw).q0)=(C_([129,2],((bpv).q0)));
((bpw).qz)=(C_([134],((bpv).qz)));
((bpw).zo)=(C_([134],((bpv).zo)));
((bpw).r5)=((bpv).r5);
((bpw).qc)=((bpv).qc);
return bpw;
}
// _toBin
function bpx(bpy){
let bpz=null;
(bpz)=(new Array(8).fill(0));
(bpz)=((bpz).concat(toBin_((bpy).Rd)));
(bpz)=((bpz).concat(toBin_((bpy).ql)));
(bpz)=((bpz).concat(toBin_((bpy).qX)));
(bpz)=((bpz).concat(toBin_((bpy).qU)));
(bpz)=((bpz).concat(toBin_((bpy).pY)));
(bpz)=((bpz).concat(toBin_((bpy).q0)));
(bpz)=((bpz).concat(toBin_((bpy).qz)));
(bpz)=((bpz).concat(toBin_((bpy).zo)));
(bpz)=((bpz).concat(toBin_((bpy).r5)));
(bpz)=((bpz).concat(toBin_((bpy).qc)));
return bpz;
}
// _fromBin
function bpA(bpB,bpC,bpD){
let bpE=null;
(bpE)=(new Rb());
((bpE).Rd)=(fromBin_((bpC),(bpD.$)));
((bpE).ql)=(fromBin_((bpC),(bpD.$)));
((bpE).qX)=(fromBin_((bpC),(bpD.$)));
((bpE).qU)=(fromBin_((bpC),(bpD.$)));
((bpE).pY)=(fromBin_((bpC),(bpD.$)));
((bpE).q0)=(fromBin_((bpC),(bpD.$)));
((bpE).qz)=(fromBin_((bpC),(bpD.$)));
((bpE).zo)=(fromBin_((bpC),(bpD.$)));
((bpE).r5)=(fromBin_((bpC),(bpD.$)));
((bpE).qc)=(fromBin_((bpC),(bpD.$)));
return bpE;
}
// _dtor
function bpF(bpG){
((bpG).ql)=(null);
((bpG).qX)=(null);
((bpG).qU)=(null);
((bpG).pY)=(null);
((bpG).q0)=(null);
((bpG).qz)=(null);
((bpG).zo)=(null);
}
// _copy
function bpH(bpI){
let bpJ=null;
(bpJ)=(new RW());
((bpJ).ql)=(C_([134],((bpI).ql)));
((bpJ).qX)=(C_([129,2],((bpI).qX)));
((bpJ).qU)=(C_([134],((bpI).qU)));
((bpJ).pY)=(C_([133,129,2,134],((bpI).pY)));
((bpJ).q0)=(C_([129,2],((bpI).q0)));
((bpJ).qz)=(C_([134],((bpI).qz)));
((bpJ).zo)=(C_([134],((bpI).zo)));
((bpJ).r5)=((bpI).r5);
((bpJ).qc)=((bpI).qc);
return bpJ;
}
// _toBin
function bpK(bpL){
let bpM=null;
(bpM)=(new Array(8).fill(0));
(bpM)=((bpM).concat(toBin_((bpL).ql)));
(bpM)=((bpM).concat(toBin_((bpL).qX)));
(bpM)=((bpM).concat(toBin_((bpL).qU)));
(bpM)=((bpM).concat(toBin_((bpL).pY)));
(bpM)=((bpM).concat(toBin_((bpL).q0)));
(bpM)=((bpM).concat(toBin_((bpL).qz)));
(bpM)=((bpM).concat(toBin_((bpL).zo)));
(bpM)=((bpM).concat(toBin_((bpL).r5)));
(bpM)=((bpM).concat(toBin_((bpL).qc)));
return bpM;
}
// _fromBin
function bpW(bpX,bpY,bpZ){
let bqa=null;
(bqa)=(new RW());
((bqa).ql)=(fromBin_((bpY),(bpZ.$)));
((bqa).qX)=(fromBin_((bpY),(bpZ.$)));
((bqa).qU)=(fromBin_((bpY),(bpZ.$)));
((bqa).pY)=(fromBin_((bpY),(bpZ.$)));
((bqa).q0)=(fromBin_((bpY),(bpZ.$)));
((bqa).qz)=(fromBin_((bpY),(bpZ.$)));
((bqa).zo)=(fromBin_((bpY),(bpZ.$)));
((bqa).r5)=(fromBin_((bpY),(bpZ.$)));
((bqa).qc)=(fromBin_((bpY),(bpZ.$)));
return bqa;
}
// _dtor
function bqb(bqc){
((bqc).SS)=(null);
((bqc).ST)=(null);
((bqc).ql)=(null);
((bqc).qX)=(null);
((bqc).qU)=(null);
((bqc).pY)=(null);
((bqc).q0)=(null);
((bqc).qz)=(null);
((bqc).zo)=(null);
}
// _copy
function bqd(bqe){
let bqf=null;
(bqf)=(new SR());
((bqf).SS)=(C_([134],((bqe).SS)));
((bqf).ST)=(C_([134],((bqe).ST)));
((bqf).ql)=(C_([134],((bqe).ql)));
((bqf).qX)=(C_([129,2],((bqe).qX)));
((bqf).qU)=(C_([134],((bqe).qU)));
((bqf).pY)=(C_([133,129,2,134],((bqe).pY)));
((bqf).q0)=(C_([129,2],((bqe).q0)));
((bqf).qz)=(C_([134],((bqe).qz)));
((bqf).zo)=(C_([134],((bqe).zo)));
((bqf).r5)=((bqe).r5);
((bqf).qc)=((bqe).qc);
return bqf;
}
// _toBin
function bqg(bqh){
let bqi=null;
(bqi)=(new Array(8).fill(0));
(bqi)=((bqi).concat(toBin_((bqh).SS)));
(bqi)=((bqi).concat(toBin_((bqh).ST)));
(bqi)=((bqi).concat(toBin_((bqh).ql)));
(bqi)=((bqi).concat(toBin_((bqh).qX)));
(bqi)=((bqi).concat(toBin_((bqh).qU)));
(bqi)=((bqi).concat(toBin_((bqh).pY)));
(bqi)=((bqi).concat(toBin_((bqh).q0)));
(bqi)=((bqi).concat(toBin_((bqh).qz)));
(bqi)=((bqi).concat(toBin_((bqh).zo)));
(bqi)=((bqi).concat(toBin_((bqh).r5)));
(bqi)=((bqi).concat(toBin_((bqh).qc)));
return bqi;
}
// _fromBin
function bqu(bqv,bqw,bqx){
let bqy=null;
(bqy)=(new SR());
((bqy).SS)=(fromBin_((bqw),(bqx.$)));
((bqy).ST)=(fromBin_((bqw),(bqx.$)));
((bqy).ql)=(fromBin_((bqw),(bqx.$)));
((bqy).qX)=(fromBin_((bqw),(bqx.$)));
((bqy).qU)=(fromBin_((bqw),(bqx.$)));
((bqy).pY)=(fromBin_((bqw),(bqx.$)));
((bqy).q0)=(fromBin_((bqw),(bqx.$)));
((bqy).qz)=(fromBin_((bqw),(bqx.$)));
((bqy).zo)=(fromBin_((bqw),(bqx.$)));
((bqy).r5)=(fromBin_((bqw),(bqx.$)));
((bqy).qc)=(fromBin_((bqw),(bqx.$)));
return bqy;
}
// _dtor
function bqz(bq0){
((bq0).Ts)=(null);
((bq0).T6)=(null);
((bq0).ql)=(null);
((bq0).qX)=(null);
((bq0).qU)=(null);
((bq0).pY)=(null);
((bq0).q0)=(null);
((bq0).qz)=(null);
((bq0).zo)=(null);
}
// _copy
function bq1(bq2){
let bq3=null;
(bq3)=(new Tq());
((bq3).Ts)=(C_([130,134],((bq2).Ts)));
((bq3).T6)=(C_([134],((bq2).T6)));
((bq3).ql)=(C_([134],((bq2).ql)));
((bq3).qX)=(C_([129,2],((bq2).qX)));
((bq3).qU)=(C_([134],((bq2).qU)));
((bq3).pY)=(C_([133,129,2,134],((bq2).pY)));
((bq3).q0)=(C_([129,2],((bq2).q0)));
((bq3).qz)=(C_([134],((bq2).qz)));
((bq3).zo)=(C_([134],((bq2).zo)));
((bq3).r5)=((bq2).r5);
((bq3).qc)=((bq2).qc);
return bq3;
}
// _toBin
function bq4(bq5){
let bq6=null;
(bq6)=(new Array(8).fill(0));
(bq6)=((bq6).concat(toBin_((bq5).Ts)));
(bq6)=((bq6).concat(toBin_((bq5).T6)));
(bq6)=((bq6).concat(toBin_((bq5).ql)));
(bq6)=((bq6).concat(toBin_((bq5).qX)));
(bq6)=((bq6).concat(toBin_((bq5).qU)));
(bq6)=((bq6).concat(toBin_((bq5).pY)));
(bq6)=((bq6).concat(toBin_((bq5).q0)));
(bq6)=((bq6).concat(toBin_((bq5).qz)));
(bq6)=((bq6).concat(toBin_((bq5).zo)));
(bq6)=((bq6).concat(toBin_((bq5).r5)));
(bq6)=((bq6).concat(toBin_((bq5).qc)));
return bq6;
}
// _fromBin
function bqI(bqJ,bqK,bqL){
let bqM=null;
(bqM)=(new Tq());
((bqM).Ts)=(fromBin_((bqK),(bqL.$)));
((bqM).T6)=(fromBin_((bqK),(bqL.$)));
((bqM).ql)=(fromBin_((bqK),(bqL.$)));
((bqM).qX)=(fromBin_((bqK),(bqL.$)));
((bqM).qU)=(fromBin_((bqK),(bqL.$)));
((bqM).pY)=(fromBin_((bqK),(bqL.$)));
((bqM).q0)=(fromBin_((bqK),(bqL.$)));
((bqM).qz)=(fromBin_((bqK),(bqL.$)));
((bqM).zo)=(fromBin_((bqK),(bqL.$)));
((bqM).r5)=(fromBin_((bqK),(bqL.$)));
((bqM).qc)=(fromBin_((bqK),(bqL.$)));
return bqM;
}
// _dtor
function bqN(bqO){
((bqO).axh)=(null);
((bqO).ql)=(null);
((bqO).qX)=(null);
((bqO).qU)=(null);
((bqO).pY)=(null);
((bqO).q0)=(null);
((bqO).qz)=(null);
((bqO).zo)=(null);
}
// _copy
function bqP(bqQ){
let bqR=null;
(bqR)=(new axg());
((bqR).axh)=(C_([134],((bqQ).axh)));
((bqR).ql)=(C_([134],((bqQ).ql)));
((bqR).qX)=(C_([129,2],((bqQ).qX)));
((bqR).qU)=(C_([134],((bqQ).qU)));
((bqR).pY)=(C_([133,129,2,134],((bqQ).pY)));
((bqR).q0)=(C_([129,2],((bqQ).q0)));
((bqR).qz)=(C_([134],((bqQ).qz)));
((bqR).zo)=(C_([134],((bqQ).zo)));
((bqR).r5)=((bqQ).r5);
((bqR).qc)=((bqQ).qc);
return bqR;
}
// _toBin
function bqS(bqT){
let bqU=null;
(bqU)=(new Array(8).fill(0));
(bqU)=((bqU).concat(toBin_((bqT).axh)));
(bqU)=((bqU).concat(toBin_((bqT).ql)));
(bqU)=((bqU).concat(toBin_((bqT).qX)));
(bqU)=((bqU).concat(toBin_((bqT).qU)));
(bqU)=((bqU).concat(toBin_((bqT).pY)));
(bqU)=((bqU).concat(toBin_((bqT).q0)));
(bqU)=((bqU).concat(toBin_((bqT).qz)));
(bqU)=((bqU).concat(toBin_((bqT).zo)));
(bqU)=((bqU).concat(toBin_((bqT).r5)));
(bqU)=((bqU).concat(toBin_((bqT).qc)));
return bqU;
}
// _fromBin
function brf(brg,brh,bri){
let brj=null;
(brj)=(new axg());
((brj).axh)=(fromBin_((brh),(bri.$)));
((brj).ql)=(fromBin_((brh),(bri.$)));
((brj).qX)=(fromBin_((brh),(bri.$)));
((brj).qU)=(fromBin_((brh),(bri.$)));
((brj).pY)=(fromBin_((brh),(bri.$)));
((brj).q0)=(fromBin_((brh),(bri.$)));
((brj).qz)=(fromBin_((brh),(bri.$)));
((brj).zo)=(fromBin_((brh),(bri.$)));
((brj).r5)=(fromBin_((brh),(bri.$)));
((brj).qc)=(fromBin_((brh),(bri.$)));
return brj;
}
// _dtor
function brk(brl){
((brl).axl)=(null);
((brl).ql)=(null);
((brl).qX)=(null);
((brl).qU)=(null);
((brl).pY)=(null);
((brl).q0)=(null);
((brl).qz)=(null);
((brl).zo)=(null);
}
// _copy
function brm(brn){
let bro=null;
(bro)=(new axk());
((bro).axl)=(C_([134],((brn).axl)));
((bro).ql)=(C_([134],((brn).ql)));
((bro).qX)=(C_([129,2],((brn).qX)));
((bro).qU)=(C_([134],((brn).qU)));
((bro).pY)=(C_([133,129,2,134],((brn).pY)));
((bro).q0)=(C_([129,2],((brn).q0)));
((bro).qz)=(C_([134],((brn).qz)));
((bro).zo)=(C_([134],((brn).zo)));
((bro).r5)=((brn).r5);
((bro).qc)=((brn).qc);
return bro;
}
// _toBin
function brp(brq){
let brr=null;
(brr)=(new Array(8).fill(0));
(brr)=((brr).concat(toBin_((brq).axl)));
(brr)=((brr).concat(toBin_((brq).ql)));
(brr)=((brr).concat(toBin_((brq).qX)));
(brr)=((brr).concat(toBin_((brq).qU)));
(brr)=((brr).concat(toBin_((brq).pY)));
(brr)=((brr).concat(toBin_((brq).q0)));
(brr)=((brr).concat(toBin_((brq).qz)));
(brr)=((brr).concat(toBin_((brq).zo)));
(brr)=((brr).concat(toBin_((brq).r5)));
(brr)=((brr).concat(toBin_((brq).qc)));
return brr;
}
// _fromBin
function br2(br3,br4,br5){
let br6=null;
(br6)=(new axk());
((br6).axl)=(fromBin_((br4),(br5.$)));
((br6).ql)=(fromBin_((br4),(br5.$)));
((br6).qX)=(fromBin_((br4),(br5.$)));
((br6).qU)=(fromBin_((br4),(br5.$)));
((br6).pY)=(fromBin_((br4),(br5.$)));
((br6).q0)=(fromBin_((br4),(br5.$)));
((br6).qz)=(fromBin_((br4),(br5.$)));
((br6).zo)=(fromBin_((br4),(br5.$)));
((br6).r5)=(fromBin_((br4),(br5.$)));
((br6).qc)=(fromBin_((br4),(br5.$)));
return br6;
}
// _dtor
function br7(br8){
((br8).axo)=(null);
((br8).ql)=(null);
((br8).qX)=(null);
((br8).qU)=(null);
((br8).pY)=(null);
((br8).q0)=(null);
((br8).qz)=(null);
((br8).zo)=(null);
}
// _copy
function br9(brA){
let brB=null;
(brB)=(new axn());
((brB).axo)=(C_([134],((brA).axo)));
((brB).ql)=(C_([134],((brA).ql)));
((brB).qX)=(C_([129,2],((brA).qX)));
((brB).qU)=(C_([134],((brA).qU)));
((brB).pY)=(C_([133,129,2,134],((brA).pY)));
((brB).q0)=(C_([129,2],((brA).q0)));
((brB).qz)=(C_([134],((brA).qz)));
((brB).zo)=(C_([134],((brA).zo)));
((brB).r5)=((brA).r5);
((brB).qc)=((brA).qc);
return brB;
}
// _toBin
function brC(brD){
let brE=null;
(brE)=(new Array(8).fill(0));
(brE)=((brE).concat(toBin_((brD).axo)));
(brE)=((brE).concat(toBin_((brD).ql)));
(brE)=((brE).concat(toBin_((brD).qX)));
(brE)=((brE).concat(toBin_((brD).qU)));
(brE)=((brE).concat(toBin_((brD).pY)));
(brE)=((brE).concat(toBin_((brD).q0)));
(brE)=((brE).concat(toBin_((brD).qz)));
(brE)=((brE).concat(toBin_((brD).zo)));
(brE)=((brE).concat(toBin_((brD).r5)));
(brE)=((brE).concat(toBin_((brD).qc)));
return brE;
}
// _fromBin
function brP(brQ,brR,brS){
let brT=null;
(brT)=(new axn());
((brT).axo)=(fromBin_((brR),(brS.$)));
((brT).ql)=(fromBin_((brR),(brS.$)));
((brT).qX)=(fromBin_((brR),(brS.$)));
((brT).qU)=(fromBin_((brR),(brS.$)));
((brT).pY)=(fromBin_((brR),(brS.$)));
((brT).q0)=(fromBin_((brR),(brS.$)));
((brT).qz)=(fromBin_((brR),(brS.$)));
((brT).zo)=(fromBin_((brR),(brS.$)));
((brT).r5)=(fromBin_((brR),(brS.$)));
((brT).qc)=(fromBin_((brR),(brS.$)));
return brT;
}
// _dtor
function brU(brV){
((brV).axr)=(null);
((brV).ql)=(null);
((brV).qX)=(null);
((brV).qU)=(null);
((brV).pY)=(null);
((brV).q0)=(null);
((brV).qz)=(null);
((brV).zo)=(null);
}
// _copy
function brW(brX){
let brY=null;
(brY)=(new axq());
((brY).axr)=(C_([134],((brX).axr)));
((brY).ql)=(C_([134],((brX).ql)));
((brY).qX)=(C_([129,2],((brX).qX)));
((brY).qU)=(C_([134],((brX).qU)));
((brY).pY)=(C_([133,129,2,134],((brX).pY)));
((brY).q0)=(C_([129,2],((brX).q0)));
((brY).qz)=(C_([134],((brX).qz)));
((brY).zo)=(C_([134],((brX).zo)));
((brY).r5)=((brX).r5);
((brY).qc)=((brX).qc);
return brY;
}
// _toBin
function brZ(bsa){
let bsb=null;
(bsb)=(new Array(8).fill(0));
(bsb)=((bsb).concat(toBin_((bsa).axr)));
(bsb)=((bsb).concat(toBin_((bsa).ql)));
(bsb)=((bsb).concat(toBin_((bsa).qX)));
(bsb)=((bsb).concat(toBin_((bsa).qU)));
(bsb)=((bsb).concat(toBin_((bsa).pY)));
(bsb)=((bsb).concat(toBin_((bsa).q0)));
(bsb)=((bsb).concat(toBin_((bsa).qz)));
(bsb)=((bsb).concat(toBin_((bsa).zo)));
(bsb)=((bsb).concat(toBin_((bsa).r5)));
(bsb)=((bsb).concat(toBin_((bsa).qc)));
return bsb;
}
// _fromBin
function bsm(bsn,bso,bsp){
let bsq=null;
(bsq)=(new axq());
((bsq).axr)=(fromBin_((bso),(bsp.$)));
((bsq).ql)=(fromBin_((bso),(bsp.$)));
((bsq).qX)=(fromBin_((bso),(bsp.$)));
((bsq).qU)=(fromBin_((bso),(bsp.$)));
((bsq).pY)=(fromBin_((bso),(bsp.$)));
((bsq).q0)=(fromBin_((bso),(bsp.$)));
((bsq).qz)=(fromBin_((bso),(bsp.$)));
((bsq).zo)=(fromBin_((bso),(bsp.$)));
((bsq).r5)=(fromBin_((bso),(bsp.$)));
((bsq).qc)=(fromBin_((bso),(bsp.$)));
return bsq;
}
// _dtor
function bsr(bss){
((bss).axu)=(null);
((bss).ql)=(null);
((bss).qX)=(null);
((bss).qU)=(null);
((bss).pY)=(null);
((bss).q0)=(null);
((bss).qz)=(null);
((bss).zo)=(null);
}
// _copy
function bst(bsu){
let bsv=null;
(bsv)=(new axt());
((bsv).axu)=(C_([134],((bsu).axu)));
((bsv).ql)=(C_([134],((bsu).ql)));
((bsv).qX)=(C_([129,2],((bsu).qX)));
((bsv).qU)=(C_([134],((bsu).qU)));
((bsv).pY)=(C_([133,129,2,134],((bsu).pY)));
((bsv).q0)=(C_([129,2],((bsu).q0)));
((bsv).qz)=(C_([134],((bsu).qz)));
((bsv).zo)=(C_([134],((bsu).zo)));
((bsv).r5)=((bsu).r5);
((bsv).qc)=((bsu).qc);
return bsv;
}
// _toBin
function bsw(bsx){
let bsy=null;
(bsy)=(new Array(8).fill(0));
(bsy)=((bsy).concat(toBin_((bsx).axu)));
(bsy)=((bsy).concat(toBin_((bsx).ql)));
(bsy)=((bsy).concat(toBin_((bsx).qX)));
(bsy)=((bsy).concat(toBin_((bsx).qU)));
(bsy)=((bsy).concat(toBin_((bsx).pY)));
(bsy)=((bsy).concat(toBin_((bsx).q0)));
(bsy)=((bsy).concat(toBin_((bsx).qz)));
(bsy)=((bsy).concat(toBin_((bsx).zo)));
(bsy)=((bsy).concat(toBin_((bsx).r5)));
(bsy)=((bsy).concat(toBin_((bsx).qc)));
return bsy;
}
// _fromBin
function bs9(bsA,bsB,bsC){
let bsD=null;
(bsD)=(new axt());
((bsD).axu)=(fromBin_((bsB),(bsC.$)));
((bsD).ql)=(fromBin_((bsB),(bsC.$)));
((bsD).qX)=(fromBin_((bsB),(bsC.$)));
((bsD).qU)=(fromBin_((bsB),(bsC.$)));
((bsD).pY)=(fromBin_((bsB),(bsC.$)));
((bsD).q0)=(fromBin_((bsB),(bsC.$)));
((bsD).qz)=(fromBin_((bsB),(bsC.$)));
((bsD).zo)=(fromBin_((bsB),(bsC.$)));
((bsD).r5)=(fromBin_((bsB),(bsC.$)));
((bsD).qc)=(fromBin_((bsB),(bsC.$)));
return bsD;
}
// _dtor
function bsE(bsF){
((bsF).ql)=(null);
((bsF).qX)=(null);
((bsF).qU)=(null);
((bsF).pY)=(null);
((bsF).q0)=(null);
((bsF).qz)=(null);
((bsF).zo)=(null);
}
// _copy
function bsG(bsH){
let bsI=null;
(bsI)=(new aNu());
((bsI).ql)=(C_([134],((bsH).ql)));
((bsI).qX)=(C_([129,2],((bsH).qX)));
((bsI).qU)=(C_([134],((bsH).qU)));
((bsI).pY)=(C_([133,129,2,134],((bsH).pY)));
((bsI).q0)=(C_([129,2],((bsH).q0)));
((bsI).qz)=(C_([134],((bsH).qz)));
((bsI).zo)=(C_([134],((bsH).zo)));
((bsI).r5)=((bsH).r5);
((bsI).qc)=((bsH).qc);
return bsI;
}
// _toBin
function bsJ(bsK){
let bsL=null;
(bsL)=(new Array(8).fill(0));
(bsL)=((bsL).concat(toBin_((bsK).ql)));
(bsL)=((bsL).concat(toBin_((bsK).qX)));
(bsL)=((bsL).concat(toBin_((bsK).qU)));
(bsL)=((bsL).concat(toBin_((bsK).pY)));
(bsL)=((bsL).concat(toBin_((bsK).q0)));
(bsL)=((bsL).concat(toBin_((bsK).qz)));
(bsL)=((bsL).concat(toBin_((bsK).zo)));
(bsL)=((bsL).concat(toBin_((bsK).r5)));
(bsL)=((bsL).concat(toBin_((bsK).qc)));
return bsL;
}
// _fromBin
function bsV(bsW,bsX,bsY){
let bsZ=null;
(bsZ)=(new aNu());
((bsZ).ql)=(fromBin_((bsX),(bsY.$)));
((bsZ).qX)=(fromBin_((bsX),(bsY.$)));
((bsZ).qU)=(fromBin_((bsX),(bsY.$)));
((bsZ).pY)=(fromBin_((bsX),(bsY.$)));
((bsZ).q0)=(fromBin_((bsX),(bsY.$)));
((bsZ).qz)=(fromBin_((bsX),(bsY.$)));
((bsZ).zo)=(fromBin_((bsX),(bsY.$)));
((bsZ).r5)=(fromBin_((bsX),(bsY.$)));
((bsZ).qc)=(fromBin_((bsX),(bsY.$)));
return bsZ;
}
// addr
function aQE(bta /*class_*/){
}
// _signInt
function aSa(btb /*me_*/){
return ((btb)>(0))?(1):(((btb)<(0))?(-1):(0));
}
function C_(t,v){
switch(t[0]){
case 0:
case 1:
case 2:
case 3:
case 4:
case 5:
case 6:
case 7:
case 8:
case 9:
return v;
case 129:
if(t[1]===2)
return v===null?null:{S:v.S};
else{
let a=new Array(v.length);
for(let i=0;i<v.length;i++)a[i]=C_(t.slice(1),v[i]);
return a;
}
case 130:
case 131:
case 132:
case 133:
case 134:
}
}
function F_(p,f){
if(p==="res/")
return f?null:true;
else if(p==="res/analyze.kn")
return f?"var asts: dict<[]char, \\ast@Ast>\n\n+func analyze(asts: dict<[]char, \\ast@Ast>): \\ast@AstFunc\n\u0009do @asts :: asts\n\u0009\n\u0009var mainFunc: \\ast@AstFunc :: @searchMain()\n\u0009if(mainFunc =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009do asts.forEach(@resolveIdentifier, null)\n\u0009ret @rebuild(mainFunc)\nend func\n\n+func searchMain(): \\ast@AstFunc\n\u0009var ast: \\ast@Ast :: @asts.get(\"\\\\\" ~ \\option@inputName, &)\n\u0009if(ast =& null)\n\u0009\u0009do \\err@err(%noMainFunc, null, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009var mainFunc: \\ast@Ast :: ast.scopeChildren.get(\"main\", &)\n\u0009if(mainFunc =& null | mainFunc.typeId <> %func_)\n\u0009\u0009do \\err@err(%noMainFunc, null, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009var mainFunc2: \\ast@AstFunc :: mainFunc $ \\ast@AstFunc\n\u0009if(^mainFunc2.args <> 0 | mainFunc2.ret_ <>& null | mainFunc2.funcOption <> %none | ^mainFunc2.funcAttr <> 0)\n\u0009\u0009do \\err@err(%wrongMainFunc, mainFunc2.pos, null)\n\u0009end if\n\u0009ret mainFunc2\nend func\n\nfunc resolveIdentifier(key: []char, value: \\ast@Ast, data: kuin@Class): bool\n\u0009assert value =$ \\ast@AstRoot\n\u0009var scopeRefedItems: list<\\ast@ScopeRefedItem> :: (value $ \\ast@AstRoot).scopeRefedItems\n\u0009\n\u0009; Search scopes for identifiers and resolve references.\n\u0009do scopeRefedItems.head()\n\u0009while(!scopeRefedItems.term())\n\u0009\u0009var item: \\ast@ScopeRefedItem :: scopeRefedItems.get()\n\u0009\u0009var ast: \\ast@Ast :: item.def\n\u0009\u0009assert ast.refItem =& null {Must not resolve references that have been already resolved.}\n\u0009\u0009assert ast.refName <>& null\n\u0009\u0009var otherFile: bool :: false\n\u0009\u0009var ptrAt: int :: ast.refName.find(\'@\', -1)\n\u0009\u0009var ptrName: []char :: ptrAt = -1 ?(ast.refName, ast.refName.sub(ptrAt + 1, -1))\n\u0009\u0009var foundAst: \\ast@Ast :: null\n\u0009\u0009if(ptrAt <> -1)\n\u0009\u0009\u0009; Search the root of the source.\n\u0009\u0009\u0009var ptrSrc: []char {The source name before \'@\'.}\n\u0009\u0009\u0009if(ptrAt = 0)\n\u0009\u0009\u0009\u0009do ptrSrc :: key\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do ptrSrc :: ast.refName.sub(0, ptrAt)\n\u0009\u0009\u0009\u0009if(ptrSrc = key)\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%nonOmittingAt, ast.pos, [ptrSrc])\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do otherFile :: true\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009var ast2: \\ast@Ast :: @asts.get(ptrSrc, &)\n\u0009\u0009\u0009if(ast2 <>& null)\n\u0009\u0009\u0009\u0009do foundAst :: ast2.scopeChildren.get(ptrName, &)\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009; Search from the current scope toward its parent\'s scope.\n\u0009\u0009\u0009var scope: \\ast@Ast :: item.scope\n\u0009\u0009\u0009var overFunc: bool :: false\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009if(scope.scopeParent =& null)\n\u0009\u0009\u0009\u0009\u0009break loop {No more parent scope exists.}\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(scope.name <>& null & scope.name = ptrName)\n\u0009\u0009\u0009\u0009\u0009if(scope.typeId = %func_ & scope.refName <>& null)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%accessMemberWithoutMe, ast.pos, [ptrName])\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009; The compiler also looks at the current scope\'s name.\n\u0009\u0009\u0009\u0009\u0009\u0009do foundAst :: scope\n\u0009\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009var ast2: \\ast@Ast :: scope.scopeChildren.get(ptrName, &)\n\u0009\u0009\u0009\u0009if(ast2 <>& null)\n\u0009\u0009\u0009\u0009\u0009var err: bool :: false\n\u0009\u0009\u0009\u0009\u0009if(overFunc)\n\u0009\u0009\u0009\u0009\u0009\u0009if(ast2.typeId = %arg)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var kind: \\ast@AstArgKind :: (ast2 $ \\ast@AstArg).kind\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(kind = %member | kind = %localVar | kind = %localArg)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do err :: true\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009if(!err & ast2.typeId.and(%statBreakable) = %statBreakable)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do err :: true\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(!err & ast2.typeId = %func_ & ast2.refName <>& null)\n\u0009\u0009\u0009\u0009\u0009\u0009do err :: true\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(err)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%accessMemberWithoutMe, ast.pos, [ptrName])\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do foundAst :: ast2\n\u0009\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(scope.typeId = %func_)\n\u0009\u0009\u0009\u0009\u0009do overFunc :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do scope :: scope.scopeParent\n\u0009\u0009\u0009end while\n\u0009\u0009end if\n\u0009\u0009if(foundAst <>& null)\n\u0009\u0009\u0009if(otherFile & !foundAst.publicInSrc)\n\u0009\u0009\u0009\u0009do \\err@err(%accessUnpublishedElement, ast.pos, [ast.refName])\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.refItem :: foundAst\n\u0009\u0009else\n\u0009\u0009\u0009do \\err@err(%identifierNotFound, ast.pos, [ast.refName])\n\u0009\u0009\u0009do ast.refItem :: null\n\u0009\u0009end if\n\u0009\u0009do scopeRefedItems.next()\n\u0009end while\n\u0009ret true\nend func\n\nfunc rebuild(mainFunc: \\ast@AstFunc): \\ast@AstFunc\n\u0009var entry: \\ast@AstFunc\n\u0009\n\u0009; Build the entry point and register it in the root.\n\u0009block\n\u0009\u0009do entry :: @makeEntryPoint(mainFunc)\n\u0009\u0009do @rebuildFunc(entry)\n\u0009\u0009var root: \\ast@Ast :: @asts.get(\"\\\\\" ~ \\option@inputName, &)\n\u0009\u0009assert root =$ \\ast@AstRoot\n\u0009\u0009do(root $ \\ast@AstRoot).items.add(entry)\n\u0009end block\n\u0009\n\u0009do @asts.forEach(@rebuildRoot, null)\n\u0009\n\u0009ret entry\nend func\n\nfunc makeEntryPoint(mainFunc: \\ast@AstFunc): \\ast@AstFunc\n\u0009var pos: \\pos@Pos :: \\pos@make(\"kuin\", 1, 1)\n\u0009var entry: \\ast@AstFunc :: #\\ast@AstFunc\n\u0009do @initAst(entry, %func_, pos)\n\u0009do entry.name :: \"$\"\n\u0009do entry.funcOption :: %none\n\u0009do entry.funcAttr :: #list<[]char>\n\u0009do entry.args :: #list<\\ast@AstArg>\n\u0009do entry.ret_ :: null\n\u0009do entry.stats :: #list<\\ast@AstStat>\n\u0009block\n\u0009\u0009var try_: \\ast@AstStatTry :: #\\ast@AstStatTry\n\u0009\u0009do @initAst(try_, %statTry, pos)\n\u0009\u0009block\n\u0009\u0009\u0009var var_: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009do @initAst(var_, %arg, pos)\n\u0009\u0009\u0009do var_.name :: \"$\"\n\u0009\u0009\u0009do var_.kind :: %localVar\n\u0009\u0009\u0009do var_.refVar :: false\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, pos)\n\u0009\u0009\u0009\u0009do type.kind :: %int_\n\u0009\u0009\u0009\u0009do var_.type :: type\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do var_.expr :: null\n\u0009\u0009\u0009do try_.blockVar :: var_\n\u0009\u0009end block\n\u0009\u0009block\n\u0009\u0009\u0009var block_: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009\u0009\u0009do @initAst(block_, %statBlock, pos)\n\u0009\u0009\u0009do block_.name :: \"$\"\n\u0009\u0009\u0009do block_.blockVar :: null\n\u0009\u0009\u0009do block_.stats :: #list<\\ast@AstStat>\n\u0009\u0009\u0009do try_.statBlock :: block_\n\u0009\u0009end block\n\u0009\u0009do try_.catches :: #list<\\ast@AstStatCatch>\n\u0009\u0009block\n\u0009\u0009\u0009var block_: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009\u0009\u0009do @initAst(block_, %statBlock, pos)\n\u0009\u0009\u0009do block_.name :: \"$\"\n\u0009\u0009\u0009do block_.blockVar :: null\n\u0009\u0009\u0009do block_.stats :: #list<\\ast@AstStat>\n\u0009\u0009\u0009do try_.finallyStatBlock :: block_\n\u0009\u0009end block\n\u0009\u0009block\n\u0009\u0009\u0009; Make the program to call \'init\' and \'main\'.\n\u0009\u0009\u0009var funcs: list<\\ast@Ast> :: #list<\\ast@Ast>\n\u0009\u0009\u0009do funcs.add(@searchStdItem(\"kuin\", \"_init\", false))\n\u0009\u0009\u0009do funcs.add(@searchStdItem(\"kuin\", \"_initVars\", false))\n\u0009\u0009\u0009do funcs.add(mainFunc)\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009do funcs.head()\n\u0009\u0009\u0009\u0009while(!funcs.term())\n\u0009\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, pos)\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var call: \\ast@AstExprCall :: #\\ast@AstExprCall\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(call, %exprCall, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do call.args :: #list<\\ast@AstExprCallArg>\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref, %exprRef, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ref.refItem :: funcs.get()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do call.func_ :: ref\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do do_.expr :: call\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do try_.statBlock.stats.add(do_)\n\u0009\u0009\u0009\u0009\u0009do funcs.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end block\n\u0009\u0009end block\n\u0009\u0009block\n\u0009\u0009\u0009var catch_: \\ast@AstStatCatch :: #\\ast@AstStatCatch\n\u0009\u0009\u0009do @initAst(catch_, %statCatch, pos)\n\u0009\u0009\u0009do catch_.conds :: #list<\\ast@ExprPair>\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var block_: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009\u0009\u0009\u0009do @initAst(block_, %statBlock, pos)\n\u0009\u0009\u0009\u0009do block_.name :: \"$\"\n\u0009\u0009\u0009\u0009do block_.blockVar :: null\n\u0009\u0009\u0009\u0009do block_.stats :: #list<\\ast@AstStat>\n\u0009\u0009\u0009\u0009do catch_.statBlock :: block_\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: #\\ast@ExprPair\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, pos)\n\u0009\u0009\u0009\u0009\u0009do expr.varKind :: %value\n\u0009\u0009\u0009\u0009\u0009do expr.value :: 0b64\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.kind :: %int_\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do exprs.expr0 :: expr\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, pos)\n\u0009\u0009\u0009\u0009\u0009do expr.varKind :: %value\n\u0009\u0009\u0009\u0009\u0009do expr.value :: 0xFFFFFFFFb64\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.kind :: %int_\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do exprs.expr1 :: expr\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do catch_.conds.add(exprs)\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009; Make the program to call \'err\'.\n\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var call: \\ast@AstExprCall :: #\\ast@AstExprCall\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(call, %exprCall, pos)\n\u0009\u0009\u0009\u0009\u0009do call.args :: #list<\\ast@AstExprCallArg>\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var ref_: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref_, %exprRef, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do ref_.refItem :: @searchStdItem(\"kuin\", \"_err\", false)\n\u0009\u0009\u0009\u0009\u0009\u0009do call.func_ :: ref_\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var excpt: \\ast@AstExprCallArg :: #\\ast@AstExprCallArg\n\u0009\u0009\u0009\u0009\u0009\u0009do excpt.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009do excpt.skipVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var ref_: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref_, %exprRef, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ref_.refItem :: try_.blockVar\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do excpt.arg :: ref_\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do call.args.add(excpt)\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do do_.expr :: call\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do catch_.statBlock.stats.add(do_)\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do try_.catches.add(catch_)\n\u0009\u0009end block\n\u0009\u0009block\n\u0009\u0009\u0009; Make the program to call \'fin\'.\n\u0009\u0009\u0009var funcs: list<\\ast@Ast> :: #list<\\ast@Ast>\n\u0009\u0009\u0009do funcs.add(@searchStdItem(\"kuin\", \"_finVars\", false))\n\u0009\u0009\u0009do funcs.add(@searchStdItem(\"kuin\", \"_fin\", false))\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009do funcs.head()\n\u0009\u0009\u0009\u0009while(!funcs.term())\n\u0009\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, pos)\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var call: \\ast@AstExprCall :: #\\ast@AstExprCall\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(call, %exprCall, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do call.args :: #list<\\ast@AstExprCallArg>\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref, %exprRef, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ref.refItem :: funcs.get()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do call.func_ :: ref\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do do_.expr :: call\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do try_.finallyStatBlock.stats.add(do_)\n\u0009\u0009\u0009\u0009\u0009do funcs.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end block\n\u0009\u0009end block\n\u0009\u0009do entry.stats.add(try_)\n\u0009end block\n\u0009ret entry\nend func\n\nfunc rebuildRoot(key: []char, value: \\ast@Ast, data: kuin@Class): bool\n\u0009var ast: \\ast@AstRoot :: value $ \\ast@AstRoot\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret true\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009; Initialize and finalize global variables of each source file.\n\u0009var initVarsFunc: \\ast@AstFunc :: @searchStdItem(\"kuin\", \"_initVars\", false) $ \\ast@AstFunc\n\u0009var finVarsFunc: \\ast@AstFunc :: @searchStdItem(\"kuin\", \"_finVars\", false) $ \\ast@AstFunc\n\u0009var items: list<\\ast@Ast> :: ast.items\n\u0009do items.head()\n\u0009while(!items.term())\n\u0009\u0009var item: \\ast@Ast :: items.get()\n\u0009\u0009if(item.typeId = %func_)\n\u0009\u0009\u0009do @rebuildFunc(item $ \\ast@AstFunc)\n\u0009\u0009elif(item.typeId = %var_)\n\u0009\u0009\u0009var var_: \\ast@AstVar :: item $ \\ast@AstVar\n\u0009\u0009\u0009assert var_.arg.kind = %global\n\u0009\u0009\u0009if(var_.arg.expr <>& null)\n\u0009\u0009\u0009\u0009; Add initialization processing of global variables to \'_initVars\'.\n\u0009\u0009\u0009\u0009do var_.arg.expr :: @rebuildExpr(var_.arg.expr, false)\n\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var assign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(assign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do assign.kind :: %assign\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do ref.type :: var_.arg.type\n\u0009\u0009\u0009\u0009\u0009\u0009do ref.refItem :: var_.arg\n\u0009\u0009\u0009\u0009\u0009\u0009do assign.children0 :: ref\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do assign.children1 :: var_.arg.expr\n\u0009\u0009\u0009\u0009\u0009do do_.expr :: assign\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do initVarsFunc.stats.add(@rebuildStat(do_, null, null))\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(var_.arg.type <>& null & \\ast@isRef(var_.arg.type))\n\u0009\u0009\u0009\u0009; Add finalization processing of global variables to \'_finVars\'.\n\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var assign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(assign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do assign.kind :: %assign\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do ref.type :: var_.arg.type\n\u0009\u0009\u0009\u0009\u0009\u0009do ref.refItem :: var_.arg\n\u0009\u0009\u0009\u0009\u0009\u0009do assign.children0 :: ref\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do assign.children1 :: @makeExprNull(ast.pos)\n\u0009\u0009\u0009\u0009\u0009do do_.expr :: assign\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do finVarsFunc.stats.add(@rebuildStat(do_, null, null))\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009assert item.typeId = %const_ | item.typeId = %alias_ | item.typeId = %class_ | item.typeId = %enum_\n\u0009\u0009end if\n\u0009\u0009do items.next()\n\u0009end while\n\u0009ret true\nend func\n\nfunc rebuildFunc(ast: \\ast@AstFunc)\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009var items: list<\\ast@AstArg> :: ast.args\n\u0009do items.head()\n\u0009while(!items.term())\n\u0009\u0009do @rebuildArg(items.get())\n\u0009\u0009do items.next()\n\u0009end while\n\u0009\n\u0009if(ast.ret_ <>& null)\n\u0009\u0009do ast.ret_ :: @rebuildType(ast.ret_, null)\n\u0009end if\n\u0009do ast.stats :: @refreshStats(ast.stats, ast.ret_, ast)\nend func\n\nfunc rebuildVar(ast: \\ast@AstVar)\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do @rebuildArg(ast.arg)\nend func\n\nfunc rebuildAlias(ast: \\ast@AstAlias, parent: \\ast@AstAlias)\n\u0009; Make sure that the enum references do not circulate.\n\u0009if(ast = parent)\n\u0009\u0009do \\err@err(%circulatingAlias, parent.pos, [parent.name])\n\u0009\u0009do ast.type :: null\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.type :: @rebuildType(ast.type, ast)\nend func\n\nfunc rebuildClass(ast: \\ast@AstClass)\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009var dtor: \\ast@AstFunc :: null\n\u0009var copy: \\ast@AstFunc :: null\n\u0009var toBin: \\ast@AstFunc :: null\n\u0009var fromBin: \\ast@AstFunc :: null\n\u0009do process1(ast, &dtor, &copy, &toBin, &fromBin)\n\u0009do process2(ast, dtor, copy, toBin, fromBin)\n\u0009do @rebuildFunc(dtor)\n\u0009do @rebuildFunc(copy)\n\u0009do @rebuildFunc(toBin)\n\u0009do @rebuildFunc(fromBin)\n\u0009\n\u0009func process1(ast: \\ast@AstClass, dtor: &\\ast@AstFunc, copy: &\\ast@AstFunc, toBin: &\\ast@AstFunc, fromBin: &\\ast@AstFunc)\n\u0009\u0009if(ast.refItem <>& null)\n\u0009\u0009\u0009var parent: \\ast@Ast :: ast.refItem\n\u0009\u0009\u0009if(parent.typeId = %alias_)\n\u0009\u0009\u0009\u0009do @rebuildAlias(parent $ \\ast@AstAlias, null)\n\u0009\u0009\u0009\u0009do ast.refItem :: (parent $ \\ast@AstAlias).type.refItem\n\u0009\u0009\u0009\u0009assert ast.refItem.typeId = %class_\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009assert parent.typeId = %class_\n\u0009\u0009\u0009\u0009do @rebuildClass(parent $ \\ast@AstClass)\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009block\n\u0009\u0009\u0009; Make sure that the class references do not circulate.\n\u0009\u0009\u0009var parent: \\ast@AstClass :: ast\n\u0009\u0009\u0009var chk: dict<\\ast@AstClass, bool> :: #dict<\\ast@AstClass, bool>\n\u0009\u0009\u0009while(parent <>& null)\n\u0009\u0009\u0009\u0009if(chk.get(parent, &))\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%circulatingClass, ast.pos, [ast.name])\n\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do chk.add(parent, true)\n\u0009\u0009\u0009\u0009do parent :: parent.refItem $ \\ast@AstClass\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009\n\u0009\u0009block\n\u0009\u0009\u0009var astItems: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009\u0009do astItems.head()\n\u0009\u0009\u0009while(!astItems.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: astItems.get()\n\u0009\u0009\u0009\u0009var memberName: []char\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var def: \\ast@Ast :: item.def\n\u0009\u0009\u0009\u0009\u0009if(def.typeId = %var_)\n\u0009\u0009\u0009\u0009\u0009\u0009do memberName :: (def $ \\ast@AstVar).arg.name\n\u0009\u0009\u0009\u0009\u0009elif(def.typeId = %const_)\n\u0009\u0009\u0009\u0009\u0009\u0009do memberName :: (def $ \\ast@AstConst).arg.name\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do memberName :: def.name\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009; Check whether functions are overriding another.\n\u0009\u0009\u0009\u0009var parentItem: \\ast@AstClassItem :: null\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var parent: \\ast@AstClass :: ast.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009\u0009while(parentItem =& null & parent <>& null)\n\u0009\u0009\u0009\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: parent.items\n\u0009\u0009\u0009\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var parentName: []char\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var item2: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var def: \\ast@Ast :: item2.def\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(def.typeId = %var_)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do parentName :: (def $ \\ast@AstVar).arg.name\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009elif(def.typeId = %const_)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do parentName :: (def $ \\ast@AstConst).arg.name\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do parentName :: def.name\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(memberName = parentName)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do parentItem :: item2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009\u0009do parent :: parent.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009if(parentItem =& null)\n\u0009\u0009\u0009\u0009\u0009if(item.override)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%overridedMemberNotFound, item.def.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009if(!item.override)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%memberDuplicatedWithParentClass, item.def.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(!(item.def.typeId = %func_ & parentItem.def.typeId = %func_))\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%overridingNonFunc, item.def.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(item.public <> parentItem.public)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%overriddenMemberNotMatchAccessModifier, item.def.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009var func1: \\ast@AstFunc :: item.def $ \\ast@AstFunc\n\u0009\u0009\u0009\u0009\u0009var func2: \\ast@AstFunc :: parentItem.def $ \\ast@AstFunc\n\u0009\u0009\u0009\u0009\u0009if(func1.ret_ =& null & func2.ret_ <>& null |\n\u0009\u0009\u0009\u0009\u0009\u0009|func1.ret_ <>& null & func2.ret_ =& null |\n\u0009\u0009\u0009\u0009\u0009\u0009|func1.ret_ <>& null & func2.ret_ <>& null & !@cmpType(func1.ret_, func2.ret_, false) |\n\u0009\u0009\u0009\u0009\u0009\u0009|^func1.args <> ^func2.args)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%overriddenMemberNotMatchTypeOrArg, item.def.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009var items1: list<\\ast@AstArg> :: func1.args\n\u0009\u0009\u0009\u0009\u0009var items2: list<\\ast@AstArg> :: func2.args\n\u0009\u0009\u0009\u0009\u0009do items1.head()\n\u0009\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009\u0009for i(0, ^items1 - 1)\n\u0009\u0009\u0009\u0009\u0009\u0009var arg1: \\ast@AstArg :: items1.get()\n\u0009\u0009\u0009\u0009\u0009\u0009var arg2: \\ast@AstArg :: items2.get()\n\u0009\u0009\u0009\u0009\u0009\u0009if(arg1.type.typeId = %typeUser & arg1.type.refItem =& null |\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009|arg2.type.typeId = %typeUser & arg2.type.refItem =& null |\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009|!@cmpType(arg1.type, arg2.type, false) |\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009|arg1.name <>& null & arg2.name <>& null & arg1.name <> arg2.name |\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009|arg1.refVar <> arg2.refVar)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%overriddenMemberNotMatchTypeOrArg, item.def.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do items1.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009\u0009end for\n\u0009\u0009\u0009\u0009\u0009do item.parentItem :: parentItem\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009switch(memberName)\n\u0009\u0009\u0009\u0009case \"_dtor\", \"_copy\", \"_toBin\", \"_fromBin\"\n\u0009\u0009\u0009\u0009\u0009assert item.def.typeId = %func_\n\u0009\u0009\u0009\u0009\u0009var func_: \\ast@AstFunc :: item.def $ \\ast@AstFunc\n\u0009\u0009\u0009\u0009\u0009if(item.override & (item.def $ \\ast@AstFunc).funcOption.and(%frc) = %none)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%notAllowedToBeOverridden, func_.pos, [memberName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009switch(memberName[1])\n\u0009\u0009\u0009\u0009\u0009case \'d\'\n\u0009\u0009\u0009\u0009\u0009\u0009do dtor :: func_\n\u0009\u0009\u0009\u0009\u0009case \'c\'\n\u0009\u0009\u0009\u0009\u0009\u0009do copy :: func_\n\u0009\u0009\u0009\u0009\u0009case \'t\'\n\u0009\u0009\u0009\u0009\u0009\u0009do toBin :: func_\n\u0009\u0009\u0009\u0009\u0009case \'f\'\n\u0009\u0009\u0009\u0009\u0009\u0009do fromBin :: func_\n\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009; Skip \'RebuildFunc\' to add the contents later.\n\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009; Analyze functions and variables in classes because they can be referred to as instances.\n\u0009\u0009\u0009\u0009\u0009var def: \\ast@Ast :: item.def\n\u0009\u0009\u0009\u0009\u0009if(def.typeId = %func_)\n\u0009\u0009\u0009\u0009\u0009\u0009var idx: int :: astItems.idx()\n\u0009\u0009\u0009\u0009\u0009\u0009assert idx <> -1\n\u0009\u0009\u0009\u0009\u0009\u0009do @rebuildFunc(def $ \\ast@AstFunc)\n\u0009\u0009\u0009\u0009\u0009\u0009do astItems.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do astItems.moveOffset(idx)\n\u0009\u0009\u0009\u0009\u0009elif(def.typeId = %var_)\n\u0009\u0009\u0009\u0009\u0009\u0009do @rebuildVar(def $ \\ast@AstVar)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009do astItems.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009\n\u0009\u0009\u0009; Get \'me\' of special functions.\n\u0009\u0009\u0009if(dtor =& null)\n\u0009\u0009\u0009\u0009do dtor :: @addSpecialFunc(ast, \"_dtor\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(copy =& null)\n\u0009\u0009\u0009\u0009do copy :: @addSpecialFunc(ast, \"_copy\")\n\u0009\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009\u0009do @initAst(type, %typeUser, ast.pos)\n\u0009\u0009\u0009\u0009do type.refItem :: ast\n\u0009\u0009\u0009\u0009do copy.ret_ :: type\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(toBin =& null)\n\u0009\u0009\u0009\u0009do toBin :: @addSpecialFunc(ast, \"_toBin\")\n\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var type2: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009\u0009\u0009\u0009do @initAst(type2, %typeBit, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do type2.size :: 1\n\u0009\u0009\u0009\u0009\u0009do type.itemType :: type2\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do toBin.ret_ :: type\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(fromBin =& null)\n\u0009\u0009\u0009\u0009do fromBin :: @addSpecialFunc(ast, \"_fromBin\")\n\u0009\u0009\u0009\u0009; \'bin\'.\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009\u0009\u0009do @initAst(arg, %arg, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do arg.kind :: %localArg\n\u0009\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009\u0009do arg.expr :: null\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var type2: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type2, %typeBit, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type2.size :: 1\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type.itemType :: type2\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do fromBin.args.add(arg)\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009; \'idx\'.\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009\u0009\u0009do @initAst(arg, %arg, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do arg.kind :: %localArg\n\u0009\u0009\u0009\u0009\u0009do arg.refVar :: true\n\u0009\u0009\u0009\u0009\u0009do arg.expr :: null\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.kind :: %int_\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do fromBin.args.add(arg)\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do fromBin.args.head()\n\u0009\u0009\u0009\u0009do fromBin.ret_ :: fromBin.args.get().type\n\u0009\u0009\u0009end if\n\u0009\u0009end block\n\u0009end func\n\u0009\n\u0009func process2(ast: \\ast@AstClass, dtor: \\ast@AstFunc, copy: \\ast@AstFunc, toBin: \\ast@AstFunc, fromBin: \\ast@AstFunc)\n\u0009\u0009; The \'_dtor\' function.\n\u0009\u0009block\n\u0009\u0009\u0009var ptr: \\ast@AstClass :: ast\n\u0009\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: ptr.items\n\u0009\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009\u0009if(item.def.typeId = %var_ & \\ast@isRef((item.def $ \\ast@AstVar).arg.type))\n\u0009\u0009\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var assign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(assign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.kind :: %assign\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dtor.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children0 :: @makeMeDot(ast, dtor.args.get(), (item.def $ \\ast@AstVar).arg.name)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children1 :: @makeExprNull(ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do do_.expr :: assign\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do dtor.stats.add(@rebuildStat(do_, dtor.ret_, dtor))\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009\n\u0009\u0009; The \'_copy\' function.\n\u0009\u0009block\n\u0009\u0009\u0009var result: \\ast@AstExpr\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var var_: \\ast@AstStatVar :: #\\ast@AstStatVar\n\u0009\u0009\u0009\u0009do @initAst(var_, %statVar, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var var2: \\ast@AstVar :: #\\ast@AstVar\n\u0009\u0009\u0009\u0009\u0009do @initAst(var2, %var_, ast.pos)\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(arg, %arg, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.kind :: %localVar\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeUser, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type.refItem :: ast\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.type :: type\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var new_: \\ast@AstExprNew :: #\\ast@AstExprNew\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(new_, %exprNew, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do new_.itemType :: arg.type\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.expr :: new_\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do var2.arg :: arg\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do var_.def :: var2\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do copy.stats.add(@rebuildStat(var_, copy.ret_, copy))\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009do result :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(result, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do result.refName :: \"me\"\n\u0009\u0009\u0009\u0009\u0009do result.refItem :: var_.def.arg\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeUser, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.refItem :: ast\n\u0009\u0009\u0009\u0009\u0009\u0009do result.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var ptr: \\ast@AstClass :: ast\n\u0009\u0009\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: ptr.items\n\u0009\u0009\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009\u0009\u0009if(item.def.typeId = %var_)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var member: \\ast@AstArg :: (item.def $ \\ast@AstVar).arg\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var assign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(assign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.kind :: %assign\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var dot: \\ast@AstExprDot :: #\\ast@AstExprDot\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(dot, %exprDot, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.var_ :: result\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.member :: member.name\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.classItem :: null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children0 :: dot\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(\\ast@isRef(member.type))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var copy2: \\ast@AstExpr1 :: #\\ast@AstExpr1\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(copy2, %expr1, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do copy2.kind :: %copy\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do copy.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do copy2.child :: @makeMeDot(ast, copy.args.get(), member.name)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children1 :: copy2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do copy.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children1 :: @makeMeDot(ast, copy.args.get(), member.name)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do do_.expr :: assign\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do copy.stats.add(@rebuildStat(do_, copy.ret_, copy))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var ret_: \\ast@AstStatRet :: #\\ast@AstStatRet\n\u0009\u0009\u0009\u0009do @initAst(ret_, %statRet, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var as: \\ast@AstExprAs :: #\\ast@AstExprAs\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(as, %exprAs, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do as.kind :: %as\n\u0009\u0009\u0009\u0009\u0009do as.child :: result\n\u0009\u0009\u0009\u0009\u0009do as.childType :: copy.ret_\n\u0009\u0009\u0009\u0009\u0009do ret_.value :: as\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do copy.stats.add(@rebuildStat(ret_, copy.ret_, copy))\n\u0009\u0009\u0009end block\n\u0009\u0009end block\n\u0009\u0009\n\u0009\u0009; The \'_toBin\' function.\n\u0009\u0009block\n\u0009\u0009\u0009var result: \\ast@AstExpr\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var var_: \\ast@AstStatVar :: #\\ast@AstStatVar\n\u0009\u0009\u0009\u0009do @initAst(var_, %statVar, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var var2: \\ast@AstVar :: #\\ast@AstVar\n\u0009\u0009\u0009\u0009\u0009do @initAst(var2, %var_, ast.pos)\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(arg, %arg, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.kind :: %localVar\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var new_: \\ast@AstExprNewArray :: #\\ast@AstExprNewArray\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(new_, %exprNewArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do new_.idces :: #list<\\ast@AstExpr>\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var value: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(value, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value.value :: 8b64\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var prim: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(prim, %typePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do prim.kind :: %int_\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value.type :: prim\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do new_.idces.add(value)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeBit, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type.size :: 1\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do new_.itemType :: type\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.expr :: new_\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var type2: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type2, %typeBit, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type2.size :: 1\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type.itemType :: type2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.type :: type\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do var2.arg :: arg\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do var_.def :: var2\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do toBin.stats.add(@rebuildStat(var_, toBin.ret_, toBin))\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009do result :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(result, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do result.refItem :: var_.def.arg\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeUser, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.refItem :: ast\n\u0009\u0009\u0009\u0009\u0009\u0009do result.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var ptr: \\ast@AstClass :: ast\n\u0009\u0009\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: ptr.items\n\u0009\u0009\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009\u0009\u0009if(item.def.typeId = %var_)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var member: \\ast@AstArg :: (item.def $ \\ast@AstVar).arg\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var assign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(assign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.kind :: %assignCat\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children0 :: result\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprToBin :: #\\ast@AstExprToBin\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprToBin, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do toBin.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.child :: @makeMeDot(ast, toBin.args.get(), member.name)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var array_: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(array_, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var bit: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(bit, %typeBit, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do bit.size :: 1\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do array_.itemType :: bit\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.childType :: array_\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children1 :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do do_.expr :: assign\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do toBin.stats.add(@rebuildStat(do_, toBin.ret_, toBin))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var ret_: \\ast@AstStatRet :: #\\ast@AstStatRet\n\u0009\u0009\u0009\u0009do @initAst(ret_, %statRet, ast.pos)\n\u0009\u0009\u0009\u0009do ret_.value :: result\n\u0009\u0009\u0009\u0009do toBin.stats.add(@rebuildStat(ret_, toBin.ret_, toBin))\n\u0009\u0009\u0009end block\n\u0009\u0009end block\n\u0009\u0009\n\u0009\u0009; The \'_fromBin\' function.\n\u0009\u0009block\n\u0009\u0009\u0009var result: \\ast@AstExpr\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var var_: \\ast@AstStatVar :: #\\ast@AstStatVar\n\u0009\u0009\u0009\u0009do @initAst(var_, %statVar, ast.pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var var2: \\ast@AstVar :: #\\ast@AstVar\n\u0009\u0009\u0009\u0009\u0009do @initAst(var2, %var_, ast.pos)\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(arg, %arg, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.kind :: %localVar\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.type :: fromBin.args.get().type\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var new_: \\ast@AstExprNew :: #\\ast@AstExprNew\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(new_, %exprNew, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do new_.itemType :: arg.type\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.expr :: new_\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do var2.arg :: arg\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do var_.def :: var2\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do fromBin.stats.add(@rebuildStat(var_, fromBin.ret_, fromBin))\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009do result :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(result, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do result.refItem :: var_.def.arg\n\u0009\u0009\u0009\u0009\u0009do result.refName :: \"me\" {In fact, the referenced member name is not \'me\', but it needs to be set to \'me\' to access private members.}\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeUser, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.refItem :: ast\n\u0009\u0009\u0009\u0009\u0009\u0009do result.type :: type\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var ptr: \\ast@AstClass :: ast\n\u0009\u0009\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: ptr.items\n\u0009\u0009\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009\u0009\u0009if(item.def.typeId = %var_)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var member: \\ast@AstArg :: (item.def $ \\ast@AstVar).arg\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(do_, %statDo, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var assign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(assign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.kind :: %assign\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var dot: \\ast@AstExprDot :: #\\ast@AstExprDot\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(dot, %exprDot, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.classItem :: null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.var_ :: result\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.member :: member.name\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children0 :: dot\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprFromBin :: #\\ast@AstExprFromBin\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprFromBin, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ref.refItem :: fromBin.args.get()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert ref.refItem <>& null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.child :: ref\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.childType :: member.type\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ref, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ref.refItem :: fromBin.args.get()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert ref.refItem <>& null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.offset :: ref\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do assign.children1 :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do do_.expr :: assign\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do fromBin.stats.add(@rebuildStat(do_, fromBin.ret_, fromBin))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var ret_: \\ast@AstStatRet :: #\\ast@AstStatRet\n\u0009\u0009\u0009\u0009do @initAst(ret_, %statRet, ast.pos)\n\u0009\u0009\u0009\u0009do ret_.value :: result\n\u0009\u0009\u0009\u0009do fromBin.stats.add(@rebuildStat(ret_, fromBin.ret_, fromBin))\n\u0009\u0009\u0009end block\n\u0009\u0009end block\n\u0009end func\nend func\n\nfunc rebuildEnum(ast: \\ast@AstEnum)\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009do @initAst(type, %typeUser, ast.pos)\n\u0009do type.extra :: type\n\u0009do type.refItem :: ast\n\u0009\n\u0009; Assign values to items.\n\u0009var defaultNum: int :: -1\n\u0009var enumValues: dict<int, bool> :: #dict<int, bool>\n\u0009var items: list<\\ast@AstExpr> :: ast.items\n\u0009do items.head()\n\u0009while loop(!items.term())\n\u0009\u0009var item: \\ast@AstExpr :: items.get()\n\u0009\u0009var itemName: []char :: item.name\n\u0009\u0009do item :: @rebuildExpr(item, item.type =& null)\n\u0009\u0009if(item =& null)\n\u0009\u0009\u0009skip loop\n\u0009\u0009end if\n\u0009\u0009do item.name :: itemName\n\u0009\u0009do items.ins(item)\n\u0009\u0009do items.del()\n\u0009\u0009if(item.typeId <> %exprValuePrim | item.type <>& null & !\\ast@isInt(item.type))\n\u0009\u0009\u0009do \\err@err(%enumValueMustBeInt, ast.pos, [ast.name, item.name])\n\u0009\u0009\u0009ret\n\u0009\u0009end if\n\u0009\u0009var item2: \\ast@AstExprValuePrim :: item $ \\ast@AstExprValuePrim\n\u0009\u0009if(item.type =& null)\n\u0009\u0009\u0009; \'type\' is \'null\' when the value is not set.\n\u0009\u0009\u0009if(defaultNum = lib@intMax)\n\u0009\u0009\u0009\u0009do \\err@err(%enumValueExceedIntRange, ast.pos, [ast.name, item.name])\n\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do defaultNum :+ 1\n\u0009\u0009\u0009do item2.value :: defaultNum $ bit64\n\u0009\u0009else\n\u0009\u0009\u0009do defaultNum :: item2.value $ int\n\u0009\u0009end if\n\u0009\u0009block\n\u0009\u0009\u0009var value: int :: item2.value $ int\n\u0009\u0009\u0009if(enumValues.get(value, &))\n\u0009\u0009\u0009\u0009do \\err@err(%enumValueDuplicated, ast.pos, [ast.name, item.name, value.toStr()])\n\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do enumValues.add(value, true)\n\u0009\u0009end block\n\u0009\u0009do item.type :: type {Cast values of \'int\' to \'enum\' so as not to being treated as \'int\'.}\n\u0009\u0009; The item was already deleted so do not do \'do items.next()\'.\n\u0009end while\nend func\n\nfunc rebuildEnumElement(enumElement: \\ast@AstExpr, type: \\ast@AstType): \\ast@AstExprValuePrim\n\u0009assert enumElement.typeId = %exprValueEnumElement\n\u0009assert \\ast@isEnum(type)\n\u0009var enumElement2: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009do @initAstExpr(enumElement2, %exprValuePrim, enumElement.pos)\n\u0009do enumElement2.value :: @searchEnumElementValue(enumElement $ \\ast@AstExprValueEnumElement, type.refItem $ \\ast@AstEnum)\n\u0009do enumElement2.type :: type\n\u0009do enumElement2 :: @rebuildExprValuePrim(enumElement2) $ \\ast@AstExprValuePrim\n\u0009ret enumElement2\nend func\n\nfunc rebuildArg(ast: \\ast@AstArg)\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.type :: @rebuildType(ast.type, null)\n\u0009if(ast.expr <>& null)\n\u0009\u0009do ast.expr :: @rebuildExpr(ast.expr, false)\n\u0009\u0009if(ast.expr =& null)\n\u0009\u0009\u0009ret\n\u0009\u0009end if\n\u0009\u0009if(ast.kind = %global & ast.expr.typeId.and(%exprValue) <> %exprValue)\n\u0009\u0009\u0009do \\err@err(%valueOfGlobalVarMustBeConst, ast.pos, [ast.name])\n\u0009\u0009end if\n\u0009\u0009if(ast.kind = %const_ & ast.expr.typeId.and(%exprValue) <> %exprValue)\n\u0009\u0009\u0009do \\err@err(%valueOfConstMustBeConst, ast.pos, [ast.name])\n\u0009\u0009end if\n\u0009\u0009if(!@cmpType(ast.expr.type, ast.type, false))\n\u0009\u0009\u0009do \\err@err(%varAndValueTypeNotMatch, ast.pos, [ast.name])\n\u0009\u0009elif(ast.expr.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009do ast.expr :: @rebuildEnumElement(ast.expr, ast.type)\n\u0009\u0009end if\n\u0009end if\nend func\n\nfunc rebuildStat(ast: \\ast@AstStat, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009switch(ast.typeId)\n\u0009case %statFunc, %statConst, %statAlias, %statClass, %statEnum\n\u0009\u0009ret null\n\u0009case %statVar\n\u0009\u0009var ast2: \\ast@AstStatVar :: ast $ \\ast@AstStatVar\n\u0009\u0009do @rebuildVar(ast2.def)\n\u0009\u0009var arg: \\ast@AstArg :: ast2.def.arg\n\u0009\u0009if(arg.name <>& null & arg.name = \"super\")\n\u0009\u0009\u0009assert parentFunc <>& null & parentFunc.name <>& null\n\u0009\u0009\u0009assert arg.type.typeId = %typeFunc\n\u0009\u0009\u0009var args: list<\\ast@AstTypeFuncArg> :: (arg.type $ \\ast@AstTypeFunc).args\n\u0009\u0009\u0009do args.head()\n\u0009\u0009\u0009var refClass: \\ast@AstClass :: args.get().arg.refItem $ \\ast@AstClass\n\u0009\u0009\u0009assert refClass.typeId = %class_\n\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: refClass.items\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while loop(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009if(item.def.name <>& null & item.def.name = parentFunc.name)\n\u0009\u0009\u0009\u0009\u0009assert item.override\n\u0009\u0009\u0009\u0009\u0009var astRef: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(astRef, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do astRef.refItem :: item.parentItem.def\n\u0009\u0009\u0009\u0009\u0009do arg.expr :: astRef\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009assert !items.term()\n\u0009\u0009end if\n\u0009\u0009if(arg.expr =& null)\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009block\n\u0009\u0009\u0009; Replace initializers with assignment operators.\n\u0009\u0009\u0009var astDo: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009\u0009do @initAst(astDo, %statDo, ast.pos)\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var astAssign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009do @initAstExpr(astAssign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009do astAssign.kind :: %assign\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var astRef: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(astRef, %exprRef, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do astRef.refItem :: arg\n\u0009\u0009\u0009\u0009\u0009do astAssign.children0 :: astRef\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do astAssign.children1 :: arg.expr\n\u0009\u0009\u0009\u0009do astDo.expr :: astAssign\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do arg.expr :: null\n\u0009\u0009\u0009do ast :: @rebuildStat(astDo, retType, parentFunc)\n\u0009\u0009end block\n\u0009case %statIf\n\u0009\u0009do ast :: @rebuildIf(ast $ \\ast@AstStatIf, retType, parentFunc)\n\u0009case %statSwitch\n\u0009\u0009do ast :: @rebuildSwitch(ast $ \\ast@AstStatSwitch, retType, parentFunc)\n\u0009case %statWhile\n\u0009\u0009do ast :: @rebuildWhile(ast $ \\ast@AstStatWhile, retType, parentFunc)\n\u0009case %statFor\n\u0009\u0009do ast :: @rebuildFor(ast $ \\ast@AstStatFor, retType, parentFunc)\n\u0009case %statTry\n\u0009\u0009do ast :: @rebuildTry(ast $ \\ast@AstStatTry, retType, parentFunc)\n\u0009case %statThrow\n\u0009\u0009do ast :: @rebuildThrow(ast $ \\ast@AstStatThrow)\n\u0009case %statBlock\n\u0009\u0009do ast :: @rebuildBlock(ast $ \\ast@AstStatBlock, retType, parentFunc)\n\u0009case %statRet\n\u0009\u0009do ast :: @rebuildRet(ast $ \\ast@AstStatRet, retType)\n\u0009case %statDo\n\u0009\u0009do ast :: @rebuildDo(ast $ \\ast@AstStatDo)\n\u0009case %statBreak\n\u0009\u0009do ast :: @rebuildBreak(ast $ \\ast@AstStat, retType, parentFunc)\n\u0009case %statSkip\n\u0009\u0009do ast :: @rebuildSkip(ast $ \\ast@AstStat, retType, parentFunc)\n\u0009case %statAssert\n\u0009\u0009do ast :: @rebuildAssert(ast $ \\ast@AstStatAssert)\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\n\u0009if(ast =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009assert ast.extra <>& null\n\u0009ret ast\nend func\n\nfunc rebuildIf(ast: \\ast@AstStatIf, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.cond :: @rebuildExpr(ast.cond, false)\n\u0009if(ast.cond <>& null & !\\ast@isBool(ast.cond.type))\n\u0009\u0009do \\err@err(%ifCondMustBeBool, ast.cond.pos, null)\n\u0009end if\n\u0009do ast.statBlock :: @rebuildBlock(ast.statBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009block\n\u0009\u0009var items: list<\\ast@AstStatElIf> :: ast.elIfs\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var elIf: \\ast@AstStatElIf :: items.get()\n\u0009\u0009\u0009do elIf.cond :: @rebuildExpr(elIf.cond, false)\n\u0009\u0009\u0009if(elIf.cond <>& null & !\\ast@isBool(elIf.cond.type))\n\u0009\u0009\u0009\u0009do \\err@err(%elIfCondMustBeBool, elIf.cond.pos, null)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do elIf.statBlock :: @rebuildBlock(elIf.statBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009if(ast.elseStatBlock <>& null)\n\u0009\u0009do ast.elseStatBlock :: @rebuildBlock(ast.elseStatBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009end if\n\u0009if(ast.cond <>& null)\n\u0009\u0009; Optimize the code.\n\u0009\u0009var stats: \\ast@AstStatBlock :: null\n\u0009\u0009if(ast.cond.typeId <> %exprValuePrim)\n\u0009\u0009\u0009ret ast\n\u0009\u0009end if\n\u0009\u0009if((ast.cond $ \\ast@AstExprValuePrim).value <> 0b64)\n\u0009\u0009\u0009do stats :: ast.statBlock\n\u0009\u0009end if\n\u0009\u0009if(stats <>& null)\n\u0009\u0009\u0009var items: list<\\ast@AstStatElIf> :: ast.elIfs\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while loop(!items.term())\n\u0009\u0009\u0009\u0009var elIf: \\ast@AstStatElIf :: items.get()\n\u0009\u0009\u0009\u0009if(elIf.cond.typeId <> %exprValuePrim)\n\u0009\u0009\u0009\u0009\u0009ret ast\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if((elIf.cond $ \\ast@AstExprValuePrim).value <> 0b64)\n\u0009\u0009\u0009\u0009\u0009do stats :: elIf.statBlock\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009if(stats =& null)\n\u0009\u0009\u0009\u0009if(ast.elseStatBlock =& null)\n\u0009\u0009\u0009\u0009\u0009var block_: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009\u0009\u0009\u0009\u0009do @initAst(block_, %statBlock, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do block_.name :: \"$\"\n\u0009\u0009\u0009\u0009\u0009do block_.stats :: #list<\\ast@AstStat>\n\u0009\u0009\u0009\u0009\u0009do stats :: block_\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do stats :: ast.elseStatBlock\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009do ast.cond :: null\n\u0009\u0009do ast.statBlock :: stats\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildSwitch(ast: \\ast@AstStatSwitch, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.cond :: @rebuildExpr(ast.cond, false)\n\u0009if(ast.cond <>& null)\n\u0009\u0009if(!@isComparable(ast.cond.type, true))\n\u0009\u0009\u0009do \\err@err(%switchCondMustBeComparable, ast.cond.pos, null)\n\u0009\u0009end if\n\u0009\u0009do ast.blockVar.type :: ast.cond.type\n\u0009end if\n\u0009block\n\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var case_: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: case_.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009do exprs.expr0 :: @rebuildExpr(exprs.expr0, false)\n\u0009\u0009\u0009\u0009if(ast.cond <>& null & exprs.expr0 <>& null)\n\u0009\u0009\u0009\u0009\u0009if(!@cmpType(ast.cond.type, exprs.expr0.type, false))\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%caseCondNotMatchSwitch, exprs.expr0.pos, null)\n\u0009\u0009\u0009\u0009\u0009elif(exprs.expr0.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009do exprs.expr0 :: @rebuildEnumElement(exprs.expr0, ast.cond.type)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(exprs.expr1 <>& null)\n\u0009\u0009\u0009\u0009\u0009do exprs.expr1 :: @rebuildExpr(exprs.expr1, false)\n\u0009\u0009\u0009\u0009\u0009if(ast.cond <>& null & exprs.expr1 <>& null)\n\u0009\u0009\u0009\u0009\u0009\u0009if(!@cmpType(ast.cond.type, exprs.expr1.type, false))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%caseCondNotMatchSwitch, exprs.expr1.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009elif(exprs.expr1.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do exprs.expr1 :: @rebuildEnumElement(exprs.expr1, ast.cond.type)\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do case_.statBlock :: @rebuildBlock(case_.statBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009if(ast.defaultStatBlock <>& null)\n\u0009\u0009do ast.defaultStatBlock :: @rebuildBlock(ast.defaultStatBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildWhile(ast: \\ast@AstStatWhile, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009if(ast.cond <>& null)\n\u0009\u0009do ast.cond :: @rebuildExpr(ast.cond, false)\n\u0009\u0009if(ast.cond <>& null & !\\ast@isBool(ast.cond.type))\n\u0009\u0009\u0009do \\err@err(%whileCondMustBeBool, ast.cond.pos, null)\n\u0009\u0009end if\n\u0009end if\n\u0009do ast.stats :: @refreshStats(ast.stats, retType, parentFunc)\n\u0009ret ast\nend func\n\nfunc rebuildFor(ast: \\ast@AstStatFor, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.start :: @rebuildExpr(ast.start, false)\n\u0009if(ast.start <>& null)\n\u0009\u0009if(!\\ast@isInt(ast.start.type))\n\u0009\u0009\u0009do \\err@err(%forBeginValueMustBeInt, ast.start.pos, null)\n\u0009\u0009end if\n\u0009\u0009do ast.blockVar.type :: ast.start.type\n\u0009end if\n\u0009do ast.cond :: @rebuildExpr(ast.cond, false)\n\u0009if(ast.cond <>& null & !\\ast@isInt(ast.cond.type))\n\u0009\u0009do \\err@err(%forEndValueMustBeInt, ast.cond.pos, null)\n\u0009end if\n\u0009do ast.step :: @rebuildExpr(ast.step, false)\n\u0009if(ast.step <>& null)\n\u0009\u0009if(!\\ast@isInt(ast.step.type))\n\u0009\u0009\u0009do \\err@err(%forIncreaseDecreaseValueMustBeInt, ast.step.pos, null)\n\u0009\u0009end if\n\u0009\u0009if(ast.step.typeId <> %exprValuePrim)\n\u0009\u0009\u0009do \\err@err(%forIncreaseDecreaseValueMustBeConst, ast.step.pos, null)\n\u0009\u0009end if\n\u0009\u0009if((ast.step $ \\ast@AstExprValuePrim).value = 0b64)\n\u0009\u0009\u0009do \\err@err(%forIncreaseDecreaseValueMustBeOtherThanZero, ast.step.pos, null)\n\u0009\u0009end if\n\u0009end if\n\u0009do ast.stats :: @refreshStats(ast.stats, retType, parentFunc)\n\u0009ret ast\nend func\n\nfunc rebuildTry(ast: \\ast@AstStatTry, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do @rebuildArg(ast.blockVar)\n\u0009do ast.statBlock :: @rebuildBlock(ast.statBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009if(^ast.catches <> 0)\n\u0009\u0009var items: list<\\ast@AstStatCatch> :: ast.catches\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var catch_: \\ast@AstStatCatch :: items.get()\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: catch_.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009do exprs.expr0 :: @rebuildExpr(exprs.expr0, false)\n\u0009\u0009\u0009\u0009if(exprs.expr0 <>& null & (!\\ast@isInt(exprs.expr0.type) | exprs.expr0.typeId <> %exprValuePrim))\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%catchCondMustBeConstInt, exprs.expr0.pos, null)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(exprs.expr1 <>& null)\n\u0009\u0009\u0009\u0009\u0009do exprs.expr1 :: @rebuildExpr(exprs.expr1, false)\n\u0009\u0009\u0009\u0009\u0009if(exprs.expr1 <>& null & (!\\ast@isInt(exprs.expr1.type) | exprs.expr1.typeId <> %exprValuePrim))\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%catchCondMustBeConstInt, exprs.expr1.pos, null)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do catch_.statBlock :: @rebuildBlock(catch_.statBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end if\n\u0009if(ast.finallyStatBlock <>& null)\n\u0009\u0009do ast.finallyStatBlock :: @rebuildBlock(ast.finallyStatBlock, retType, parentFunc) $ \\ast@AstStatBlock\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildThrow(ast: \\ast@AstStatThrow): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.code :: @rebuildExpr(ast.code, false)\n\u0009if(ast.code <>& null & !\\ast@isInt(ast.code.type))\n\u0009\u0009do \\err@err(%excptCodeMustBeInt, ast.code.pos, null)\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildBlock(ast: \\ast@AstStatBlock, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.stats :: @refreshStats(ast.stats, retType, parentFunc)\n\u0009ret ast\nend func\n\nfunc rebuildRet(ast: \\ast@AstStatRet, retType: \\ast@AstType): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009if(ast.value =& null)\n\u0009\u0009if(retType <>& null)\n\u0009\u0009\u0009do \\err@err(%mustRetValue, ast.pos, null)\n\u0009\u0009end if\n\u0009else\n\u0009\u0009do ast.value :: @rebuildExpr(ast.value, false)\n\u0009\u0009if(ast.value <>& null)\n\u0009\u0009\u0009if(retType =& null | !@cmpType(ast.value.type, retType, false))\n\u0009\u0009\u0009\u0009do \\err@err(%retTypeNotMatchFunc, ast.pos, null)\n\u0009\u0009\u0009elif(ast.value.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009do ast.value :: @rebuildEnumElement(ast.value, retType)\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildDo(ast: \\ast@AstStatDo): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009if(ast.expr <>& null & ast.expr.typeId = %expr2)\n\u0009\u0009; Replace all assignment operators that are not \'::\' with \'::\'\n\u0009\u0009var expr: \\ast@AstExpr2 :: ast.expr $ \\ast@AstExpr2\n\u0009\u0009var kind: \\ast@AstExpr2Kind :: %assign\n\u0009\u0009switch(expr.kind)\n\u0009\u0009case %assignAdd\n\u0009\u0009\u0009do kind :: %add\n\u0009\u0009case %assignSub\n\u0009\u0009\u0009do kind :: %sub\n\u0009\u0009case %assignMul\n\u0009\u0009\u0009do kind :: %mul\n\u0009\u0009case %assignDiv\n\u0009\u0009\u0009do kind :: %div\n\u0009\u0009case %assignMod\n\u0009\u0009\u0009do kind :: %mod\n\u0009\u0009case %assignPow\n\u0009\u0009\u0009do kind :: %pow\n\u0009\u0009case %assignCat\n\u0009\u0009\u0009do kind :: %cat\n\u0009\u0009end switch\n\u0009\u0009if(kind <> %assign)\n\u0009\u0009\u0009var block_: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009\u0009\u0009do @initAst(block_, %statBlock, ast.pos)\n\u0009\u0009\u0009do block_.extra :: block_\n\u0009\u0009\u0009do block_.name :: \"$\"\n\u0009\u0009\u0009do block_.blockVar :: null\n\u0009\u0009\u0009do block_.stats :: #list<\\ast@AstStat>\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var lhs: \\ast@AstExpr :: @rebuildExpr(expr.children0, false)\n\u0009\u0009\u0009\u0009if(lhs =& null)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(lhs.typeId = %exprDot)\n\u0009\u0009\u0009\u0009\u0009var lhs2: \\ast@AstExprDot :: lhs $ \\ast@AstExprDot\n\u0009\u0009\u0009\u0009\u0009do lhs2.var_ :: @cacheSubExpr(block_.stats, lhs2.var_, ast.pos)\n\u0009\u0009\u0009\u0009elif(lhs.typeId = %exprArray)\n\u0009\u0009\u0009\u0009\u0009var lhs2: \\ast@AstExprArray :: lhs $ \\ast@AstExprArray\n\u0009\u0009\u0009\u0009\u0009do lhs2.var_ :: @cacheSubExpr(block_.stats, lhs2.var_, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do lhs2.idx :: @cacheSubExpr(block_.stats, lhs2.idx, ast.pos)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009var exprAssign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009do @initAstExpr(exprAssign, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009do exprAssign.kind :: %assign\n\u0009\u0009\u0009\u0009do exprAssign.children0 :: lhs\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var exprOne: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(exprOne, %expr2, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do exprOne.kind :: kind\n\u0009\u0009\u0009\u0009\u0009do exprOne.children0 :: lhs\n\u0009\u0009\u0009\u0009\u0009do exprOne.children1 :: expr.children1\n\u0009\u0009\u0009\u0009\u0009do exprAssign.children1 :: exprOne\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do ast.expr :: @rebuildExpr(exprAssign, true)\n\u0009\u0009\u0009\u0009do block_.stats.add(ast)\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009ret block_\n\u0009\u0009end if\n\u0009end if\n\u0009do ast.expr :: @rebuildExpr(ast.expr, true)\n\u0009if(ast.expr =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009; \'do\' needs to end with side effects.\n\u0009if(!(ast.expr.typeId = %expr2 & ((ast.expr $ \\ast@AstExpr2).kind = %assign | (ast.expr $ \\ast@AstExpr2).kind = %swap) | ast.expr.typeId = %exprCall))\n\u0009\u0009do \\err@err(%noSideEffectDo, ast.expr.pos, null)\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildBreak(ast: \\ast@AstStat, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009if(ast.refItem =& null | ast.refItem.typeId.and(%statBreakable) <> %statBreakable)\n\u0009\u0009do \\err@err(%mustSpecifyBlockName, ast.pos, [\"break\"])\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.refItem :: @rebuildStat(ast.refItem $ \\ast@AstStat, retType, parentFunc)\n\u0009ret ast\nend func\n\nfunc rebuildSkip(ast: \\ast@AstStat, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009if(ast.refItem =& null | ast.refItem.typeId.and(%statBreakable) <> %statBreakable)\n\u0009\u0009do \\err@err(%mustSpecifyBlockName, ast.pos, [\"skip\"])\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.refItem :: @rebuildStat(ast.refItem $ \\ast@AstStat, retType, parentFunc)\n\u0009ret ast\nend func\n\nfunc rebuildAssert(ast: \\ast@AstStatAssert): \\ast@AstStat\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstStat\n\u0009end if\n\u0009\n\u0009if(\\option@rls)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009do ast.cond :: @rebuildExpr(ast.cond, false)\n\u0009if(ast.cond <>& null & !\\ast@isBool(ast.cond.type))\n\u0009\u0009do \\err@err(%assertCondMustBeBool, ast.cond.pos, null)\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildType(ast: \\ast@AstType, parentAlias: \\ast@AstAlias): \\ast@AstType\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstType\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009var type: \\ast@TypeId :: ast.typeId\n\u0009switch(type)\n\u0009case %typeUser\n\u0009\u0009var refItem: \\ast@Ast :: ast.refItem\n\u0009\u0009if(refItem =& null)\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009switch(refItem.typeId)\n\u0009\u0009case %class_\n\u0009\u0009\u0009do @rebuildClass(refItem $ \\ast@AstClass)\n\u0009\u0009case %enum_\n\u0009\u0009\u0009do @rebuildEnum(refItem $ \\ast@AstEnum)\n\u0009\u0009case %alias_\n\u0009\u0009\u0009do @rebuildAlias(refItem $ \\ast@AstAlias, parentAlias)\n\u0009\u0009\u0009do ast.extra :: (refItem $ \\ast@AstAlias).type\n\u0009\u0009\u0009do ast :: (refItem $ \\ast@AstAlias).type\n\u0009\u0009default\n\u0009\u0009\u0009do \\err@err(%nonTypeWritten, ast.pos, null)\n\u0009\u0009\u0009ret null\n\u0009\u0009end switch\n\u0009case %typeArray\n\u0009\u0009do(ast $ \\ast@AstTypeArray).itemType :: @rebuildType((ast $ \\ast@AstTypeArray).itemType, parentAlias)\n\u0009case %typeFunc\n\u0009\u0009var ast2: \\ast@AstTypeFunc :: ast $ \\ast@AstTypeFunc\n\u0009\u0009var items: list<\\ast@AstTypeFuncArg> :: ast2.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var arg: \\ast@AstTypeFuncArg :: items.get()\n\u0009\u0009\u0009do arg.arg :: @rebuildType(arg.arg, parentAlias)\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009if(ast2.ret_ <>& null)\n\u0009\u0009\u0009do ast2.ret_ :: @rebuildType(ast2.ret_, parentAlias)\n\u0009\u0009end if\n\u0009case %typeGen\n\u0009\u0009do(ast $ \\ast@AstTypeGen).itemType :: @rebuildType((ast $ \\ast@AstTypeGen).itemType, parentAlias)\n\u0009case %typeDict\n\u0009\u0009var ast2: \\ast@AstTypeDict :: ast $ \\ast@AstTypeDict\n\u0009\u0009do ast2.itemTypeKey :: @rebuildType(ast2.itemTypeKey, parentAlias)\n\u0009\u0009do ast2.itemTypeValue :: @rebuildType(ast2.itemTypeValue, parentAlias)\n\u0009default\n\u0009\u0009assert type = %none {Error}|type = %typeBit | type = %typePrim | type = %typeNull\n\u0009end switch\n\u0009ret ast\nend func\n\nfunc rebuildExpr(ast: \\ast@AstExpr, nullable: bool): \\ast@AstExpr\n\u0009if(ast =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009switch(ast.typeId)\n\u0009case %none\n\u0009\u0009ret null\n\u0009case %expr1\n\u0009\u0009do ast :: @rebuildExpr1(ast $ \\ast@AstExpr1)\n\u0009case %expr2\n\u0009\u0009do ast :: @rebuildExpr2(ast $ \\ast@AstExpr2)\n\u0009case %expr3\n\u0009\u0009do ast :: @rebuildExpr3(ast $ \\ast@AstExpr3)\n\u0009case %exprNew\n\u0009\u0009do ast :: @rebuildExprNew(ast $ \\ast@AstExprNew)\n\u0009case %exprNewArray\n\u0009\u0009do ast :: @rebuildExprNewArray(ast $ \\ast@AstExprNewArray)\n\u0009case %exprAs\n\u0009\u0009do ast :: @rebuildExprAs(ast $ \\ast@AstExprAs)\n\u0009case %exprToBin\n\u0009\u0009do ast :: @rebuildExprToBin(ast $ \\ast@AstExprToBin)\n\u0009case %exprFromBin\n\u0009\u0009do ast :: @rebuildExprFromBin(ast $ \\ast@AstExprFromBin)\n\u0009case %exprCall\n\u0009\u0009do ast :: @rebuildExprCall(ast $ \\ast@AstExprCall)\n\u0009case %exprArray\n\u0009\u0009do ast :: @rebuildExprArray(ast $ \\ast@AstExprArray)\n\u0009case %exprDot\n\u0009\u0009do ast :: @rebuildExprDot(ast $ \\ast@AstExprDot)\n\u0009case %exprValue\n\u0009\u0009do ast :: @rebuildExprValue(ast $ \\ast@AstExprValue)\n\u0009case %exprValuePrim\n\u0009\u0009do ast :: @rebuildExprValuePrim(ast $ \\ast@AstExprValuePrim)\n\u0009case %exprValueStr\n\u0009\u0009do ast :: @rebuildExprValueStr(ast $ \\ast@AstExprValueStr)\n\u0009case %exprValueEnumElement\n\u0009\u0009do ast :: @rebuildExprValueEnumElement(ast $ \\ast@AstExprValueEnumElement)\n\u0009case %exprValueFloat\n\u0009\u0009do ast :: @rebuildExprValueFloat(ast $ \\ast@AstExprValueFloat)\n\u0009case %exprValueArray\n\u0009\u0009do ast :: @rebuildExprValueArray(ast $ \\ast@AstExprValueArray)\n\u0009case %exprRef\n\u0009\u0009do ast :: @rebuildExprRef(ast)\n\u0009end switch\n\u0009if(ast =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(!nullable & ast.type =& null)\n\u0009\u0009; \'type\' is null, for example, when calling a function whose return value is \'void\'.\n\u0009\u0009do \\err@err(%noValuePassed, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009ret ast\nend func\n\nfunc rebuildExpr1(ast: \\ast@AstExpr1): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.child :: @rebuildExpr(ast.child, false)\n\u0009if(ast.child =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009assert ast.type =& null\n\u0009var childType: \\ast@AstType :: ast.child.type\n\u0009switch(ast.kind)\n\u0009case %plus\n\u0009\u0009if(\\ast@isInt(childType) | \\ast@isFloat(childType) | childType.typeId = %typeBit)\n\u0009\u0009\u0009if(ast.child.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009do ast.extra :: ast.child\n\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.type :: childType\n\u0009\u0009end if\n\u0009case %minus\n\u0009\u0009if(\\ast@isInt(childType) | \\ast@isFloat(childType))\n\u0009\u0009\u0009if(ast.child.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009if(\\ast@isInt(childType))\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do expr.type :: childType\n\u0009\u0009\u0009\u0009\u0009do expr.value :: (-((ast.child $ \\ast@AstExprValuePrim).value $ int)) $ bit64\n\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009assert \\ast@isFloat(childType)\n\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValueFloat :: #\\ast@AstExprValueFloat\n\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValueFloat, ast.pos)\n\u0009\u0009\u0009\u0009do expr.type :: childType\n\u0009\u0009\u0009\u0009do expr.value :: -(ast.child $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009do expr :: @rebuildExprValueFloat(expr) $ \\ast@AstExprValueFloat\n\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.type :: childType\n\u0009\u0009end if\n\u0009case %not\n\u0009\u0009if(\\ast@isBool(childType))\n\u0009\u0009\u0009if(ast.child.typeId = %exprValuePrim)\n\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009do expr.type :: childType\n\u0009\u0009\u0009\u0009do expr.value :: (ast.child $ \\ast@AstExprValuePrim).value <> 0b64 ?(0b64, 1b64)\n\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.type :: childType\n\u0009\u0009end if\n\u0009case %copy\n\u0009\u0009if(\\ast@isClass(childType) | childType.typeId = %typeArray | childType.typeId = %typeGen | childType.typeId = %typeDict)\n\u0009\u0009\u0009do ast.type :: childType\n\u0009\u0009end if\n\u0009case %len\n\u0009\u0009if(childType.typeId = %typeArray | childType.typeId = %typeGen | childType.typeId = %typeDict)\n\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009do @initAst(type, %typePrim, ast.pos)\n\u0009\u0009\u0009do type.kind :: %int_\n\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009end if\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\n\u0009if(ast.type =& null)\n\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExpr2(ast: \\ast@AstExpr2): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.children0 :: @rebuildExpr(ast.children0, false)\n\u0009if(ast.children0 =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.children1 :: @rebuildExpr(ast.children1, false)\n\u0009if(ast.children1 =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(!@cmpType(ast.children1.type, ast.children0.type, false))\n\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009block\n\u0009\u0009var correct: bool :: false\n\u0009\u0009switch(ast.kind)\n\u0009\u0009case %assign\n\u0009\u0009\u0009if(ast.children0.varKind = %value)\n\u0009\u0009\u0009\u0009do \\err@err(%wrongLeftValueOfAssignOperator, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(\\ast@isClass(ast.children0.type) & \\ast@isClass(ast.children1.type))\n\u0009\u0009\u0009\u0009var ptr: \\ast@AstClass :: ast.children1.type.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009while(ast.children0.type.refItem <>& ptr)\n\u0009\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009\u0009if(ptr =& null)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(ast.children1.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009do ast.children1 :: @rebuildEnumElement(ast.children1, ast.children0.type)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.type :: null\n\u0009\u0009\u0009do correct :: true\n\u0009\u0009case %or, %and\n\u0009\u0009\u0009if(\\ast@isBool(ast.children0.type))\n\u0009\u0009\u0009\u0009if(ast.children0.typeId = %exprValuePrim)\n\u0009\u0009\u0009\u0009\u0009var value: bool :: (ast.children0 $ \\ast@AstExprValuePrim).value <> 0b64\n\u0009\u0009\u0009\u0009\u0009; \'true | x\' becomes \'true\'. \'false & x\' becomes \'false\'.\n\u0009\u0009\u0009\u0009\u0009if(ast.kind = %or)\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: value ?(ast.children0, ast.children1)\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert ast.kind = %and\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: !value ?(ast.children0, ast.children1)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: ast.children0.type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %lt, %gt, %le, %ge\n\u0009\u0009\u0009if(ast.children0.type.typeId = %typeNull | ast.children1.type.typeId = %typeNull)\n\u0009\u0009\u0009\u0009do \\err@err(%comparingNullByValue, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(@isComparable(ast.children0.type, true))\n\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, ast.pos)\n\u0009\u0009\u0009\u0009do type.kind :: %bool_\n\u0009\u0009\u0009\u0009if(ast.children0.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009if(ast.children1.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009assert(ast.children0.typeId = %exprValueEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%enumTypeNotInferred, ast.pos, [(ast.children0 $ \\ast@AstExprValueEnumElement).identifier])\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do ast.children0 :: @rebuildEnumElement(ast.children0, ast.children1.type)\n\u0009\u0009\u0009\u0009elif(ast.children1.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009do ast.children1 :: @rebuildEnumElement(ast.children1, ast.children0.type)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(ast.children0.typeId.and(%exprValue) = %exprValue & ast.children1.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009\u0009var value: bool :: false\n\u0009\u0009\u0009\u0009\u0009var children0Type: \\ast@AstType :: ast.children0.type\n\u0009\u0009\u0009\u0009\u0009if(children0Type.typeId = %typeBit | \\ast@isChar(children0Type))\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: bit64 :: (ast.children0 $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: bit64 :: (ast.children1 $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %lt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 < n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %gt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 > n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %le\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 <= n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %ge\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 >= n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isInt(children0Type) | \\ast@isEnum(children0Type))\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: int :: (ast.children0 $ \\ast@AstExprValuePrim).value $ int\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: int :: (ast.children1 $ \\ast@AstExprValuePrim).value $ int\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %lt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 < n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %gt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 > n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %le\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 <= n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %ge\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 >= n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isFloat(children0Type))\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: float :: (ast.children0 $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: float :: (ast.children1 $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %lt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 < n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %gt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 > n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %le\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 <= n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %ge\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 >= n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isStr(children0Type)\n\u0009\u0009\u0009\u0009\u0009\u0009var cmp: int :: lib@cmp((ast.children0 $ \\ast@AstExprValueStr).value, (ast.children1 $ \\ast@AstExprValueStr).value)\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %lt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: cmp < 0\n\u0009\u0009\u0009\u0009\u0009\u0009case %gt\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: cmp > 0\n\u0009\u0009\u0009\u0009\u0009\u0009case %le\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: cmp <= 0\n\u0009\u0009\u0009\u0009\u0009\u0009case %ge\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: cmp >= 0\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do expr.type :: type\n\u0009\u0009\u0009\u0009\u0009do expr.value :: value ?(1b64, 0b64)\n\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %eq, %nEq\n\u0009\u0009\u0009if(ast.children0.type.typeId = %typeNull | ast.children1.type.typeId = %typeNull)\n\u0009\u0009\u0009\u0009do \\err@err(%comparingNullByValue, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(@isComparable(ast.children0.type, false))\n\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, ast.pos)\n\u0009\u0009\u0009\u0009do type.kind :: %bool_\n\u0009\u0009\u0009\u0009if(ast.children0.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009if(ast.children1.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009assert(ast.children0.typeId = %exprValueEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%enumTypeNotInferred, ast.pos, [(ast.children0 $ \\ast@AstExprValueEnumElement).identifier])\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do ast.children0 :: @rebuildEnumElement(ast.children0, ast.children1.type)\n\u0009\u0009\u0009\u0009elif(ast.children1.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009do ast.children1 :: @rebuildEnumElement(ast.children1, ast.children0.type)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(ast.children0.typeId.and(%exprValue) = %exprValue & ast.children1.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009\u0009var value: bool :: false\n\u0009\u0009\u0009\u0009\u0009var children0Type: \\ast@AstType :: ast.children0.type\n\u0009\u0009\u0009\u0009\u0009if(children0Type.typeId = %typeBit | \\ast@isInt(children0Type) | \\ast@isFloat(children0Type) | \\ast@isChar(children0Type) | \\ast@isBool(children0Type) | \\ast@isEnum(children0Type))\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: bit64 :: (ast.children0 $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: bit64 :: (ast.children1 $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %eq\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 = n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %nEq\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: n1 <> n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isStr(children0Type)\n\u0009\u0009\u0009\u0009\u0009\u0009var cmp: int :: lib@cmp((ast.children0 $ \\ast@AstExprValueStr).value, (ast.children1 $ \\ast@AstExprValueStr).value)\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %eq\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: cmp = 0\n\u0009\u0009\u0009\u0009\u0009\u0009case %nEq\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value :: cmp <> 0\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do expr.type :: type\n\u0009\u0009\u0009\u0009\u0009do expr.value :: value ?(1b64, 0b64)\n\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %eqRef, %nEqRef\n\u0009\u0009\u0009if(\\ast@isNullable(ast.children0.type) | ast.children0.type.typeId = %typeNull)\n\u0009\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(type, %typePrim, ast.pos)\n\u0009\u0009\u0009\u0009do type.kind :: %bool_\n\u0009\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %cat\n\u0009\u0009\u0009if(ast.children0.type.typeId = %typeNull | ast.children1.type.typeId = %typeNull)\n\u0009\u0009\u0009\u0009do \\err@err(%concatNull, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(ast.children0.type.typeId = %typeArray)\n\u0009\u0009\u0009\u0009if(ast.children0.typeId.and(%exprValue) = %exprValue & ast.children1.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009\u0009if(\\ast@isStr(ast.children0.type))\n\u0009\u0009\u0009\u0009\u0009\u0009var s1: []char :: (ast.children0 $ \\ast@AstExprValueStr).value\n\u0009\u0009\u0009\u0009\u0009\u0009var s2: []char :: (ast.children1 $ \\ast@AstExprValueStr).value\n\u0009\u0009\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValueStr :: #\\ast@AstExprValueStr\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValueStr, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.children0.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: s1 ~ s2\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValueStr(expr) $ \\ast@AstExprValueStr\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: ast.children0.type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %add, %sub, %mul, %div, %mod\n\u0009\u0009\u0009if(ast.children0.type.typeId = %typeBit | \\ast@isInt(ast.children0.type) | \\ast@isFloat(ast.children0.type))\n\u0009\u0009\u0009\u0009if(ast.children0.typeId.and(%exprValue) = %exprValue & ast.children1.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009\u0009if(ast.children0.type.typeId = %typeBit)\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: bit64 :: (ast.children0 $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: bit64 :: (ast.children1 $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %add\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :+ n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %sub\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :- n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %mul\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :* n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %div\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(n2 = 0b64)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%dividedBy0, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :/ n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %mod\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(n2 = 0b64)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%dividedBy0, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :% n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.children0.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: @bitCast((ast.children0.type $ \\ast@AstTypeBit).size, n1)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isInt(ast.children0.type))\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: int :: (ast.children0 $ \\ast@AstExprValuePrim).value $ int\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: int :: (ast.children1 $ \\ast@AstExprValuePrim).value $ int\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %add\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :+ n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %sub\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :- n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %mul\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :* n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %div\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(n2 = 0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%dividedBy0, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :/ n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %mod\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(n2 = 0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%dividedBy0, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :% n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.children0.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n1 $ bit64\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isFloat(ast.children0.type)\n\u0009\u0009\u0009\u0009\u0009\u0009var n1: float :: (ast.children0 $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009\u0009\u0009var n2: float :: (ast.children1 $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009\u0009\u0009switch(ast.kind)\n\u0009\u0009\u0009\u0009\u0009\u0009case %add\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :+ n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %sub\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :- n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %mul\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :* n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %div\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(n1 = 0.0 & n2 = 0.0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%dividedBy0, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :/ n2\n\u0009\u0009\u0009\u0009\u0009\u0009case %mod\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(n1 = 0.0 & n2 = 0.0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%dividedBy0, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do n1 :% n2\n\u0009\u0009\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValueFloat :: #\\ast@AstExprValueFloat\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValueFloat, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.children0.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n1\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValueFloat(expr) $ \\ast@AstExprValueFloat\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: ast.children0.type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %pow\n\u0009\u0009\u0009if(\\ast@isInt(ast.children0.type) | \\ast@isFloat(ast.children0.type))\n\u0009\u0009\u0009\u0009do ast.type :: ast.children0.type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009case %swap\n\u0009\u0009\u0009if(ast.children0.varKind = %value | ast.children1.varKind = %value)\n\u0009\u0009\u0009\u0009do \\err@err(%wrongLeftOrRightValueOfSwapOperator, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!\\ast@isClass(ast.children0.type) & ast.children0.type.refItem <>& ast.children1.type.refItem)\n\u0009\u0009\u0009\u0009do ast.type :: ast.children0.type\n\u0009\u0009\u0009\u0009do correct :: true\n\u0009\u0009\u0009end if\n\u0009\u0009end switch\n\u0009\u0009if(!correct)\n\u0009\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009end block\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExpr3(ast: \\ast@AstExpr3): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.children0 :: @rebuildExpr(ast.children0, false)\n\u0009if(ast.children0 =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.children1 :: @rebuildExpr(ast.children1, false)\n\u0009if(ast.children1 =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.children2 :: @rebuildExpr(ast.children2, false)\n\u0009if(ast.children2 =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(!\\ast@isBool(ast.children0.type))\n\u0009\u0009do \\err@err(%condForCondOperatorMustBeBool, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(!@cmpType(ast.children1.type, ast.children2.type, false) & !@cmpType(ast.children2.type, ast.children1.type, false))\n\u0009\u0009do \\err@err(%twoValueForCondOperatorMustSameType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(ast.children0.typeId = %exprValuePrim)\n\u0009\u0009do ast.extra :: (ast.children0 $ \\ast@AstExprValuePrim).value <> 0b64 ?(ast.children1, ast.children2)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009if(ast.children1.type.typeId = %typeEnumElement)\n\u0009\u0009if(ast.children2.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009assert ast.children1.typeId = %exprValueEnumElement\n\u0009\u0009\u0009do \\err@err(%enumTypeNotInferred, ast.pos, [(ast.children1 $ \\ast@AstExprValueEnumElement).identifier])\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009do ast.children1 :: @rebuildEnumElement(ast.children1, ast.children2.type)\n\u0009elif(ast.children2.type.typeId = %typeEnumElement)\n\u0009\u0009do ast.children2 :: @rebuildEnumElement(ast.children2, ast.children1.type)\n\u0009end if\n\u0009if(@cmpType(ast.children1.type, ast.children2.type, false))\n\u0009\u0009do ast.type :: ast.children2.type.typeId = %typeNull ?(ast.children1.type, ast.children2.type)\n\u0009else\n\u0009\u0009do ast.type :: ast.children1.type.typeId = %typeNull ?(ast.children2.type, ast.children1.type)\n\u0009end if\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprNew(ast: \\ast@AstExprNew): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.itemType :: @rebuildType(ast.itemType, null)\n\u0009if(ast.itemType =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009if(\\ast@isClass(ast.itemType) & ast.itemType.refItem =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009if(!(\\ast@isClass(ast.itemType) | ast.itemType.typeId = %typeGen | ast.itemType.typeId = %typeDict))\n\u0009\u0009do \\err@err(%wrongTypeForNewOperator, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.type :: ast.itemType\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprNewArray(ast: \\ast@AstExprNewArray): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009block\n\u0009\u0009var items: list<\\ast@AstExpr> :: ast.idces\n\u0009\u0009do items.head()\n\u0009\u0009while loop(!items.term())\n\u0009\u0009\u0009var data: \\ast@AstExpr :: items.get()\n\u0009\u0009\u0009do data :: @rebuildExpr(data, false)\n\u0009\u0009\u0009if(data =& null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!\\ast@isInt(data.type))\n\u0009\u0009\u0009\u0009do \\err@err(%numOfElementsMustBeInt, data.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.ins(data)\n\u0009\u0009\u0009do items.del()\n\u0009\u0009end while\n\u0009end block\n\u0009\n\u0009do ast.itemType :: @rebuildType(ast.itemType, null)\n\u0009if(ast.itemType =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009block\n\u0009\u0009; Make a type of \'[][]...[]type\'.\n\u0009\u0009var type: \\ast@AstType :: ast.itemType\n\u0009\u0009for i(0, ^ast.idces - 1)\n\u0009\u0009\u0009var type2: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009do @initAst(type2, %typeArray, ast.pos)\n\u0009\u0009\u0009do type2.itemType :: type\n\u0009\u0009\u0009do type :: type2\n\u0009\u0009end for\n\u0009\u0009do ast.type :: type\n\u0009end block\n\u0009\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprAs(ast: \\ast@AstExprAs): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.child :: @rebuildExpr(ast.child, false)\n\u0009if(ast.child =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.childType :: @rebuildType(ast.childType, null)\n\u0009if(ast.childType =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009assert ast.type =& null\n\u0009switch(ast.kind)\n\u0009case %as\n\u0009\u0009var t1: \\ast@AstType :: ast.child.type\n\u0009\u0009var t2: \\ast@AstType :: ast.childType\n\u0009\u0009if(t1.typeId = %typeBit | \\ast@isInt(t1))\n\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2) | \\ast@isFloat(t2) | \\ast@isChar(t2) | \\ast@isBool(t2) | \\ast@isEnum(t2))\n\u0009\u0009\u0009\u0009if(@cmpType(t1, t2, false))\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: ast.child\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009elif(\\ast@isFloat(t1))\n\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2) | \\ast@isFloat(t2))\n\u0009\u0009\u0009\u0009if(@cmpType(t1, t2, false))\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: ast.child\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009elif(\\ast@isChar(t1))\n\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2) | \\ast@isChar(t2))\n\u0009\u0009\u0009\u0009if(@cmpType(t1, t2, false))\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: ast.child\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009elif(\\ast@isBool(t1))\n\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2) | \\ast@isBool(t2))\n\u0009\u0009\u0009\u0009if(@cmpType(t1, t2, false))\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: ast.child\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009elif(\\ast@isClass(t1))\n\u0009\u0009\u0009if(\\ast@isClass(t2))\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009elif(\\ast@isEnum(t1))\n\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2) | \\ast@isEnum(t2))\n\u0009\u0009\u0009\u0009if(@cmpType(t1, t2, false))\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: ast.child\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009elif(t1.typeId = %typeEnumElement)\n\u0009\u0009\u0009if(\\ast@isEnum(t2))\n\u0009\u0009\u0009\u0009do ast.type :: t2\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(ast.type <>& null)\n\u0009\u0009\u0009if(ast.child.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009\u0009\u0009if(t1.typeId = %typeBit | \\ast@isChar(t1) | \\ast@isBool(t1) | \\ast@isInt(t1) | \\ast@isEnum(t1))\n\u0009\u0009\u0009\u0009\u0009var n: bit64 :: (ast.child $ \\ast@AstExprValuePrim).value\n\u0009\u0009\u0009\u0009\u0009if(t2.typeId = %typeBit)\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: @bitCast((t2 $ \\ast@AstTypeBit).size, n)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isInt(t2) | \\ast@isEnum(t2))\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isFloat(t2))\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValueFloat :: #\\ast@AstExprValueFloat\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValueFloat, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009if(\\ast@isInt(t1) | \\ast@isEnum(t1))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n $ int $ float\n\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n $ float\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValueFloat(expr) $ \\ast@AstExprValueFloat\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009elif(\\ast@isChar(t2))\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: @bitCast(2, n)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isBool(t2)\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n <> 0b64 ?(1b64, 0b64)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009elif(t1.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009assert t2.refItem.typeId = %enum_\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009do expr.value :: @searchEnumElementValue(ast.child $ \\ast@AstExprValueEnumElement, t2.refItem $ \\ast@AstEnum)\n\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert \\ast@isFloat(t1)\n\u0009\u0009\u0009\u0009\u0009var n: float :: (ast.child $ \\ast@AstExprValueFloat).value\n\u0009\u0009\u0009\u0009\u0009if(t2.typeId = %typeBit)\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: @bitCast((t2 $ \\ast@AstTypeBit).size, n $ bit64)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(t2)\n\u0009\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.type :: ast.type\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.value :: n $ bit64\n\u0009\u0009\u0009\u0009\u0009\u0009do expr :: @rebuildExprValuePrim(expr) $ \\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.extra :: expr\n\u0009\u0009\u0009\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009case %is, %nIs\n\u0009\u0009if(\\ast@isClass(ast.child.type) & \\ast@isClass(ast.childType))\n\u0009\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009do @initAst(type, %typePrim, ast.pos)\n\u0009\u0009\u0009do type.kind :: %bool_\n\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009end if\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\n\u0009if(ast.type =& null)\n\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprToBin(ast: \\ast@AstExprToBin): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.child :: @rebuildExpr(ast.child, false)\n\u0009if(ast.child =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(ast.child.type.typeId = %typeNull | ast.child.type.typeId = %typeEnumElement)\n\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(ast.childType.typeId <> %typeArray | (ast.childType $ \\ast@AstTypeArray).itemType.typeId <> %typeBit | ((ast.childType $ \\ast@AstTypeArray).itemType $ \\ast@AstTypeBit).size <> 1)\n\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.type :: ast.childType\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprFromBin(ast: \\ast@AstExprFromBin): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.child :: @rebuildExpr(ast.child, false)\n\u0009if(ast.child =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(ast.child.type.typeId <> %typeArray | ((ast.child.type) $ \\ast@AstTypeArray).itemType.typeId <> %typeBit | ((ast.child.type $ \\ast@AstTypeArray).itemType $ \\ast@AstTypeBit).size <> 1)\n\u0009\u0009do \\err@err(%wrongOperatorType, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.type :: ast.childType\n\u0009do ast.varKind :: %value\n\u0009do ast.offset :: @rebuildExpr(ast.offset, false)\n\u0009ret ast\nend func\n\nfunc rebuildExprCall(ast: \\ast@AstExprCall): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.func_ :: @rebuildExpr(ast.func_, false)\n\u0009if(ast.func_ =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009block\n\u0009\u0009var type: \\ast@AstTypeFunc :: ast.func_.type $ \\ast@AstTypeFunc\n\u0009\u0009if(type.funcOption.and(%mki) <> %none)\n\u0009\u0009\u0009; Make an instance and add it to the second argument when \'__mki\' is specified.\n\u0009\u0009\u0009var valueType: \\ast@AstExprCallArg :: #\\ast@AstExprCallArg\n\u0009\u0009\u0009assert type.ret_ <>& null\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var expr: \\ast@AstExprNew :: #\\ast@AstExprNew\n\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprNew, ast.pos)\n\u0009\u0009\u0009\u0009do expr.itemType :: type.ret_\n\u0009\u0009\u0009\u0009do valueType.arg :: @rebuildExpr(expr, false)\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do valueType.refVar :: false\n\u0009\u0009\u0009do valueType.skipVar :: false\n\u0009\u0009\u0009if(^ast.args = 0)\n\u0009\u0009\u0009\u0009do ast.args.add(valueType)\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do ast.args.head()\n\u0009\u0009\u0009\u0009do ast.args.ins(valueType)\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(ast.func_.typeId = %exprDot & ast.func_.type.typeId = %typeFunc)\n\u0009\u0009\u0009var me_: \\ast@AstExprCallArg :: #\\ast@AstExprCallArg\n\u0009\u0009\u0009do me_.arg :: (ast.func_ $ \\ast@AstExprDot).var_\n\u0009\u0009\u0009do me_.refVar :: false\n\u0009\u0009\u0009do me_.skipVar :: false\n\u0009\u0009\u0009if(^ast.args = 0)\n\u0009\u0009\u0009\u0009do ast.args.add(me_)\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do ast.args.head()\n\u0009\u0009\u0009\u0009do ast.args.ins(me_)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(type.funcOption.and(%any) <> %none)\n\u0009\u0009\u0009\u0009; Add the type of \'me\' to the second argument when \'_any_type\' is specified.\n\u0009\u0009\u0009\u0009var meType: \\ast@AstExprCallArg :: #\\ast@AstExprCallArg\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var expr: \\ast@AstExprValueArray :: #\\ast@AstExprValueArray\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(expr, %exprValueArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do expr.values :: #list<\\ast@AstExpr>\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var value: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(value, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do value.value :: 0b64\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var prim: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(prim, %typePrim, ast.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do prim.kind :: %int_\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do value.type :: prim\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do expr.values.add(value)\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do meType.arg :: @rebuildExpr(expr, false)\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do meType.refVar :: false\n\u0009\u0009\u0009\u0009do meType.skipVar :: false\n\u0009\u0009\u0009\u0009if(^ast.args = 1)\n\u0009\u0009\u0009\u0009\u0009do ast.args.add(meType)\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert ^ ast.args >= 2\n\u0009\u0009\u0009\u0009\u0009do ast.args.head()\n\u0009\u0009\u0009\u0009\u0009do ast.args.next()\n\u0009\u0009\u0009\u0009\u0009do ast.args.ins(meType)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009if(type.typeId <> %typeFunc)\n\u0009\u0009\u0009\u0009do \\err@err(%callNonFunction, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do type :: ast.func_.type $ \\ast@AstTypeFunc\n\u0009\u0009end if\n\u0009\u0009do ast.type :: type.ret_\n\u0009\u0009if(^ast.args <> ^type.args)\n\u0009\u0009\u0009do \\err@err(%wrongArgNumInFunc, ast.pos, [(^type.args).toStr(), (^ast.args).toStr(), @getTypeName(type)])\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009block\n\u0009\u0009\u0009var n: int :: 0\n\u0009\u0009\u0009var itemsExpr: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009\u0009var itemsType: list<\\ast@AstTypeFuncArg> :: type.args\n\u0009\u0009\u0009do itemsExpr.head()\n\u0009\u0009\u0009do itemsType.head()\n\u0009\u0009\u0009while(!itemsExpr.term())\n\u0009\u0009\u0009\u0009var argExpr: \\ast@AstExprCallArg :: itemsExpr.get()\n\u0009\u0009\u0009\u0009var argType: \\ast@AstTypeFuncArg :: itemsType.get()\n\u0009\u0009\u0009\u0009if(argExpr.skipVar)\n\u0009\u0009\u0009\u0009\u0009do(argExpr.arg.refItem $ \\ast@AstArg).type :: argType.arg\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do argExpr.arg :: @rebuildExpr(argExpr.arg, false)\n\u0009\u0009\u0009\u0009if(argExpr.arg <>& null)\n\u0009\u0009\u0009\u0009\u0009if(argExpr.refVar & !argExpr.skipVar & argExpr.arg.varKind = %value)\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%nonRefArgPassed, ast.pos, [(n + 1).toStr()])\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(argExpr.refVar <> argType.refVar | !@cmpType(argExpr.arg.type, argType.arg, false))\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%wrongArgTypeInFunc, ast.pos, [(n + 1).toStr(), (argType.refVar ?(\"&\", \"\")) ~ @getTypeName(argType.arg), (argExpr.refVar ?(\"&\", \"\")) ~ @getTypeName(argExpr.arg.type)])\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(argExpr.arg.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009do argExpr.arg :: @rebuildEnumElement(argExpr.arg, argType.arg)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do itemsExpr.next()\n\u0009\u0009\u0009\u0009do itemsType.next()\n\u0009\u0009\u0009\u0009do n :+ 1\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009end block\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprArray(ast: \\ast@AstExprArray): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.var_ :: @rebuildExpr(ast.var_, false)\n\u0009if(ast.var_ =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(ast.var_.type.typeId <> %typeArray)\n\u0009\u0009do \\err@err(%nonArrayAccess, ast.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.idx :: @rebuildExpr(ast.idx, false)\n\u0009if(ast.idx =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(!\\ast@isInt(ast.idx.type))\n\u0009\u0009do \\err@err(%arrayIdxMustBeInt, ast.idx.pos, null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.type :: (ast.var_.type $ \\ast@AstTypeArray).itemType\n\u0009do ast.varKind :: %globalVar {An array can be an left value.}\n\u0009ret ast\nend func\n\nfunc rebuildExprDot(ast: \\ast@AstExprDot): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.var_ :: @rebuildExpr(ast.var_, false)\n\u0009if(ast.var_ =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(\\ast@isClass(ast.var_.type))\n\u0009\u0009var found: bool :: false\n\u0009\u0009var ptr: \\ast@AstClass :: ast.var_.type.refItem $ \\ast@AstClass\n\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009var items: list<\\ast@AstClassItem> :: ptr.items\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009\u0009if(item.def.typeId = %var_ & ast.member = (item.def $ \\ast@AstVar).arg.name)\n\u0009\u0009\u0009\u0009\u0009do ast.type :: (item.def $ \\ast@AstVar).arg.type\n\u0009\u0009\u0009\u0009\u0009do ast.varKind :: %globalVar {The addresses of properties are treated as those of global variables. They can be left values.}\n\u0009\u0009\u0009\u0009\u0009do found :: true\n\u0009\u0009\u0009\u0009elif(item.def.typeId = %func_ & ast.member = item.def.name)\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeFunc :: #\\ast@AstTypeFunc\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeFunc, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do type.funcOption :: (item.def $ \\ast@AstFunc).funcOption\n\u0009\u0009\u0009\u0009\u0009do type.funcAttr :: (item.def $ \\ast@AstFunc).funcAttr\n\u0009\u0009\u0009\u0009\u0009do type.args :: #list<\\ast@AstTypeFuncArg>\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var items2: list<\\ast@AstArg> :: (item.def $ \\ast@AstFunc).args\n\u0009\u0009\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: items2.get()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var arg2: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg2.arg :: arg.type\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg2.refVar :: arg.refVar\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do type.args.add(arg2)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do type.ret_ :: (item.def $ \\ast@AstFunc).ret_\n\u0009\u0009\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009\u0009\u0009\u0009do ast.varKind :: %value\n\u0009\u0009\u0009\u0009\u0009do found :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(found)\n\u0009\u0009\u0009\u0009\u0009; \'me\' and automatically generated arguments can be accessed even though they are private.\n\u0009\u0009\u0009\u0009\u0009if(!item.public & (ast.var_.refName =& null | ast.var_.refName <> \"me\"))\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%refUnpublishedMember, ast.pos, [ast.member])\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do ast.classItem :: item\n\u0009\u0009\u0009\u0009\u0009ret ast\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009end while\n\u0009else\n\u0009\u0009; Built-in methods.\n\u0009\u0009var varType: \\ast@AstType :: ast.var_.type\n\u0009\u0009if(varType.typeId = %typeEnumElement)\n\u0009\u0009\u0009assert ast.var_.typeId = %exprValueEnumElement\n\u0009\u0009\u0009do \\err@err(%enumTypeNotInferred, ast.pos, [(ast.var_ $ \\ast@AstExprValueEnumElement).identifier])\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009var member: []char :: ast.member\n\u0009\u0009if(\\builtin_func@chkBuiltinFuncType(&member, varType))\n\u0009\u0009\u0009var expr: \\ast@AstExpr :: @searchStdItem(\"kuin\", \"_\" ~ member, true) $ \\ast@AstExpr\n\u0009\u0009\u0009if(expr =& null)\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var func_: \\ast@AstTypeFunc :: expr.type $ \\ast@AstTypeFunc\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%any) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert ^ func_.args >= 2\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.args.get().arg)\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009var argType: \\ast@AstType :: func_.args.get().arg\n\u0009\u0009\u0009\u0009\u0009\u0009assert argType.typeId = %typeArray & \\ast@isInt((argType $ \\ast@AstTypeArray).itemType)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: varType\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%tme) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tkv) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%kvf) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert ^ func_.args >= 3\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.args.get().arg)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: varType\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%tch) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tkv) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%kvf) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert ^ func_.args >= 3\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.args.get().arg)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009if(varType.typeId = %typeArray)\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: (varType $ \\ast@AstTypeArray).itemType\n\u0009\u0009\u0009\u0009\u0009elif(varType.typeId = %typeGen)\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: (varType $ \\ast@AstTypeGen).itemType\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: (varType $ \\ast@AstTypeDict).itemTypeKey\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%tkv) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%kvf) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert ^ func_.args >= 4\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.args.get().arg)\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.args.get().arg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: (varType $ \\ast@AstTypeDict).itemTypeKey\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: (varType $ \\ast@AstTypeDict).itemTypeValue\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%kvf) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%tkv) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert ^ func_.args >= 3\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.args.get().arg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeFunc :: #\\ast@AstTypeFunc\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeFunc, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do type.funcOption :: %none\n\u0009\u0009\u0009\u0009\u0009do type.funcAttr :: #list<[]char>\n\u0009\u0009\u0009\u0009\u0009do type.args :: #list<\\ast@AstTypeFuncArg>\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009\u0009do item.arg :: (varType $ \\ast@AstTypeDict).itemTypeKey\n\u0009\u0009\u0009\u0009\u0009\u0009do item.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009do type.args.add(item)\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009\u0009do item.arg :: (varType $ \\ast@AstTypeDict).itemTypeValue\n\u0009\u0009\u0009\u0009\u0009\u0009do item.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009do type.args.add(item)\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var item: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009\u0009do item.arg :: func_.args.get().arg\n\u0009\u0009\u0009\u0009\u0009\u0009do item.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009do type.args.add(item)\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009do type.ret_ :: func_.ret_\n\u0009\u0009\u0009\u0009\u0009do func_.args.head()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.next()\n\u0009\u0009\u0009\u0009\u0009do func_.args.get().arg :: type\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%rme) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rac) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rak) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rav) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.ret_)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: varType\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%rch) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rac) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rak) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rav) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.ret_)\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(varType.typeId = %typeArray)\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: (varType $ \\ast@AstTypeArray).itemType\n\u0009\u0009\u0009\u0009\u0009elif(varType.typeId = %typeGen)\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: (varType $ \\ast@AstTypeGen).itemType\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: (varType $ \\ast@AstTypeDict).itemTypeValue\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%rac) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rak) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rav) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.ret_)\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeGen\n\u0009\u0009\u0009\u0009\u0009\u0009assert(varType $ \\ast@AstTypeGen).kind = %list_\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do type.itemType :: (varType $ \\ast@AstTypeGen).itemType\n\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: type\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%rak) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rac) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rav) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.ret_)\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do type.itemType :: (varType $ \\ast@AstTypeDict).itemTypeKey\n\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: type\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(func_.funcOption.and(%rav) <> %none)\n\u0009\u0009\u0009\u0009\u0009if(dbg)\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%any) <> %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rme) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rch) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rac) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert func_.funcOption.and(%rak) = %none\n\u0009\u0009\u0009\u0009\u0009\u0009assert \\ast@isInt(func_.ret_)\n\u0009\u0009\u0009\u0009\u0009\u0009assert varType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, ast.pos)\n\u0009\u0009\u0009\u0009\u0009do type.itemType :: (varType $ \\ast@AstTypeDict).itemTypeValue\n\u0009\u0009\u0009\u0009\u0009do func_.ret_ :: type\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009\n\u0009\u0009\u0009do ast.refItem :: expr\n\u0009\u0009\u0009do ast.type :: expr.type\n\u0009\u0009\u0009do ast.varKind :: %value\n\u0009\u0009\u0009ret ast\n\u0009\u0009end if\n\u0009end if\n\u0009do \\err@err(%memberNotExist, ast.pos, [ast.member])\n\u0009ret null\nend func\n\nfunc rebuildExprValue(ast: \\ast@AstExprValue): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009assert ast.typeId = %exprValue\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprValuePrim(ast: \\ast@AstExprValuePrim): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprValueStr(ast: \\ast@AstExprValueStr): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprValueEnumElement(ast: \\ast@AstExprValueEnumElement): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprValueFloat(ast: \\ast@AstExprValueFloat): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprValueArray(ast: \\ast@AstExprValueArray): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009assert ast.type =& null\n\u0009\n\u0009block\n\u0009\u0009var nullSet: bool :: false\n\u0009\u0009var enumSet: bool :: false\n\u0009\u0009var items: list<\\ast@AstExpr> :: ast.values\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var data: \\ast@AstExpr :: items.get()\n\u0009\u0009\u0009do data :: @rebuildExpr(data, false)\n\u0009\u0009\u0009if(data =& null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var dataType: \\ast@AstType :: data.type\n\u0009\u0009\u0009\u0009if(ast.type =& null)\n\u0009\u0009\u0009\u0009\u0009if(dataType.typeId = %typeNull)\n\u0009\u0009\u0009\u0009\u0009\u0009if(enumSet)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%elementTypesOfArrayInitNotMatch, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do nullSet :: true\n\u0009\u0009\u0009\u0009\u0009elif(dataType.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009\u0009\u0009if(nullSet)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%nullForValueTypeArrayInit, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do enumSet :: true\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009; Determine the type of the array initializer when a value other than \'null\' is specified.\n\u0009\u0009\u0009\u0009\u0009\u0009if(nullSet & !\\ast@isNullable(dataType))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%nullForValueTypeArrayInit, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009if(enumSet & !\\ast@isEnum(dataType))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%elementTypesOfArrayInitNotMatch, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeArray, dataType.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do type.itemType :: dataType\n\u0009\u0009\u0009\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009elif(!@cmpType((ast.type $ \\ast@AstTypeArray).itemType, dataType, false))\n\u0009\u0009\u0009\u0009\u0009; The types of the second and subsequent elements of the array initializer do not match the type of the first element.\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%elementTypesOfArrayInitNotMatch, ast.pos, null)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do items.ins(data)\n\u0009\u0009\u0009do items.del()\n\u0009\u0009end while\n\u0009\u0009if(ast.type =& null)\n\u0009\u0009\u0009if(enumSet)\n\u0009\u0009\u0009\u0009do \\err@err(%allElementsAreEnum, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do \\err@err(%allElementsAreNull, ast.pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009if(\\ast@isEnum((ast.type $ \\ast@AstTypeArray).itemType))\n\u0009\u0009var items: list<\\ast@AstExpr> :: ast.values\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstExpr :: items.get()\n\u0009\u0009\u0009if(item.type.typeId = %typeEnumElement)\n\u0009\u0009\u0009\u0009do item :: @rebuildEnumElement(item, (ast.type $ \\ast@AstTypeArray).itemType)\n\u0009\u0009\u0009\u0009do items.ins(item)\n\u0009\u0009\u0009\u0009do items.del()\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end if\n\u0009\u0009end while\n\u0009end if\n\u0009\n\u0009if(\\ast@isStr(ast.type))\n\u0009\u0009; Replace constants consisting only of characters with string literals.\n\u0009\u0009var isConst: bool :: true\n\u0009\u0009block\n\u0009\u0009\u0009var items: list<\\ast@AstExpr> :: ast.values\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while loop(!items.term())\n\u0009\u0009\u0009\u0009if(items.get().typeId <> %exprValue)\n\u0009\u0009\u0009\u0009\u0009do isConst :: false\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009if(isConst)\n\u0009\u0009\u0009var ast2: \\ast@AstExprValueStr :: #\\ast@AstExprValueStr\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprValueStr, ast.pos)\n\u0009\u0009\u0009do ast2.type :: ast.type\n\u0009\u0009\u0009var s: []char :: #[^ast.values]char\n\u0009\u0009\u0009var idx: int :: 0\n\u0009\u0009\u0009var items: list<\\ast@AstExpr> :: ast.values\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009do s[idx] :: (items.get() $ \\ast@AstExprValuePrim).value $ char\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do ast2.value :: s\n\u0009\u0009\u0009do ast2 :: @rebuildExprValueStr(ast2) $ \\ast@AstExprValueStr\n\u0009\u0009\u0009do ast.extra :: ast\n\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009end if\n\u0009end if\n\u0009\n\u0009do ast.varKind :: %value\n\u0009ret ast\nend func\n\nfunc rebuildExprRef(ast: \\ast@AstExpr): \\ast@AstExpr\n\u0009if(ast.extra <>& null)\n\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009end if\n\u0009do ast.extra :: ast\n\u0009\n\u0009assert ast.typeId = %exprRef\n\u0009var refItem: \\ast@Ast :: ast.refItem\n\u0009if(refItem =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009switch(refItem.typeId)\n\u0009case %func_\n\u0009\u0009var func_: \\ast@AstFunc :: ast.refItem $ \\ast@AstFunc\n\u0009\u0009do @rebuildFunc(func_)\n\u0009\u0009block\n\u0009\u0009\u0009var type: \\ast@AstTypeFunc :: #\\ast@AstTypeFunc\n\u0009\u0009\u0009do @initAst(type, %typeFunc, ast.pos)\n\u0009\u0009\u0009do type.funcOption :: func_.funcOption\n\u0009\u0009\u0009do type.funcAttr :: func_.funcAttr\n\u0009\u0009\u0009do type.args :: #list<\\ast@AstTypeFuncArg>\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var items: list<\\ast@AstArg> :: func_.args\n\u0009\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: items.get()\n\u0009\u0009\u0009\u0009\u0009var arg2: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009do arg2.refVar :: arg.refVar\n\u0009\u0009\u0009\u0009\u0009do arg2.arg :: arg.type\n\u0009\u0009\u0009\u0009\u0009do type.args.add(arg2)\n\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do type.ret_ :: func_.ret_\n\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009end block\n\u0009\u0009do ast.varKind :: %value\n\u0009case %arg\n\u0009\u0009var arg: \\ast@AstArg :: ast.refItem $ \\ast@AstArg\n\u0009\u0009do @rebuildArg(arg)\n\u0009\u0009switch(arg.kind)\n\u0009\u0009case %global\n\u0009\u0009\u0009do ast.type :: arg.type\n\u0009\u0009\u0009do ast.varKind :: %globalVar\n\u0009\u0009case %localArg\n\u0009\u0009\u0009do ast.type :: arg.type\n\u0009\u0009\u0009do ast.varKind :: arg.refVar ?(%refVar $ \\ast@AstExprVarKind, %localVar)\n\u0009\u0009case %localVar\n\u0009\u0009\u0009do ast.type :: arg.type\n\u0009\u0009\u0009do ast.varKind :: %localVar\n\u0009\u0009case %const_\n\u0009\u0009\u0009if(arg.expr =& null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009assert arg.expr.typeId.and(%exprValue) = %exprValue\n\u0009\u0009\u0009do ast.extra :: arg.expr\n\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009case %member\n\u0009\u0009\u0009do \\err@err(%accessMemberWithoutMe, ast.pos, [ast.refName])\n\u0009\u0009\u0009ret null\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009case %statSwitch, %statFor, %statTry\n\u0009\u0009assert refItem.extra <>& null\n\u0009\u0009do ast.refItem :: (refItem $ \\ast@AstStatBreakable).blockVar\n\u0009\u0009do ast.type :: (refItem $ \\ast@AstStatBreakable).blockVar.type\n\u0009\u0009do ast.varKind :: %localVar\n\u0009default\n\u0009\u0009if(refItem.typeId.and(%expr) = %expr & refItem.extra <>& null & \\ast@isEnum((refItem.extra $ \\ast@AstExpr).type))\n\u0009\u0009\u0009do ast.extra :: refItem.extra\n\u0009\u0009\u0009ret ast.extra $ \\ast@AstExpr\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009do \\err@err(%inaccessibleElement, ast.pos, [ast.refName])\n\u0009\u0009ret null\n\u0009end switch\n\u0009ret ast\nend func\n\nfunc searchStdItem(src: []char, identifier: []char, makeExprRef: bool): \\ast@Ast\n\u0009var ast: \\ast@Ast :: @asts.get(src, &)\n\u0009if(ast =& null)\n\u0009\u0009do \\err@err(%sysFileOpenFailed, null, [src])\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009var ast2: \\ast@Ast :: ast.scopeChildren.get(identifier, &)\n\u0009if(ast =& null)\n\u0009\u0009do \\err@err(%sysFileBroken, null, [src])\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009if(makeExprRef)\n\u0009\u0009var expr: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009do @initAstExpr(expr, %exprRef, \\pos@make(\"kuin\", 1, 1))\n\u0009\u0009do expr.refItem :: ast2\n\u0009\u0009ret @rebuildExprRef(expr)\n\u0009end if\n\u0009ret ast2\nend func\n\nfunc initAst(ast: \\ast@Ast, typeId: \\ast@TypeId, pos: \\pos@Pos)\n\u0009assert ast <>$ \\ast@AstExpr\n\u0009do @initAstImpl(ast, typeId, pos)\nend func\n\nfunc initAstExpr(ast: \\ast@AstExpr, typeId: \\ast@TypeId, pos: \\pos@Pos)\n\u0009assert ast =$ \\ast@AstExpr\n\u0009do @initAstImpl(ast, typeId, pos)\n\u0009do ast.type :: null\n\u0009do ast.varKind :: %unknown\nend func\n\nfunc initAstImpl(ast: \\ast@Ast, typeId: \\ast@TypeId, pos: \\pos@Pos)\n\u0009do ast.typeId :: typeId\n\u0009do ast.pos :: pos\n\u0009do ast.name :: null\n\u0009do ast.scopeParent :: null\n\u0009do ast.scopeChildren :: null\n\u0009do ast.refName :: null\n\u0009do ast.refItem :: null\n\u0009do ast.extra :: null\n\u0009do ast.publicInSrc :: false\nend func\n\nfunc makeExprNull(pos: \\pos@Pos): \\ast@AstExprValue\n\u0009var value: \\ast@AstExprValue :: #\\ast@AstExprValue\n\u0009do @initAstExpr(value, %exprValue, pos)\n\u0009block\n\u0009\u0009var type: \\ast@AstTypeNull :: #\\ast@AstTypeNull\n\u0009\u0009do @initAst(type, %typeNull, pos)\n\u0009\u0009do value.type :: type\n\u0009end block\n\u0009ret value\nend func\n\nfunc refreshStats(stats: list<\\ast@AstStat>, retType: \\ast@AstType, parentFunc: \\ast@AstFunc): list<\\ast@AstStat>\n\u0009var stats2: list<\\ast@AstStat> :: #list<\\ast@AstStat>\n\u0009do stats.head()\n\u0009while(!stats.term())\n\u0009\u0009var stat: \\ast@AstStat :: @rebuildStat(stats.get(), retType, parentFunc)\n\u0009\u0009if(stat <>& null)\n\u0009\u0009\u0009do stats2.add(stat)\n\u0009\u0009end if\n\u0009\u0009do stats.next()\n\u0009end while\n\u0009ret stats2\nend func\n\nfunc addSpecialFunc(class_: \\ast@AstClass, name: []char): \\ast@AstFunc\n\u0009; Make frameworks for \'_dtor\', \'_copy\', \'_toBin\', and \'_fromBin\'.\n\u0009var ast: \\ast@AstFunc :: #\\ast@AstFunc\n\u0009do @initAst(ast, %func_, class_.pos)\n\u0009do ast.name :: name\n\u0009do ast.funcOption :: %none\n\u0009do ast.funcAttr :: #list<[]char>\n\u0009do ast.args :: #list<\\ast@AstArg>\n\u0009do ast.ret_ :: null\n\u0009do ast.stats :: #list<\\ast@AstStat>\n\u0009block\n\u0009\u0009var me_: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009do @initAst(me_, %arg, class_.pos)\n\u0009\u0009do me_.kind :: %localArg\n\u0009\u0009do me_.refVar :: false\n\u0009\u0009do me_.expr :: null\n\u0009\u0009block\n\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009do @initAst(type, %typeUser, class_.pos)\n\u0009\u0009\u0009do type.refItem :: class_\n\u0009\u0009\u0009do me_.type :: type\n\u0009\u0009end block\n\u0009\u0009do ast.args.add(me_)\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009; These functions override functions of the root class.\n\u0009\u0009var item: \\ast@AstClassItem :: #\\ast@AstClassItem\n\u0009\u0009do item.override :: true\n\u0009\u0009do item.def :: ast\n\u0009\u0009do item.parentItem :: null\n\u0009\u0009var ptr: \\ast@AstClass :: class_.refItem $ \\ast@AstClass\n\u0009\u0009while(ptr.refItem <>& null)\n\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009end while\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ptr.items\n\u0009\u0009do items.head()\n\u0009\u0009while loop(!items.term())\n\u0009\u0009\u0009var item2: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item2.def.name = name)\n\u0009\u0009\u0009\u0009do item.parentItem :: item2\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009assert item.parentItem <>& null\n\u0009\u0009do item.public :: item.parentItem.public\n\u0009\u0009do class_.items.add(item)\n\u0009end block\n\u0009\n\u0009ret ast\nend func\n\nfunc cmpType(type1: \\ast@AstType, type2: \\ast@AstType, strict: bool): bool\n\u0009if(type1 =& null | type2 =& null)\n\u0009\u0009ret false\n\u0009end if\n\u0009var typeId1: \\ast@TypeId :: type1.typeId\n\u0009var typeId2: \\ast@TypeId :: type2.typeId\n\u0009block\n\u0009\u0009; Comparing \'null\' and \'nullable\' should be true.\n\u0009\u0009var nullable1: bool :: typeId1 = %typeUser & type1.refItem.typeId = %enum_ ?(false, typeId1.and(%typeNullable) = %typeNullable)\n\u0009\u0009var nullable2: bool :: typeId2 = %typeUser & type2.refItem.typeId = %enum_ ?(false, typeId2.and(%typeNullable) = %typeNullable)\n\u0009\u0009if(nullable1 & typeId2 = %typeNull | typeId1 = %typeNull & nullable2 | typeId1 = %typeNull & typeId2 = %typeNull)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009end block\n\u0009if(typeId1 = %typeArray & typeId2 = %typeArray)\n\u0009\u0009ret @cmpType((type1 $ \\ast@AstTypeArray).itemType, (type2 $ \\ast@AstTypeArray).itemType, true)\n\u0009end if\n\u0009if(typeId1 = %typeBit & typeId2 = %typeBit)\n\u0009\u0009ret(type1 $ \\ast@AstTypeBit).size = (type2 $ \\ast@AstTypeBit).size\n\u0009end if\n\u0009if(typeId1 = %typeFunc & typeId2 = %typeFunc)\n\u0009\u0009var func1: \\ast@AstTypeFunc :: type1 $ \\ast@AstTypeFunc\n\u0009\u0009var func2: \\ast@AstTypeFunc :: type2 $ \\ast@AstTypeFunc\n\u0009\u0009; TODO:\n\u0009\u0009{\n\u0009\u0009if(func1.funcOption <> func2.funcOption)\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009var attrs1: list<[]char> :: func1.funcAttr\n\u0009\u0009var attrs2: list<[]char> :: func2.funcAttr\n\u0009\u0009do attrs1.head()\n\u0009\u0009do attrs2.head()\n\u0009\u0009while(!attrs1.term() & !attrs2.term())\n\u0009\u0009\u0009if(attrs1.get() <> attrs2.get())\n\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do attrs1.next()\n\u0009\u0009\u0009do attrs2.next()\n\u0009\u0009end while\n\u0009\u0009if(!(attrs1.term() & attrs2.term()))\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009}\n\u0009\u0009var args1: list<\\ast@AstTypeFuncArg> :: func1.args\n\u0009\u0009var args2: list<\\ast@AstTypeFuncArg> :: func2.args\n\u0009\u0009do args1.head()\n\u0009\u0009do args2.head()\n\u0009\u0009while(!args1.term() & !args2.term())\n\u0009\u0009\u0009var arg1: \\ast@AstTypeFuncArg :: args1.get()\n\u0009\u0009\u0009var arg2: \\ast@AstTypeFuncArg :: args2.get()\n\u0009\u0009\u0009if(arg1.refVar <> arg2.refVar | !@cmpType(arg1.arg, arg2.arg, true))\n\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do args1.next()\n\u0009\u0009\u0009do args2.next()\n\u0009\u0009end while\n\u0009\u0009if(!(args1.term() & args2.term()))\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009if(func1.ret_ =& null & func2.ret_ =& null)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009\u0009if(func1.ret_ =& null | func2.ret_ =& null)\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009ret @cmpType(func1.ret_, func2.ret_, true)\n\u0009end if\n\u0009if(typeId1 = %typeGen & typeId2 = %typeGen)\n\u0009\u0009if((type1 $ \\ast@AstTypeGen).kind <> (type2 $ \\ast@AstTypeGen).kind)\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009ret @cmpType((type1 $ \\ast@AstTypeGen).itemType, (type2 $ \\ast@AstTypeGen).itemType, true)\n\u0009end if\n\u0009if(typeId1 = %typeDict & typeId2 = %typeDict)\n\u0009\u0009var dict1: \\ast@AstTypeDict :: type1 $ \\ast@AstTypeDict\n\u0009\u0009var dict2: \\ast@AstTypeDict :: type2 $ \\ast@AstTypeDict\n\u0009\u0009ret @cmpType(dict1.itemTypeKey, dict2.itemTypeKey, true) & @cmpType(dict1.itemTypeValue, dict2.itemTypeValue, true)\n\u0009end if\n\u0009if(typeId1 = %typePrim & typeId2 = %typePrim)\n\u0009\u0009ret(type1 $ \\ast@AstTypePrim).kind = (type2 $ \\ast@AstTypePrim).kind\n\u0009end if\n\u0009if(typeId1 = %typeUser & typeId2 = %typeUser)\n\u0009\u0009assert type1.refItem.typeId <> %alias_ & type2.refItem.typeId <> %alias_\n\u0009\u0009if(type1.refItem.typeId = %class_ & type2.refItem.typeId = %class_)\n\u0009\u0009\u0009if(strict)\n\u0009\u0009\u0009\u0009ret type1.refItem $ \\ast@AstClass =& type2.refItem $ \\ast@AstClass\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009; Check whether they are parent-child relationship.\n\u0009\u0009\u0009\u0009var class1: \\ast@AstClass :: type1.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009var class2: \\ast@AstClass :: type2.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009var ptr: \\ast@AstClass\n\u0009\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009\u0009{\n\u0009\u0009\u0009\u0009do ptr :: class2\n\u0009\u0009\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009\u0009\u0009if(ptr =& class1)\n\u0009\u0009\u0009\u0009\u0009\u0009ret true\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009}\n\u0009\u0009\u0009\u0009do ptr :: class1\n\u0009\u0009\u0009\u0009while(ptr <>& null)\n\u0009\u0009\u0009\u0009\u0009if(ptr =& class2)\n\u0009\u0009\u0009\u0009\u0009\u0009ret true\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do ptr :: ptr.refItem $ \\ast@AstClass\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009ret type1.refItem =& type2.refItem\n\u0009end if\n\u0009if((typeId1 = %typeUser & type1.refItem.typeId = %enum_ | typeId1 = %typeEnumElement) &\n\u0009\u0009|(typeId2 = %typeUser & type2.refItem.typeId = %enum_ | typeId2 = %typeEnumElement) &\n\u0009\u0009|!(typeId1 = %typeEnumElement & typeId2 = %typeEnumElement))\n\u0009\u0009ret true\n\u0009end if\n\u0009ret false\nend func\n\nfunc makeMeDot(class_: \\ast@AstClass, arg: \\ast@AstArg, name: []char): \\ast@AstExprDot\n\u0009var ast: \\ast@AstExprDot :: #\\ast@AstExprDot\n\u0009do @initAstExpr(ast, %exprDot, class_.pos)\n\u0009do ast.member :: name\n\u0009do ast.classItem :: null\n\u0009block\n\u0009\u0009var me_: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009do @initAstExpr(me_, %exprRef, class_.pos)\n\u0009\u0009do me_.refName :: \"me\"\n\u0009\u0009do me_.refItem :: arg\n\u0009\u0009block\n\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009do @initAst(type, %typeUser, class_.pos)\n\u0009\u0009\u0009do type.refItem :: class_\n\u0009\u0009\u0009do me_.type :: type\n\u0009\u0009end block\n\u0009\u0009do ast.var_ :: me_\n\u0009end block\n\u0009ret ast\nend func\n\nfunc isComparable(type: \\ast@AstType, lessOrGreater: bool): bool\n\u0009; Note: \'null\' itself is an incomparable type.\n\u0009; The following types can be compared.\n\u0009if(type.typeId = %typeBit | \\ast@isInt(type) | \\ast@isFloat(type) | \\ast@isChar(type) | \\ast@isEnum(type) | \\ast@isClass(type) | \\ast@isStr(type) | type.typeId = %typeEnumElement)\n\u0009\u0009ret true\n\u0009end if\n\u0009\n\u0009; \'bool\' can be just determined whether the values match.\n\u0009if(!lessOrGreater & \\ast@isBool(type))\n\u0009\u0009ret true\n\u0009end if\n\u0009ret false\nend func\n\nfunc searchEnumElementValue(ast: \\ast@AstExprValueEnumElement, enum_: \\ast@AstEnum): bit64\n\u0009assert ast.type.typeId = %typeEnumElement\n\u0009do @rebuildEnum(enum_)\n\u0009var name: []char :: ast.identifier\n\u0009var items: list<\\ast@AstExpr> :: enum_.items\n\u0009do items.head()\n\u0009while(!items.term())\n\u0009\u0009var item: \\ast@AstExpr :: items.get()\n\u0009\u0009if(name = item.name)\n\u0009\u0009\u0009if(item.typeId <> %exprValuePrim)\n\u0009\u0009\u0009\u0009ret 0b64\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009ret(item $ \\ast@AstExprValuePrim).value\n\u0009\u0009end if\n\u0009\u0009do items.next()\n\u0009end while\n\u0009do \\err@err(%notExistedElementName, ast.pos, [name])\n\u0009ret 0b64\nend func\n\nfunc cacheSubExpr(stats: list<\\ast@AstStat>, ast: \\ast@AstExpr, pos: \\pos@Pos): \\ast@AstExpr\n\u0009if(ast =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009if(ast.typeId = %exprRef | ast.typeId.and(%exprValue) = %exprValue)\n\u0009\u0009ret ast\n\u0009end if\n\u0009var ref: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009do @initAstExpr(ref, %exprRef, pos)\n\u0009do ref.refName :: \"$\"\n\u0009do ref.varKind :: %localVar\n\u0009do ref.extra :: ref\n\u0009block\n\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009do @initAst(arg, %arg, pos)\n\u0009\u0009do arg.kind :: %localVar\n\u0009\u0009do arg.refVar :: false\n\u0009\u0009do arg.type :: ast.type\n\u0009\u0009do arg.expr :: null\n\u0009\u0009do arg.extra :: arg\n\u0009\u0009do ref.refItem :: arg\n\u0009\u0009do ref.type :: arg.type\n\u0009end block\n\u0009block\n\u0009\u0009var do_: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009\u0009do @initAst(do_, %statDo, pos)\n\u0009\u0009block\n\u0009\u0009\u0009var exprAssign: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(exprAssign, %expr2, pos)\n\u0009\u0009\u0009do exprAssign.kind :: %assign\n\u0009\u0009\u0009do exprAssign.children0 :: ref\n\u0009\u0009\u0009do exprAssign.children1 :: ast\n\u0009\u0009\u0009do do_.expr :: exprAssign\n\u0009\u0009end block\n\u0009\u0009do stats.add(@rebuildDo(do_))\n\u0009end block\n\u0009ret ref\nend func\n\nfunc bitCast(size: int, n: bit64): bit64\n\u0009switch(size)\n\u0009case 1\n\u0009\u0009ret n $ bit8 $ bit64\n\u0009case 2\n\u0009\u0009ret n $ bit16 $ bit64\n\u0009case 4\n\u0009\u0009ret n $ bit32 $ bit64\n\u0009case 8\n\u0009\u0009ret n\n\u0009\u0009assert false\n\u0009end switch\n\u0009ret 0b64\nend func\n\nfunc getTypeName(type: \\ast@AstType): []char\n\u0009if(type =& null)\n\u0009\u0009ret \"\"\n\u0009end if\n\u0009switch(type.typeId)\n\u0009case %typeArray\n\u0009\u0009ret \"[]\" ~ @getTypeName((type $ \\ast@AstTypeArray).itemType)\n\u0009case %typeBit\n\u0009\u0009ret \"bit\" ~ ((type $ \\ast@AstTypeBit).size * 8).toStr()\n\u0009case %typeFunc\n\u0009\u0009var type2: \\ast@AstTypeFunc :: type $ \\ast@AstTypeFunc\n\u0009\u0009var s: []char :: \"func<(\"\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstTypeFuncArg> :: type2.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var arg: \\ast@AstTypeFuncArg :: items.get()\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do s :~ \", \"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(arg.refVar)\n\u0009\u0009\u0009\u0009do s :~ \"&\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do s :~ @getTypeName(arg.arg)\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009if(type2.ret_ =& null)\n\u0009\u0009\u0009do s :~ \")>\"\n\u0009\u0009else\n\u0009\u0009\u0009do s :~ \"): \" ~ @getTypeName(type2.ret_) ~ \">\"\n\u0009\u0009end if\n\u0009\u0009ret s\n\u0009case %typeGen\n\u0009\u0009var type2: \\ast@AstTypeGen :: type $ \\ast@AstTypeGen\n\u0009\u0009var s: []char\n\u0009\u0009switch(type2.kind)\n\u0009\u0009case %list_\n\u0009\u0009\u0009do s :: \"list<\"\n\u0009\u0009case %stack_\n\u0009\u0009\u0009do s :: \"stack<\"\n\u0009\u0009case %queue_\n\u0009\u0009\u0009do s :: \"queue<\"\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009ret s ~ @getTypeName(type2.itemType) ~ \">\"\n\u0009case %typeDict\n\u0009\u0009var type2: \\ast@AstTypeDict :: type $ \\ast@AstTypeDict\n\u0009\u0009ret \"dict<\" ~ @getTypeName(type2.itemTypeKey) ~ \", \" ~ @getTypeName(type2.itemTypeValue) ~ \">\"\n\u0009case %typePrim\n\u0009\u0009var type2: \\ast@AstTypePrim :: type $ \\ast@AstTypePrim\n\u0009\u0009switch(type2.kind)\n\u0009\u0009case %int_\n\u0009\u0009\u0009ret \"int\"\n\u0009\u0009case %float_\n\u0009\u0009\u0009ret \"float\"\n\u0009\u0009case %char_\n\u0009\u0009\u0009ret \"char\"\n\u0009\u0009case %bool_\n\u0009\u0009\u0009ret \"bool\"\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009case %typeUser\n\u0009\u0009ret(type.refName = \"@\" ?(type.pos.srcName, \"\")) ~ type.refName\n\u0009case %typeEnumElement\n\u0009\u0009ret \"(UNKNOWN)\"\n\u0009default\n\u0009\u0009assert false\n\u0009\u0009ret \"\"\n\u0009end switch\nend func\n":true;
else if(p==="res/ast.kn")
return f?"+enum TypeId\n\u0009none :: 0x00\n\u0009root :: 0x01\n\u0009func_ :: 0x0100\n\u0009var_ :: 0x02\n\u0009const_ :: 0x03\n\u0009alias_ :: 0x04\n\u0009class_ :: 0x05\n\u0009enum_ :: 0x06\n\u0009arg :: 0x07\n\u0009stat :: 0x0200\n\u0009statBreakable :: 0x00010200\n\u0009statSkipable :: 0x01010200\n\u0009statEnd :: 0x0201\n\u0009statFunc :: 0x0202\n\u0009statVar :: 0x0203\n\u0009statConst :: 0x0204\n\u0009statAlias :: 0x0205\n\u0009statClass :: 0x0206\n\u0009statEnum :: 0x0207\n\u0009statIf :: 0x00010201\n\u0009statElIf :: 0x0208\n\u0009statElse :: 0x0209\n\u0009statSwitch :: 0x00010202\n\u0009statCase :: 0x020A\n\u0009statDefault :: 0x020B\n\u0009statWhile :: 0x01010201\n\u0009statFor :: 0x01010202\n\u0009statTry :: 0x00010203\n\u0009statCatch :: 0x020C\n\u0009statFinally :: 0x020D\n\u0009statThrow :: 0x020E\n\u0009statBlock :: 0x00010204\n\u0009statRet :: 0x020F\n\u0009statDo :: 0x0210\n\u0009statBreak :: 0x0211\n\u0009statSkip :: 0x0212\n\u0009statAssert :: 0x0213\n\u0009type :: 0x0400\n\u0009typeNullable :: 0x00010400\n\u0009typeArray :: 0x00010401\n\u0009typeBit :: 0x0401\n\u0009typeFunc :: 0x00010402\n\u0009typeGen :: 0x00010403\n\u0009typeDict :: 0x00010404\n\u0009typePrim :: 0x0402\n\u0009typeUser :: 0x00010405\n\u0009typeNull :: 0x0403\n\u0009typeEnumElement :: 0x0404\n\u0009expr :: 0x0800\n\u0009expr1 :: 0x0801\n\u0009expr2 :: 0x0802\n\u0009expr3 :: 0x0803\n\u0009exprNew :: 0x0804\n\u0009exprNewArray :: 0x0805\n\u0009exprAs :: 0x0806\n\u0009exprToBin :: 0x0807\n\u0009exprFromBin :: 0x0808\n\u0009exprCall :: 0x0809\n\u0009exprArray :: 0x080A\n\u0009exprDot :: 0x080B\n\u0009exprValue :: 0x00010800\n\u0009exprValuePrim :: 0x00010801\n\u0009exprValueStr :: 0x00010802\n\u0009exprValueEnumElement :: 0x00010803\n\u0009exprValueFloat :: 0x00010804\n\u0009exprValueArray :: 0x080C\n\u0009exprRef :: 0x080E\n\u0009info :: 0x10000000\nend enum\n\n+class HasType()\n\u0009+var typeId: @TypeId\nend class\n\n+class Ast(@HasType)\n\u0009+*func cmp(t: @Ast): int\n\u0009\u0009var meAddr: bit64 :: lib@addr(me)\n\u0009\u0009var tAddr: bit64 :: lib@addr(t)\n\u0009\u0009ret meAddr > tAddr ?(1, meAddr < tAddr ?(-1, 0))\n\u0009end func\n\u0009\n\u0009+var pos: \\pos@Pos\n\u0009+var name: []char\n\u0009+var scopeParent: @Ast\n\u0009+var scopeChildren: dict<[]char, @Ast>\n\u0009+var refName: []char\n\u0009+var refItem: @Ast\n\u0009+var extra: @HasType {\'AnalyzedCache\' etc.}\n\u0009+var publicInSrc: bool\nend class\n\n+class ScopeRefedItem()\n\u0009+var def: @Ast\n\u0009+var scope: @Ast\nend class\n\n+class AstRoot(@Ast)\n\u0009+var items: list<@Ast>\n\u0009+var scopeRefedItems: list<@ScopeRefedItem>\nend class\n\n+enum AstFuncOption\n\u0009none :: 0x00\n\u0009any :: 0x01 {Ignore type checking of \'me\' and the add the type of it to the second argument.}\n\u0009tme :: 0x02 {The function receives a value of the same type as \'me\' in the third argument.}\n\u0009rme :: 0x04 {The function returns a value of the same type as \'me\'.}\n\u0009tch :: 0x08 {The function receives a value of the type of elements of \'me\' in the third argument.}\n\u0009rch :: 0x10 {The function returns a value of the type of elements of \'me\'.}\n\u0009tkv :: 0x20 {The function receives a value of the type of \'key\' in the third argument and a value of the type of \'value\' in the fourth.}\n\u0009rac :: 0x40 {The function returns an array of the type of list elements of \'me\'.}\n\u0009frc :: 0x0080 {Force to define a method that cannot be overridden.}\n\u0009kvf :: 0x0100 {The function receives a callback function that receives key-value pairs.}\n\u0009rak :: 0x0200 {Return array of dictionary key.}\n\u0009rav :: 0x0400 {Return array of dictionary value.}\n\u0009mki :: 0x0800 {Make an instance automatically.}\n\u0009raw :: 0x1000 {Raw function.}\nend enum\n\n+class AstFunc(@Ast)\n\u0009+var funcOption: @AstFuncOption\n\u0009+var funcAttr: list<[]char>\n\u0009+var args: list<@AstArg>\n\u0009+var ret_: @AstType\n\u0009+var stats: list<@AstStat>\nend class\n\n+class AstVar(@Ast)\n\u0009+var arg: @AstArg\nend class\n\n+class AstConst(@Ast)\n\u0009+var arg: @AstArg\nend class\n\n+class AstAlias(@Ast)\n\u0009+var type: @AstType\nend class\n\n+class AstClassItem()\n\u0009+var public: bool\n\u0009+var override: bool\n\u0009+var def: @Ast\n\u0009+var parentItem: @AstClassItem\nend class\n\n+class AstClass(@Ast)\n\u0009+var items: list<@AstClassItem>\nend class\n\n+class AstEnum(@Ast)\n\u0009+var items: list<@AstExpr>\nend class\n\n+enum AstArgKind\n\u0009unknown\n\u0009global\n\u0009localArg\n\u0009localVar\n\u0009const_\n\u0009member\nend enum\n\n+class AstArg(@Ast)\n\u0009+var kind: @AstArgKind\n\u0009+var refVar: bool\n\u0009+var type: @AstType\n\u0009+var expr: @AstExpr\nend class\n\n+class AstStat(@Ast)\nend class\n\n+class AstStatBreakable(@AstStat)\n\u0009+var blockVar: @AstArg\nend class\n\n+class AstStatSkipable(@AstStatBreakable)\nend class\n\n+class AstStatFunc(@AstStat)\n\u0009+var def: @AstFunc\nend class\n\n+class AstStatVar(@AstStat)\n\u0009+var def: @AstVar\nend class\n\n+class AstStatConst(@AstStat)\n\u0009+var def: @AstConst\nend class\n\n+class AstStatAlias(@AstStat)\n\u0009+var def: @AstAlias\nend class\n\n+class AstStatClass(@AstStat)\n\u0009+var def: @AstClass\nend class\n\n+class AstStatEnum(@AstStat)\n\u0009+var def: @AstEnum\nend class\n\n+class AstStatIf(@AstStatBreakable)\n\u0009+var cond: @AstExpr\n\u0009+var statBlock: @AstStatBlock\n\u0009+var elIfs: list<@AstStatElIf>\n\u0009+var elseStatBlock: @AstStatBlock\nend class\n\n+class AstStatElIf(@AstStat)\n\u0009+var cond: @AstExpr\n\u0009+var statBlock: @AstStatBlock\nend class\n\n+class AstStatSwitch(@AstStatBreakable)\n\u0009+var cond: @AstExpr\n\u0009+var cases: list<@AstStatCase>\n\u0009+var defaultStatBlock: @AstStatBlock\nend class\n\n+class ExprPair()\n\u0009+var expr0: @AstExpr\n\u0009+var expr1: @AstExpr\nend class\n\n+class AstStatCase(@AstStat)\n\u0009+var conds: list<@ExprPair>\n\u0009+var statBlock: @AstStatBlock\nend class\n\n+class AstStatWhile(@AstStatSkipable)\n\u0009+var cond: @AstExpr\n\u0009+var skip_: bool\n\u0009+var stats: list<@AstStat>\nend class\n\n+class AstStatFor(@AstStatSkipable)\n\u0009+var start: @AstExpr\n\u0009+var cond: @AstExpr\n\u0009+var step: @AstExpr\n\u0009+var stats: list<@AstStat>\nend class\n\n+class AstStatTry(@AstStatBreakable)\n\u0009+var statBlock: @AstStatBlock\n\u0009+var catches: list<@AstStatCatch>\n\u0009+var finallyStatBlock: @AstStatBlock\nend class\n\n+class AstStatCatch(@AstStat)\n\u0009+var conds: list<@ExprPair>\n\u0009+var statBlock: @AstStatBlock\nend class\n\n+class AstStatThrow(@AstStat)\n\u0009+var code: @AstExpr\nend class\n\n+class AstStatBlock(@AstStatBreakable)\n\u0009+var stats: list<@AstStat>\nend class\n\n+class AstStatRet(@AstStat)\n\u0009+var value: @AstExpr\nend class\n\n+class AstStatDo(@AstStat)\n\u0009+var expr: @AstExpr\nend class\n\n+class AstStatAssert(@AstStat)\n\u0009+var cond: @AstExpr\nend class\n\n+class AstType(@Ast)\nend class\n\n+class AstTypeNullable(@AstType)\nend class\n\n+class AstTypeArray(@AstTypeNullable)\n\u0009+var itemType: @AstType\nend class\n\n+class AstTypeBit(@AstType)\n\u0009+var size: int\nend class\n\n+class AstTypeFuncArg()\n\u0009+var arg: @AstType\n\u0009+var refVar: bool\nend class\n\n+class AstTypeFunc(@AstTypeNullable)\n\u0009+var funcOption: @AstFuncOption\n\u0009+var funcAttr: list<[]char>\n\u0009+var args: list<@AstTypeFuncArg>\n\u0009+var ret_: @AstType\nend class\n\n+enum AstTypeGenKind\n\u0009list_\n\u0009stack_\n\u0009queue_\nend enum\n\n+class AstTypeGen(@AstTypeNullable)\n\u0009+var kind: @AstTypeGenKind\n\u0009+var itemType: @AstType\nend class\n\n+class AstTypeDict(@AstTypeNullable)\n\u0009+var itemTypeKey: @AstType\n\u0009+var itemTypeValue: @AstType\nend class\n\n+enum AstTypePrimKind\n\u0009int_\n\u0009float_\n\u0009char_\n\u0009bool_\nend enum\n\n+class AstTypePrim(@AstType)\n\u0009+var kind: @AstTypePrimKind\nend class\n\n+class AstTypeUser(@AstTypeNullable)\nend class\n\n+class AstTypeNull(@AstType)\nend class\n\n+class AstTypeEnumElement(@AstType)\nend class\n\n+enum AstExprVarKind\n\u0009unknown\n\u0009value\n\u0009localVar\n\u0009globalVar\n\u0009refVar\nend enum\n\n+class AstExpr(@Ast)\n\u0009+var type: @AstType\n\u0009+var varKind: @AstExprVarKind\nend class\n\n+enum AstExpr1Kind\n\u0009plus\n\u0009minus\n\u0009not\n\u0009copy\n\u0009len\nend enum\n\n+class AstExpr1(@AstExpr)\n\u0009+var kind: @AstExpr1Kind\n\u0009+var child: @AstExpr\nend class\n\n+enum AstExpr2Kind\n\u0009assign\n\u0009assignAdd\n\u0009assignSub\n\u0009assignMul\n\u0009assignDiv\n\u0009assignMod\n\u0009assignPow\n\u0009assignCat\n\u0009or\n\u0009and\n\u0009lt\n\u0009gt\n\u0009le\n\u0009ge\n\u0009eq\n\u0009nEq\n\u0009eqRef\n\u0009nEqRef\n\u0009cat\n\u0009add\n\u0009sub\n\u0009mul\n\u0009div\n\u0009mod\n\u0009pow\n\u0009swap\nend enum\n\n+class AstExpr2(@AstExpr)\n\u0009+var kind: @AstExpr2Kind\n\u0009+var children0: @AstExpr\n\u0009+var children1: @AstExpr\nend class\n\n+class AstExpr3(@AstExpr)\n\u0009+var children0: @AstExpr\n\u0009+var children1: @AstExpr\n\u0009+var children2: @AstExpr\nend class\n\n+class AstExprNew(@AstExpr)\n\u0009+var itemType: @AstType\nend class\n\n+class AstExprNewArray(@AstExpr)\n\u0009+var idces: list<@AstExpr>\n\u0009+var itemType: @AstType\nend class\n\n+enum AstExprAsKind\n\u0009as\n\u0009is\n\u0009nIs\nend enum\n\n+class AstExprAs(@AstExpr)\n\u0009+var kind: @AstExprAsKind\n\u0009+var child: @AstExpr\n\u0009+var childType: @AstType\nend class\n\n+class AstExprToBin(@AstExpr)\n\u0009+var child: @AstExpr\n\u0009+var childType: @AstType\nend class\n\n+class AstExprFromBin(@AstExpr)\n\u0009+var child: @AstExpr\n\u0009+var childType: @AstType\n\u0009+var offset: @AstExpr\nend class\n\n+class AstExprCallArg()\n\u0009+var arg: @AstExpr\n\u0009+var refVar: bool\n\u0009+var skipVar: bool\nend class\n\n+class AstExprCall(@AstExpr)\n\u0009+var func_: @AstExpr\n\u0009+var args: list<@AstExprCallArg>\nend class\n\n+class AstExprArray(@AstExpr)\n\u0009+var var_: @AstExpr\n\u0009+var idx: @AstExpr\nend class\n\n+class AstExprDot(@AstExpr)\n\u0009+var var_: @AstExpr\n\u0009+var member: []char\n\u0009+var classItem: @AstClassItem {For caching to store class references.}\nend class\n\n+class AstExprValue(@AstExpr)\nend class\n\n+class AstExprValuePrim(@AstExprValue)\n\u0009+var value: bit64\nend class\n\n+class AstExprValueStr(@AstExprValue)\n\u0009+var value: []char\nend class\n\n+class AstExprValueEnumElement(@AstExprValue)\n\u0009+var identifier: []char\nend class\n\n+class AstExprValueFloat(@AstExprValue)\n\u0009+var value: float\nend class\n\n+class AstExprValueArray(@AstExpr)\n\u0009+var values: list<@AstExpr>\nend class\n\n+func isInt(type: @AstType): bool\n\u0009ret type.typeId = %typePrim & (type $ @AstTypePrim).kind = %int_\nend func\n\n+func isFloat(type: @AstType): bool\n\u0009ret type.typeId = %typePrim & (type $ @AstTypePrim).kind = %float_\nend func\n\n+func isChar(type: @AstType): bool\n\u0009ret type.typeId = %typePrim & (type $ @AstTypePrim).kind = %char_\nend func\n\n+func isBool(type: @AstType): bool\n\u0009ret type.typeId = %typePrim & (type $ @AstTypePrim).kind = %bool_\nend func\n\n+func isRef(type: @AstType): bool\n\u0009var typeId: @TypeId :: type.typeId\n\u0009ret typeId = %typeArray | typeId = %typeGen | typeId = %typeDict | @isClass(type)\nend func\n\n+func isNullable(type: @AstType): bool\n\u0009ret type.typeId.and(%typeNullable) = %typeNullable & !@isEnum(type)\nend func\n\n+func isClass(type: @AstType): bool\n\u0009ret type.typeId = %typeUser & type.refItem.typeId = %class_\nend func\n\n+func isEnum(type: @AstType): bool\n\u0009ret type.typeId = %typeUser & type.refItem.typeId = %enum_\nend func\n\n+func isStr(type: @AstType): bool\n\u0009if(type.typeId = %typeArray)\n\u0009\u0009var itemType: @AstType :: (type $ @AstTypeArray).itemType\n\u0009\u0009if(itemType.typeId = %typePrim & (itemType $ @AstTypePrim).kind = %char_)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009end if\n\u0009ret false\nend func\n":true;
else if(p==="res/builtin_func.kn")
return f?"enum BuiltinFuncKind\n\u0009toStr\n\u0009bitEnum\n\u0009char_\n\u0009bit\n\u0009array\n\u0009str\n\u0009addGenDict\n\u0009getGenDict\n\u0009list_\n\u0009peekStackQueue\n\u0009intFloat\n\u0009arrayOfStr\n\u0009dict_\n\u0009arrayList\n\u0009delListDict\nend enum\n\nvar builtinFuncs: dict<[]char, @BuiltinFuncKind>\n\n+func chkBuiltinFuncType(member: &[]char, type: \\ast@AstType): bool\n\u0009if(@builtinFuncs =& null)\n\u0009\u0009do @builtinFuncs :: #dict<[]char, @BuiltinFuncKind>\n\u0009\u0009do @builtinFuncs.add(\"abs\", %intFloat)\n\u0009\u0009do @builtinFuncs.add(\"add\", %addGenDict)\n\u0009\u0009do @builtinFuncs.add(\"and\", %bitEnum)\n\u0009\u0009do @builtinFuncs.add(\"clamp\", %intFloat)\n\u0009\u0009do @builtinFuncs.add(\"clampMax\", %intFloat)\n\u0009\u0009do @builtinFuncs.add(\"clampMin\", %intFloat)\n\u0009\u0009do @builtinFuncs.add(\"del\", %delListDict)\n\u0009\u0009do @builtinFuncs.add(\"delNext\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"endian\", %bit)\n\u0009\u0009do @builtinFuncs.add(\"exist\", %dict_)\n\u0009\u0009do @builtinFuncs.add(\"fill\", %array)\n\u0009\u0009do @builtinFuncs.add(\"find\", %arrayList)\n\u0009\u0009do @builtinFuncs.add(\"findBin\", %array)\n\u0009\u0009do @builtinFuncs.add(\"findLast\", %arrayList)\n\u0009\u0009do @builtinFuncs.add(\"findStr\", %str)\n\u0009\u0009do @builtinFuncs.add(\"findStrEx\", %str)\n\u0009\u0009do @builtinFuncs.add(\"findStrLast\", %str)\n\u0009\u0009do @builtinFuncs.add(\"forEach\", %dict_)\n\u0009\u0009do @builtinFuncs.add(\"get\", %getGenDict)\n\u0009\u0009do @builtinFuncs.add(\"getOffset\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"head\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"idx\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"ins\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"join\", %arrayOfStr)\n\u0009\u0009do @builtinFuncs.add(\"lower\", %str)\n\u0009\u0009do @builtinFuncs.add(\"max\", %array)\n\u0009\u0009do @builtinFuncs.add(\"min\", %array)\n\u0009\u0009do @builtinFuncs.add(\"moveOffset\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"next\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"not\", %bitEnum)\n\u0009\u0009do @builtinFuncs.add(\"offset\", %char_)\n\u0009\u0009do @builtinFuncs.add(\"or\", %bitEnum)\n\u0009\u0009do @builtinFuncs.add(\"peek\", %peekStackQueue)\n\u0009\u0009do @builtinFuncs.add(\"prev\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"repeat\", %array)\n\u0009\u0009do @builtinFuncs.add(\"replace\", %str)\n\u0009\u0009do @builtinFuncs.add(\"reverse\", %array)\n\u0009\u0009do @builtinFuncs.add(\"sar\", %bit)\n\u0009\u0009do @builtinFuncs.add(\"shl\", %bit)\n\u0009\u0009do @builtinFuncs.add(\"shr\", %bit)\n\u0009\u0009do @builtinFuncs.add(\"shuffle\", %array)\n\u0009\u0009do @builtinFuncs.add(\"sign\", %intFloat)\n\u0009\u0009do @builtinFuncs.add(\"sort\", %arrayList)\n\u0009\u0009do @builtinFuncs.add(\"sortDesc\", %arrayList)\n\u0009\u0009do @builtinFuncs.add(\"split\", %str)\n\u0009\u0009do @builtinFuncs.add(\"sub\", %array)\n\u0009\u0009do @builtinFuncs.add(\"tail\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"term\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"termOffset\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"toArray\", %list_)\n\u0009\u0009do @builtinFuncs.add(\"toArrayKey\", %dict_)\n\u0009\u0009do @builtinFuncs.add(\"toArrayValue\", %dict_)\n\u0009\u0009do @builtinFuncs.add(\"toBit64\", %str)\n\u0009\u0009do @builtinFuncs.add(\"toFloat\", %str)\n\u0009\u0009do @builtinFuncs.add(\"toInt\", %str)\n\u0009\u0009do @builtinFuncs.add(\"toStr\", %toStr)\n\u0009\u0009do @builtinFuncs.add(\"toStrFmt\", %intFloat)\n\u0009\u0009do @builtinFuncs.add(\"trim\", %str)\n\u0009\u0009do @builtinFuncs.add(\"trimLeft\", %str)\n\u0009\u0009do @builtinFuncs.add(\"trimRight\", %str)\n\u0009\u0009do @builtinFuncs.add(\"upper\", %str)\n\u0009\u0009do @builtinFuncs.add(\"xor\", %bitEnum)\n\u0009end if\n\u0009\n\u0009var found: bool\n\u0009var kind: @BuiltinFuncKind :: @builtinFuncs.get(member, &found)\n\u0009if(!found)\n\u0009\u0009ret false\n\u0009end if\n\u0009\n\u0009switch(kind)\n\u0009case %toStr\n\u0009\u0009if(\\ast@isInt(type) | \\ast@isFloat(type) | \\ast@isChar(type) | \\ast@isBool(type) | type.typeId = %typeBit | \\ast@isStr(type))\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %bitEnum\n\u0009\u0009if(type.typeId = %typeBit | \\ast@isEnum(type))\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %char_\n\u0009\u0009if(\\ast@isChar(type))\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %bit\n\u0009\u0009if(type.typeId = %typeBit)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %array\n\u0009\u0009if(type.typeId = %typeArray)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %str\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %addGenDict\n\u0009\u0009if(type.typeId = %typeGen)\n\u0009\u0009\u0009switch((type $ \\ast@AstTypeGen).kind)\n\u0009\u0009\u0009case %list_\n\u0009\u0009\u0009\u0009do member :: \"addList\"\n\u0009\u0009\u0009case %stack_\n\u0009\u0009\u0009\u0009do member :: \"addStack\"\n\u0009\u0009\u0009case %queue_\n\u0009\u0009\u0009\u0009do member :: \"addQueue\"\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009\u0009if(type.typeId = %typeDict)\n\u0009\u0009\u0009do member :: \"addDict\"\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %getGenDict\n\u0009\u0009if(type.typeId = %typeGen)\n\u0009\u0009\u0009switch((type $ \\ast@AstTypeGen).kind)\n\u0009\u0009\u0009case %list_\n\u0009\u0009\u0009\u0009do member :: \"getList\"\n\u0009\u0009\u0009case %stack_\n\u0009\u0009\u0009\u0009do member :: \"getStack\"\n\u0009\u0009\u0009case %queue_\n\u0009\u0009\u0009\u0009do member :: \"getQueue\"\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009\u0009if(type.typeId = %typeDict)\n\u0009\u0009\u0009do member :: \"getDict\"\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %list_\n\u0009\u0009if(type.typeId = %typeGen & (type $ \\ast@AstTypeGen).kind = %list_)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %peekStackQueue\n\u0009\u0009if(type.typeId = %typeGen)\n\u0009\u0009\u0009if((type $ \\ast@AstTypeGen).kind = %stack_)\n\u0009\u0009\u0009\u0009do member :: \"peekStack\"\n\u0009\u0009\u0009\u0009ret true\n\u0009\u0009\u0009elif((type $ \\ast@AstTypeGen).kind = %queue_)\n\u0009\u0009\u0009\u0009do member :: \"peekQueue\"\n\u0009\u0009\u0009\u0009ret true\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009case %intFloat\n\u0009\u0009if(\\ast@isInt(type))\n\u0009\u0009\u0009switch(member)\n\u0009\u0009\u0009case \"abs\"\n\u0009\u0009\u0009\u0009do member :: \"absInt\"\n\u0009\u0009\u0009case \"clamp\"\n\u0009\u0009\u0009\u0009do member :: \"clampInt\"\n\u0009\u0009\u0009case \"clampMin\"\n\u0009\u0009\u0009\u0009do member :: \"clampMinInt\"\n\u0009\u0009\u0009case \"clampMax\"\n\u0009\u0009\u0009\u0009do member :: \"clampMaxInt\"\n\u0009\u0009\u0009case \"sign\"\n\u0009\u0009\u0009\u0009do member :: \"signInt\"\n\u0009\u0009\u0009case \"toStrFmt\"\n\u0009\u0009\u0009\u0009do member :: \"toStrFmtInt\"\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009\u0009if(\\ast@isFloat(type))\n\u0009\u0009\u0009switch(member)\n\u0009\u0009\u0009case \"abs\"\n\u0009\u0009\u0009\u0009do member :: \"absFloat\"\n\u0009\u0009\u0009case \"clamp\"\n\u0009\u0009\u0009\u0009do member :: \"clampFloat\"\n\u0009\u0009\u0009case \"clampMin\"\n\u0009\u0009\u0009\u0009do member :: \"clampMinFloat\"\n\u0009\u0009\u0009case \"clampMax\"\n\u0009\u0009\u0009\u0009do member :: \"clampMaxFloat\"\n\u0009\u0009\u0009case \"sign\"\n\u0009\u0009\u0009\u0009do member :: \"signFloat\"\n\u0009\u0009\u0009case \"toStrFmt\"\n\u0009\u0009\u0009\u0009do member :: \"toStrFmtFloat\"\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %arrayOfStr\n\u0009\u0009if(type.typeId = %typeArray & \\ast@isStr((type $ \\ast@AstTypeArray).itemType))\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %dict_\n\u0009\u0009if(type.typeId = %typeDict)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %arrayList\n\u0009\u0009if(type.typeId = %typeArray)\n\u0009\u0009\u0009switch(member)\n\u0009\u0009\u0009case \"sort\"\n\u0009\u0009\u0009\u0009do member :: \"sortArray\"\n\u0009\u0009\u0009case \"sortDesc\"\n\u0009\u0009\u0009\u0009do member :: \"sortDescArray\"\n\u0009\u0009\u0009case \"find\"\n\u0009\u0009\u0009\u0009do member :: \"findArray\"\n\u0009\u0009\u0009case \"findLast\"\n\u0009\u0009\u0009\u0009do member :: \"findLastArray\"\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009\u0009if(type.typeId = %typeGen & (type $ \\ast@AstTypeGen).kind = %list_)\n\u0009\u0009\u0009switch(member)\n\u0009\u0009\u0009case \"sort\"\n\u0009\u0009\u0009\u0009do member :: \"sortList\"\n\u0009\u0009\u0009case \"sortDesc\"\n\u0009\u0009\u0009\u0009do member :: \"sortDescList\"\n\u0009\u0009\u0009case \"find\"\n\u0009\u0009\u0009\u0009do member :: \"findList\"\n\u0009\u0009\u0009case \"findLast\"\n\u0009\u0009\u0009\u0009do member :: \"findLastList\"\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009case %delListDict\n\u0009\u0009if(type.typeId = %typeGen & (type $ \\ast@AstTypeGen).kind = %list_)\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009\u0009if(type.typeId = %typeDict)\n\u0009\u0009\u0009do member :: \"delDict\"\n\u0009\u0009\u0009ret true\n\u0009\u0009end if\n\u0009end switch\n\u0009\n\u0009ret false\nend func\n":true;
else if(p==="res/convert.kn")
return f?"+enum runtimeTypeId\n\u0009int_\n\u0009float_\n\u0009char_\n\u0009bool_\n\u0009bit8_\n\u0009bit16_\n\u0009bit32_\n\u0009bit64_\n\u0009func_\n\u0009enum_\n\u0009ref :: 0x80\n\u0009array\n\u0009list_\n\u0009stack_\n\u0009queue_\n\u0009dict_\n\u0009class_\nend enum\n\n+func getTypeId(type: \\ast@AstType): list<int>\n\u0009var result: list<int> :: #list<int>\n\u0009do @makeTypeIdRecursion(type, result)\n\u0009ret result\nend func\n\nfunc makeTypeIdRecursion(type: \\ast@AstType, output: list<int>)\n\u0009if(\\ast@isInt(type))\n\u0009\u0009do output.add(%int_ $ @runtimeTypeId $ int)\n\u0009\u0009ret\n\u0009end if\n\u0009if(\\ast@isFloat(type))\n\u0009\u0009do output.add(%float_ $ @runtimeTypeId $ int)\n\u0009\u0009ret\n\u0009end if\n\u0009if(\\ast@isChar(type))\n\u0009\u0009do output.add(%char_ $ @runtimeTypeId $ int)\n\u0009\u0009ret\n\u0009end if\n\u0009if(\\ast@isBool(type))\n\u0009\u0009do output.add(%bool_ $ @runtimeTypeId $ int)\n\u0009\u0009ret\n\u0009end if\n\u0009if(type.typeId = %typeBit)\n\u0009\u0009switch((type $ \\ast@AstTypeBit).size)\n\u0009\u0009case 1\n\u0009\u0009\u0009do output.add(%bit8_ $ @runtimeTypeId $ int)\n\u0009\u0009case 2\n\u0009\u0009\u0009do output.add(%bit16_ $ @runtimeTypeId $ int)\n\u0009\u0009case 4\n\u0009\u0009\u0009do output.add(%bit32_ $ @runtimeTypeId $ int)\n\u0009\u0009case 8\n\u0009\u0009\u0009do output.add(%bit64_ $ @runtimeTypeId $ int)\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009ret\n\u0009end if\n\u0009if(type.typeId = %typeFunc)\n\u0009\u0009do output.add(%func_ $ @runtimeTypeId $ int)\n\u0009\u0009ret\n\u0009end if\n\u0009if(\\ast@isEnum(type))\n\u0009\u0009do output.add(%enum_ $ @runtimeTypeId $ int)\n\u0009\u0009ret\n\u0009end if\n\u0009if(type.typeId = %typeArray)\n\u0009\u0009do output.add(%array $ @runtimeTypeId $ int)\n\u0009\u0009do @makeTypeIdRecursion((type $ \\ast@AstTypeArray).itemType, output)\n\u0009\u0009ret\n\u0009end if\n\u0009if(type.typeId = %typeGen)\n\u0009\u0009switch((type $ \\ast@AstTypeGen).kind)\n\u0009\u0009case %list_\n\u0009\u0009\u0009do output.add(%list_ $ @runtimeTypeId $ int)\n\u0009\u0009case %stack_\n\u0009\u0009\u0009do output.add(%stack_ $ @runtimeTypeId $ int)\n\u0009\u0009case %queue_\n\u0009\u0009\u0009do output.add(%queue_ $ @runtimeTypeId $ int)\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009do @makeTypeIdRecursion((type $ \\ast@AstTypeGen).itemType, output)\n\u0009\u0009ret\n\u0009end if\n\u0009if(type.typeId = %typeDict)\n\u0009\u0009do output.add(%dict_ $ @runtimeTypeId $ int)\n\u0009\u0009do @makeTypeIdRecursion((type $ \\ast@AstTypeDict).itemTypeKey, output)\n\u0009\u0009do @makeTypeIdRecursion((type $ \\ast@AstTypeDict).itemTypeValue, output)\n\u0009\u0009ret\n\u0009end if\n\u0009assert \\ast@isClass(type)\n\u0009do output.add(%class_ $ @runtimeTypeId $ int)\nend func\n":true;
else if(p==="res/cpp/")
return f?null:true;
else if(p==="res/cpp/output.kn")
return f?"const classTableItemSize: int :: 2\n\nvar funcs: queue<\\ast@AstFunc>\nvar classes: queue<\\ast@AstClass>\n\nvar uniqueId: []char\nvar classDefs: list<[]char>\nvar funcPrototypes: list<[]char>\nvar codes: list<[]char>\nvar classFuncs: list<[]char>\nvar tmpVars: list<@TmpVar>\nvar globalVars: list<\\ast@AstArg>\nvar localVars: list<\\ast@AstArg>\nvar classTableSize: int\nvar classTable: list<[]char>\n\n+class CppInfo(\\ast@HasType)\n\u0009+var id: []char\n\u0009+var breakLabel: []char\n\u0009+var skipLabel: []char\n\u0009+var classTableOffset: int\n\u0009+var alreadyWritten: bool\n\u0009+var breakLabelUsed: bool\n\u0009+var skipLabelUsed: bool\nend class\n\nclass TmpVar()\n\u0009+var identifier: []char\n\u0009+var type: \\ast@AstType\nend class\n\n+func output(entry: \\ast@AstFunc, resFiles: list<[]char>): bool\n\u0009do @funcs :: #queue<\\ast@AstFunc>\n\u0009do @funcs.add(entry)\n\u0009do @classes :: #queue<\\ast@AstClass>\n\u0009\n\u0009do @uniqueId :: \"a\"\n\u0009do @classDefs :: #list<[]char>\n\u0009do @funcPrototypes :: #list<[]char>\n\u0009do @codes :: #list<[]char>\n\u0009do @classFuncs :: #list<[]char>\n\u0009do @tmpVars :: #list<@TmpVar>\n\u0009do @globalVars :: #list<\\ast@AstArg>\n\u0009do @localVars :: #list<\\ast@AstArg>\n\u0009do @classTableSize :: 0\n\u0009do @classTable :: #list<[]char>\n\u0009\n\u0009while(^@funcs > 0 | ^@classes > 0)\n\u0009\u0009while(^@funcs > 0)\n\u0009\u0009\u0009var func_: \\ast@AstFunc :: @funcs.get()\n\u0009\u0009\u0009do @buildFunc(func_)\n\u0009\u0009end while\n\u0009\u0009while(^@classes > 0)\n\u0009\u0009\u0009var class_: \\ast@AstClass :: @classes.get()\n\u0009\u0009\u0009do @buildClass(class_)\n\u0009\u0009end while\n\u0009end while\n\u0009\n\u0009do @write(resFiles)\n\u0009ret true\nend func\n\nfunc buildFunc(ast: \\ast@AstFunc)\n\u0009var info: @CppInfo :: @getInfo(ast)\n\u0009if(info.alreadyWritten)\n\u0009\u0009ret\n\u0009end if\n\u0009do info.alreadyWritten :: true\n\u0009\n\u0009var template: []char :: \"\"\n\u0009if(ast.funcOption.and(%any) = %any)\n\u0009\u0009if(ast.funcOption.and(%tkv) = %tkv)\n\u0009\u0009\u0009do template :: \"template<typename T_, typename K_, typename V_> \"\n\u0009\u0009elif(ast.funcOption.and(%tch) = %tch)\n\u0009\u0009\u0009if(ast.funcOption.and(%rch) = %rch)\n\u0009\u0009\u0009\u0009do template :: \"template<typename T_, typename C_, typename R_> \"\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do template :: \"template<typename T_, typename C_> \"\n\u0009\u0009\u0009end if\n\u0009\u0009elif(ast.funcOption.and(%rch) = %rch)\n\u0009\u0009\u0009do template :: \"template<typename T_, typename R_> \"\n\u0009\u0009elif(ast.funcOption.and(%kvf) = %kvf)\n\u0009\u0009\u0009do template :: \"template<typename T_, typename K_, typename V_> \"\n\u0009\u0009else\n\u0009\u0009\u0009do template :: \"template<typename T_> \"\n\u0009\u0009end if\n\u0009end if\n\u0009\n\u0009var retType: []char\n\u0009if(ast.funcOption.and(%rch) = %rch)\n\u0009\u0009do retType :: \"R_\"\n\u0009elif(ast.funcOption.and(%rme) = %rme)\n\u0009\u0009do retType :: \"T_\"\n\u0009else\n\u0009\u0009do retType :: @getType(ast.ret_)\n\u0009end if\n\u0009\n\u0009var arg: []char :: \"\"\n\u0009block\n\u0009\u0009var idx: int :: 0\n\u0009\u0009var items: list<\\ast@AstArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstArg :: items.get()\n\u0009\u0009\u0009if(idx <> 0)\n\u0009\u0009\u0009\u0009do arg :~ \", \"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009var info2: @CppInfo :: @getInfo(item)\n\u0009\u0009\u0009if(ast.funcOption.and(%any) = %any & idx = 0)\n\u0009\u0009\u0009\u0009assert \\ast@isInt(item.type)\n\u0009\u0009\u0009\u0009do arg :~ \"T_\"\n\u0009\u0009\u0009elif(ast.funcOption.and(%tkv) = %tkv & idx = 2)\n\u0009\u0009\u0009\u0009assert \\ast@isInt(item.type)\n\u0009\u0009\u0009\u0009do arg :~ \"K_\"\n\u0009\u0009\u0009elif(ast.funcOption.and(%tkv) = %tkv & idx = 3)\n\u0009\u0009\u0009\u0009assert \\ast@isInt(item.type)\n\u0009\u0009\u0009\u0009do arg :~ \"V_\"\n\u0009\u0009\u0009elif(ast.funcOption.and(%tch) = %tch & idx = 2)\n\u0009\u0009\u0009\u0009assert \\ast@isInt(item.type)\n\u0009\u0009\u0009\u0009do arg :~ \"C_\"\n\u0009\u0009\u0009elif(ast.funcOption.and(%tme) = %tme & idx = 2)\n\u0009\u0009\u0009\u0009assert \\ast@isInt(item.type)\n\u0009\u0009\u0009\u0009do arg :~ \"T_\"\n\u0009\u0009\u0009elif(ast.funcOption.and(%kvf) = %kvf & idx = 2)\n\u0009\u0009\u0009\u0009assert \\ast@isInt(item.type)\n\u0009\u0009\u0009\u0009do arg :~ \"const void*\"\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do arg :~ \"\\{@getType(item.type)}\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(item.refVar)\n\u0009\u0009\u0009\u0009do arg :~ \"*\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do arg :~ \" \\{info2.id}\"\n\u0009\u0009\u0009if(item.name <>& null)\n\u0009\u0009\u0009\u0009do arg :~ \" /*\\{item.name}*/\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009end while\n\u0009end block\n\u0009\n\u0009if(ast.name <>& null)\n\u0009\u0009do @codes.add(\"// \\{ast.name}\\n\")\n\u0009end if\n\u0009do @funcPrototypes.add(\"\\{template}static \\{retType} \\{info.id}(\\{arg});\\n\")\n\u0009do @codes.add(\"\\{template}static \\{retType} \\{info.id}(\\{arg}){\\n\")\n\u0009\n\u0009if(ast.funcOption.and(%raw) = %raw)\n\u0009\u0009if(^ast.funcAttr = 1)\n\u0009\u0009\u0009do ast.funcAttr.head()\n\u0009\u0009\u0009var hasMembers: bool :: false\n\u0009\u0009\u0009if(^ast.args > 0)\n\u0009\u0009\u0009\u0009do ast.args.head()\n\u0009\u0009\u0009\u0009var arg2: \\ast@AstArg :: ast.args.get()\n\u0009\u0009\u0009\u0009if(arg2.type.refItem <>& null & arg2.type.refItem.typeId = %class_)\n\u0009\u0009\u0009\u0009\u0009var members: list<\\ast@AstClassItem> :: (arg2.type.refItem $ \\ast@AstClass).items\n\u0009\u0009\u0009\u0009\u0009do \\cpp\\raw_funcs@write(@codes, ast.funcAttr.get(), ast.args, members)\n\u0009\u0009\u0009\u0009\u0009do hasMembers :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!hasMembers)\n\u0009\u0009\u0009\u0009do \\cpp\\raw_funcs@write(@codes, ast.funcAttr.get(), ast.args, null)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009end if\n\u0009else\n\u0009\u0009do @codes.tail()\n\u0009\u0009var localVarPos: int :: @codes.idx()\n\u0009\u0009\n\u0009\u0009do @buildStats(ast.stats, null, null)\n\u0009\u0009\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\n\u0009\u0009do @codes.head()\n\u0009\u0009do @codes.moveOffset(localVarPos)\n\u0009\u0009do @codes.next()\n\u0009\u0009do @localVars.head()\n\u0009\u0009while(!@localVars.term())\n\u0009\u0009\u0009var localVar: \\ast@AstArg :: @localVars.get()\n\u0009\u0009\u0009var info2: @CppInfo :: @getInfo(localVar)\n\u0009\u0009\u0009if(localVar.name =& null)\n\u0009\u0009\u0009\u0009do @codes.ins(\"\\{@getType(localVar.type)} \\{info2.id} = \\{@getDefaultValue(localVar.type)};\\n\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.ins(\"\\{@getType(localVar.type)} \\{info2.id} = \\{@getDefaultValue(localVar.type)}; // \\{localVar.name}\\n\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @localVars.del()\n\u0009\u0009end while\n\u0009\u0009do @tmpVars.head()\n\u0009\u0009while(!@tmpVars.term())\n\u0009\u0009\u0009var tmpVar: @TmpVar :: @tmpVars.get()\n\u0009\u0009\u0009do @codes.ins(\"\\{@getType(tmpVar.type)} \\{tmpVar.identifier} = \\{@getDefaultValue(tmpVar.type)};\\n\")\n\u0009\u0009\u0009do @tmpVars.del()\n\u0009\u0009end while\n\u0009end if\nend func\n\nfunc buildClass(ast: \\ast@AstClass)\n\u0009var parentId: []char :: null\n\u0009if(ast.refItem <>& null)\n\u0009\u0009do parentId :: @refClass(ast.refItem $ \\ast@AstClass)\n\u0009end if\n\u0009if(parentId =& null)\n\u0009\u0009do parentId :: \"Class_\"\n\u0009end if\n\u0009var info: @CppInfo :: @getInfo(ast)\n\u0009block\n\u0009\u0009assert info.classTableOffset <> -1\n\u0009\u0009var parentOffset: int\n\u0009\u0009if(ast.refItem =& null)\n\u0009\u0009\u0009do parentOffset :: 0\n\u0009\u0009else\n\u0009\u0009\u0009var parentInfo: @CppInfo :: @getInfo(ast.refItem)\n\u0009\u0009\u0009assert parentInfo.classTableOffset <> -1\n\u0009\u0009\u0009do parentOffset :: parentInfo.classTableOffset\n\u0009\u0009end if\n\u0009\u0009do @classTable.add(\"classTable_[\\{info.classTableOffset * @classTableItemSize}] = \\{parentOffset * @classTableItemSize};\\n\")\n\u0009end block\n\u0009if(ast.name <>& null)\n\u0009\u0009do @classDefs.add(\"// \\{ast.name}\\n\")\n\u0009end if\n\u0009do @classDefs.add(\"class \\{info.id} : public \\{parentId}{\\npublic:\\n\")\n\u0009do @classDefs.add(\"\\{info.id}();\\n\")\n\u0009do @classFuncs.add(\"\\{info.id}::\\{info.id}(): \\{parentId}()\")\n\u0009block\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item.def.typeId = %var_)\n\u0009\u0009\u0009\u0009var var_: \\ast@AstVar :: item.def $ \\ast@AstVar\n\u0009\u0009\u0009\u0009var info2: @CppInfo :: @getInfo(var_.arg)\n\u0009\u0009\u0009\u0009do @classFuncs.add(\", \\{info2.id}()\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do @classFuncs.add(\"{\\n\")\n\u0009do @classFuncs.add(\"Y = \\{info.classTableOffset * @classTableItemSize};\\n\")\n\u0009block\n\u0009\u0009var ctor: \\ast@AstFunc :: findFunc(ast, \"ctor\")\n\u0009\u0009if(ctor <>& null)\n\u0009\u0009\u0009var ctorInfo: @CppInfo :: @getInfo(ctor)\n\u0009\u0009\u0009do @classFuncs.add(\"\\{ctorInfo.id}(this);\\n\")\n\u0009\u0009end if\n\u0009end block\n\u0009do @classFuncs.add(\"}\\n\")\n\u0009; TODO: Destructor.\n\u0009block\n\u0009\u0009var cmp: \\ast@AstFunc :: findFunc(ast, \"cmp\")\n\u0009\u0009if(cmp <>& null)\n\u0009\u0009\u0009var cmpInfo: @CppInfo :: @getInfo(cmp)\n\u0009\u0009\u0009do @classDefs.add(\"virtual int64_t cmp_(Class_* t) override;\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"int64_t \\{info.id}::cmp_(Class_* t){\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"\\{info.id}* u = reinterpret_cast<\\{info.id}*>(t);\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"return \\{cmpInfo.id}(this, u);\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"}\\n\")\n\u0009\u0009end if\n\u0009\u0009var copy: \\ast@AstFunc :: findFunc(ast, \"_copy\")\n\u0009\u0009block\n\u0009\u0009\u0009assert copy <>& null\n\u0009\u0009\u0009var copyInfo: @CppInfo :: @getInfo(copy)\n\u0009\u0009\u0009do @classDefs.add(\"virtual Class_* copy_(Class_* t) override;\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"Class_* \\{info.id}::copy_(Class_* t){\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"return \\{copyInfo.id}(this);\\n\")\n\u0009\u0009\u0009do @classFuncs.add(\"}\\n\")\n\u0009\u0009end block\n\u0009end block\n\u0009block\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item.def.typeId = %var_)\n\u0009\u0009\u0009\u0009var var_: \\ast@AstVar :: item.def $ \\ast@AstVar\n\u0009\u0009\u0009\u0009var info2: @CppInfo :: @getInfo(var_.arg)\n\u0009\u0009\u0009\u0009if(var_.arg.name =& null)\n\u0009\u0009\u0009\u0009\u0009do @classDefs.add(\"\\{@getType(var_.arg.type)} \\{info2.id};\\n\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @classDefs.add(\"\\{@getType(var_.arg.type)} \\{info2.id}; // \\{var_.arg.name}\\n\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do @classDefs.add(\"};\\n\")\n\u0009\n\u0009func findFunc(ast: \\ast@AstClass, name: []char): \\ast@AstFunc\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item.def.typeId = %func_ & item.def.name = name)\n\u0009\u0009\u0009\u0009ret item.def $ \\ast@AstFunc\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009ret null\n\u0009end func\nend func\n\nfunc buildStats(stats: list<\\ast@AstStat>, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009do stats.head()\n\u0009while(!stats.term())\n\u0009\u0009var stat: \\ast@AstStat :: stats.get()\n\u0009\u0009switch(stat.typeId)\n\u0009\u0009case %statIf\n\u0009\u0009\u0009do @buildIf(stat $ \\ast@AstStatIf, breakStat, skipStat)\n\u0009\u0009case %statSwitch\n\u0009\u0009\u0009do @buildSwitch(stat $ \\ast@AstStatSwitch, breakStat, skipStat)\n\u0009\u0009case %statWhile\n\u0009\u0009\u0009do @buildWhile(stat $ \\ast@AstStatWhile, breakStat, skipStat)\n\u0009\u0009case %statFor\n\u0009\u0009\u0009do @buildFor(stat $ \\ast@AstStatFor, breakStat, skipStat)\n\u0009\u0009case %statTry\n\u0009\u0009\u0009do @buildTry(stat $ \\ast@AstStatTry, breakStat, skipStat)\n\u0009\u0009case %statThrow\n\u0009\u0009\u0009do @buildThrow(stat $ \\ast@AstStatThrow)\n\u0009\u0009case %statBlock\n\u0009\u0009\u0009do @buildBlock(stat $ \\ast@AstStatBlock, breakStat, skipStat)\n\u0009\u0009case %statRet\n\u0009\u0009\u0009do @buildRet(stat $ \\ast@AstStatRet)\n\u0009\u0009case %statDo\n\u0009\u0009\u0009do @buildDo(stat $ \\ast@AstStatDo)\n\u0009\u0009case %statBreak\n\u0009\u0009\u0009do @buildBreak(stat $ \\ast@AstStat, breakStat)\n\u0009\u0009case %statSkip\n\u0009\u0009\u0009do @buildSkip(stat $ \\ast@AstStat, skipStat)\n\u0009\u0009case %statAssert\n\u0009\u0009\u0009do @buildAssert(stat $ \\ast@AstStatAssert)\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009do stats.next()\n\u0009end while\nend func\n\nfunc buildIf(ast: \\ast@AstStatIf, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009var infoMe: @CppInfo :: @getInfo(ast)\n\u0009if(ast.cond =& null)\n\u0009\u0009; Optimized code.\n\u0009\u0009do @buildBlock(ast.statBlock, breakStat, skipStat)\n\u0009\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009\u0009end if\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009do @codes.add(\"if(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\"){\\n\")\n\u0009do @buildBlock(ast.statBlock, breakStat, skipStat)\n\u0009do @codes.add(\"}\\n\")\n\u0009block\n\u0009\u0009var items: list<\\ast@AstStatElIf> :: ast.elIfs\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatElIf :: items.get()\n\u0009\u0009\u0009do @codes.add(\"else if(\")\n\u0009\u0009\u0009do @buildExpr(item.cond)\n\u0009\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009\u0009do @buildBlock(item.statBlock, breakStat, skipStat)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009if(ast.elseStatBlock <>& null)\n\u0009\u0009do @codes.add(\"else{\\n\")\n\u0009\u0009do @buildBlock(ast.elseStatBlock, breakStat, skipStat)\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009end if\n\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009end if\nend func\n\nfunc buildSwitch(ast: \\ast@AstStatSwitch, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009var infoMe: @CppInfo :: @getInfo(ast)\n\u0009var info: @CppInfo :: @getInfo(ast.blockVar)\n\u0009if(!info.alreadyWritten)\n\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009do @localVars.add(ast.blockVar)\n\u0009end if\n\u0009var useSwitch: bool :: false\n\u0009if chk(\\ast@isInt(ast.cond.type) | \\ast@isChar(ast.cond.type) | \\ast@isEnum(ast.cond.type) | ast.cond.type.typeId = %typeBit)\n\u0009\u0009do useSwitch :: true\n\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009if(exprs.expr0.typeId.and(%exprValue) <> %exprValue | exprs.expr1 <>& null)\n\u0009\u0009\u0009\u0009\u0009do useSwitch :: false\n\u0009\u0009\u0009\u0009\u0009break chk\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end if\n\u0009if(useSwitch)\n\u0009\u0009do @codes.add(\"switch(\")\n\u0009\u0009do @buildExpr(ast.cond)\n\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009block\n\u0009\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009\u0009assert exprs.expr1 =& null\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"case \")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\":\\n\")\n\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @buildBlock(item.statBlock, ast, skipStat)\n\u0009\u0009\u0009\u0009do @codes.add(\"break;\\n\")\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009if(ast.defaultStatBlock <>& null)\n\u0009\u0009\u0009do @codes.add(\"default:\\n\")\n\u0009\u0009\u0009do @buildBlock(ast.defaultStatBlock, ast, skipStat)\n\u0009\u0009\u0009do @codes.add(\"break;\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009else\n\u0009\u0009do @codes.add(\"\\{info.id} = \")\n\u0009\u0009do @buildExpr(ast.cond)\n\u0009\u0009do @codes.add(\";\\n\")\n\u0009\u0009block\n\u0009\u0009\u0009var first: bool :: true\n\u0009\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"if(\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"else if(\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009var first2: bool :: true\n\u0009\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009\u0009if(first2)\n\u0009\u0009\u0009\u0009\u0009\u0009do first2 :: false\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\" || \")\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(exprs.expr1 =& null)\n\u0009\u0009\u0009\u0009\u0009\u0009if(\\ast@isRef(ast.cond.type))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"cmp_(\\{info.id}, (\")\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\")) == 0\")\n\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"\\{info.id} == (\")\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\") <= \\{info.id} && \\{info.id} <= (\")\n\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr1)\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009\u0009\u0009do @buildBlock(item.statBlock, breakStat, skipStat)\n\u0009\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009if(ast.defaultStatBlock <>& null)\n\u0009\u0009\u0009do @codes.add(\"else{\")\n\u0009\u0009\u0009do @buildBlock(ast.defaultStatBlock, breakStat, skipStat)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009end if\n\u0009end if\n\u0009\n\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009end if\nend func\n\nfunc buildWhile(ast: \\ast@AstStatWhile, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009var infoMe: @CppInfo :: @getInfo(ast)\n\u0009if(ast.cond =& null)\n\u0009\u0009do @codes.add(\"for(;;){\\n\")\n\u0009\u0009do @buildStats(ast.stats, ast, ast)\n\u0009\u0009if(infoMe.skipLabel <>& null & infoMe.skipLabelUsed)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.skipLabel}:;\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009\u0009end if\n\u0009\u0009ret\n\u0009end if\n\u0009if(ast.skip_)\n\u0009\u0009do @codes.add(\"do{\\n\")\n\u0009\u0009do @buildStats(ast.stats, ast, ast)\n\u0009\u0009if(infoMe.skipLabel <>& null & infoMe.skipLabelUsed)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.skipLabel}:;\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"}while(\")\n\u0009\u0009do @buildExpr(ast.cond)\n\u0009\u0009do @codes.add(\");\\n\")\n\u0009\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009\u0009end if\n\u0009\u0009ret\n\u0009end if\n\u0009do @codes.add(\"while(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\"){\\n\")\n\u0009do @buildStats(ast.stats, ast, ast)\n\u0009if(infoMe.skipLabel <>& null & infoMe.skipLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.skipLabel}:;\\n\")\n\u0009end if\n\u0009do @codes.add(\"}\\n\")\n\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009end if\nend func\n\nfunc buildFor(ast: \\ast@AstStatFor, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009var infoMe: @CppInfo :: @getInfo(ast)\n\u0009var info: @CppInfo :: @getInfo(ast.blockVar)\n\u0009if(!info.alreadyWritten)\n\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009do @localVars.add(ast.blockVar)\n\u0009end if\n\u0009var endId: []char :: @addTmpVar(ast.cond.type)\n\u0009do @codes.add(\"for(\\{info.id} = (\")\n\u0009do @buildExpr(ast.start)\n\u0009do @codes.add(\"), \\{endId} = (\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\"); \\{info.id} \")\n\u0009assert ast.step.typeId = %exprValuePrim & \\ast@isInt(ast.cond.type)\n\u0009var step: int :: (ast.step $ \\ast@AstExprValuePrim).value $ int\n\u0009if(step > 0)\n\u0009\u0009do @codes.add(\"<=\")\n\u0009else\n\u0009\u0009do @codes.add(\">=\")\n\u0009end if\n\u0009do @codes.add(\" \\{endId}; \\{info.id} \")\n\u0009if(step > 0)\n\u0009\u0009do @codes.add(\"+= (\")\n\u0009else\n\u0009\u0009do @codes.add(\"-= (\")\n\u0009end if\n\u0009do @buildExpr(ast.step)\n\u0009do @codes.add(\")){\\n\")\n\u0009do @buildStats(ast.stats, ast, ast)\n\u0009if(infoMe.skipLabel <>& null & infoMe.skipLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.skipLabel}:;\\n\")\n\u0009end if\n\u0009do @codes.add(\"}\\n\")\n\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009end if\nend func\n\nfunc buildTry(ast: \\ast@AstStatTry, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009var infoMe: @CppInfo :: @getInfo(ast)\n\u0009var info: @CppInfo :: @getInfo(ast.blockVar)\n\u0009if(!info.alreadyWritten)\n\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009do @localVars.add(ast.blockVar)\n\u0009end if\n\u0009if(ast.finallyStatBlock <>& null)\n\u0009\u0009do @codes.add(\"try{\\n\")\n\u0009end if\n\u0009do @codes.add(\"try{\\n\")\n\u0009do @buildBlock(ast.statBlock, breakStat, skipStat)\n\u0009if(ast.finallyStatBlock <>& null)\n\u0009\u0009do @buildBlock(ast.finallyStatBlock, breakStat, skipStat)\n\u0009end if\n\u0009do @codes.add(\"}catch(int64_t \\{info.id}){\\n\")\n\u0009block\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstStatCatch> :: ast.catches\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatCatch :: items.get()\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009do @codes.add(\"if(\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"else if(\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009var first2: bool :: true\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009if(first2)\n\u0009\u0009\u0009\u0009\u0009do first2 :: false\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\" || \")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(exprs.expr1 =& null)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"\\{info.id} == (\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\") <= \\{info.id} && \\{info.id} <= (\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr1)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009\u0009do @buildBlock(item.statBlock, breakStat, skipStat)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009if(first)\n\u0009\u0009\u0009do @codes.add(\"{\\n\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"else{\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"throw;\\n}\\n\")\n\u0009end block\n\u0009do @codes.add(\"}\\n\")\n\u0009if(ast.finallyStatBlock <>& null)\n\u0009\u0009do @codes.add(\"}\\ncatch(...){\\n\")\n\u0009\u0009do @buildBlock(ast.finallyStatBlock, breakStat, skipStat)\n\u0009\u0009do @codes.add(\"throw;\\n}\\n\")\n\u0009end if\n\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009end if\nend func\n\nfunc buildThrow(ast: \\ast@AstStatThrow)\n\u0009do @codes.add(\"throw \")\n\u0009do @buildExpr(ast.code)\n\u0009do @codes.add(\";\\n\")\nend func\n\nfunc buildBlock(ast: \\ast@AstStatBlock, breakStat: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009var infoMe: @CppInfo :: @getInfo(ast)\n\u0009do @buildStats(ast.stats, breakStat, skipStat)\n\u0009if(infoMe.breakLabel <>& null & infoMe.breakLabelUsed)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakLabel}:;\\n\")\n\u0009end if\nend func\n\nfunc buildRet(ast: \\ast@AstStatRet)\n\u0009if(ast.value =& null)\n\u0009\u0009do @codes.add(\"return;\\n\")\n\u0009else\n\u0009\u0009do @codes.add(\"return \")\n\u0009\u0009do @buildExpr(ast.value)\n\u0009\u0009do @codes.add(\";\\n\")\n\u0009end if\nend func\n\nfunc buildDo(ast: \\ast@AstStatDo)\n\u0009do @buildExpr(ast.expr)\n\u0009do @codes.add(\";\\n\")\nend func\n\nfunc buildBreak(ast: \\ast@AstStat, breakStat: \\ast@AstStat)\n\u0009assert ast.refItem.typeId.and(%statBreakable) = %statBreakable\n\u0009if(ast.refItem =& breakStat)\n\u0009\u0009do @codes.add(\"break;\\n\")\n\u0009else\n\u0009\u0009var info: @CppInfo :: @getInfo(ast.refItem)\n\u0009\u0009do info.breakLabelUsed :: true\n\u0009\u0009do @codes.add(\"goto \\{info.breakLabel};\\n\")\n\u0009end if\nend func\n\nfunc buildSkip(ast: \\ast@AstStat, skipStat: \\ast@AstStat)\n\u0009assert ast.refItem.typeId.and(%statSkipable) = %statSkipable\n\u0009if(ast.refItem =& skipStat)\n\u0009\u0009do @codes.add(\"continue;\\n\")\n\u0009else\n\u0009\u0009var info: @CppInfo :: @getInfo(ast.refItem)\n\u0009\u0009do info.skipLabelUsed :: true\n\u0009\u0009do @codes.add(\"goto \\{info.skipLabel};\\n\")\n\u0009end if\nend func\n\nfunc buildAssert(ast: \\ast@AstStatAssert)\n\u0009do @codes.add(\"if(!(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\")){\\nthrow \\{excpt@dbgAssertFailed $ bit32}U;\\n}\\n\")\nend func\n\nfunc buildExpr(ast: \\ast@AstExpr)\n\u0009switch(ast.typeId)\n\u0009case %expr1\n\u0009\u0009do @buildExpr1(ast $ \\ast@AstExpr1)\n\u0009case %expr2\n\u0009\u0009do @buildExpr2(ast $ \\ast@AstExpr2)\n\u0009case %expr3\n\u0009\u0009do @buildExpr3(ast $ \\ast@AstExpr3)\n\u0009case %exprNew\n\u0009\u0009do @buildExprNew(ast $ \\ast@AstExprNew)\n\u0009case %exprNewArray\n\u0009\u0009do @buildExprNewArray(ast $ \\ast@AstExprNewArray)\n\u0009case %exprAs\n\u0009\u0009do @buildExprAs(ast $ \\ast@AstExprAs)\n\u0009case %exprToBin\n\u0009\u0009do @buildExprToBin(ast $ \\ast@AstExprToBin)\n\u0009case %exprFromBin\n\u0009\u0009do @buildExprFromBin(ast $ \\ast@AstExprFromBin)\n\u0009case %exprCall\n\u0009\u0009do @buildExprCall(ast $ \\ast@AstExprCall)\n\u0009case %exprArray\n\u0009\u0009do @buildExprArray(ast $ \\ast@AstExprArray)\n\u0009case %exprDot\n\u0009\u0009do @buildExprDot(ast $ \\ast@AstExprDot)\n\u0009case %exprValue\n\u0009\u0009do @buildExprValue(ast $ \\ast@AstExprValue)\n\u0009case %exprValuePrim\n\u0009\u0009do @buildExprValuePrim(ast $ \\ast@AstExprValuePrim)\n\u0009case %exprValueStr\n\u0009\u0009do @buildExprValueStr(ast $ \\ast@AstExprValueStr)\n\u0009case %exprValueFloat\n\u0009\u0009do @buildExprValueFloat(ast $ \\ast@AstExprValueFloat)\n\u0009case %exprValueArray\n\u0009\u0009do @buildExprValueArray(ast $ \\ast@AstExprValueArray)\n\u0009case %exprRef\n\u0009\u0009do @buildExprRef(ast $ \\ast@AstExpr)\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExpr1(ast: \\ast@AstExpr1)\n\u0009assert ast.varKind <> %unknown\n\u0009switch(ast.kind)\n\u0009case %plus\n\u0009\u0009do @buildExpr(ast.child)\n\u0009case %minus\n\u0009\u0009do @codes.add(\"-(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %not\n\u0009\u0009do @codes.add(\"!(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %copy\n\u0009\u0009do @codes.add(\"copy_(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %len\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")->Len()\")\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExpr2(ast: \\ast@AstExpr2)\n\u0009assert ast.varKind <> %unknown\n\u0009var type: \\ast@AstType :: ast.children0.type\n\u0009switch(ast.kind)\n\u0009case %assign\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") = (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %or\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") || (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %and\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") && (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %lt\n\u0009\u0009if(\\ast@isRef(type))\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")) < 0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") < (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %gt\n\u0009\u0009if(\\ast@isRef(type))\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")) > 0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") > (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %le\n\u0009\u0009if(\\ast@isRef(type))\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")) <= 0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") <= (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %ge\n\u0009\u0009if(\\ast@isRef(type))\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")) >= 0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") >= (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %eq\n\u0009\u0009if(\\ast@isRef(type))\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")) == 0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") == (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %nEq\n\u0009\u0009if(\\ast@isRef(type))\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")) != 0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") != (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %eqRef\n\u0009\u0009do @codes.add(\"eqAddr_((\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\"))\")\n\u0009case %nEqRef\n\u0009\u0009do @codes.add(\"!eqAddr_((\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\"))\")\n\u0009case %cat\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")->Cat(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %add\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") + (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %sub\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") - (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %mul\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") * (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %div\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") / (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %mod\n\u0009\u0009if(\\ast@isInt(type) | type.typeId.and(%typeBit) = %typeBit)\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\") % (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009else\n\u0009\u0009\u0009assert \\ast@isFloat(type)\n\u0009\u0009\u0009do @codes.add(\"fmod((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))\")\n\u0009\u0009end if\n\u0009case %pow\n\u0009\u0009if(\\ast@isInt(type) | type.typeId.and(%typeBit) = %typeBit)\n\u0009\u0009\u0009do @codes.add(\"powI_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))\")\n\u0009\u0009else\n\u0009\u0009\u0009assert \\ast@isFloat(type)\n\u0009\u0009\u0009do @codes.add(\"pow((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))\")\n\u0009\u0009end if\n\u0009case %swap\n\u0009\u0009var tmpVar: []char :: @addTmpVar(type)\n\u0009\u0009do @codes.add(\"\\{tmpVar} = (\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\") = (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\"), (\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\") = (\\{tmpVar})\")\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExpr3(ast: \\ast@AstExpr3)\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"(\")\n\u0009do @buildExpr(ast.children0)\n\u0009do @codes.add(\") ? (\")\n\u0009do @buildExpr(ast.children1)\n\u0009do @codes.add(\") : (\")\n\u0009do @buildExpr(ast.children2)\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprNew(ast: \\ast@AstExprNew)\n\u0009assert ast.varKind <> %unknown\n\u0009if(\\ast@isClass(ast.itemType))\n\u0009\u0009var class_: \\ast@AstClass :: ast.itemType.refItem $ \\ast@AstClass\n\u0009\u0009var id: []char :: @refClass(class_)\n\u0009\u0009do @codes.add(\"new \\{id}()\")\n\u0009else\n\u0009\u0009if(ast.itemType.typeId = %typeGen)\n\u0009\u0009\u0009var gen: \\ast@AstTypeGen :: ast.itemType $ \\ast@AstTypeGen\n\u0009\u0009\u0009switch(gen.kind)\n\u0009\u0009\u0009case %list_\n\u0009\u0009\u0009\u0009do @codes.add(\"new List_<\\{@getType(gen.itemType)}>()\")\n\u0009\u0009\u0009case %stack_\n\u0009\u0009\u0009\u0009do @codes.add(\"new Stack_<\\{@getType(gen.itemType)}>()\")\n\u0009\u0009\u0009case %queue_\n\u0009\u0009\u0009\u0009do @codes.add(\"new Queue_<\\{@getType(gen.itemType)}>()\")\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009else\n\u0009\u0009\u0009assert ast.itemType.typeId = %typeDict\n\u0009\u0009\u0009var dict_: \\ast@AstTypeDict :: ast.itemType $ \\ast@AstTypeDict\n\u0009\u0009\u0009do @codes.add(\"new Dict_<\\{@getType(dict_.itemTypeKey)}, \\{@getType(dict_.itemTypeValue)}>()\")\n\u0009\u0009end if\n\u0009end if\nend func\n\nfunc buildExprNewArray(ast: \\ast@AstExprNewArray)\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"newArray_<\\{@getType(ast.itemType)}, \\{@getType(ast.type)}>(\\{^ast.idces}\")\n\u0009block\n\u0009\u0009var items: list<\\ast@AstExpr> :: ast.idces\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009do @codes.add(\", (\")\n\u0009\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprAs(ast: \\ast@AstExprAs)\n\u0009assert ast.varKind <> %unknown\n\u0009switch(ast.kind)\n\u0009case %as\n\u0009\u0009var t1: \\ast@AstType :: ast.child.type\n\u0009\u0009var t2: \\ast@AstType :: ast.childType\n\u0009\u0009if(\\ast@isClass(t1))\n\u0009\u0009\u0009assert \\ast@isClass(t2)\n\u0009\u0009\u0009var id: []char :: @refClass(t2.refItem $ \\ast@AstClass)\n\u0009\u0009\u0009var info: @CppInfo :: @getInfo(t2.refItem)\n\u0009\u0009\u0009do @codes.add(\"as_<\\{id}>(classTable_, (\")\n\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009do @codes.add(\"), \\{info.classTableOffset * @classTableItemSize})\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"static_cast<\\{@getType(ast.childType)}>(\")\n\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %is\n\u0009\u0009do @refClass(ast.childType.refItem $ \\ast@AstClass)\n\u0009\u0009var info: @CppInfo :: @getInfo(ast.childType.refItem)\n\u0009\u0009do @codes.add(\"is_(classTable_, (\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\"), \\{info.classTableOffset * @classTableItemSize})\")\n\u0009case %nIs\n\u0009\u0009do @refClass(ast.childType.refItem $ \\ast@AstClass)\n\u0009\u0009var info: @CppInfo :: @getInfo(ast.childType.refItem)\n\u0009\u0009do @codes.add(\"!is_(classTable_, (\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\"), \\{info.classTableOffset * @classTableItemSize})\")\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExprToBin(ast: \\ast@AstExprToBin)\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"toBin_(\")\n\u0009do @buildExpr(ast.child)\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprFromBin(ast: \\ast@AstExprFromBin)\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"fromBin_<\\{@getType(ast.childType)}>((\")\n\u0009do @buildExpr(ast.child)\n\u0009do @codes.add(\"), (\")\n\u0009do @buildExpr(ast.offset)\n\u0009do @codes.add(\"))\")\nend func\n\nfunc buildExprCall(ast: \\ast@AstExprCall)\n\u0009assert ast.varKind <> %unknown\n\u0009var funcType: \\ast@AstTypeFunc :: ast.func_.type $ \\ast@AstTypeFunc\n\u0009var template: []char :: null\n\u0009if(funcType <>& null & funcType.funcOption.and(%any) = %any)\n\u0009\u0009var items: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009var meType: \\ast@AstType :: items.get().arg.type\n\u0009\u0009if(funcType.funcOption.and(%tkv) = %tkv)\n\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}, \\{@getType((meType $ \\ast@AstTypeDict).itemTypeKey)}, \\{@getType((meType $ \\ast@AstTypeDict).itemTypeValue)}>\"\n\u0009\u0009elif(funcType.funcOption.and(%tch) = %tch)\n\u0009\u0009\u0009if(funcType.funcOption.and(%rch) = %rch)\n\u0009\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}, \"\n\u0009\u0009\u0009\u0009if(meType.typeId = %typeGen)\n\u0009\u0009\u0009\u0009\u0009do template :~ \"\\{@getType((meType $ \\ast@AstTypeGen).itemType)}, \"\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert meType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009do template :~ \"\\{@getType((meType $ \\ast@AstTypeDict).itemTypeKey)}, \"\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do template :~ \"\\{@getType(funcType.ret_)}>\"\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}, \"\n\u0009\u0009\u0009\u0009if(meType.typeId = %typeArray)\n\u0009\u0009\u0009\u0009\u0009do template :~ \"\\{@getType((meType $ \\ast@AstTypeArray).itemType)}>\"\n\u0009\u0009\u0009\u0009elif(meType.typeId = %typeGen)\n\u0009\u0009\u0009\u0009\u0009do template :~ \"\\{@getType((meType $ \\ast@AstTypeGen).itemType)}>\"\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert meType.typeId = %typeDict\n\u0009\u0009\u0009\u0009\u0009do template :~ \"\\{@getType((meType $ \\ast@AstTypeDict).itemTypeKey)}>\"\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009elif(funcType.funcOption.and(%rch) = %rch)\n\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}, \\{@getType(funcType.ret_)}>\"\n\u0009\u0009elif(funcType.funcOption.and(%kvf) = %kvf)\n\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}, \\{@getType((meType $ \\ast@AstTypeDict).itemTypeKey)}, \\{@getType((meType $ \\ast@AstTypeDict).itemTypeValue)}>\"\n\u0009\u0009else\n\u0009\u0009\u0009do template :: \"<\\{@getType(meType)}>\"\n\u0009\u0009end if\n\u0009end if\n\u0009if(template =& null)\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.func_)\n\u0009\u0009do @codes.add(\")\")\n\u0009else\n\u0009\u0009do @buildExpr(ast.func_)\n\u0009\u0009do @codes.add(template)\n\u0009end if\n\u0009do @codes.add(\"(\")\n\u0009block\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstExprCallArg :: items.get()\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\", (\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(item.refVar)\n\u0009\u0009\u0009\u0009do @codes.add(\"&\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @buildExpr(item.arg)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do @codes.add(\")\")\n\u0009\n\u0009block\n\u0009\u0009var type: \\ast@AstType :: ast.type\n\u0009\u0009if(type <>& null)\n\u0009\u0009\u0009if(\\ast@isClass(type))\n\u0009\u0009\u0009\u0009do @refClass(type.refItem $ \\ast@AstClass)\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009end block\nend func\n\nfunc buildExprArray(ast: \\ast@AstExprArray)\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"(\")\n\u0009do @buildExpr(ast.var_)\n\u0009do @codes.add(\")->At(\")\n\u0009do @buildExpr(ast.idx)\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprDot(ast: \\ast@AstExprDot)\n\u0009assert ast.varKind <> %unknown\n\u0009if(\\ast@isClass(ast.var_.type))\n\u0009\u0009var classItem: \\ast@AstClassItem :: ast.classItem\n\u0009\u0009assert classItem <>& null\n\u0009\u0009do @refClass(ast.var_.type.refItem $ \\ast@AstClass)\n\u0009\u0009var info: @CppInfo\n\u0009\u0009if(classItem.def.typeId = %var_)\n\u0009\u0009\u0009do info :: @getInfo((classItem.def $ \\ast@AstVar).arg)\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.var_)\n\u0009\u0009\u0009do @codes.add(\")->\\{info.id}\")\n\u0009\u0009else\n\u0009\u0009\u0009assert classItem.def.typeId = %func_\n\u0009\u0009\u0009do info :: @getInfo(classItem.def)\n\u0009\u0009\u0009; \'ast.var_\' is calculated elsewhere.\n\u0009\u0009\u0009do @codes.add(\"\\{info.id}\")\n\u0009\u0009end if\n\u0009else\n\u0009\u0009assert ast.refItem.typeId = %exprRef\n\u0009\u0009do @buildExprRef(ast.refItem $ \\ast@AstExpr)\n\u0009end if\nend func\n\nfunc buildExprValue(ast: \\ast@AstExprValue)\n\u0009assert ast.type.typeId = %typeNull\n\u0009do @codes.add(\"nullptr\")\nend func\n\nfunc buildExprValuePrim(ast: \\ast@AstExprValuePrim)\n\u0009var type: \\ast@AstType :: ast.type\n\u0009if(\\ast@isInt(type) | \\ast@isEnum(type))\n\u0009\u0009do @codes.add((ast.value $ int).toStr() ~ \"LL\")\n\u0009elif(\\ast@isChar(type))\n\u0009\u0009do @codes.add(\"u\'\\\\u\\{(ast.value $ bit16).toStr().sub(2, -1)}\'\")\n\u0009elif(\\ast@isBool(type))\n\u0009\u0009do @codes.add(ast.value = 0b64 ?(\"false\", \"true\"))\n\u0009elif(type.typeId = %typeBit)\n\u0009\u0009switch((type $ \\ast@AstTypeBit).size)\n\u0009\u0009case 1\n\u0009\u0009\u0009do @codes.add(\"static_cast<uint8_t>(\\{ast.value $ bit8}U)\")\n\u0009\u0009case 2\n\u0009\u0009\u0009do @codes.add(\"static_cast<uint16_t>(\\{ast.value $ bit16}U)\")\n\u0009\u0009case 4\n\u0009\u0009\u0009do @codes.add(\"\\{ast.value $ bit32}U\")\n\u0009\u0009case 8\n\u0009\u0009\u0009do @codes.add(\"\\{ast.value $ bit64}ULL\")\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009else\n\u0009\u0009assert false\n\u0009end if\nend func\n\nfunc buildExprValueStr(ast: \\ast@AstExprValueStr)\n\u0009var value: []char :: ast.value\n\u0009var s: []char :: \"new Array_<char16_t>(\\{^value}\"\n\u0009for i(0, ^value - 1)\n\u0009\u0009do s :~ \", u\'\\\\u\\{(value[i] $ bit16).toStr().sub(2, -1)}\'\"\n\u0009end for\n\u0009do s :~ \")\"\n\u0009do @codes.add(s)\nend func\n\nfunc buildExprValueFloat(ast: \\ast@AstExprValueFloat)\n\u0009var value: []char :: ast.value.toStr()\n\u0009if(value = \"inf\")\n\u0009\u0009do @codes.add(\"std::numeric_limits<double>::infinity()\")\n\u0009elif(value.find(\'.\', -1) = -1)\n\u0009\u0009do @codes.add(value ~ \".0\")\n\u0009else\n\u0009\u0009do @codes.add(value)\n\u0009end if\nend func\n\nfunc buildExprValueArray(ast: \\ast@AstExprValueArray)\n\u0009; Note that constant string values are handled by \'ExprValueStr\'.\n\u0009do @codes.add(\"new Array_<\\{@getType((ast.type $ \\ast@AstTypeArray).itemType)}>(\\{^ast.values}\")\n\u0009var items: list<\\ast@AstExpr> :: ast.values\n\u0009do items.head()\n\u0009while(!items.term())\n\u0009\u0009do @codes.add(\", (\")\n\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009do @codes.add(\")\")\n\u0009\u0009do items.next()\n\u0009end while\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprRef(ast: \\ast@AstExpr)\n\u0009var ast2: \\ast@Ast :: ast.refItem\n\u0009var info: @CppInfo :: @getInfo(ast2)\n\u0009if(ast2.typeId = %func_)\n\u0009\u0009do @funcs.add(ast2 $ \\ast@AstFunc)\n\u0009else\n\u0009\u0009assert ast2.typeId = %arg\n\u0009\u0009var arg: \\ast@AstArg :: ast2 $ \\ast@AstArg\n\u0009\u0009switch(arg.kind)\n\u0009\u0009case %global\n\u0009\u0009\u0009if(!info.alreadyWritten)\n\u0009\u0009\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009\u0009\u0009do @globalVars.add(arg)\n\u0009\u0009\u0009end if\n\u0009\u0009case %localArg\n\u0009\u0009\u0009; Do nothing.\n\u0009\u0009case %localVar\n\u0009\u0009\u0009if(!info.alreadyWritten)\n\u0009\u0009\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009\u0009\u0009do @localVars.add(arg)\n\u0009\u0009\u0009end if\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009if(arg.refVar)\n\u0009\u0009\u0009do @codes.add(\"*\")\n\u0009\u0009end if\n\u0009end if\n\u0009do @codes.add(info.id)\nend func\n\nfunc write(resFiles: list<[]char>)\n\u0009if(\\option@extra.get(\"merge\", &))\n\u0009\u0009var writer: file@Writer :: file@makeWriter(\\option@outputFile ~ \".cpp\", false)\n\u0009\u0009var reader: file@Reader :: file@makeReader(\\option@sysDir ~ \"common.h\")\n\u0009\u0009while(!reader.term())\n\u0009\u0009\u0009var s: []char :: reader.readLine()\n\u0009\u0009\u0009do writer.writeStr(s ~ \"\\n\")\n\u0009\u0009end while\n\u0009\u0009do reader.fin()\n\u0009\u0009do writeCpp(writer, resFiles)\n\u0009\u0009do writer.fin()\n\u0009else\n\u0009\u0009do file@copyFile(\\option@outputDir ~ \"common.h\", \\option@sysDir ~ \"common.h\")\n\u0009\u0009\n\u0009\u0009var writer: file@Writer :: file@makeWriter(\\option@outputFile ~ \".cpp\", false)\n\u0009\u0009do writer.writeStr(\"#include \\\"common.h\\\"\\n\")\n\u0009\u0009do writeCpp(writer, resFiles)\n\u0009\u0009do writer.fin()\n\u0009end if\n\u0009\n\u0009func writeCpp(writer: file@Writer, resFiles: list<[]char>)\n\u0009\u0009do writer.writeStr(\"namespace {\\n\")\n\u0009\u0009\n\u0009\u0009do @classDefs.head()\n\u0009\u0009while(!@classDefs.term())\n\u0009\u0009\u0009do writer.writeStr(@classDefs.get())\n\u0009\u0009\u0009do @classDefs.next()\n\u0009\u0009end while\n\u0009\u0009do @funcPrototypes.head()\n\u0009\u0009while(!@funcPrototypes.term())\n\u0009\u0009\u0009do writer.writeStr(@funcPrototypes.get())\n\u0009\u0009\u0009do @funcPrototypes.next()\n\u0009\u0009end while\n\u0009\u0009; TODO: ResFiles\n\u0009\u0009if(@classTableSize <> 0)\n\u0009\u0009\u0009do writer.writeStr(\"static int64_t classTable_[\\{@classTableSize * @classTableItemSize}];\\n\")\n\u0009\u0009end if\n\u0009\u0009do writer.writeStr(\"static int64_t argc_;\\n\")\n\u0009\u0009do writer.writeStr(\"static char** argv_;\\n\")\n\u0009\u0009do @globalVars.head()\n\u0009\u0009while(!@globalVars.term())\n\u0009\u0009\u0009var globalVar: \\ast@AstArg :: @globalVars.get()\n\u0009\u0009\u0009var info: @CppInfo :: @getInfo(globalVar)\n\u0009\u0009\u0009do writer.writeStr(\"static \\{@getType(globalVar.type)} \\{info.id};\\n\")\n\u0009\u0009\u0009do @globalVars.next()\n\u0009\u0009end while\n\u0009\u0009do @classFuncs.head()\n\u0009\u0009while(!@classFuncs.term())\n\u0009\u0009\u0009do writer.writeStr(@classFuncs.get())\n\u0009\u0009\u0009do @classFuncs.next()\n\u0009\u0009end while\n\u0009\u0009do @codes.head()\n\u0009\u0009while(!@codes.term())\n\u0009\u0009\u0009do writer.writeStr(@codes.get())\n\u0009\u0009\u0009do @codes.next()\n\u0009\u0009end while\n\u0009\u0009do writer.writeStr(\"}\\n\")\n\u0009\u0009do writer.writeStr(\"int main(int c_, char** v_){\\n\")\n\u0009\u0009do writer.writeStr(\"argc_ = c_ - 1;\\n\")\n\u0009\u0009do writer.writeStr(\"argv_ = v_ + 1;\\n\")\n\u0009\u0009block\n\u0009\u0009\u0009do @classTable.head()\n\u0009\u0009\u0009while(!@classTable.term())\n\u0009\u0009\u0009\u0009var item: []char :: @classTable.get()\n\u0009\u0009\u0009\u0009do writer.writeStr(item)\n\u0009\u0009\u0009\u0009do @classTable.next()\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009do writer.writeStr(\"init_();\\n\")\n\u0009\u0009do writer.writeStr(\"a();\\n\")\n\u0009\u0009do writer.writeStr(\"return 0;\\n\")\n\u0009\u0009do writer.writeStr(\"}\\n\")\n\u0009end func\nend func\n\nfunc getType(type: \\ast@AstType): []char\n\u0009if(type =& null)\n\u0009\u0009ret \"void\"\n\u0009end if\n\u0009switch(type.typeId)\n\u0009case %typeArray\n\u0009\u0009ret \"Array_<\\{@getType((type $ \\ast@AstTypeArray).itemType)}>*\"\n\u0009case %typeBit\n\u0009\u0009ret \"uint\\{(type $ \\ast@AstTypeBit).size * 8}_t\"\n\u0009case %typeFunc\n\u0009\u0009var func_: \\ast@AstTypeFunc :: type $ \\ast@AstTypeFunc\n\u0009\u0009var id: []char :: @getId()\n\u0009\u0009do @funcPrototypes.add(\"typedef \\{@getType(func_.ret_)}(*\\{id})(\")\n\u0009\u0009block\n\u0009\u0009\u0009var arg: []char :: \"\"\n\u0009\u0009\u0009var first: bool :: true\n\u0009\u0009\u0009var items: list<\\ast@AstTypeFuncArg> :: func_.args\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstTypeFuncArg :: items.get()\n\u0009\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do arg :~ \", \"\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do arg :~ \"\\{@getType(item.arg)}\"\n\u0009\u0009\u0009\u0009if(item.refVar)\n\u0009\u0009\u0009\u0009\u0009do arg :~ \"*\"\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do @funcPrototypes.add(\"\\{arg});\\n\")\n\u0009\u0009end block\n\u0009\u0009ret id\n\u0009case %typeGen\n\u0009\u0009var gen: \\ast@AstTypeGen :: type $ \\ast@AstTypeGen\n\u0009\u0009switch(gen.kind)\n\u0009\u0009case %list_\n\u0009\u0009\u0009ret \"List_<\\{@getType(gen.itemType)}>*\"\n\u0009\u0009case %stack_\n\u0009\u0009\u0009ret \"Stack_<\\{@getType(gen.itemType)}>*\"\n\u0009\u0009case %queue_\n\u0009\u0009\u0009ret \"Queue_<\\{@getType(gen.itemType)}>*\"\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009case %typeDict\n\u0009\u0009var dict_: \\ast@AstTypeDict :: type $ \\ast@AstTypeDict\n\u0009\u0009ret \"Dict_<\\{@getType(dict_.itemTypeKey)}, \\{@getType(dict_.itemTypeValue)}>*\"\n\u0009case %typePrim\n\u0009\u0009var prim: \\ast@AstTypePrim :: type $ \\ast@AstTypePrim\n\u0009\u0009switch(prim.kind)\n\u0009\u0009case %int_\n\u0009\u0009\u0009ret \"int64_t\"\n\u0009\u0009case %float_\n\u0009\u0009\u0009ret \"double\"\n\u0009\u0009case %char_\n\u0009\u0009\u0009ret \"char16_t\"\n\u0009\u0009case %bool_\n\u0009\u0009\u0009ret \"bool\"\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009case %typeUser\n\u0009\u0009var ref: \\ast@Ast :: type.refItem\n\u0009\u0009if(ref.typeId = %class_)\n\u0009\u0009\u0009do @refClass(ref $ \\ast@AstClass)\n\u0009\u0009\u0009var info: @CppInfo :: @getInfo(ref)\n\u0009\u0009\u0009ret info.id ~ \"*\"\n\u0009\u0009else\n\u0009\u0009\u0009assert ref.typeId = %enum_\n\u0009\u0009\u0009ret \"int64_t\"\n\u0009\u0009end if\n\u0009case %typeNull\n\u0009\u0009assert false\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc getId(): []char\n\u0009var curId: []char :: @uniqueId\n\u0009var newId: []char :: ##@uniqueId\n\u0009while loop2(true)\n\u0009\u0009var idx: int :: ^newId - 1\n\u0009\u0009while loop(true)\n\u0009\u0009\u0009if(newId[idx] = \'z\')\n\u0009\u0009\u0009\u0009if(idx = 0)\n\u0009\u0009\u0009\u0009\u0009do newId :: #[^newId + 1]char\n\u0009\u0009\u0009\u0009\u0009do newId.fill(\'a\')\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do newId[idx] :: \'a\'\n\u0009\u0009\u0009\u0009\u0009do idx :- 1\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do newId[idx] :: newId[idx].offset(1)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009break loop\n\u0009\u0009end while\n\u0009\u0009switch(^newId)\n\u0009\u0009case 2\n\u0009\u0009\u0009switch(newId)\n\u0009\u0009\u0009case \"do\", \"if\", \"or\"\n\u0009\u0009\u0009\u0009skip loop2\n\u0009\u0009\u0009end switch\n\u0009\u0009case 3\n\u0009\u0009\u0009switch(newId)\n\u0009\u0009\u0009case \"and\", \"asm\", \"for\", \"int\", \"new\", \"not\", \"try\", \"xor\"\n\u0009\u0009\u0009\u0009skip loop2\n\u0009\u0009\u0009end switch\n\u0009\u0009case 4\n\u0009\u0009\u0009switch(newId)\n\u0009\u0009\u0009case \"auto\", \"bool\", \"case\", \"char\", \"else\", \"enum\", \"goto\", \"long\", \"main\", \"this\", \"true\", \"void\"\n\u0009\u0009\u0009\u0009skip loop2\n\u0009\u0009\u0009end switch\n\u0009\u0009end switch\n\u0009\u0009break loop2\n\u0009end while\n\u0009do @uniqueId :: newId\n\u0009ret curId\nend func\n\n+func getInfo(ast: \\ast@Ast): @CppInfo\n\u0009if(ast.extra =& null | ast.extra.typeId <> %info)\n\u0009\u0009var info: @CppInfo :: #@CppInfo\n\u0009\u0009do info.typeId :: %info\n\u0009\u0009do info.id :: @getId()\n\u0009\u0009if(ast.typeId.and(%statBreakable) = %statBreakable & ast.name <>& null & ast.name <> \"$\")\n\u0009\u0009\u0009do info.breakLabel :: @getId()\n\u0009\u0009\u0009if(ast.typeId.and(%statSkipable) = %statSkipable)\n\u0009\u0009\u0009\u0009do info.skipLabel :: @getId()\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do info.skipLabel :: null\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009do info.breakLabel :: null\n\u0009\u0009\u0009do info.skipLabel :: null\n\u0009\u0009end if\n\u0009\u0009do info.classTableOffset :: -1\n\u0009\u0009do info.alreadyWritten :: false\n\u0009\u0009do info.breakLabelUsed :: false\n\u0009\u0009do info.skipLabelUsed :: false\n\u0009\u0009do ast.extra :: info\n\u0009end if\n\u0009ret ast.extra $ @CppInfo\nend func\n\nfunc addTmpVar(type: \\ast@AstType): []char\n\u0009var tmpVar: @TmpVar :: #@TmpVar\n\u0009do tmpVar.identifier :: @getId()\n\u0009do tmpVar.type :: type\n\u0009do @tmpVars.add(tmpVar)\n\u0009ret tmpVar.identifier\nend func\n\nfunc refClass(ast: \\ast@AstClass): []char\n\u0009var info: @CppInfo :: @getInfo(ast)\n\u0009if(info.alreadyWritten)\n\u0009\u0009ret info.id\n\u0009end if\n\u0009do info.alreadyWritten :: true\n\u0009if(ast.refItem <>& null)\n\u0009\u0009do @refClass(ast.refItem $ \\ast@AstClass)\n\u0009end if\n\u0009if(info.classTableOffset = -1)\n\u0009\u0009do info.classTableOffset :: @classTableSize\n\u0009\u0009do @classTableSize :+ 1\n\u0009end if\n\u0009block\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item.def.typeId = %func_)\n\u0009\u0009\u0009\u0009var func_: \\ast@AstFunc :: item.def $ \\ast@AstFunc\n\u0009\u0009\u0009\u0009if(func_.ret_ <>& null)\n\u0009\u0009\u0009\u0009\u0009do @getType(func_.ret_)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009var items2: list<\\ast@AstArg> :: func_.args\n\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: items2.get()\n\u0009\u0009\u0009\u0009\u0009do @getType(arg.type)\n\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @funcs.add(func_)\n\u0009\u0009\u0009elif(item.def.typeId = %var_)\n\u0009\u0009\u0009\u0009var var_: \\ast@AstVar :: item.def $ \\ast@AstVar\n\u0009\u0009\u0009\u0009do @getType(var_.arg.type)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do @classes.add(ast)\n\u0009ret info.id\nend func\n\nfunc getDefaultValue(type: \\ast@AstType): []char\n\u0009if(\\ast@isNullable(type))\n\u0009\u0009ret \"nullptr\"\n\u0009end if\n\u0009switch(type.typeId)\n\u0009case %typeUser\n\u0009\u0009assert \\ast@isEnum(type)\n\u0009\u0009ret \"0\"\n\u0009case %typeBit\n\u0009\u0009ret \"0\"\n\u0009case %typePrim\n\u0009\u0009switch((type $ \\ast@AstTypePrim).kind)\n\u0009\u0009case %int_, %char_\n\u0009\u0009\u0009ret \"0\"\n\u0009\u0009case %float_\n\u0009\u0009\u0009ret \"0.0\"\n\u0009\u0009case %bool_\n\u0009\u0009\u0009ret \"false\"\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n":true;
else if(p==="res/cpp/raw_funcs.kn")
return f?"+func write(codes: list<[]char>, attr: []char, args: list<\\ast@AstArg>, members: list<\\ast@AstClassItem>)\n\u0009switch(attr)\n\u0009case \"addr\"\n\u0009\u0009do args.head()\n\u0009\u0009var class_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return reinterpret_cast<uint64_t>(\\{class_.id});\\n\")\n\u0009case \"addDict\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var key: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->Add(\\{key.id}, \\{item.id});\\n\")\n\u0009case \"addList\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->B.push_back(\\{item.id});\\n\")\n\u0009case \"addQueue\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->B.push(\\{item.id});\\n\")\n\u0009case \"addStack\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->B.push(\\{item.id});\\n\")\n\u0009case \"and\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id} & \\{n.id};\\n\")\n\u0009case \"cmdLine\"\n\u0009\u0009do codes.add(\"Array_<Array_<char16_t>*>* a_ = new Array_<Array_<char16_t>*>();\\n\")\n\u0009\u0009do codes.add(\"a_->L = argc_;\\n\")\n\u0009\u0009do codes.add(\"a_->B = new Array_<char16_t>*[static_cast<size_t>(argc_)];\\n\")\n\u0009\u0009do codes.add(\"for (int64_t i_ = 0; i_ < argc_; i_++){\\n\")\n\u0009\u0009do codes.add(\"std::string s_ = argv_[i_];\\n\")\n\u0009\u0009do codes.add(\"const std::u16string t_ = utf8ToUtf16_(s_);\\n\")\n\u0009\u0009do codes.add(\"a_->B[i_] = new Array_<char16_t>();\\n\")\n\u0009\u0009do codes.add(\"a_->B[i_]->L = static_cast<int64_t>(t_.size());\\n\")\n\u0009\u0009do codes.add(\"a_->B[i_]->B = new char16_t[t_.size() + 1];\\n\")\n\u0009\u0009do codes.add(\"std::memcpy(a_->B[i_]->B, t_.c_str(), sizeof(char16_t) * (t_.size() + 1));\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return a_;\\n\")\n\u0009case \"del\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"auto& i_ = \\{me_.id}->I++;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}->B.erase(i_);\\n\")\n\u0009case \"fill\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var value: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"for(int64_t i_ = 0; i_ < \\{me_.id}->L; i_++) \\{me_.id}->B[i_] = \\{value.id};\\n\")\n\u0009case \"findArray\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var start: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{start.id} == -1) \\{start.id} = 0;\\n\")\n\u0009\u0009do codes.add(\"if(\\{start.id} < 0) return -1;\\n\")\n\u0009\u0009do codes.add(\"for(int64_t i_ = \\{start.id}; i_ < \\{me_.id}->L; i_++){\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}->B[i_] == \\{item.id}) return i_;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return -1;\\n\")\n\u0009case \"findBin\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"int64_t a_ = 0, b_ = \\{me_.id}->L - 1;\\n\")\n\u0009\u0009do codes.add(\"while (a_ <= b_) {\\n\")\n\u0009\u0009do codes.add(\"int64_t c_ = (a_ + b_) / 2;\\n\")\n\u0009\u0009do codes.add(\"int64_t m_ = cmp_(\\{item.id}, \\{me_.id}->B[c_]);\\n\")\n\u0009\u0009do codes.add(\"if(m_ < 0) b_ = c_ - 1;\\n\")\n\u0009\u0009do codes.add(\"else if(m_ > 0) a_ = c_ + 1;\\n\")\n\u0009\u0009do codes.add(\"else return c_;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return -1;\\n\")\n\u0009case \"forEach\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var callback: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var data: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return dictForEach_(\\{me_.id}->B, static_cast<bool(*)(K_, V_, Class_*)>(\\{callback.id}), \\{data.id});\\n\")\n\u0009case \"getDict\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var key: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var existed: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return dictSearch_(\\{me_.id}->B, \\{key.id}, \\{existed.id});\\n\")\n\u0009case \"getList\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return *\\{me_.id}->I;\\n\")\n\u0009case \"getQueue\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"R_ r_ = \\{me_.id}->B.front();\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}->B.pop();\\n\")\n\u0009\u0009do codes.add(\"return r_;\\n\")\n\u0009case \"getStack\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"R_ r_ = \\{me_.id}->B.top();\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}->B.pop();\\n\")\n\u0009\u0009do codes.add(\"return r_;\\n\")\n\u0009case \"head\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->I = \\{me_.id}->B.begin();\\n\")\n\u0009case \"idx\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"int64_t i_ = 0;\\n\")\n\u0009\u0009do codes.add(\"for(auto& t_ = \\{me_.id}->B.begin(); t_ != \\{me_.id}->B.end(); ++t_){\\n\")\n\u0009\u0009do codes.add(\"if(t_ == \\{me_.id}->I) return i_;\\n\")\n\u0009\u0009do codes.add(\"i_++;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return -1;\\n\")\n\u0009case \"ins\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->B.insert(\\{me_.id}->I, \\{item.id});\\n\")\n\u0009case \"moveOffset\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var offset: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{offset.id} >= 0){\\n\")\n\u0009\u0009do codes.add(\"for(int64_t i_ = 0; i_ < \\{offset.id}; i_++){\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}->I == \\{me_.id}->B.end()) break;\\n\")\n\u0009\u0009do codes.add(\"++\\{me_.id}->I;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"for(int64_t i_ = 0; i_ > \\{offset.id}; i_--){\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}->I == \\{me_.id}->B.end()) break;\\n\")\n\u0009\u0009do codes.add(\"--\\{me_.id}->I;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"next\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"++\\{me_.id}->I;\\n\")\n\u0009case \"or\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id} | \\{n.id};\\n\")\n\u0009case \"peekQueue\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}->B.front();\\n\")\n\u0009case \"peekStack\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}->B.top();\\n\")\n\u0009case \"rnd\"\n\u0009\u0009do args.head()\n\u0009\u0009var min: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var max: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return rnd_(\\{min.id}, \\{max.id});\\n\")\n\u0009case \"rndFloat\"\n\u0009\u0009do args.head()\n\u0009\u0009var min: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var max: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return rndFloat_(\\{min.id}, \\{max.id});\\n\")\n\u0009case \"sub\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var start: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var len: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return sub_(\\{me_.id}, \\{start.id}, \\{len.id});\\n\")\n\u0009case \"sysTime\"\n\u0009\u0009do codes.add(\"return static_cast<int64_t>(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());\\n\")\n\u0009case \"tail\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}->I = \\{me_.id}->B.end();\\n\")\n\u0009\u0009do codes.add(\"--\\{me_.id}->I;\\n\")\n\u0009case \"term\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}->I == \\{me_.id}->B.end();\\n\")\n\u0009case \"toBit64\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var success: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"std::u16string s_ = \\{me_.id}->B;\\n\")\n\u0009\u0009do codes.add(\"const std::string& t_ = utf16ToUtf8_(s_);\\n\")\n\u0009\u0009do codes.add(\"try{\\n\")\n\u0009\u0009do codes.add(\"size_t s_;\\n\")\n\u0009\u0009do codes.add(\"uint64_t v_ = t_.size() > 2 && t_[0] == \'0\' && t_[1] == \'x\' ? std::stoull(t_, &s_, 16) : std::stoull(t_, &s_);\\n\")\n\u0009\u0009do codes.add(\"if(s_ == t_.size()){\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = true;\\n\")\n\u0009\u0009do codes.add(\"return v_;\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = false;\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}catch(...){\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = false;\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"toFloat\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var success: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"std::u16string s_ = \\{me_.id}->B;\\n\")\n\u0009\u0009do codes.add(\"const std::string& t_ = utf16ToUtf8_(s_);\\n\")\n\u0009\u0009do codes.add(\"try{\\n\")\n\u0009\u0009do codes.add(\"size_t s_;\\n\")\n\u0009\u0009do codes.add(\"double v_ = std::stod(t_, &s_);\\n\")\n\u0009\u0009do codes.add(\"if(s_ == t_.size()){\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = true;\\n\")\n\u0009\u0009do codes.add(\"return v_;\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = false;\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}catch(...){\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = false;\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"toInt\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var success: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"std::u16string s_ = \\{me_.id}->B;\\n\")\n\u0009\u0009do codes.add(\"const std::string& t_ = utf16ToUtf8_(s_);\\n\")\n\u0009\u0009do codes.add(\"try{\\n\")\n\u0009\u0009do codes.add(\"size_t s_;\\n\")\n\u0009\u0009do codes.add(\"int64_t v_ = t_.size() > 2 && t_[0] == \'0\' && t_[1] == \'x\' ? std::stoll(t_, &s_, 16) : std::stoull(t_, &s_);\\n\")\n\u0009\u0009do codes.add(\"if(s_ == t_.size()){\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = true;\\n\")\n\u0009\u0009do codes.add(\"return v_;\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = false;\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}catch(...){\\n\")\n\u0009\u0009do codes.add(\"*\\{success.id} = false;\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"toStr\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return toStr_(\\{me_.id});\\n\")\n\u0009case \"cui_print\"\n\u0009\u0009do args.head()\n\u0009\u0009var str: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"std::u16string s_ = \\{str.id}->B;\\n\")\n\u0009\u0009do codes.add(\"const std::string& t_ = utf16ToUtf8_(s_);\\n\")\n\u0009\u0009do codes.add(\"std::cout << t_ << std::flush;\\n\")\n\u0009case \"file_copyFile\"\n\u0009\u0009do args.head()\n\u0009\u0009var dst: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var src: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return copyFile_(\\{dst.id}->B, \\{src.id}->B);\\n\")\n\u0009case \"file_exist\"\n\u0009\u0009do args.head()\n\u0009\u0009var path: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"return false;\\n\")\n\u0009case \"file_forEach\"\n\u0009\u0009do args.head()\n\u0009\u0009var path: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var recursion: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var callback: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var data: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"return false;\\n\")\n\u0009case \"file_makeReader\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var path: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"\\{me_.id}->\\{handle.id} = reinterpret_cast<int64_t>(new reader_());\\n\")\n\u0009\u0009do codes.add(\"std::u16string s_ = \\{path.id}->B;\\n\")\n\u0009\u0009do codes.add(\"const std::string& t_ = utf16ToUtf8_(s_);\\n\")\n\u0009\u0009do codes.add(\"reader_* r_ = reinterpret_cast<reader_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"r_->F = new std::ifstream(t_.c_str(), std::ios::in | std::ios::binary);\\n\")\n\u0009\u0009do codes.add(\"if(!*r_->F) return nullptr;\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id};\\n\")\n\u0009case \"file_makeWriter\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var path: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var append: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"\\{me_.id}->\\{handle.id} = reinterpret_cast<int64_t>(new writer_());\\n\")\n\u0009\u0009do codes.add(\"std::u16string s_ = \\{path.id}->B;\\n\")\n\u0009\u0009do codes.add(\"const std::string& t_ = utf16ToUtf8_(s_);\\n\")\n\u0009\u0009do codes.add(\"writer_* r_ = reinterpret_cast<writer_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"r_->F = new std::ofstream(t_.c_str(), std::ios::out | std::ios::binary | (\\{append.id} ? std::ios::app : std::ios::trunc));\\n\")\n\u0009\u0009do codes.add(\"if(!*r_->F) return nullptr;\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id};\\n\")\n\u0009case \"file_readerFin\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"reader_* r_ = reinterpret_cast<reader_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"r_->F->close();\\n\")\n\u0009case \"file_readerGetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"reader_* r_ = reinterpret_cast<reader_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"return static_cast<int64_t>(r_->F->tellg());\\n\")\n\u0009case \"file_readerReadLetter\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"reader_* r_ = reinterpret_cast<reader_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"return readUtf8_(r_->F);\\n\")\n\u0009case \"file_readerSetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var origin: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var pos: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"reader_* r_ = reinterpret_cast<reader_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"std::ios_base::seekdir o_ = std::ios_base::beg;\\n\")\n\u0009\u0009do codes.add(\"switch(\\{origin.id}){\\n\")\n\u0009\u0009do codes.add(\"case 0: o_ = std::ios_base::beg; break;\\n\")\n\u0009\u0009do codes.add(\"case 1: o_ = std::ios_base::cur; break;\\n\")\n\u0009\u0009do codes.add(\"case 2: o_ = std::ios_base::end; break;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"r_->F->seekg(\\{pos.id}, o_);\\n\")\n\u0009case \"file_readerTerm\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"reader_* r_ = reinterpret_cast<reader_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"char c_;\\n\")\n\u0009\u0009do codes.add(\"if(r_->F->get(c_)) {\\n\")\n\u0009\u0009do codes.add(\"r_->F->seekg(-1, std::ios_base::cur);\\n\")\n\u0009\u0009do codes.add(\"return false;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return true;\\n\")\n\u0009case \"file_writerFin\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"writer_* r_ = reinterpret_cast<writer_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"r_->F->close();\\n\")\n\u0009case \"file_writerGetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"writer_* r_ = reinterpret_cast<writer_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"return static_cast<int64_t>(r_->F->tellp());\\n\")\n\u0009case \"file_writerSetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var origin: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var pos: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"writer_* r_ = reinterpret_cast<writer_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"std::ios_base::seekdir o_ = std::ios_base::beg;\\n\")\n\u0009\u0009do codes.add(\"switch(\\{origin.id}){\\n\")\n\u0009\u0009do codes.add(\"case 0: o_ = std::ios_base::beg; break;\\n\")\n\u0009\u0009do codes.add(\"case 1: o_ = std::ios_base::cur; break;\\n\")\n\u0009\u0009do codes.add(\"case 2: o_ = std::ios_base::end; break;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"r_->F->seekp(\\{pos.id}, o_);\\n\")\n\u0009case \"file_writerWrite\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"writer_* r_ = reinterpret_cast<writer_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"r_->F->write(reinterpret_cast<char*>(\\{n.id}->B), \\{n.id}->L);\\n\")\n\u0009case \"file_writerWriteChar\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\cpp\\output@CppInfo :: \\cpp\\output@getInfo(args.get())\n\u0009\u0009var handle: \\cpp\\output@CppInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"writer_* r_ = reinterpret_cast<writer_*>(\\{me_.id}->\\{handle.id});\\n\")\n\u0009\u0009do codes.add(\"writeUtf8_(r_->F, \\{n.id});\\n\")\n\u0009case \"wnd_editBaseGetText\"\n\u0009\u0009; TODO:\n\u0009case \"wnd_makeEditMulti\"\n\u0009\u0009; TODO:\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\n\u0009\n\u0009func search(members: list<\\ast@AstClassItem>, name: []char): \\cpp\\output@CppInfo\n\u0009\u0009do members.head()\n\u0009\u0009while(!members.term())\n\u0009\u0009\u0009var def: \\ast@Ast :: members.get().def\n\u0009\u0009\u0009if(def.typeId = %var_ & (def $ \\ast@AstVar).arg.name <>& null & (def $ \\ast@AstVar).arg.name = name)\n\u0009\u0009\u0009\u0009ret \\cpp\\output@getInfo((def $ \\ast@AstVar).arg)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do members.next()\n\u0009\u0009end while\n\u0009\u0009assert false\n\u0009\u0009ret null\n\u0009end func\nend func\n":true;
else if(p==="res/err.kn")
return f?"+var errCnt: int\n\n+func err(id: \\msg@Id, pos: \\pos@Pos, args: [][]char)\n\u0009if(id < %_nonErrs & @errCnt >= 100)\n\u0009\u0009ret {Stop error detection at 100 pieces.}\n\u0009end if\n\u0009\n\u0009var msg: []char :: \\msg@get(id, args)\n\u0009do cui@print((id $ bit32).toStr() ~ \": \")\n\u0009if(pos <>& null)\n\u0009\u0009do cui@print(\"[\\{pos.srcName}: \\{pos.row}, \\{pos.col}]\")\n\u0009end if\n\u0009do cui@print(msg ~ \"\\n\")\n\u0009if(id < %_nonErrs)\n\u0009\u0009do @errCnt :+ 1\n\u0009end if\nend func\n":true;
else if(p==="res/main.kn")
return f?"const major: int :: 2019\nconst minor: int :: 10\nconst micro: int :: 17\n\nfunc main()\n\u0009if(!\\option@acquireOption())\n\u0009\u0009do lib@exitCode(1)\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009if(\\option@version)\n\u0009\u0009do cui@print(\"Kuin Programming Language v.\\{@major}.\\{@minor}.\\{@micro}\\n\")\n\u0009\u0009do cui@print(\"(C)Kuina-chan\\n\")\n\u0009\u0009do lib@exitCode(0)\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009if(\\option@help | \\option@inputFile =& null)\n\u0009\u0009do cui@print(\"Usage: kuincl [-i input.kn] [-o output.kn] [-s \'sys\' directory] [-c icon.ico] [-e environment] [-a appcode] [-r] [-h] [-v] [-q]\\n\")\n\u0009\u0009do lib@exitCode(0)\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009if(@build())\n\u0009\u0009do \\err@err(%success, null, null)\n\u0009\u0009do lib@exitCode(0)\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009if(!\\option@quiet)\n\u0009\u0009do \\err@err(%failure, null, null)\n\u0009end if\n\u0009do lib@exitCode(1)\nend func\n\nfunc build(): bool\n\u0009var asts: dict<[]char, \\ast@Ast>\n\u0009var entry: \\ast@AstFunc\n\u0009\n\u0009do \\err@errCnt :: 0\n\u0009var beginTime: int :: lib@sysTime()\n\u0009do \\err@err(%compilationStarted, null, [((lib@sysTime() - beginTime) $ float / 1000.0).toStr()])\n\u0009\n\u0009; \'Parse\'\n\u0009do asts :: \\parse@parse()\n\u0009do \\err@err(%parsingCompleted, null, [((lib@sysTime() - beginTime) $ float / 1000.0).toStr()])\n\u0009\n\u0009; \'Analyze\'\n\u0009do entry :: \\analyze@analyze(asts)\n\u0009do \\err@err(%semanticAnalysisCompleted, null, [((lib@sysTime() - beginTime) $ float / 1000.0).toStr()])\n\u0009\n\u0009; Stop compilation if some errors occur.\n\u0009if(\\err@errCnt > 0)\n\u0009\u0009ret false\n\u0009end if\n\u0009\n\u0009; \'Res\' files.\n\u0009var resDir: []char :: \\option@inputDir ~ \"res/\"\n\u0009class ResFiles()\n\u0009\u0009+var files: list<[]char>\n\u0009end class\n\u0009var resFiles: ResFiles :: #ResFiles\n\u0009do resFiles.files :: #list<[]char>\n\u0009if(file@exist(resDir))\n\u0009\u0009do file@forEach(resDir, true, searchResFiles, resFiles)\n\u0009end if\n\u0009\n\u0009; \'Output\'\n\u0009switch(\\option@env_)\n\u0009case %cpp\n\u0009\u0009if(!\\cpp\\output@output(entry, resFiles.files))\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009case %web\n\u0009\u0009if(!\\web\\output@output(entry, resFiles.files))\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\n\u0009\n\u0009do \\err@err(%generationProcessCompleted, null, [((lib@sysTime() - beginTime) $ float / 1000.0).toStr()])\n\u0009\n\u0009ret true\n\u0009\n\u0009func searchResFiles(path: []char, isDir: bool, data: kuin@Class): bool\n\u0009\u0009var data2: ResFiles :: data $ ResFiles\n\u0009\u0009do data2.files.add(path)\n\u0009\u0009ret true\n\u0009end func\nend func\n":true;
else if(p==="res/msg.kn")
return f?"+var lang: @Lang :: %ja\n\n+enum Lang\n\u0009ja\n\u0009en\nend enum\n\n+enum Id\n\u0009_generalErrs :: 0x00000000\n\u0009incorrectOption\n\u0009unexpectedOption\n\u0009incorrectExt\n\u0009incorrectSrcName\n\u0009fileOpenFailed\n\u0009sysFileOpenFailed\n\u0009sysFileBroken\n\u0009\n\u0009_parsingErrs :: 0x00010000\n\u0009sameIdentifierInSameScope\n\u0009sameIdentifierInUpperScope\n\u0009noBrace\n\u0009tabInStr\n\u0009lineBreakInStr\n\u0009wrongCharacterInIdentifier\n\u0009wrongAtInIdentifier\n\u0009uppercaseFileName\n\u0009wrongBackslashInIdentifier\n\u0009tooLongIdentifier\n\u0009incorrectBlockOrSentence\n\u0009wrongCharacterInFuncAttr\n\u0009tooLongFuncAttr\n\u0009charShouldBeWritten\n\u0009noEnd\n\u0009overrideNonFunctionMember\n\u0009exposeNonFunctionOrVariableMember\n\u0009wrongEnd\n\u0009wrongMember\n\u0009ampersandInNonArgument\n\u0009initializerInArgument\n\u0009initializerInMember\n\u0009noInitializerInConst\n\u0009noEndUnspecified\n\u0009wrongEndUnspecified\n\u0009nonCorrespondingEnd\n\u0009elifOrElseAfterElse\n\u0009caseOrDefaultAfterDefault\n\u0009catchOrFinallyAfterFinally\n\u0009wrongClause\n\u0009wrongClauseInSwitch\n\u0009wrongWord\n\u0009wrongOperator\n\u0009tooLongStringLiteral\n\u0009wrongEscSequence\n\u0009wrongCharCodeRepresentation\n\u0009nonClosingStrLiteral\n\u0009tooLongCharLiteral\n\u0009emptyCharLiteral\n\u0009noParenthesis\n\u0009wrongNumericLiteral\n\u0009tooLongNumericLiteral\n\u0009wrongHexadecimalLiteral\n\u0009wrongExponentialNotationLiteral\n\u0009wrongFloatingPointLiteral\n\u0009wrongBitTypeLiteral\n\u0009integerLiteralOverflowed\n\u0009\n\u0009_analysisErrs :: 0x00020000\n\u0009noMainFunc\n\u0009wrongMainFunc\n\u0009accessMemberWithoutMe\n\u0009nonOmittingAt\n\u0009accessUnpublishedElement\n\u0009identifierNotFound\n\u0009circulatingAlias\n\u0009circulatingClass\n\u0009overridedMemberNotFound\n\u0009memberDuplicatedWithParentClass\n\u0009overridingNonFunc\n\u0009overriddenMemberNotMatchAccessModifier\n\u0009overriddenMemberNotMatchTypeOrArg\n\u0009notAllowedToBeOverridden\n\u0009enumValueMustBeInt\n\u0009enumValueExceedIntRange\n\u0009enumValueDuplicated\n\u0009notExistedElementName\n\u0009valueOfGlobalVarMustBeConst\n\u0009valueOfConstMustBeConst\n\u0009varAndValueTypeNotMatch\n\u0009ifCondMustBeBool\n\u0009elIfCondMustBeBool\n\u0009switchCondMustBeComparable\n\u0009caseCondNotMatchSwitch\n\u0009whileCondMustBeBool\n\u0009forBeginValueMustBeInt\n\u0009forEndValueMustBeInt\n\u0009forIncreaseDecreaseValueMustBeInt\n\u0009forIncreaseDecreaseValueMustBeConst\n\u0009forIncreaseDecreaseValueMustBeOtherThanZero\n\u0009catchCondMustBeConstInt\n\u0009excptCodeMustBeInt\n\u0009mustRetValue\n\u0009retTypeNotMatchFunc\n\u0009noSideEffectDo\n\u0009mustSpecifyBlockName\n\u0009assertCondMustBeBool\n\u0009nonTypeWritten\n\u0009noValuePassed\n\u0009wrongOperatorType\n\u0009wrongLeftValueOfAssignOperator\n\u0009comparingNullByValue\n\u0009enumTypeNotInferred\n\u0009concatNull\n\u0009dividedBy0\n\u0009wrongLeftOrRightValueOfSwapOperator\n\u0009condForCondOperatorMustBeBool\n\u0009twoValueForCondOperatorMustSameType\n\u0009wrongTypeForNewOperator\n\u0009numOfElementsMustBeInt\n\u0009callNonFunction\n\u0009wrongArgNumInFunc\n\u0009nonRefArgPassed\n\u0009wrongArgTypeInFunc\n\u0009nonArrayAccess\n\u0009arrayIdxMustBeInt\n\u0009memberNotExist\n\u0009refUnpublishedMember\n\u0009elementTypesOfArrayInitNotMatch\n\u0009nullForValueTypeArrayInit\n\u0009allElementsAreEnum\n\u0009allElementsAreNull\n\u0009inaccessibleElement\n\u0009\n\u0009_nonErrs :: 0x00030000\n\u0009success\n\u0009failure\n\u0009compilationStarted\n\u0009parsingCompleted\n\u0009semanticAnalysisCompleted\n\u0009generationProcessCompleted\nend enum\n\n+func get(id: @Id, args: [][]char): []char\n\u0009switch(id)\n\u0009case %incorrectOption\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30AA\u30D7\u30B7\u30E7\u30F3\u300C\\{args[0]}\u300D\u306E\u4F7F\u308F\u308C\u65B9\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The option \'\\{args[0]}\' was used incorrectly.\"\n\u0009\u0009end switch\n\u0009case %unexpectedOption\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u4E0D\u660E\u306A\u30AA\u30D7\u30B7\u30E7\u30F3\u300C\\{args[0]}\u300D\u304C\u6307\u5B9A\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Unexpected option: \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %incorrectExt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5165\u529B\u30D5\u30A1\u30A4\u30EB\u300C\\{args[0]}\u300D\u306E\u62E1\u5F35\u5B50\u306F\u300C.kn\u300D\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The extension of the input file \'\\{args[0]}\' must be \'.kn\'.\"\n\u0009\u0009end switch\n\u0009case %incorrectSrcName\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u540D\u300C\\{args[0]}\u300D\u306B\u4F7F\u3048\u306A\u3044\u6587\u5B57\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The source file name \'\\{args[0]}\' contains characters that cannot be used.\"\n\u0009\u0009end switch\n\u0009case %fileOpenFailed\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u300C\\{args[0]}\u300D\u304C\u958B\u3051\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Cannot open source file \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %sysFileOpenFailed\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30B7\u30B9\u30C6\u30E0\u30D5\u30A1\u30A4\u30EB\u300C\\{args[0]}\u300D\u304C\u958B\u3051\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The system file \'\\{args[0]}\' could not be opened.\"\n\u0009\u0009end switch\n\u0009case %sysFileBroken\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30B7\u30B9\u30C6\u30E0\u30D5\u30A1\u30A4\u30EB\u300C\\{args[0]}\u300D\u304C\u58CA\u308C\u3066\u3044\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The system file \'\\{args[0]}\' is broken.\"\n\u0009\u0009end switch\n\u0009case %sameIdentifierInSameScope\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u540C\u3058\u30B9\u30B3\u30FC\u30D7\u5185\u306B\u65E2\u306B\u540C\u3058\u8B58\u5225\u5B50\u300C\\{args[0]}\u300D\u304C\u5B58\u5728\u3057\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The same identifier \'\\{args[0]}\' already exists in the same scope.\"\n\u0009\u0009end switch\n\u0009case %sameIdentifierInUpperScope\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u4E0A\u4F4D\u306E\u30B9\u30B3\u30FC\u30D7\u5185\u306B\u65E2\u306B\u540C\u3058\u8B58\u5225\u5B50\u300C\\{args[0]}\u300D\u304C\u5B58\u5728\u3057\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The same identifier \'\\{args[0]}\' already exists in the upper scope.\"\n\u0009\u0009end switch\n\u0009case %noBrace\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30B3\u30E1\u30F3\u30C8\u306E\u300C{\u300D\u306B\u5BFE\u5FDC\u3059\u308B\u300C}\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"There is no \'}\' corresponding to \'{\' for comment.\"\n\u0009\u0009end switch\n\u0009case %tabInStr\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3084\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u4E2D\u306B\u30BF\u30D6\u6587\u5B57\u306F\u8A18\u8FF0\u3067\u304D\u307E\u305B\u3093\u3002 \u30A8\u30B9\u30B1\u30FC\u30D7\u30B7\u30FC\u30B1\u30F3\u30B9\u300C\\\\t\u300D\u3092\u4EE3\u7528\u3057\u3066\u304F\u3060\u3055\u3044\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Tab characters cannot be written in character literals and string literals. Use the escape sequence \'\\\\t\' instead.\"\n\u0009\u0009end switch\n\u0009case %lineBreakInStr\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3084\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u4E2D\u3067\u306F\u6539\u884C\u3067\u304D\u307E\u305B\u3093\u3002 \u30A8\u30B9\u30B1\u30FC\u30D7\u30B7\u30FC\u30B1\u30F3\u30B9\u300C\\\\n\u300D\u3092\u4EE3\u7528\u3057\u3066\u304F\u3060\u3055\u3044\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Line breaks are not allowed in character literals and string literals. Use the escape sequence \'\\\\n\' instead.\"\n\u0009\u0009end switch\n\u0009case %wrongCharacterInIdentifier\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u8B58\u5225\u5B50\u306B\u306F\u4F7F\u3048\u306A\u3044\u6587\u5B57\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The character \'\\{args[0]}\' that cannot be used in identifiers was written.\"\n\u0009\u0009end switch\n\u0009case %wrongAtInIdentifier\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u8B58\u5225\u5B50\u306B\u6B63\u3057\u304F\u306A\u3044\u5F62\u5F0F\u3067\u300C@\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Incorrect \'@\' was written in an identifier.\"\n\u0009\u0009end switch\n\u0009case %uppercaseFileName\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u540D\u306E\u6307\u5B9A\u300C\\{args[0]}\u300D\u306B\u5927\u6587\u5B57\u304C\u542B\u307E\u308C\u3066\u3044\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A source file name description \'\\{args[0]}\' contains uppercase letters.\"\n\u0009\u0009end switch\n\u0009case %wrongBackslashInIdentifier\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u8B58\u5225\u5B50\u306B\u6B63\u3057\u304F\u306A\u3044\u5F62\u5F0F\u3067\u300C\\\\\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Incorrect \'\\\\\' was written in an identifier.\"\n\u0009\u0009end switch\n\u0009case %tooLongIdentifier\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u8B58\u5225\u5B50\u300C\\{args[0]}...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 128\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The identifier \'\\{args[0]}...\' is too long. Must be 128 characters or less.\"\n\u0009\u0009end switch\n\u0009case %incorrectBlockOrSentence\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u30D6\u30ED\u30C3\u30AF\u3082\u3057\u304F\u306F\u6587\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An incorrect block or sentence \'\\{args[0]}\' was written.\"\n\u0009\u0009end switch\n\u0009case %wrongCharacterInFuncAttr\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u5C5E\u6027\u306B\u306F\u4F7F\u3048\u306A\u3044\u6587\u5B57\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The character \'\\{args[0]}\' that cannot be used in function attributes was written.\"\n\u0009\u0009end switch\n\u0009case %tooLongFuncAttr\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u5C5E\u6027\u300C\\{args[0]}...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 128\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The function attribute \'\\{args[0]}...\' is too long. Must be 128 characters or less.\"\n\u0009\u0009end switch\n\u0009case %charShouldBeWritten\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u308B\u3079\u304D\u7B87\u6240\u306B\u3001\u4E0D\u6B63\u306A\u6587\u5B57\u300C\\{args[1]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An invalid character \'\\{args[1]}\' was written in a place where the character \'\\{args[0]}\' should be written.\"\n\u0009\u0009end switch\n\u0009case %noEnd\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\\{args[0]}\u300D\u306B\u5BFE\u5FDC\u3059\u308B\u300Cend \\{args[0]}\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"There is no \'end \\{args[0]}\' corresponding to \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %overrideNonFunctionMember\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u4EE5\u5916\u306E\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Overridden non-function member \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %exposeNonFunctionOrVariableMember\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u304A\u3088\u3073\u5909\u6570\u4EE5\u5916\u306E\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3092\u516C\u958B\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The member \'\\{args[0]}\' other than functions and variables has been released.\"\n\u0009\u0009end switch\n\u0009case %wrongEnd\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\\{args[0]}\u300D\u304C\u300Cend \\{args[0]}\u300D\u3067\u306F\u306A\u304F\u4E0D\u6B63\u306A\u300Cend \\{args[1]}\u300D\u3067\u9589\u3058\u3089\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'\\{args[0]}\' was closed with invalid \'end \\{args[1]}\' instead of \'end \\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %wrongMember\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6B63\u3057\u304F\u306A\u3044\u5F62\u5F0F\u306E\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Incorrectly formatted member \'\\{args[0]}\' was written.\"\n\u0009\u0009end switch\n\u0009case %ampersandInNonArgument\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5F15\u6570\u4EE5\u5916\u306E\u5909\u6570\u306B\u4E0D\u6B63\u306A\u300C&\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An invalid \'&\' was written in other than an argument.\"\n\u0009\u0009end switch\n\u0009case %initializerInArgument\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5F15\u6570\u306B\u521D\u671F\u5316\u5B50\u300C::\u300D\u3092\u8A18\u8FF0\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The initializer \'::\' cannot be written in arguments.\"\n\u0009\u0009end switch\n\u0009case %initializerInMember\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30E1\u30F3\u30D0\u306B\u521D\u671F\u5316\u5B50\u300C::\u300D\u3092\u8A18\u8FF0\u3059\u308B\u3053\u3068\u306F\u3067\u304D\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The initializer \'::\' cannot be written in members.\"\n\u0009\u0009end switch\n\u0009case %noInitializerInConst\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"const\u6587\u306B\u306F\u521D\u671F\u5316\u5B50\u300C::\u300D\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The initializer \'::\' must be written in const statements.\"\n\u0009\u0009end switch\n\u0009case %noEndUnspecified\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30D6\u30ED\u30C3\u30AF\u306B\u5BFE\u5FDC\u3059\u308B\u300Cend\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"There is no \'end\' corresponding to a block.\"\n\u0009\u0009end switch\n\u0009case %wrongEndUnspecified\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cend \\{args[0]}\u300D\u306F\u4E0D\u6B63\u306A\u5F62\u5F0F\u3067\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'end \\{args[0]}\' is incorrectly formatted.\"\n\u0009\u0009end switch\n\u0009case %nonCorrespondingEnd\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30D6\u30ED\u30C3\u30AF\u3068\u5BFE\u5FDC\u3057\u306A\u3044\u4E0D\u6B63\u306A\u300Cend \\{args[0]}\u300D\u3067\u9589\u3058\u3089\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Closed with invalid \'end \\{args[0]}\' that does not correspond to the block.\"\n\u0009\u0009end switch\n\u0009case %elifOrElseAfterElse\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cif\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Celse\u300D\u7BC0\u306E\u5F8C\u306B\u4E0D\u6B63\u306A\u300Celif\u300D\u7BC0\u3084\u300Celse\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"In an \'if\' block, an invalid \'elif\' or \'else\' clauses is written after an \'else\' clause.\"\n\u0009\u0009end switch\n\u0009case %caseOrDefaultAfterDefault\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Cdefault\u300D\u7BC0\u306E\u5F8C\u306B\u4E0D\u6B63\u306A\u300Ccase\u300D\u7BC0\u3084\u300Cdefault\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"In a \'switch\' block, an invalid \'case\' or \'default\' clauses is written after a \'default\' clause.\"\n\u0009\u0009end switch\n\u0009case %catchOrFinallyAfterFinally\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Ctry\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Cfinally\u300D\u7BC0\u306E\u5F8C\u306B\u4E0D\u6B63\u306A\u300Ccatch\u300D\u7BC0\u3084\u300Cfinally\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"In a \'try\' block, an invalid \'catch\' or \'finally\' clauses is written after a \'finally\' clause.\"\n\u0009\u0009end switch\n\u0009case %wrongClause\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\\{args[0]}\u300D\u30D6\u30ED\u30C3\u30AF\u4EE5\u5916\u3067\u4E0D\u6B63\u306A\u300C\\{args[1]}\u300D\u7BC0\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A invalid \'\\{args[1]}\' clause was written outside \'\\{args[0]}\' blocks.\"\n\u0009\u0009end switch\n\u0009case %wrongClauseInSwitch\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u3067\u300Ccase\u300D\u300Cdefault\u300D\u300Cend switch\u300D\u306E\u3044\u305A\u308C\u304B\u304C\u8A18\u8FF0\u3055\u308C\u308B\u3079\u304D\u7B87\u6240\u306B\u305D\u308C\u4EE5\u5916\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"In a \'switch\' block, clauses other than \'case\', \'default\' and \'end switch\' were written.\"\n\u0009\u0009end switch\n\u0009case %wrongWord\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u308B\u3079\u304D\u7B87\u6240\u306B\u4E0D\u6B63\u306A\u300C\\{args[1]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An invalid \'\\{args[1]}\' was written where \'\\{args[0]}\' should be written.\"\n\u0009\u0009end switch\n\u0009case %wrongOperator\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u6F14\u7B97\u5B50\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An incorrect operator \'\\{args[0]}\' was written.\"\n\u0009\u0009end switch\n\u0009case %tooLongStringLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u300C\\{args[0]}...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 1024\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The string literal \'\\{args[0]}\' is too long. Must be 1024 characters or less.\"\n\u0009\u0009end switch\n\u0009case %wrongEscSequence\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u30A8\u30B9\u30B1\u30FC\u30D7\u30B7\u30FC\u30B1\u30F3\u30B9\u300C\\\\\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A invalid escape sequence \'\\\\\\{args[0]}\' was written.\"\n\u0009\u0009end switch\n\u0009case %wrongCharCodeRepresentation\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u30B3\u30FC\u30C9\u8868\u8A18\u306F\u300C\\\\u\u300D\u306B\u7D9A\u3044\u3066\u3001\u6570\u5B57\u307E\u305F\u306F\u5927\u6587\u5B57\u30A2\u30EB\u30D5\u30A1\u30D9\u30C3\u30C8\u30674\u6841\u306E16\u9032\u6570\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Character code representations must be \'\\\\u\' followed by a 4-digit hexadecimal number in numbers or capital letters.\"\n\u0009\u0009end switch\n\u0009case %nonClosingStrLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u3082\u3057\u304F\u306F\u6587\u5B57\u5217\u30EA\u30C6\u30E9\u30EB\u304C\u9589\u3058\u3089\u308C\u3066\u3044\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A character literal or string literal is not closed.\"\n\u0009\u0009end switch\n\u0009case %tooLongCharLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u300C\\{args[0]}...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 1\u6587\u5B57\u5206\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The character literal \'\\{args[0]}...\' is too long. A character literal must contain one character.\"\n\u0009\u0009end switch\n\u0009case %emptyCharLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6587\u5B57\u30EA\u30C6\u30E9\u30EB\u304C\u7A7A\u3067\u3059\u3002 1\u6587\u5B57\u5206\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"There is an empty character literal. A character literal must contain one character.\"\n\u0009\u0009end switch\n\u0009case %noParenthesis\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u62EC\u5F27\u300C(\u300D\u306B\u5BFE\u5FDC\u3059\u308B\u300C)\u300D\u304C\u3001\u3042\u308B\u3079\u304D\u5834\u6240\u306B\u5B58\u5728\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The \')\' corresponding to the parenthesis \'(\' does not exist where it should be.\"\n\u0009\u0009end switch\n\u0009case %wrongNumericLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6570\u5024\u30EA\u30C6\u30E9\u30EB\u306B\u4E0D\u6B63\u306A\u5F62\u5F0F\u306E\u300C\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An invalid \'\\{args[0]}\' was written in a numeric literal.\"\n\u0009\u0009end switch\n\u0009case %tooLongNumericLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6570\u5024\u30EA\u30C6\u30E9\u30EB\u300C\\{args[0]}...\u300D\u304C\u9577\u3059\u304E\u307E\u3059\u3002 1024\u6587\u5B57\u4EE5\u4E0B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The numeric literal \'\\{args[0]}\' is too long. Must be 1024 characters or less.\"\n\u0009\u0009end switch\n\u0009case %wrongHexadecimalLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"16\u9032\u6570\u30EA\u30C6\u30E9\u30EB\u306F\u300C0x\u300D\u304B\u3089\u59CB\u3081\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Hexadecimal literals must start with \'0x\'.\"\n\u0009\u0009end switch\n\u0009case %wrongExponentialNotationLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6307\u6570\u8868\u8A18\u30EA\u30C6\u30E9\u30EB\u306F\u300Ce+\u300D\u3082\u3057\u304F\u306F\u300Ce-\u300D\u304B\u3089\u59CB\u3081\u3066\u6307\u6570\u90E8\u3092\u8A18\u8FF0\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Exponential notation literals must start with \'e+\' or \'e-\' and write the exponent part.\"\n\u0009\u0009end switch\n\u0009case %wrongFloatingPointLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6D6E\u52D5\u5C0F\u6570\u70B9\u30EA\u30C6\u30E9\u30EB\u300C\\{args[0]}\u300D\u304C\u89E3\u91C8\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002 \u5024\u304C\u5927\u304D\u3059\u304E\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The floating point literal \'\\{args[0]}\' could not be interpreted. The value may be too large.\"\n\u0009\u0009end switch\n\u0009case %wrongBitTypeLiteral\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30D3\u30C3\u30C8\u578B\u30EA\u30C6\u30E9\u30EB\u300C\\{args[0]}\u300D\u306E\u63A5\u5C3E\u8F9E\u306F\u300Cb8\u300D\u300Cb16\u300D\u300Cb32\u300D\u300Cb64\u300D\u306E\u3044\u305A\u308C\u304B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The suffix of bit type literal \'\\{args[0]}\' must be either \'b8\', \'b16\', \'b32\' or \'b64\'.\"\n\u0009\u0009end switch\n\u0009case %integerLiteralOverflowed\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6574\u6570\u30EA\u30C6\u30E9\u30EB\u300C\\{args[0]}\u300D\u304C\u30AA\u30FC\u30D0\u30FC\u30D5\u30ED\u30FC\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The integer literal \'\\{args[0]}\' has overflowed.\"\n\u0009\u0009end switch\n\u0009case %noMainFunc\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cmain\u300D\u95A2\u6570\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002 \u30B3\u30F3\u30D1\u30A4\u30EB\u3059\u308B\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u306B\u300Cfunc main()\u300D\u3092\u5B9A\u7FA9\u3057\u3066\u304F\u3060\u3055\u3044\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'main\' function does not exist. Define \'func main()\' in the source files to be compiled.\"\n\u0009\u0009end switch\n\u0009case %wrongMainFunc\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cmain\u300D\u95A2\u6570\u306E\u5B9A\u7FA9\u306F\u300Cfunc main()\u300D\u3068\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The definition of the \'main\' function must be \'func main()\'.\"\n\u0009\u0009end switch\n\u0009case %accessMemberWithoutMe\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30E1\u30F3\u30D0\u3082\u3057\u304F\u306F\u5909\u6570\u300C\\{args[0]}\u300D\u306B\u3001\u300Cme\u300D\u3092\u4ECB\u3055\u305A\u76F4\u63A5\u30A2\u30AF\u30BB\u30B9\u3057\u305F\u304B\u3001\u95A2\u6570\u3092\u8D85\u3048\u3066\u30A2\u30AF\u30BB\u30B9\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The member or variable \'\\{args[0]}\' was accessed directly without \'me\', or accessed beyond the function.\"\n\u0009\u0009end switch\n\u0009case %nonOmittingAt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\\{args[0]}@\u300D\u306B\u3064\u3044\u3066\u3001\u81EA\u8EAB\u306E\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u306E\u30B0\u30ED\u30FC\u30D0\u30EB\u8981\u7D20\u3092\u53C2\u7167\u3059\u308B\u3068\u304D\u306F\u3001\u300C@\u300D\u306E\u524D\u306E\u30BD\u30FC\u30B9\u540D\u3092\u7701\u7565\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"For \'\\{args[0]}@\', when referring to global elements in its own source file, the source name before the \'@\' must be omitted.\"\n\u0009\u0009end switch\n\u0009case %accessUnpublishedElement\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u4ED6\u306E\u30BD\u30FC\u30B9\u30D5\u30A1\u30A4\u30EB\u306E\u516C\u958B\u3055\u308C\u3066\u3044\u306A\u3044\u8981\u7D20\u300C\\{args[0]}\u300D\u3092\u53C2\u7167\u3057\u307E\u3057\u305F\u3002\u8981\u7D20\u306E\u5148\u982D\u306B\u300C+\u300D\u304C\u4ED8\u3044\u3066\u3044\u308B\u5FC5\u8981\u304C\u3042\u308A\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A non-public element \'\\{args[0]}\' in another souce file was referenced. The element must start with a \'+\'.\"\n\u0009\u0009end switch\n\u0009case %identifierNotFound\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u8B58\u5225\u5B50\u300C\\{args[0]}\u300D\u306E\u5B9A\u7FA9\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002\u540D\u524D\u3092\u9593\u9055\u3048\u3066\u3044\u308B\u53EF\u80FD\u6027\u304C\u3042\u308A\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The definition of identifier \'\\{args[0]}\' was not be found. The name may have been written incorrectly.\"\n\u0009\u0009end switch\n\u0009case %circulatingAlias\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Calias \\{args[0]}\u300D\u306E\u5B9A\u7FA9\u304C\u5FAA\u74B0\u3057\u3066\u3044\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The definition of \'alias \\{args[0]}\' is circulating.\"\n\u0009\u0009end switch\n\u0009case %circulatingClass\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cclass \\{args[0]}\u300D\u306E\u7D99\u627F\u304C\u5FAA\u74B0\u3057\u3066\u3044\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The inheritance of \'class \\{args[0]}\' is circulating.\"\n\u0009\u0009end switch\n\u0009case %overridedMemberNotFound\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B\u89AA\u30AF\u30E9\u30B9\u306E\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u304C\u898B\u3064\u304B\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The member \'\\{args[0]}\' of the parent class to override cannot be found.\"\n\u0009\u0009end switch\n\u0009case %memberDuplicatedWithParentClass\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30E1\u30F3\u30D0\u540D\u300C\\{args[0]}\u300D\u304C\u89AA\u30AF\u30E9\u30B9\u306E\u3082\u306E\u3068\u91CD\u8907\u3057\u3066\u3044\u307E\u3059\u3002 \u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3059\u308B\u5834\u5408\u306F\u300C*\u300D\u3092\u4ED8\u3051\u3066\u304F\u3060\u3055\u3044\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The member name \'\\{args[0]}\' is duplicated with that of the parent class. Add \'*\' when overriding.\"\n\u0009\u0009end switch\n\u0009case %overridingNonFunc\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u4EE5\u5916\u306E\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Overridden non-function member \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %overriddenMemberNotMatchAccessModifier\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u305F\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3068\u30A2\u30AF\u30BB\u30B9\u4FEE\u98FE\u5B50\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The access modifier does not match that of the overridden member \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %overriddenMemberNotMatchTypeOrArg\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u305F\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3068\u578B\u3082\u3057\u304F\u306F\u5F15\u6570\u540D\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The types or argument names do not match that of the overridden member \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %notAllowedToBeOverridden\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u304C\u8A31\u53EF\u3055\u308C\u3066\u3044\u306A\u3044\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3092\u30AA\u30FC\u30D0\u30FC\u30E9\u30A4\u30C9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The member \'\\{args[0]}\' that is not allowed to be overridden was overridden.\"\n\u0009\u0009end switch\n\u0009case %enumValueMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5217\u6319\u578B\u300C\\{args[0]}\u300D\u306E\u8981\u7D20\u300C%\\{args[1]}\u300D\u306E\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u300Cint\u300D\u578B\u306E\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The value of the element \'%\\{args[1]}\' of enumeration type \'\\{args[0]}\' must be an \'int\' value that can be made a constant at compile time.\"\n\u0009\u0009end switch\n\u0009case %enumValueExceedIntRange\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5217\u6319\u578B\u300C\\{args[0]}\u300D\u306E\u8981\u7D20\u300C%\\{args[1]}\u300D\u306E\u5024\u304C\u300Cint\u300D\u578B\u306E\u6709\u52B9\u7BC4\u56F2\u3092\u8D85\u3048\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The value of the element \'%\\{args[1]}\' of enumeration type \'\\{args[0]}\' exceeds the valid range of \'int\' type.\"\n\u0009\u0009end switch\n\u0009case %enumValueDuplicated\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5217\u6319\u578B\u300C\\{args[0]}\u300D\u306E\u8981\u7D20\u300C%\\{args[1]}\u300D\u306E\u5024\u300C\\{args[2]}\u300D\u304C\u5225\u306E\u8981\u7D20\u306E\u5024\u3068\u91CD\u8907\u3057\u3066\u3044\u307E\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The value \'\\{args[2]}\' of the element \'%\\{args[1]}\' of enumeration type \'\\{args[0]}\' is duplicated with the value of another element.\"\n\u0009\u0009end switch\n\u0009case %notExistedElementName\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5217\u6319\u578B\u5185\u306B\u5B58\u5728\u3057\u306A\u3044\u8981\u7D20\u540D\u300C%\\{args[0]}\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The element name \'%\\{args[0]}\' that does not exist in the enumeration type was written.\"\n\u0009\u0009end switch\n\u0009case %valueOfGlobalVarMustBeConst\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30B0\u30ED\u30FC\u30D0\u30EB\u5909\u6570\u300C\\{args[0]}\u300D\u306E\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The value of global variable \'\\{args[0]}\' must be a constant at compile time.\"\n\u0009\u0009end switch\n\u0009case %valueOfConstMustBeConst\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cconst\u300D\u6587\u300C\\{args[0]}\u300D\u306E\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The value of \'const\' statement \'\\{args[0]}\' must be a constant at compile time.\"\n\u0009\u0009end switch\n\u0009case %varAndValueTypeNotMatch\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5909\u6570\u300C\\{args[0]}\u300D\u306E\u578B\u3068\u5024\u306E\u578B\u304C\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type of the variable \'\\{args[0]}\' does not match the value type.\"\n\u0009\u0009end switch\n\u0009case %ifCondMustBeBool\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cif\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The conditional expression of the \'if\' block must be \'bool\' type.\"\n\u0009\u0009end switch\n\u0009case %elIfCondMustBeBool\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Celif\u300D\u7BC0\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The conditional expression of the \'elif\' clause must be \'bool\' type.\"\n\u0009\u0009end switch\n\u0009case %switchCondMustBeComparable\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306F\u6BD4\u8F03\u53EF\u80FD\u306A\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The conditional expression of the \'switch\' block must be a comparable type.\"\n\u0009\u0009end switch\n\u0009case %caseCondNotMatchSwitch\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Ccase\u300D\u7BC0\u306E\u578B\u304C\u300Cswitch\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306E\u578B\u3068\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type of the \'case\' clause does not match the type of the conditional expression in the \'switch\' block.\"\n\u0009\u0009end switch\n\u0009case %whileCondMustBeBool\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cwhile\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The conditional expression of the \'while\' block must be \'bool\' type.\"\n\u0009\u0009end switch\n\u0009case %forBeginValueMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u521D\u671F\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The begin value of the \'for\' block must be \'int\' type.\"\n\u0009\u0009end switch\n\u0009case %forEndValueMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u7D42\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The end value of the \'for\' block must be \'int\' type.\"\n\u0009\u0009end switch\n\u0009case %forIncreaseDecreaseValueMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u5897\u6E1B\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The increase / decrease value of the \'for\' block must be \'int\' type.\"\n\u0009\u0009end switch\n\u0009case %forIncreaseDecreaseValueMustBeConst\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u5897\u6E1B\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The increase / decrease value of the \'for\' block must be a constant at compile time.\"\n\u0009\u0009end switch\n\u0009case %forIncreaseDecreaseValueMustBeOtherThanZero\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cfor\u300D\u30D6\u30ED\u30C3\u30AF\u306E\u5897\u6E1B\u5024\u306F\u300C0\u300D\u4EE5\u5916\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The increase / decrease value of the \'for\' block must be other than \'0\'.\"\n\u0009\u0009end switch\n\u0009case %catchCondMustBeConstInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Ccatch\u300D\u7BC0\u306E\u6761\u4EF6\u5024\u306F\u30B3\u30F3\u30D1\u30A4\u30EB\u6642\u306B\u5B9A\u6570\u306B\u3067\u304D\u308B\u300Cint\u300D\u578B\u306E\u5024\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The condition value in the \'catch\' clause must be an \'int\' value that can be a constant at compile time.\"\n\u0009\u0009end switch\n\u0009case %excptCodeMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cthrow\u300D\u6587\u306E\u4F8B\u5916\u30B3\u30FC\u30C9\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The exception code for the \'throw\' statement must be \'int\'.\"\n\u0009\u0009end switch\n\u0009case %mustRetValue\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u623B\u308A\u5024\u3092\u8FD4\u3059\u95A2\u6570\u3067\u306F\u300Cret\u300D\u6587\u306F\u5024\u3092\u8FD4\u3055\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"For functions that return a value, \'ret\' statements must return a value.\"\n\u0009\u0009end switch\n\u0009case %retTypeNotMatchFunc\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cret\u300D\u6587\u306E\u5024\u306E\u578B\u304C\u95A2\u6570\u306E\u623B\u308A\u5024\u306E\u578B\u3068\u4E00\u81F4\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type of the \'ret\' statement does not match the return type of the function.\"\n\u0009\u0009end switch\n\u0009case %noSideEffectDo\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cdo\u300D\u6587\u3067\u6700\u5F8C\u306B\u884C\u3046\u6F14\u7B97\u306F\u300C::\u300D\u6F14\u7B97\u5B50\u3084\u95A2\u6570\u547C\u3073\u51FA\u3057\u306A\u3069\u306E\u526F\u4F5C\u7528\u306E\u3042\u308B\u6F14\u7B97\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The last operation in \'do\' statements must be with side effects such as \'::\' operator or function calls.\"\n\u0009\u0009end switch\n\u0009case %mustSpecifyBlockName\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C\\{args[0]}\u300D\u6587\u306B\u306F\u30D6\u30ED\u30C3\u30AF\u540D\u3092\u6307\u5B9A\u3057\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'\\{args[0]}\' statements must be given block names.\"\n\u0009\u0009end switch\n\u0009case %assertCondMustBeBool\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cassert\u300D\u6587\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The conditional expression of the \'assert\' statement must be \'bool\' type.\"\n\u0009\u0009end switch\n\u0009case %nonTypeWritten\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u578B\u3092\u8A18\u8FF0\u3059\u3079\u304D\u3068\u3053\u308D\u306B\u578B\u4EE5\u5916\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A non-type was written where a type should be written.\"\n\u0009\u0009end switch\n\u0009case %noValuePassed\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5024\u304C\u8A2D\u5B9A\u3055\u308C\u308B\u3079\u304D\u5834\u6240\u306B\u5024\u304C\u6E21\u3055\u308C\u307E\u305B\u3093\u3067\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"No value was passed where some value should be set.\"\n\u0009\u0009end switch\n\u0009case %wrongOperatorType\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6F14\u7B97\u5B50\u306E\u578B\u304C\u6B63\u3057\u304F\u3042\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Incorrect type for operator.\"\n\u0009\u0009end switch\n\u0009case %wrongLeftValueOfAssignOperator\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u4EE3\u5165\u6F14\u7B97\u5B50\u306E\u5DE6\u8FBA\u5024\u304C\u4EE3\u5165\u53EF\u80FD\u306A\u5909\u6570\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The left value of the assignment operator is not an assignable variable.\"\n\u0009\u0009end switch\n\u0009case %comparingNullByValue\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cnull\u300D\u306F\u5024\u6BD4\u8F03\u304C\u3067\u304D\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'null\' cannot be compared by value.\"\n\u0009\u0009end switch\n\u0009case %enumTypeNotInferred\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cenum\u300D\u306E\u8981\u7D20\u540D\u300C\\{args[0]}\u300D\u304B\u3089\u578B\u304C\u63A8\u6E2C\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type could not be inferred from the element name \'\\{args[0]}\' of \'enum\'.\"\n\u0009\u0009end switch\n\u0009case %concatNull\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300Cnull\u300D\u306F\u300C~\u300D\u6F14\u7B97\u5B50\u3067\u9023\u7D50\u3067\u304D\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'null\' cannot be concatenated with the \'~\' operator.\"\n\u0009\u0009end switch\n\u0009case %dividedBy0\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"0\u3067\u9664\u7B97\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Divided by 0.\"\n\u0009\u0009end switch\n\u0009case %wrongLeftOrRightValueOfSwapOperator\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C:$\u300D\u6F14\u7B97\u5B50\u306E\u5DE6\u8FBA\u5024\u3082\u3057\u304F\u306F\u53F3\u8FBA\u5024\u304C\u4EE3\u5165\u53EF\u80FD\u306A\u5909\u6570\u3067\u306F\u3042\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The left or right value of the \':$\' operator is not an assignable variable.\"\n\u0009\u0009end switch\n\u0009case %condForCondOperatorMustBeBool\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C?(,)\u300D\u6F14\u7B97\u5B50\u306E\u6761\u4EF6\u5F0F\u306F\u300Cbool\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The conditional expression for the \'?(,)\' operator must be \'bool\'.\"\n\u0009\u0009end switch\n\u0009case %twoValueForCondOperatorMustSameType\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C?(,)\u300D\u6F14\u7B97\u5B50\u306E\u62EC\u5F27\u5185\u306E2\u3064\u306E\u5024\u306F\u540C\u3058\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The two values in the parenthesis for the \'?(,)\' operator must be the same type.\"\n\u0009\u0009end switch\n\u0009case %wrongTypeForNewOperator\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C#\u300D\u6F14\u7B97\u5B50\u306F\u30AF\u30E9\u30B9\u3084\u300Clist\u300D\u300Cdict\u300D\u306A\u3069\u306E\u53C2\u7167\u578B\u306B\u3057\u304B\u4F7F\u3048\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The \'#\' operator can only be used for reference types such as classes, \'list\' and \'dict\'.\"\n\u0009\u0009end switch\n\u0009case %numOfElementsMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u300C#\u300D\u6F14\u7B97\u5B50\u306B\u8A18\u8FF0\u3059\u308B\u914D\u5217\u306E\u8981\u7D20\u6570\u306E\u5024\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The number of array elements written in the \'#\' operator must be \'int\'.\"\n\u0009\u0009end switch\n\u0009case %callNonFunction\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u3067\u306A\u3044\u3082\u306E\u3092\u95A2\u6570\u547C\u3073\u51FA\u3057\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A non-function was called as if it were a function.\"\n\u0009\u0009end switch\n\u0009case %wrongArgNumInFunc\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\\{args[0]}\u500B\u306E\u5F15\u6570\u3092\u53D7\u3051\u53D6\u308B\u95A2\u6570\u547C\u3073\u51FA\u3057\u306B\\{args[1]}\u500B\u306E\u5F15\u6570\u304C\u6307\u5B9A\u3055\u308C\u307E\u3057\u305F\u3002 \u95A2\u6570\u306E\u578B\u306F\u300C\\{args[2]}\u300D\u3067\u3059\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\\{args[1]} arguments were written in the function call that received \\{args[0]} arguments. The function type is \'\\{args[2]}\'\"\n\u0009\u0009end switch\n\u0009case %nonRefArgPassed\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u547C\u3073\u51FA\u3057\u306E\\{args[0]}\u756A\u76EE\u306E\u53C2\u7167\u6E21\u3057\u306E\u5F15\u6570\u306B\u3001\u53C2\u7167\u3092\u53D6\u308C\u306A\u3044\u5024\u304C\u6E21\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A value that cannot be referenced was passed to the \\{args[0]}th/st/nd/rd argument, which is a reference argument, of the function call.\"\n\u0009\u0009end switch\n\u0009case %wrongArgTypeInFunc\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u95A2\u6570\u547C\u3073\u51FA\u3057\u306E\u5F15\u6570\u306E\u578B\u304C\u7570\u306A\u308A\u307E\u3059\u3002 \\{args[0]}\u756A\u76EE\u306E\u5F15\u6570\u3067\u300C\\{args[1]}\u300D\u3092\u6307\u5B9A\u3059\u3079\u304D\u3068\u3053\u308D\u306B\u300C\\{args[2]}\u300D\u304C\u6E21\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type of arguments of the function call is different. \'\\{args[2]}\' has been passed where \'\\{args[1]}\' should be written in the \\{args[0]}th/st/nd/rd argument.\"\n\u0009\u0009end switch\n\u0009case %nonArrayAccess\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u914D\u5217\u3067\u306A\u3044\u3082\u306E\u306B\u914D\u5217\u30A2\u30AF\u30BB\u30B9\u3057\u3088\u3046\u3068\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"A non-array was accessed as an array.\"\n\u0009\u0009end switch\n\u0009case %arrayIdxMustBeInt\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u914D\u5217\u306E\u6DFB\u5B57\u306F\u300Cint\u300D\u578B\u3067\u306A\u3051\u308C\u3070\u306A\u308A\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Array indices must be \'int\'.\"\n\u0009\u0009end switch\n\u0009case %memberNotExist\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u53C2\u7167\u5148\u306E\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u304C\u5B58\u5728\u3057\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The referenced member \'\\{args[0]}\' does not exist.\"\n\u0009\u0009end switch\n\u0009case %refUnpublishedMember\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u516C\u958B\u3055\u308C\u3066\u3044\u306A\u3044\u30E1\u30F3\u30D0\u300C\\{args[0]}\u300D\u3092\u53C2\u7167\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"An unpublished member \'\\{args[0]}\' was referenced.\"\n\u0009\u0009end switch\n\u0009case %elementTypesOfArrayInitNotMatch\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306E\u8981\u7D20\u306E\u578B\u304C\u4E00\u81F4\u3057\u3066\u3044\u307E\u305B\u3093\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The element types of the array initializer \'[]\' do not match.\"\n\u0009\u0009end switch\n\u0009case %nullForValueTypeArrayInit\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5024\u578B\u306E\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306B\u300Cnull\u300D\u304C\u8A18\u8FF0\u3055\u308C\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"\'null\' was written in the value type array initializer \'[]\'.\"\n\u0009\u0009end switch\n\u0009case %allElementsAreEnum\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306E\u3059\u3079\u3066\u306E\u8981\u7D20\u304C\u300Cenum\u300D\u306E\u8981\u7D20\u540D\u306E\u305F\u3081\u3001\u578B\u304C\u6C7A\u5B9A\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002 \u3044\u305A\u308C\u304B\u306E\u8981\u7D20\u540D\u3092\u30AD\u30E3\u30B9\u30C8\u3057\u3066\u578B\u3092\u793A\u3057\u3066\u304F\u3060\u3055\u3044\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type could not be determined because all elements of the array initializer \'[]\' are element names of \'enum\'. Cast one of the element names to indicate the type.\"\n\u0009\u0009end switch\n\u0009case %allElementsAreNull\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u914D\u5217\u521D\u671F\u5316\u5B50\u300C[]\u300D\u306E\u3059\u3079\u3066\u306E\u8981\u7D20\u304C\u300Cnull\u300D\u306E\u305F\u3081\u3001\u578B\u304C\u6C7A\u5B9A\u3067\u304D\u307E\u305B\u3093\u3067\u3057\u305F\u3002 \u3044\u305A\u308C\u304B\u306E\u300Cnull\u300D\u3092\u30AD\u30E3\u30B9\u30C8\u3057\u3066\u578B\u3092\u793A\u3057\u3066\u304F\u3060\u3055\u3044\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"The type could not be determined because all elements of the array initializer \'[]\' are \'null\'. Cast one of \'null\' to indicate the type.\"\n\u0009\u0009end switch\n\u0009case %inaccessibleElement\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30A2\u30AF\u30BB\u30B9\u3067\u304D\u306A\u3044\u8981\u7D20\u300C\\{args[0]}\u300D\u306B\u30A2\u30AF\u30BB\u30B9\u3057\u307E\u3057\u305F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Accessed inaccessible element \'\\{args[0]}\'.\"\n\u0009\u0009end switch\n\u0009case %success\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u6210\u529F\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Success.\"\n\u0009\u0009end switch\n\u0009case %failure\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5931\u6557\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Failure.\"\n\u0009\u0009end switch\n\u0009case %compilationStarted\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u30B3\u30F3\u30D1\u30A4\u30EB\u958B\u59CB: \\{args[0]}\u79D2\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Compilation started: \\{args[0]}s.\"\n\u0009\u0009end switch\n\u0009case %parsingCompleted\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u5B57\u53E5\u69CB\u6587\u89E3\u6790\u5B8C\u4E86: \\{args[0]}\u79D2\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Parsing is complete: \\{args[0]}s.\"\n\u0009\u0009end switch\n\u0009case %semanticAnalysisCompleted\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u610F\u5473\u89E3\u6790\u5B8C\u4E86: \\{args[0]}\u79D2\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Semantic analysis is complete: \\{args[0]}s.\"\n\u0009\u0009end switch\n\u0009case %generationProcessCompleted\n\u0009\u0009switch(@lang)\n\u0009\u0009case %ja\n\u0009\u0009\u0009ret \"\u751F\u6210\u51E6\u7406\u5B8C\u4E86: \\{args[0]}\u79D2\u3002\"\n\u0009\u0009default\n\u0009\u0009\u0009ret \"Generation process is complete: \\{args[0]}s.\"\n\u0009\u0009end switch\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n":true;
else if(p==="res/option.kn")
return f?"+enum Env\n\u0009cui\n\u0009wnd\n\u0009web\n\u0009cpp\nend enum\n\n+var inputFile: []char\n+var outputFile: []char\n+var sysDir: []char\n+var icon: []char\n+var rls: bool\n+var env_: @Env\n+var help: bool\n+var version: bool\n+var quiet: bool\n+var appCode: int\n+var notDeploy: bool\n+var extra: dict<[]char, bool>\n\n+var inputDir: []char\n+var inputName: []char\n+var outputDir: []char\n\n+func acquireOption(): bool\n\u0009var cmdLines: [][]char :: lib@cmdLine()\n\u0009var envStr: []char\n\u0009var appCodeStr: []char\n\u0009do @extra :: #dict<[]char, bool>\n\u0009\n\u0009for i(0, ^cmdLines - 1)\n\u0009\u0009var cmdLine: []char :: cmdLines[i]\n\u0009\u0009if(^cmdLine = 2 & cmdLine[0] = \'-\')\n\u0009\u0009\u0009switch c(cmdLine[1])\n\u0009\u0009\u0009case \'i\'\n\u0009\u0009\u0009\u0009if(!getArg1(&@inputFile, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'o\'\n\u0009\u0009\u0009\u0009if(!getArg1(&@outputFile, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'s\'\n\u0009\u0009\u0009\u0009if(!getArg1(&@sysDir, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'c\'\n\u0009\u0009\u0009\u0009if(!getArg1(&@icon, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'r\'\n\u0009\u0009\u0009\u0009if(!getArg0(&@rls, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'e\'\n\u0009\u0009\u0009\u0009if(!getArg1(&envStr, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'h\'\n\u0009\u0009\u0009\u0009if(!getArg0(&@help, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'v\'\n\u0009\u0009\u0009\u0009if(!getArg0(&@version, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'q\'\n\u0009\u0009\u0009\u0009if(!getArg0(&@quiet, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'a\'\n\u0009\u0009\u0009\u0009if(!getArg1(&appCodeStr, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'d\' {This option is only used in Kuin Editor builds.}\n\u0009\u0009\u0009\u0009if(!getArg0(&@notDeploy, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009case \'x\'\n\u0009\u0009\u0009\u0009var extra: []char :: null\n\u0009\u0009\u0009\u0009if(!getArg1(&extra, cmdLines, &i, c))\n\u0009\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do @extra.add(extra, true)\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do \\err@err(%unexpectedOption, null, [\"-\\{c}\"])\n\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009end switch\n\u0009\u0009else\n\u0009\u0009\u0009do \\err@err(%unexpectedOption, null, [\"\\{cmdLine}\"])\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009end for\n\u0009\n\u0009if(@inputFile =& null)\n\u0009\u0009ret true\n\u0009end if\n\u0009\n\u0009if(envStr =& null)\n\u0009\u0009do @env_ :: %cui\n\u0009else\n\u0009\u0009switch(envStr)\n\u0009\u0009case \"cui\"\n\u0009\u0009\u0009do @env_ :: %cui\n\u0009\u0009case \"wnd\"\n\u0009\u0009\u0009do @env_ :: %wnd\n\u0009\u0009case \"web\"\n\u0009\u0009\u0009do @env_ :: %web\n\u0009\u0009case \"cpp\"\n\u0009\u0009\u0009do @env_ :: %cpp\n\u0009\u0009default\n\u0009\u0009\u0009do \\err@err(%incorrectOption, null, [\"-e\"])\n\u0009\u0009end switch\n\u0009end if\n\u0009\n\u0009if(appCodeStr =& null)\n\u0009\u0009do @appCode :: lib@rnd(1, 0xFFFFFFFF)\n\u0009else\n\u0009\u0009var success: bool\n\u0009\u0009do @appCode :: appCodeStr.toInt(&success)\n\u0009\u0009if(!success)\n\u0009\u0009\u0009do \\err@err(%incorrectOption, null, [\"-a\"])\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009end if\n\u0009\n\u0009if(@outputFile =& null)\n\u0009\u0009do @outputFile :: file@dir(@inputFile) ~ \"out\"\n\u0009else\n\u0009\u0009do @outputFile :: file@delExt(@outputFile)\n\u0009end if\n\u0009\n\u0009if(@sysDir =& null)\n\u0009\u0009do @sysDir :: \"sys/\"\n\u0009end if\n\u0009\n\u0009if(@icon =& null)\n\u0009\u0009do @icon :: @sysDir ~ \"default.ico\"\n\u0009end if\n\u0009\n\u0009do @inputDir :: file@dir(@inputFile)\n\u0009do @inputName :: file@delExt(file@fileName(@inputFile))\n\u0009do @outputDir :: file@dir(@outputFile)\n\u0009\n\u0009if(file@ext(@inputFile) <> \"kn\")\n\u0009\u0009do \\err@err(%incorrectExt, null, [@inputName])\n\u0009end if\n\u0009\n\u0009ret true\n\u0009\n\u0009func getArg0(out: &bool, option: char): bool\n\u0009\u0009if(out <> false)\n\u0009\u0009\u0009do \\err@err(%incorrectOption, null, [\"-\\{option}\"])\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009do out :: true\n\u0009\u0009ret true\n\u0009end func\n\u0009\n\u0009func getArg1(out: &[]char, cmdLines: [][]char, idx: &int, option: char): bool\n\u0009\u0009if(out <>& null | idx + 1 >= ^cmdLines)\n\u0009\u0009\u0009do \\err@err(%incorrectOption, null, [\"-\\{option}\"])\n\u0009\u0009\u0009ret false\n\u0009\u0009end if\n\u0009\u0009do out :: cmdLines[idx + 1]\n\u0009\u0009do idx :+ 1\n\u0009\u0009ret true\n\u0009end func\nend func\n":true;
else if(p==="res/parse.kn")
return f?"var reserved: [][]char\n\nvar srcesCur: dict<[]char, \\ast@Ast>\nvar srcesNext: dict<[]char, \\ast@Ast>\nvar filePtr: file@Reader\n\nvar srcName: []char\nvar row: int\nvar col: int\n\nvar fileBuf: char\nvar fileBufTmp: char {For single line comments and line breaking.}\nvar fileLast: bool\nvar scope: stack<\\ast@Ast>\nvar uniqueCnt: int\nvar scopeRefedItems: list<\\ast@ScopeRefedItem>\n\n+func parse(): dict<[]char, \\ast@Ast>\n\u0009do @srcesCur :: #dict<[]char, \\ast@Ast>\n\u0009do @srcesCur.add(\"\\\\\" ~ \\option@inputName, null)\n\u0009do @srcesCur.add(\"kuin\", null)\n\u0009\n\u0009var endFlag: lib@Bool :: #lib@Bool\n\u0009do endFlag.value :: false\n\u0009while(!endFlag.value)\n\u0009\u0009do endFlag.value :: true\n\u0009\u0009do @srcesNext :: #dict<[]char, \\ast@Ast>\n\u0009\u0009do @srcesCur.forEach(@parseSrc, endFlag)\n\u0009\u0009do @srcesCur :: @srcesNext\n\u0009end while\n\u0009\n\u0009ret @srcesCur\nend func\n\nfunc parseSrc(key: []char, value: \\ast@Ast, data: kuin@Class): bool\n\u0009if(value <>& null)\n\u0009\u0009do @srcesNext.add(key, value)\n\u0009\u0009ret true\n\u0009end if\n\u0009\n\u0009if(!isCorrectSrcName(key))\n\u0009\u0009do \\err@err(%incorrectSrcName, null, [key])\n\u0009\u0009ret true\n\u0009end if\n\u0009do(data $ lib@Bool).value :: false\n\u0009\n\u0009var truePath: []char\n\u0009if(key[0] = \'\\\\\')\n\u0009\u0009do truePath :: \\option@inputDir ~ replacePath(key.sub(1, -1)) ~ \".kn\"\n\u0009else\n\u0009\u0009do truePath :: \\option@sysDir ~ replacePath(key) ~ \".kn\"\n\u0009end if\n\u0009do @filePtr :: file@makeReader(truePath)\n\u0009if(@filePtr =& null)\n\u0009\u0009do \\err@err(%fileOpenFailed, null, [truePath])\n\u0009\u0009ret true\n\u0009end if\n\u0009\n\u0009do @srcName :: key\n\u0009do @row :: 1\n\u0009do @col :: 0\n\u0009do @fileBuf :: \'\\0\'\n\u0009do @fileBufTmp :: \'\\0\'\n\u0009do @fileLast :: false\n\u0009do @scope :: #stack<\\ast@Ast>\n\u0009do @uniqueCnt :: 0\n\u0009do @scopeRefedItems :: null\n\u0009\n\u0009var ast: \\ast@AstRoot :: @parseRoot()\n\u0009do @filePtr.fin()\n\u0009do @srcesNext.add(key, ast)\n\u0009ret true\n\u0009\n\u0009func isCorrectSrcName(name: []char): bool\n\u0009\u0009var idx: int :: 0\n\u0009\u0009if(idx < ^name & name[idx] = \'\\\\\')\n\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009end if\n\u0009\u0009while(true)\n\u0009\u0009\u0009if(idx >= ^name | !(\'a\' <= name[idx] & name[idx] <= \'z\' | name[idx] = \'_\'))\n\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009\u0009\u0009if(idx >= ^name)\n\u0009\u0009\u0009\u0009\u0009ret true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(\'a\' <= name[idx] & name[idx] <= \'z\' | name[idx] = \'_\' | \'0\' <= name[idx] & name[idx] <= \'9\')\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(name[idx] = \'\\\\\')\n\u0009\u0009\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009ret false\n\u0009\u0009\u0009end while\n\u0009\u0009end while\n\u0009end func\n\u0009\n\u0009func replacePath(path: []char): []char\n\u0009\u0009var r: []char :: #[^path]char\n\u0009\u0009for i(0, ^path - 1)\n\u0009\u0009\u0009do r[i] :: path[i] = \'\\\\\' ?(\'/\', path[i])\n\u0009\u0009end for\n\u0009\u0009ret r\n\u0009end func\nend func\n\nfunc parseRoot(): \\ast@AstRoot\n\u0009var ast: \\ast@AstRoot :: #\\ast@AstRoot\n\u0009do @initAst(ast, %root, \\pos@make(@srcName, 1, 1), null, false)\n\u0009do ast.scopeRefedItems :: #list<\\ast@ScopeRefedItem>\n\u0009do ast.items :: #list<\\ast@Ast>\n\u0009do @scopeRefedItems :: ast.scopeRefedItems\n\u0009\n\u0009do ast.scopeChildren :: #dict<[]char, \\ast@Ast>\n\u0009do @scope.add(ast)\n\u0009\n\u0009; For the case where there is a single line comment at the beginning of source codes.\n\u0009do @fileBuf :: \'\\n\'\n\u0009do @fileBuf :: @readChar()\n\u0009\n\u0009while loop(true)\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009skip loop\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009var item: \\ast@Ast\n\u0009\u0009var itemPublic: bool :: false\n\u0009\u0009if(c = \'+\')\n\u0009\u0009\u0009do itemPublic :: true\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009block\n\u0009\u0009\u0009var row: int :: @row\n\u0009\u0009\u0009var col: int :: @col\n\u0009\u0009\u0009var id: []char :: @readIdentifier(true, false)\n\u0009\u0009\u0009switch(id)\n\u0009\u0009\u0009case \"func\"\n\u0009\u0009\u0009\u0009do item :: @parseFunc(null, false)\n\u0009\u0009\u0009case \"var\"\n\u0009\u0009\u0009\u0009do item :: @parseVar(%global, null)\n\u0009\u0009\u0009case \"const\"\n\u0009\u0009\u0009\u0009do item :: @parseConst()\n\u0009\u0009\u0009case \"alias\"\n\u0009\u0009\u0009\u0009do item :: @parseAlias()\n\u0009\u0009\u0009case \"include\"\n\u0009\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009case \"class\"\n\u0009\u0009\u0009\u0009do item :: @parseClass()\n\u0009\u0009\u0009case \"enum\"\n\u0009\u0009\u0009\u0009do item :: @parseEnum()\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do \\err@err(%incorrectBlockOrSentence, \\pos@make(@srcName, row, col), [id])\n\u0009\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end switch\n\u0009\u0009end block\n\u0009\u0009\n\u0009\u0009if(item.typeId = %var_)\n\u0009\u0009\u0009do(item $ \\ast@AstVar).arg.publicInSrc :: itemPublic\n\u0009\u0009elif(item.typeId = %const_)\n\u0009\u0009\u0009do(item $ \\ast@AstConst).arg.publicInSrc :: itemPublic\n\u0009\u0009else\n\u0009\u0009\u0009do item.publicInSrc :: itemPublic\n\u0009\u0009end if\n\u0009\u0009do ast.items.add(item)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseFunc(parentClass: []char, overritten: bool): \\ast@AstFunc\n\u0009var ast: \\ast@AstFunc :: #\\ast@AstFunc\n\u0009\n\u0009block\n\u0009\u0009do ast.funcOption :: %none\n\u0009\u0009do ast.funcAttr :: #list<[]char>\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'[\')\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009var row: int :: @row\n\u0009\u0009\u0009\u0009var col: int :: @col\n\u0009\u0009\u0009\u0009var s: []char :: @readFuncAttr()\n\u0009\u0009\u0009\u0009if(^s = 5 & s[0] = \'_\' & s[1] = \'_\')\n\u0009\u0009\u0009\u0009\u0009switch(s[2])\n\u0009\u0009\u0009\u0009\u0009case \'a\'\n\u0009\u0009\u0009\u0009\u0009\u0009if(s[3] = \'n\' & s[4] = \'y\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%any)\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009case \'f\'\n\u0009\u0009\u0009\u0009\u0009\u0009if(s[3] = \'r\' & s[4] = \'c\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%frc)\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009case \'k\'\n\u0009\u0009\u0009\u0009\u0009\u0009if(s[3] = \'v\' & s[4] = \'f\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%kvf)\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009case \'m\'\n\u0009\u0009\u0009\u0009\u0009\u0009if(s[3] = \'k\' & s[4] = \'i\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%mki)\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009case \'r\'\n\u0009\u0009\u0009\u0009\u0009\u0009if(s[3] = \'a\' & s[4] = \'w\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%raw)\n\u0009\u0009\u0009\u0009\u0009\u0009elif(s[3] = \'m\' & s[4] = \'e\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%rme)\n\u0009\u0009\u0009\u0009\u0009\u0009elif(s[3] = \'c\' & s[4] = \'h\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%rch)\n\u0009\u0009\u0009\u0009\u0009\u0009elif(s[3] = \'a\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009if(s[4] = \'c\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%rac)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009elif(s[4] = \'k\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%rak)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009elif(s[4] = \'v\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%rav)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009case \'t\'\n\u0009\u0009\u0009\u0009\u0009\u0009if(s[3] = \'m\' & s[4] = \'e\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%tme)\n\u0009\u0009\u0009\u0009\u0009\u0009elif(s[3] = \'c\' & s[4] = \'h\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%tch)\n\u0009\u0009\u0009\u0009\u0009\u0009elif(s[3] = \'k\' & s[4] = \'v\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do ast.funcOption :: ast.funcOption.or(%tkv)\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do ast.funcAttr.add(s)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \']\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009do @initAst(ast, %func_, @makePos(), @readIdentifier(true, false), true)\n\u0009do ast.args :: #list<\\ast@AstArg>\n\u0009do ast.ret_ :: null\n\u0009do ast.stats :: #list<\\ast@AstStat>\n\u0009\n\u0009do ast.scopeChildren :: #dict<[]char, \\ast@Ast>\n\u0009do @scope.add(ast)\n\u0009\n\u0009if(parentClass <>& null)\n\u0009\u0009do @addScopeRefeds(ast, parentClass)\n\u0009end if\n\u0009do @assertNextChar(\'(\', true)\n\u0009if(parentClass <>& null)\n\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009do @initAst(arg, %arg, ast.pos, null, false)\n\u0009\u0009do arg.name :: \"me\"\n\u0009\u0009do arg.kind :: %localArg\n\u0009\u0009do arg.refVar :: false\n\u0009\u0009do arg.expr :: null\n\u0009\u0009do @addScopeName(arg, false)\n\u0009\u0009block\n\u0009\u0009\u0009var type: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009do @initAst(type, %typeUser, ast.pos, null, false)\n\u0009\u0009\u0009do @addScopeRefeds(type, parentClass)\n\u0009\u0009\u0009do arg.type :: type\n\u0009\u0009end block\n\u0009\u0009do ast.args.add(arg)\n\u0009end if\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c <> \')\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009do ast.args.add(@parseArg(%localArg, null))\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \')\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \':\')\n\u0009\u0009\u0009do ast.ret_ :: @parseType()\n\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009end if\n\u0009\u0009if(c <> \'\\n\')\n\u0009\u0009\u0009do @nextCharErr(\'\\n\', c)\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009; TODO:\n\u0009{\n\u0009if(overritten)\n\u0009\u0009var statVar: \\ast@AstStatVar :: #\\ast@AstStatVar\n\u0009\u0009do @initAst(statVar, %statVar, ast.pos, null, false)\n\u0009\u0009block\n\u0009\u0009\u0009var var_: \\ast@AstVar :: #\\ast@AstVar\n\u0009\u0009\u0009do @initAst(var_, %var_, ast.pos, null, false)\n\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009\u0009\u0009\u0009do @initAst(arg, %arg, ast.pos, null, false)\n\u0009\u0009\u0009\u0009do arg.name :: \"super\"\n\u0009\u0009\u0009\u0009do arg.kind :: %localVar\n\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009do arg.expr :: null\n\u0009\u0009\u0009\u0009do @addScopeName(arg, false)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeFunc :: #\\ast@AstTypeFunc\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeFunc, ast.pos, null, false)\n\u0009\u0009\u0009\u0009\u0009do type.funcOption :: ast.funcOption\n\u0009\u0009\u0009\u0009\u0009do type.funcAttr :: ast.funcAttr\n\u0009\u0009\u0009\u0009\u0009do type.args :: #list<\\ast@AstTypeFuncArg>\n\u0009\u0009\u0009\u0009\u0009do type.ret_ :: ast.ret_\n\u0009\u0009\u0009\u0009\u0009var args: list<\\ast@AstArg> :: ast.args\n\u0009\u0009\u0009\u0009\u0009do args.head()\n\u0009\u0009\u0009\u0009\u0009while(!args.term())\n\u0009\u0009\u0009\u0009\u0009\u0009var data: \\ast@AstArg :: args.get()\n\u0009\u0009\u0009\u0009\u0009\u0009var arg2: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009\u0009do arg2.arg :: data.type\n\u0009\u0009\u0009\u0009\u0009\u0009do arg2.refVar :: data.refVar\n\u0009\u0009\u0009\u0009\u0009\u0009do type.args.add(arg2)\n\u0009\u0009\u0009\u0009\u0009\u0009do args.next()\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009do arg.type :: type\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009do var_.arg :: arg\n\u0009\u0009\u0009end block\n\u0009\u0009\u0009do statVar.def :: var_\n\u0009\u0009end block\n\u0009\u0009do ast.stats.add(statVar)\n\u0009end if\n\u0009}\n\u0009\n\u0009while loop(true)\n\u0009\u0009var stat: \\ast@AstStat :: @parseStat(ast)\n\u0009\u0009if(stat =& null)\n\u0009\u0009\u0009if(@fileLast)\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(stat.typeId = %statEnd)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do ast.stats.add(stat)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseVar(kind: \\ast@AstArgKind, parentClass: []char): \\ast@AstVar\n\u0009var ast: \\ast@AstVar :: #\\ast@AstVar\n\u0009do @initAst(ast, %var_, @makePos(), null, false)\n\u0009do ast.arg :: @parseArg(kind, parentClass)\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseConst(): \\ast@AstConst\n\u0009var ast: \\ast@AstConst :: #\\ast@AstConst\n\u0009do @initAst(ast, %const_, @makePos(), null, false)\n\u0009do ast.arg :: @parseArg(%const_, null)\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseAlias(): \\ast@AstAlias\n\u0009var ast: \\ast@AstAlias :: #\\ast@AstAlias\n\u0009do @initAst(ast, %alias_, @makePos(), @readIdentifier(true, false), true)\n\u0009do @assertNextChar(\':\', true)\n\u0009do ast.type :: @parseType()\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseClass(): \\ast@AstClass\n\u0009var ast: \\ast@AstClass :: #\\ast@AstClass\n\u0009do @initAst(ast, %class_, @makePos(), @readIdentifier(true, false), true)\n\u0009do ast.items :: #list<\\ast@AstClassItem>\n\u0009do @assertNextChar(\'(\', true)\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c <> \')\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009do @addScopeRefeds(ast, @readIdentifier(true, true))\n\u0009\u0009\u0009do @assertNextChar(\')\', true)\n\u0009\u0009else\n\u0009\u0009\u0009var kuinSrc: bool :: @srcName = \"kuin\"\n\u0009\u0009\u0009if(!(kuinSrc & ast.name = \"Class\"))\n\u0009\u0009\u0009\u0009do @addScopeRefeds(ast, kuinSrc ?(\"@Class\", \"kuin@Class\"))\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009\n\u0009do ast.scopeChildren :: #dict<[]char, \\ast@Ast>\n\u0009do @scope.add(ast)\n\u0009\n\u0009while loop(true)\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009do \\err@err(%noEnd, @makePos(), [\"class\"])\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009skip loop\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var item: \\ast@AstClassItem :: #\\ast@AstClassItem\n\u0009\u0009do item.public :: false\n\u0009\u0009do item.override :: false\n\u0009\u0009do item.parentItem :: null\n\u0009\u0009if(c = \'+\')\n\u0009\u0009\u0009do item.public :: true\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009\u0009do c :: @readChar()\n\u0009\u0009if(c = \'*\')\n\u0009\u0009\u0009do item.override :: true\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009var id: []char :: @readIdentifier(true, false)\n\u0009\u0009var className: []char :: ast.scopeParent.typeId = %root ?(\"@\" ~ ast.name, ast.name)\n\u0009\u0009if(id = \"func\")\n\u0009\u0009\u0009do item.def :: @parseFunc(className, item.override)\n\u0009\u0009elif(id = \"var\")\n\u0009\u0009\u0009if(item.override)\n\u0009\u0009\u0009\u0009do \\err@err(%overrideNonFunctionMember, \\pos@make(@srcName, row, col), [id])\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do item.def :: @parseVar(%member, className)\n\u0009\u0009else\n\u0009\u0009\u0009if(item.public)\n\u0009\u0009\u0009\u0009do \\err@err(%exposeNonFunctionOrVariableMember, \\pos@make(@srcName, row, col), [id])\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(item.override)\n\u0009\u0009\u0009\u0009do \\err@err(%overrideNonFunctionMember, \\pos@make(@srcName, row, col), [id])\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009switch(id)\n\u0009\u0009\u0009\u0009\n\u0009\u0009\u0009case \"end\"\n\u0009\u0009\u0009\u0009var id2: []char :: @readIdentifier(true, false)\n\u0009\u0009\u0009\u0009if(id2 <> \"class\")\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%wrongEnd, \\pos@make(@srcName, row, col), [\"class\", id2])\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009var astEndClass: \\ast@Ast :: #\\ast@Ast\n\u0009\u0009\u0009\u0009do @initAst(astEndClass, %none, \\pos@make(@srcName, row, col), null, false)\n\u0009\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009case \"const\"\n\u0009\u0009\u0009\u0009do item.def :: @parseConst()\n\u0009\u0009\u0009case \"alias\"\n\u0009\u0009\u0009\u0009do item.def :: @parseAlias()\n\u0009\u0009\u0009case \"class\"\n\u0009\u0009\u0009\u0009do item.def :: @parseClass()\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do \\err@err(%wrongMember, \\pos@make(@srcName, row, col), [id])\n\u0009\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end switch\n\u0009\u0009end if\n\u0009\u0009do ast.items.add(item)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseEnum(): \\ast@AstEnum\n\u0009var ast: \\ast@AstEnum :: #\\ast@AstEnum\n\u0009do @initAst(ast, %enum_, @makePos(), @readIdentifier(true, false), true)\n\u0009do ast.items :: #list<\\ast@AstExpr>\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009\n\u0009do ast.scopeChildren :: #dict<[]char, \\ast@Ast>\n\u0009do @scope.add(ast)\n\u0009\n\u0009while loop(true)\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009do \\err@err(%noEnd, @makePos(), [\"enum\"])\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009skip loop\n\u0009\u0009end if\n\u0009\u0009do @fileBuf :: c\n\u0009\u0009\n\u0009\u0009var item: \\ast@AstExpr\n\u0009\u0009var id: []char :: @readIdentifier(true, false)\n\u0009\u0009if(id = \"end\")\n\u0009\u0009\u0009var id2: []char :: @readIdentifier(true, false)\n\u0009\u0009\u0009if(id2 <> \"enum\")\n\u0009\u0009\u0009\u0009do \\err@err(%wrongEnd, @makePos(), [\"enum\", id2])\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do c :: @readChar()\n\u0009\u0009if(c = \':\')\n\u0009\u0009\u0009do @assertNextChar(\':\', false)\n\u0009\u0009\u0009do item :: @parseExpr()\n\u0009\u0009\u0009if(item =& null)\n\u0009\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009else\n\u0009\u0009\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009do @initAstExpr(expr, %exprValuePrim, ast.pos)\n\u0009\u0009\u0009do expr.type :: null {Set the type to \'NULL\' when no value is specified.}\n\u0009\u0009\u0009do expr.value :: 0b64\n\u0009\u0009\u0009do item :: expr\n\u0009\u0009end if\n\u0009\u0009do item.name :: id\n\u0009\u0009if(c <> \'\\n\')\n\u0009\u0009\u0009do @nextCharErr(\'\\n\', c)\n\u0009\u0009end if\n\u0009\u0009do ast.items.add(item)\n\u0009\u0009do @addScopeName(item, true)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseArg(kind: \\ast@AstArgKind, parentClass: []char): \\ast@AstArg\n\u0009var ast: \\ast@AstArg :: #\\ast@AstArg\n\u0009do @initAst(ast, %arg, @makePos(), @readIdentifier(true, false), false)\n\u0009do ast.kind :: kind\n\u0009do ast.refVar :: false\n\u0009if(parentClass <>& null)\n\u0009\u0009do @addScopeRefeds(ast, parentClass)\n\u0009end if\n\u0009do @assertNextChar(\':\', true)\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'&\')\n\u0009\u0009\u0009if(kind <> %localArg)\n\u0009\u0009\u0009\u0009do \\err@err(%ampersandInNonArgument, @makePos(), null)\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do ast.refVar :: true\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009do ast.type :: @parseType()\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \':\')\n\u0009\u0009\u0009do @assertNextChar(\':\', false)\n\u0009\u0009\u0009assert kind <> %unknown\n\u0009\u0009\u0009switch(kind)\n\u0009\u0009\u0009case %localArg\n\u0009\u0009\u0009\u0009do \\err@err(%initializerInArgument, @makePos(), null)\n\u0009\u0009\u0009\u0009do ast.expr :: null\n\u0009\u0009\u0009case %member\n\u0009\u0009\u0009\u0009do \\err@err(%initializerInMember, @makePos(), null)\n\u0009\u0009\u0009\u0009do ast.expr :: null\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do ast.expr :: @parseExpr()\n\u0009\u0009\u0009end switch\n\u0009\u0009else\n\u0009\u0009\u0009if(kind = %const_)\n\u0009\u0009\u0009\u0009do \\err@err(%noInitializerInConst, @makePos(), null)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.expr :: null\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009ret ast\nend func\n\nfunc parseStat(block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStat\n\u0009\n\u0009block\n\u0009\u0009var c: char\n\u0009\u0009while(c = \'\\n\', skip)\n\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009do \\err@err(%noEndUnspecified, @makePos(), null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009end while\n\u0009\u0009do @fileBuf :: c\n\u0009end block\n\u0009\n\u0009var row: int :: @row\n\u0009var col: int :: @col\n\u0009var id: []char :: @readIdentifier(true, false)\n\u0009switch(id)\n\u0009case \"end\"\n\u0009\u0009do ast :: @parseStatEnd(row, col, block_)\n\u0009case \"func\"\n\u0009\u0009do ast :: @parseStatFunc()\n\u0009case \"var\"\n\u0009\u0009do ast :: @parseStatVar()\n\u0009case \"const\"\n\u0009\u0009do ast :: @parseStatConst()\n\u0009case \"alias\"\n\u0009\u0009do ast :: @parseStatAlias()\n\u0009case \"class\"\n\u0009\u0009do ast :: @parseStatClass()\n\u0009case \"enum\"\n\u0009\u0009do ast :: @parseStatEnum()\n\u0009case \"if\"\n\u0009\u0009do ast :: @parseStatIf()\n\u0009case \"elif\"\n\u0009\u0009do ast :: @parseStatElIf(row, col, block_)\n\u0009case \"else\"\n\u0009\u0009do ast :: @parseStatElse(row, col, block_)\n\u0009case \"switch\"\n\u0009\u0009do ast :: @parseStatSwitch(row, col)\n\u0009case \"case\"\n\u0009\u0009do ast :: @parseStatCase(row, col, block_)\n\u0009case \"default\"\n\u0009\u0009do ast :: @parseStatDefault(row, col, block_)\n\u0009case \"while\"\n\u0009\u0009do ast :: @parseStatWhile()\n\u0009case \"for\"\n\u0009\u0009do ast :: @parseStatFor(row, col)\n\u0009case \"try\"\n\u0009\u0009do ast :: @parseStatTry(row, col)\n\u0009case \"catch\"\n\u0009\u0009do ast :: @parseStatCatch(row, col, block_)\n\u0009case \"finally\"\n\u0009\u0009do ast :: @parseStatFinally(row, col, block_)\n\u0009case \"throw\"\n\u0009\u0009do ast :: @parseStatThrow()\n\u0009case \"block\"\n\u0009\u0009do ast :: @parseStatBlock()\n\u0009case \"ret\"\n\u0009\u0009do ast :: @parseStatRet()\n\u0009case \"do\"\n\u0009\u0009do ast :: @parseStatDo()\n\u0009case \"break\"\n\u0009\u0009do ast :: @parseStatBreak()\n\u0009case \"skip\"\n\u0009\u0009do ast :: @parseStatSkip()\n\u0009case \"assert\"\n\u0009\u0009do ast :: @parseStatAssert()\n\u0009default\n\u0009\u0009do \\err@err(%incorrectBlockOrSentence, \\pos@make(@srcName, row, col), [id])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end switch\n\u0009\n\u0009if(ast =& null)\n\u0009\u0009ret null\n\u0009end if\n\u0009do ast.pos :: \\pos@make(@srcName, row, col)\n\u0009ret ast\nend func\n\nfunc parseStatEnd(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStat :: #\\ast@AstStat\n\u0009do @initAst(ast, %statEnd, \\pos@make(@srcName, row, col), null, false)\n\u0009\n\u0009var id: []char :: @readIdentifier(true, false)\n\u0009var err: bool :: false\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009switch(id)\n\u0009case \"func\"\n\u0009\u0009if(block_.typeId <> %func_)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009case \"if\"\n\u0009\u0009if(block_.typeId <> %statIf)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009case \"switch\"\n\u0009\u0009if(block_.typeId <> %statSwitch)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009case \"while\"\n\u0009\u0009if(block_.typeId <> %statWhile)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009case \"for\"\n\u0009\u0009if(block_.typeId <> %statFor)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009case \"try\"\n\u0009\u0009if(block_.typeId <> %statTry)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009case \"block\"\n\u0009\u0009if(block_.typeId <> %statBlock)\n\u0009\u0009\u0009do err :: true\n\u0009\u0009end if\n\u0009default\n\u0009\u0009do \\err@err(%wrongEndUnspecified, \\pos@make(@srcName, row, col), [id])\n\u0009end switch\n\u0009if(err)\n\u0009\u0009do \\err@err(%nonCorrespondingEnd, \\pos@make(@srcName, row, col), [id])\n\u0009end if\n\u0009ret ast\nend func\n\nfunc parseStatFunc(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatFunc :: #\\ast@AstStatFunc\n\u0009do @initAst(ast, %statFunc, null, null, false)\n\u0009do ast.def :: @parseFunc(null, false)\n\u0009ret ast\nend func\n\nfunc parseStatVar(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatVar :: #\\ast@AstStatVar\n\u0009do @initAst(ast, %statVar, null, null, false)\n\u0009do ast.def :: @parseVar(%localVar, null)\n\u0009ret ast\nend func\n\nfunc parseStatConst(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatConst :: #\\ast@AstStatConst\n\u0009do @initAst(ast, %statConst, null, null, false)\n\u0009do ast.def :: @parseConst()\n\u0009ret ast\nend func\n\nfunc parseStatAlias(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatAlias :: #\\ast@AstStatAlias\n\u0009do @initAst(ast, %statAlias, null, null, false)\n\u0009do ast.def :: @parseAlias()\n\u0009ret ast\nend func\n\nfunc parseStatClass(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatClass :: #\\ast@AstStatClass\n\u0009do @initAst(ast, %statClass, null, null, false)\n\u0009do ast.def :: @parseClass()\n\u0009ret ast\nend func\n\nfunc parseStatEnum(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatEnum :: #\\ast@AstStatEnum\n\u0009do @initAst(ast, %statEnum, null, null, false)\n\u0009do ast.def :: @parseEnum()\n\u0009ret ast\nend func\n\nfunc parseStatIf(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatIf :: #\\ast@AstStatIf\n\u0009do @initAst(ast, %statIf, @makePos(), null, false)\n\u0009do ast.blockVar :: null\n\u0009do ast.elIfs :: #list<\\ast@AstStatElIf>\n\u0009do ast.elseStatBlock :: null\n\u0009do @pushDummyScope(ast)\n\u0009do @obtainBlockName(ast)\n\u0009do ast.cond :: @parseExpr()\n\u0009do @assertNextChar(\')\', true)\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009\n\u0009block\n\u0009\u0009var stat: \\ast@AstStat\n\u0009\u0009var typeId: \\ast@TypeId\n\u0009\u0009do ast.statBlock :: @parseDummyBlock(&stat, &typeId, %statIf, ast)\n\u0009\u0009while(typeId = %statElIf)\n\u0009\u0009\u0009var elIf: \\ast@AstStatElIf :: stat $ \\ast@AstStatElIf\n\u0009\u0009\u0009do elIf.statBlock :: @parseDummyBlock(&stat, &typeId, %statElIf, ast)\n\u0009\u0009\u0009do ast.elIfs.add(elIf)\n\u0009\u0009end while\n\u0009\u0009while(typeId = %statElse)\n\u0009\u0009\u0009do ast.elseStatBlock :: @parseDummyBlock(&stat, &typeId, %statElse, ast)\n\u0009\u0009end while\n\u0009\u0009assert typeId = %statEnd\n\u0009end block\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseStatElIf(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStatElIf :: #\\ast@AstStatElIf\n\u0009do @initAst(ast, %statElIf, null, null, false)\n\u0009do ast.statBlock :: null\n\u0009if(block_.typeId <> %statIf)\n\u0009\u0009do \\err@err(%wrongClause, \\pos@make(@srcName, row, col), [\"if\", \"elif\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009do @assertNextChar(\'(\', true)\n\u0009do ast.cond :: @parseExpr()\n\u0009do @assertNextChar(\')\', true)\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatElse(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStat :: #\\ast@AstStat\n\u0009do @initAst(ast, %statElse, null, null, false)\n\u0009if(block_.typeId <> %statIf)\n\u0009\u0009do \\err@err(%wrongClause, \\pos@make(@srcName, row, col), [\"if\", \"else\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatSwitch(row: int, col: int): \\ast@AstStat\n\u0009var ast: \\ast@AstStatSwitch :: #\\ast@AstStatSwitch\n\u0009do @initAst(ast, %statSwitch, @makePos(), null, false)\n\u0009do ast.blockVar :: @makeBlockVar(ast.pos)\n\u0009do ast.cases :: #list<\\ast@AstStatCase>\n\u0009do ast.defaultStatBlock :: null\n\u0009do @pushDummyScope(ast)\n\u0009do @obtainBlockName(ast)\n\u0009do ast.cond :: @parseExpr()\n\u0009do @assertNextChar(\')\', true)\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009\n\u0009block\n\u0009\u0009var stat: \\ast@AstStat\n\u0009\u0009var typeId: \\ast@TypeId\n\u0009\u0009while loop(true)\n\u0009\u0009\u0009do stat :: @parseStat(ast)\n\u0009\u0009\u0009if(stat =& null)\n\u0009\u0009\u0009\u0009if(@fileLast)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009break loop\n\u0009\u0009end while\n\u0009\u0009do typeId :: stat.typeId\n\u0009\u0009if(!(typeId = %statCase | typeId = %statDefault | typeId = %statEnd))\n\u0009\u0009\u0009do \\err@err(%wrongClauseInSwitch, @makePos(), null)\n\u0009\u0009end if\n\u0009\u0009while(typeId = %statCase)\n\u0009\u0009\u0009var case_: \\ast@AstStatCase :: stat $ \\ast@AstStatCase\n\u0009\u0009\u0009do case_.statBlock :: @parseDummyBlock(&stat, &typeId, %statCase, ast)\n\u0009\u0009\u0009do ast.cases.add(case_)\n\u0009\u0009end while\n\u0009\u0009while(typeId = %statDefault)\n\u0009\u0009\u0009do ast.defaultStatBlock :: @parseDummyBlock(&stat, &typeId, %statDefault, ast)\n\u0009\u0009end while\n\u0009\u0009assert typeId = %statEnd\n\u0009end block\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseStatCase(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStatCase :: #\\ast@AstStatCase\n\u0009do @initAst(ast, %statCase, null, null, false)\n\u0009do ast.conds :: #list<\\ast@ExprPair>\n\u0009do ast.statBlock :: null\n\u0009if(block_.typeId <> %statSwitch)\n\u0009\u0009do \\err@err(%wrongClause, \\pos@make(@srcName, row, col), [\"switch\", \"case\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009while loop(true)\n\u0009\u0009var exprs: \\ast@ExprPair :: #\\ast@ExprPair\n\u0009\u0009do exprs.expr0 :: @parseExpr()\n\u0009\u0009do exprs.expr1 :: null\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(c = \',\')\n\u0009\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009\u0009skip loop\n\u0009\u0009end if\n\u0009\u0009do @fileBuf :: c\n\u0009\u0009var id: []char :: @readIdentifier(true, false)\n\u0009\u0009if(id <> \"to\")\n\u0009\u0009\u0009do \\err@err(%wrongWord, @makePos(), [\"to\", id])\n\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009do exprs.expr1 :: @parseExpr()\n\u0009\u0009do c :: @readChar()\n\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009end if\n\u0009end while\n\u0009\n\u0009ret ast\nend func\n\nfunc parseStatDefault(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStat :: #\\ast@AstStat\n\u0009do @initAst(ast, %statDefault, null, null, false)\n\u0009if(block_.typeId <> %statSwitch)\n\u0009\u0009do \\err@err(%wrongClause, \\pos@make(@srcName, row, col), [\"switch\", \"default\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatWhile(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatWhile :: #\\ast@AstStatWhile\n\u0009do @initAst(ast, %statWhile, @makePos(), null, false)\n\u0009do ast.blockVar :: null\n\u0009do ast.skip_ :: false\n\u0009do ast.stats :: #list<\\ast@AstStat>\n\u0009do @pushDummyScope(ast)\n\u0009do @obtainBlockName(ast)\n\u0009do ast.cond :: @parseExpr()\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \',\')\n\u0009\u0009\u0009var id: []char :: @readIdentifier(true, false)\n\u0009\u0009\u0009if(id <> \"skip\")\n\u0009\u0009\u0009\u0009do \\err@err(%wrongWord, @makePos(), [\"skip\", id])\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast.skip_ :: true\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009\u0009do @assertNextChar(\')\', true)\n\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009end block\n\u0009\n\u0009while loop(true)\n\u0009\u0009var stat: \\ast@AstStat :: @parseStat(ast)\n\u0009\u0009if(stat =& null)\n\u0009\u0009\u0009if(@fileLast)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(stat.typeId = %statEnd)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do ast.stats.add(stat)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseStatFor(row: int, col: int): \\ast@AstStat\n\u0009var ast: \\ast@AstStatFor :: #\\ast@AstStatFor\n\u0009do @initAst(ast, %statFor, @makePos(), null, false)\n\u0009do ast.blockVar :: @makeBlockVar(ast.pos)\n\u0009do ast.stats :: #list<\\ast@AstStat>\n\u0009do @pushDummyScope(ast)\n\u0009do @obtainBlockName(ast)\n\u0009do ast.start :: @parseExpr()\n\u0009do @assertNextChar(\',\', true)\n\u0009do ast.cond :: @parseExpr()\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \',\')\n\u0009\u0009\u0009do ast.step :: @parseExpr()\n\u0009\u0009\u0009do @assertNextChar(\')\', true)\n\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009else\n\u0009\u0009\u0009do ast.step :: @makePrimValue(@makePos(), %int_, 1b64)\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009do @assertNextChar(\')\', true)\n\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009while loop(true)\n\u0009\u0009var stat: \\ast@AstStat :: @parseStat(ast)\n\u0009\u0009if(stat =& null)\n\u0009\u0009\u0009if(@fileLast)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(stat.typeId = %statEnd)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do ast.stats.add(stat)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseStatTry(row: int, col: int): \\ast@AstStat\n\u0009var ast: \\ast@AstStatTry :: #\\ast@AstStatTry\n\u0009do @initAst(ast, %statTry, @makePos(), null, false)\n\u0009do ast.blockVar :: @makeBlockVar(ast.pos)\n\u0009do ast.catches :: #list<\\ast@AstStatCatch>\n\u0009do ast.finallyStatBlock :: null\n\u0009do @pushDummyScope(ast)\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c <> \'\\n\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009do ast.name :: @readIdentifier(true, false)\n\u0009\u0009\u0009do @addScopeName(ast, true)\n\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009else\n\u0009\u0009\u0009do ast.name :: \"$\"\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009do @initAst(type, %typePrim, \\pos@make(@srcName, row, col), null, false)\n\u0009\u0009do type.kind :: %int_\n\u0009\u0009do ast.blockVar.type :: type\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var stat: \\ast@AstStat\n\u0009\u0009var typeId: \\ast@TypeId\n\u0009\u0009do ast.statBlock :: @parseDummyBlock(&stat, &typeId, %statTry, ast)\n\u0009\u0009while(typeId = %statCatch)\n\u0009\u0009\u0009var catch_: \\ast@AstStatCatch :: stat $ \\ast@AstStatCatch\n\u0009\u0009\u0009do catch_.statBlock :: @parseDummyBlock(&stat, &typeId, %statCatch, ast)\n\u0009\u0009\u0009do ast.catches.add(catch_)\n\u0009\u0009end while\n\u0009\u0009if(typeId = %statFinally)\n\u0009\u0009\u0009do ast.finallyStatBlock :: @parseDummyBlock(&stat, &typeId, %statFinally, ast)\n\u0009\u0009end if\n\u0009\u0009assert typeId = %statEnd\n\u0009end block\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseStatCatch(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStatCatch :: #\\ast@AstStatCatch\n\u0009do @initAst(ast, %statCatch, null, null, false)\n\u0009do ast.conds :: #list<\\ast@ExprPair>\n\u0009do ast.statBlock :: null\n\u0009if(block_.typeId <> %statTry)\n\u0009\u0009do \\err@err(%wrongClause, \\pos@make(@srcName, row, col), [\"try\", \"catch\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009var exprs: \\ast@ExprPair :: #\\ast@ExprPair\n\u0009\u0009\u0009var pos: \\pos@Pos :: @makePos()\n\u0009\u0009\u0009do exprs.expr0 :: @makePrimValue(pos, %int_, 0b64)\n\u0009\u0009\u0009do exprs.expr1 :: @makePrimValue(pos, %int_, 0xFFFFFFFFb64)\n\u0009\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: #\\ast@ExprPair\n\u0009\u0009\u0009\u0009do exprs.expr0 :: @parseExpr()\n\u0009\u0009\u0009\u0009do exprs.expr1 :: null\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \',\')\n\u0009\u0009\u0009\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009var id: []char :: @readIdentifier(true, false)\n\u0009\u0009\u0009\u0009if(id <> \"to\")\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%wrongWord, @makePos(), [\"to\", id])\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do exprs.expr1 :: @parseExpr()\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast.conds.add(exprs)\n\u0009\u0009\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009ret ast\nend func\n\nfunc parseStatFinally(row: int, col: int, block_: \\ast@Ast): \\ast@AstStat\n\u0009var ast: \\ast@AstStat :: #\\ast@AstStat\n\u0009do @initAst(ast, %statFinally, null, null, false)\n\u0009if(block_.typeId <> %statTry)\n\u0009\u0009do \\err@err(%wrongClause, \\pos@make(@srcName, row, col), [\"try\", \"finally\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatThrow(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatThrow :: #\\ast@AstStatThrow\n\u0009do @initAst(ast, %statThrow, @makePos(), null, false)\n\u0009do ast.code :: @parseExpr()\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatBlock(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009do @initAst(ast, %statBlock, @makePos(), null, false)\n\u0009do ast.blockVar :: null\n\u0009do ast.stats :: #list<\\ast@AstStat>\n\u0009do @pushDummyScope(ast)\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c <> \'\\n\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009do ast.name :: @readIdentifier(true, false)\n\u0009\u0009\u0009do @addScopeName(ast, true)\n\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009else\n\u0009\u0009\u0009do ast.name :: \"$\"\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009while loop(true)\n\u0009\u0009var stat: \\ast@AstStat :: @parseStat(ast)\n\u0009\u0009if(stat =& null)\n\u0009\u0009\u0009if(@fileLast)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(stat.typeId = %statEnd)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do ast.stats.add(stat)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc parseStatRet(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatRet :: #\\ast@AstStatRet\n\u0009do @initAst(ast, %statRet, @makePos(), null, false)\n\u0009\n\u0009block\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c <> \'\\n\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009do ast.value :: @parseExpr()\n\u0009\u0009\u0009do @assertNextChar(\'\\n\', true)\n\u0009\u0009else\n\u0009\u0009\u0009do ast.value :: null\n\u0009\u0009end if\n\u0009end block\n\u0009\n\u0009ret ast\nend func\n\nfunc parseStatDo(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatDo :: #\\ast@AstStatDo\n\u0009do @initAst(ast, %statDo, @makePos(), null, false)\n\u0009do ast.expr :: @parseExpr()\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatBreak(): \\ast@AstStat\n\u0009var ast: \\ast@AstStat :: #\\ast@AstStat\n\u0009do @initAst(ast, %statBreak, @makePos(), null, false)\n\u0009do @addScopeRefeds(ast, @readIdentifier(true, false))\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatSkip(): \\ast@AstStat\n\u0009var ast: \\ast@AstStat :: #\\ast@AstStat\n\u0009do @initAst(ast, %statSkip, @makePos(), null, false)\n\u0009do @addScopeRefeds(ast, @readIdentifier(true, false))\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseStatAssert(): \\ast@AstStat\n\u0009var ast: \\ast@AstStatAssert :: #\\ast@AstStatAssert\n\u0009do @initAst(ast, %statAssert, @makePos(), null, false)\n\u0009do ast.cond :: @parseExpr()\n\u0009do @assertNextChar(\'\\n\', true)\n\u0009ret ast\nend func\n\nfunc parseType(): \\ast@AstType\n\u0009var pos: \\pos@Pos :: @makePos()\n\u0009var ast: \\ast@AstType :: null\n\u0009var c: char :: @readChar()\n\u0009if(c = \'[\')\n\u0009\u0009do @assertNextChar(\']\', true)\n\u0009\u0009\n\u0009\u0009var ast2: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009do @initAst(ast2, %typeArray, pos, null, false)\n\u0009\u0009do ast2.itemType :: @parseType()\n\u0009\u0009do ast :: ast2\n\u0009else\n\u0009\u0009do @fileBuf :: c\n\u0009\u0009var id: []char :: @readIdentifier(true, true)\n\u0009\u0009if(^id >= 4 & id[0] = \'b\' & id[1] = \'i\' & id[2] = \'t\')\n\u0009\u0009\u0009var size: []char :: id.sub(3, ^id - 3)\n\u0009\u0009\u0009if(size = \"8\" | size = \"16\" | size = \"32\" | size = \"64\")\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeBit, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.size :: size.toInt(&) / 8\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(ast =& null)\n\u0009\u0009\u0009switch(id)\n\u0009\u0009\u0009case \"func\"\n\u0009\u0009\u0009\u0009do @assertNextChar(\'<\', true)\n\u0009\u0009\u0009\u0009do @assertNextChar(\'(\', true)\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeFunc :: #\\ast@AstTypeFunc\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeFunc, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.funcOption :: %none\n\u0009\u0009\u0009\u0009do ast2.funcAttr :: #list<[]char>\n\u0009\u0009\u0009\u0009do ast2.args :: #list<\\ast@AstTypeFuncArg>\n\u0009\u0009\u0009\u0009do ast2.ret_ :: null\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c <> \')\')\n\u0009\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstTypeFuncArg :: #\\ast@AstTypeFuncArg\n\u0009\u0009\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009if(c = \'&\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: true\n\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.arg :: @parseType()\n\u0009\u0009\u0009\u0009\u0009\u0009do ast2.args.add(arg)\n\u0009\u0009\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009\u0009\u0009if(c = \')\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \':\')\n\u0009\u0009\u0009\u0009\u0009do ast2.ret_ :: @parseType()\n\u0009\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c <> \'>\')\n\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\'>\', c)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"list\"\n\u0009\u0009\u0009\u0009do @assertNextChar(\'<\', true)\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeGen :: #\\ast@AstTypeGen\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeGen, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %list_\n\u0009\u0009\u0009\u0009do ast2.itemType :: @parseType()\n\u0009\u0009\u0009\u0009do @assertNextChar(\'>\', true)\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"stack\"\n\u0009\u0009\u0009\u0009do @assertNextChar(\'<\', true)\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeGen :: #\\ast@AstTypeGen\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeGen, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %stack_\n\u0009\u0009\u0009\u0009do ast2.itemType :: @parseType()\n\u0009\u0009\u0009\u0009do @assertNextChar(\'>\', true)\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"queue\"\n\u0009\u0009\u0009\u0009do @assertNextChar(\'<\', true)\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeGen :: #\\ast@AstTypeGen\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeGen, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %queue_\n\u0009\u0009\u0009\u0009do ast2.itemType :: @parseType()\n\u0009\u0009\u0009\u0009do @assertNextChar(\'>\', true)\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"dict\"\n\u0009\u0009\u0009\u0009do @assertNextChar(\'<\', true)\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeDict :: #\\ast@AstTypeDict\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeDict, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.itemTypeKey :: @parseType()\n\u0009\u0009\u0009\u0009do @assertNextChar(\',\', true)\n\u0009\u0009\u0009\u0009do ast2.itemTypeValue :: @parseType()\n\u0009\u0009\u0009\u0009do @assertNextChar(\'>\', true)\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"int\"\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typePrim, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %int_\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"float\"\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typePrim, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %float_\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"char\"\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typePrim, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %char_\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \"bool\"\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typePrim, pos, null, false)\n\u0009\u0009\u0009\u0009do ast2.kind :: %bool_\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstTypeUser :: #\\ast@AstTypeUser\n\u0009\u0009\u0009\u0009do @initAst(ast2, %typeUser, pos, null, false)\n\u0009\u0009\u0009\u0009do @addScopeRefeds(ast2, id)\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009end switch\n\u0009\u0009end if\n\u0009end if\n\u0009ret ast\nend func\n\n; parseExprAssign\nfunc parseExpr(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprThree()\n\u0009var row: int :: @row\n\u0009var col: int :: @col\n\u0009var c: char :: @readChar()\n\u0009if(c = \':\')\n\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009var c2: char :: @read()\n\u0009\u0009switch(c2)\n\u0009\u0009case \':\'\n\u0009\u0009\u0009do ast2.kind :: %assign\n\u0009\u0009case \'+\'\n\u0009\u0009\u0009do ast2.kind :: %assignAdd\n\u0009\u0009case \'-\'\n\u0009\u0009\u0009do ast2.kind :: %assignSub\n\u0009\u0009case \'*\'\n\u0009\u0009\u0009do ast2.kind :: %assignMul\n\u0009\u0009case \'/\'\n\u0009\u0009\u0009do ast2.kind :: %assignDiv\n\u0009\u0009case \'%\'\n\u0009\u0009\u0009do ast2.kind :: %assignMod\n\u0009\u0009case \'^\'\n\u0009\u0009\u0009do ast2.kind :: %assignPow\n\u0009\u0009case \'~\'\n\u0009\u0009\u0009do ast2.kind :: %assignCat\n\u0009\u0009case \'$\'\n\u0009\u0009\u0009do ast2.kind :: %swap\n\u0009\u0009default\n\u0009\u0009\u0009do \\err@err(%wrongOperator, ast2.pos, [@charToStr(c2)])\n\u0009\u0009\u0009do @readUntilRet(c2)\n\u0009\u0009\u0009ret null\n\u0009\u0009end switch\n\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009do ast2.children1 :: @parseExpr()\n\u0009\u0009do ast :: ast2\n\u0009else\n\u0009\u0009do @fileBuf :: c\n\u0009end if\n\u0009ret ast\nend func\n\nfunc parseExprThree(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprOr()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'?\')\n\u0009\u0009\u0009do @assertNextChar(\'(\', false)\n\u0009\u0009\u0009var ast2: \\ast@AstExpr3 :: #\\ast@AstExpr3\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr3, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExpr()\n\u0009\u0009\u0009do @assertNextChar(\',\', true)\n\u0009\u0009\u0009do ast2.children2 :: @parseExpr()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009do @assertNextChar(\')\', true)\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprOr(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprAnd()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'|\')\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %or\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprAnd()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprAnd(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprCmp()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'&\')\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %and\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprCmp()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprCmp(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprCat()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009switch(c)\n\u0009\u0009case \'<\'\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009switch(c)\n\u0009\u0009\u0009case \'=\'\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.kind :: %le\n\u0009\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \'>\'\n\u0009\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009\u0009switch(c)\n\u0009\u0009\u0009\u0009case \'&\'\n\u0009\u0009\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009\u0009do ast2.kind :: %nEqRef\n\u0009\u0009\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009\u0009case \'$\'\n\u0009\u0009\u0009\u0009\u0009var ast2: \\ast@AstExprAs :: #\\ast@AstExprAs\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %exprAs, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009\u0009do ast2.kind :: %nIs\n\u0009\u0009\u0009\u0009\u0009do ast2.child :: ast\n\u0009\u0009\u0009\u0009\u0009do ast2.childType :: @parseType()\n\u0009\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009\u0009do ast2.kind :: %nEq\n\u0009\u0009\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009\u0009end switch\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.kind :: %lt\n\u0009\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009end switch\n\u0009\u0009case \'>\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009if(c = \'=\')\n\u0009\u0009\u0009\u0009do ast2.kind :: %ge\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009do ast2.kind :: %gt\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'=\'\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009switch(c)\n\u0009\u0009\u0009case \'&\'\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.kind :: %eqRef\n\u0009\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \'$\'\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExprAs :: #\\ast@AstExprAs\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %exprAs, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.kind :: %is\n\u0009\u0009\u0009\u0009do ast2.child :: ast\n\u0009\u0009\u0009\u0009do ast2.childType :: @parseType()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.kind :: %eq\n\u0009\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009\u0009do ast2.children1 :: @parseExprCat()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009end switch\n\u0009\u0009default\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end switch\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprCat(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprAdd()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009if(c = \'~\')\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %cat\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprAdd()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprAdd(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprMul()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009switch(c)\n\u0009\u0009case \'+\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %add\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprMul()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'-\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %sub\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprMul()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009default\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end switch\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprMul(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprPlus()\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009switch(c)\n\u0009\u0009case \'*\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %mul\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprPlus()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'/\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %div\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprPlus()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'%\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %mod\n\u0009\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009\u0009do ast2.children1 :: @parseExprPlus()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009default\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end switch\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprPlus(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprPow()\n\u0009if(ast <>& null)\n\u0009\u0009ret ast\n\u0009end if\n\u0009var row: int :: @row\n\u0009var col: int :: @col\n\u0009var c: char :: @readChar()\n\u0009if(c = \'#\')\n\u0009\u0009do c :: @read()\n\u0009\u0009switch(c)\n\u0009\u0009case \'[\'\n\u0009\u0009\u0009var ast2: \\ast@AstExprNewArray :: #\\ast@AstExprNewArray\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprNewArray, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.idces :: #list<\\ast@AstExpr>\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009do ast2.idces.add(@parseExpr())\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \']\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do ast2.itemType :: @parseType()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'#\'\n\u0009\u0009\u0009var ast2: \\ast@AstExpr1 :: #\\ast@AstExpr1\n\u0009\u0009\u0009do @initAstExpr(ast2, %expr1, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.kind :: %copy\n\u0009\u0009\u0009do ast2.child :: @parseExprPlus()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009default\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009var ast2: \\ast@AstExprNew :: #\\ast@AstExprNew\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprNew, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.itemType :: @parseType()\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009end switch\n\u0009else\n\u0009\u0009var ast2: \\ast@AstExpr1 :: #\\ast@AstExpr1\n\u0009\u0009do @initAstExpr(ast2, %expr1, \\pos@make(@srcName, row, col))\n\u0009\u0009switch(c)\n\u0009\u0009case \'+\'\n\u0009\u0009\u0009do ast2.kind :: %plus\n\u0009\u0009case \'-\'\n\u0009\u0009\u0009do ast2.kind :: %minus\n\u0009\u0009case \'!\'\n\u0009\u0009\u0009do ast2.kind :: %not\n\u0009\u0009case \'^\'\n\u0009\u0009\u0009do ast2.kind :: %len\n\u0009\u0009default\n\u0009\u0009\u0009do \\err@err(%wrongOperator, ast2.pos, [@charToStr(c)])\n\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009ret null\n\u0009\u0009end switch\n\u0009\u0009do ast2.child :: @parseExprPlus()\n\u0009\u0009do ast :: ast2\n\u0009end if\n\u0009ret ast\nend func\n\nfunc parseExprPow(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprCall()\n\u0009if(ast =& null)\n\u0009\u0009ret ast {Interpret as a unary operator.}\n\u0009end if\n\u0009var row: int :: @row\n\u0009var col: int :: @col\n\u0009var c: char :: @readChar()\n\u0009if(c = \'^\')\n\u0009\u0009var ast2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009do @initAstExpr(ast2, %expr2, \\pos@make(@srcName, row, col))\n\u0009\u0009do ast2.kind :: %pow\n\u0009\u0009do ast2.children0 :: ast\n\u0009\u0009do ast2.children1 :: @parseExprPlus()\n\u0009\u0009do ast :: ast2\n\u0009else\n\u0009\u0009do @fileBuf :: c\n\u0009end if\n\u0009ret ast\nend func\n\nfunc parseExprCall(): \\ast@AstExpr\n\u0009var ast: \\ast@AstExpr :: @parseExprValue()\n\u0009if(ast =& null)\n\u0009\u0009ret ast\n\u0009end if\n\u0009while loop(true)\n\u0009\u0009var row: int :: @row\n\u0009\u0009var col: int :: @col\n\u0009\u0009var c: char :: @readChar()\n\u0009\u0009switch(c)\n\u0009\u0009case \'(\'\n\u0009\u0009\u0009assert ast <>& null\n\u0009\u0009\u0009var ast2: \\ast@AstExprCall :: #\\ast@AstExprCall\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprCall, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.func_ :: ast\n\u0009\u0009\u0009do ast2.args :: #list<\\ast@AstExprCallArg>\n\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009if(c <> \')\')\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009while loop2(true)\n\u0009\u0009\u0009\u0009\u0009var arg: \\ast@AstExprCallArg :: #\\ast@AstExprCallArg\n\u0009\u0009\u0009\u0009\u0009do arg.skipVar :: false\n\u0009\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009\u0009if(c = \'&\')\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: true\n\u0009\u0009\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009\u0009\u0009if(c = \',\' | c = \')\')\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do arg.skipVar :: true\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.refVar :: false\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009\u0009if(arg.skipVar)\n\u0009\u0009\u0009\u0009\u0009\u0009var ast3: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(ast3, %exprRef, ast2.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do ast3.refName :: \"$\"\n\u0009\u0009\u0009\u0009\u0009\u0009do ast3.refItem :: @makeBlockVar(ast3.pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.arg :: ast3\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do arg.arg :: @parseExpr()\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do ast2.args.add(arg)\n\u0009\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009\u0009break loop2\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(c = \')\')\n\u0009\u0009\u0009\u0009\u0009\u0009break loop2\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'[\'\n\u0009\u0009\u0009assert ast <>& null\n\u0009\u0009\u0009var ast2: \\ast@AstExprArray :: #\\ast@AstExprArray\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprArray, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.var_ :: ast\n\u0009\u0009\u0009do ast2.idx :: @parseExpr()\n\u0009\u0009\u0009do @assertNextChar(\']\', true)\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'.\'\n\u0009\u0009\u0009assert ast <>& null\n\u0009\u0009\u0009var ast2: \\ast@AstExprDot :: #\\ast@AstExprDot\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprDot, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009do ast2.var_ :: ast\n\u0009\u0009\u0009do ast2.member :: @readIdentifier(true, false)\n\u0009\u0009\u0009do ast2.classItem :: null\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009case \'$\'\n\u0009\u0009\u0009assert ast <>& null\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009switch(c)\n\u0009\u0009\u0009case \'>\'\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExprToBin :: #\\ast@AstExprToBin\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %exprToBin, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.child :: ast\n\u0009\u0009\u0009\u0009do ast2.childType :: @parseType()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009case \'<\'\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExprFromBin :: #\\ast@AstExprFromBin\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %exprFromBin, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.child :: ast\n\u0009\u0009\u0009\u0009do ast2.childType :: @parseType()\n\u0009\u0009\u0009\u0009do ast2.offset :: @makePrimValue(ast2.pos, %int_, 0b64)\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009var ast2: \\ast@AstExprAs :: #\\ast@AstExprAs\n\u0009\u0009\u0009\u0009do @initAstExpr(ast2, %exprAs, \\pos@make(@srcName, row, col))\n\u0009\u0009\u0009\u0009do ast2.kind :: %as\n\u0009\u0009\u0009\u0009do ast2.child :: ast\n\u0009\u0009\u0009\u0009do ast2.childType :: @parseType()\n\u0009\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009\u0009end switch\n\u0009\u0009default\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end switch\n\u0009end while\n\u0009ret ast\nend func\n\nfunc parseExprValue(): \\ast@AstExpr\n\u0009var row: int :: @row\n\u0009var col: int :: @col\n\u0009var c: char :: @readChar()\n\u0009var pos: \\pos@Pos :: \\pos@make(@srcName, row, col)\n\u0009switch(c)\n\u0009case \'\"\'\n\u0009\u0009var buf: []char :: #[1024]char\n\u0009\u0009var len: int :: 0\n\u0009\u0009var esc: bool :: false\n\u0009\u0009while loop(true)\n\u0009\u0009\u0009do c :: @readInStr()\n\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009do \\err@err(%nonClosingStrLiteral, pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(esc)\n\u0009\u0009\u0009\u0009if(c = \'{\')\n\u0009\u0009\u0009\u0009\u0009var cat: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009do @initAstExpr(cat, %expr2, pos)\n\u0009\u0009\u0009\u0009\u0009do cat.kind :: %cat\n\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009var cat2: \\ast@AstExpr2 :: #\\ast@AstExpr2\n\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(cat2, %expr2, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009do cat2.kind :: %cat\n\u0009\u0009\u0009\u0009\u0009\u0009do cat2.children0 :: @makeStrValue(pos, buf.sub(0, len))\n\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009var call: \\ast@AstExprCall :: #\\ast@AstExprCall\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(call, %exprCall, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do call.args :: #list<\\ast@AstExprCallArg>\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009var dot: \\ast@AstExprDot :: #\\ast@AstExprDot\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @initAstExpr(dot, %exprDot, pos)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.var_ :: @parseExpr()\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.member :: \"toStr\"\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do dot.classItem :: null\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009\u0009do call.func_ :: dot\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do cat2.children1 :: call\n\u0009\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009\u0009do @assertNextChar(\'}\', false)\n\u0009\u0009\u0009\u0009\u0009\u0009do cat.children0 :: cat2\n\u0009\u0009\u0009\u0009\u0009\u0009do @fileBuf :: \'\"\'\n\u0009\u0009\u0009\u0009\u0009\u0009do cat.children1 :: @parseExprValue()\n\u0009\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009\u0009ret cat\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%tooLongStringLiteral, pos, [buf])\n\u0009\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do buf[len] :: @escChar(c)\n\u0009\u0009\u0009\u0009do len :+ 1\n\u0009\u0009\u0009\u0009do esc :: false\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(c = \'\"\')\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(c = \'\\\\\')\n\u0009\u0009\u0009\u0009do esc :: true\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009do \\err@err(%tooLongStringLiteral, pos, [buf])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf[len] :: c\n\u0009\u0009\u0009do len :+ 1\n\u0009\u0009end while\n\u0009\u0009ret @makeStrValue(pos, buf.sub(0, len))\n\u0009case \'\\\'\'\n\u0009\u0009var buf: char :: \'\\0\'\n\u0009\u0009var set: bool :: false\n\u0009\u0009var esc: bool :: false\n\u0009\u0009while loop(true)\n\u0009\u0009\u0009do c :: @readInStr()\n\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009do \\err@err(%nonClosingStrLiteral, pos, null)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(esc)\n\u0009\u0009\u0009\u0009if(set)\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%tooLongCharLiteral, pos, [@charToStr(buf)])\n\u0009\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do buf :: @escChar(c)\n\u0009\u0009\u0009\u0009do set :: true\n\u0009\u0009\u0009\u0009do esc :: false\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(c = \'\\\'\')\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(c = \'\\\\\')\n\u0009\u0009\u0009\u0009do esc :: true\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(set)\n\u0009\u0009\u0009\u0009do \\err@err(%tooLongCharLiteral, pos, [@charToStr(buf)])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf :: c\n\u0009\u0009\u0009do set :: true\n\u0009\u0009end while\n\u0009\u0009if(!set)\n\u0009\u0009\u0009do \\err@err(%emptyCharLiteral, pos, null)\n\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009ret @makePrimValue(pos, %char_, buf $ bit64)\n\u0009case \'(\'\n\u0009\u0009var ast: \\ast@AstExpr :: @parseExpr()\n\u0009\u0009do c :: @readChar()\n\u0009\u0009if(c <> \')\')\n\u0009\u0009\u0009do \\err@err(%noParenthesis, pos, null)\n\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009ret null\n\u0009\u0009end if\n\u0009\u0009ret ast\n\u0009case \'[\'\n\u0009\u0009var ast: \\ast@AstExprValueArray :: #\\ast@AstExprValueArray\n\u0009\u0009do @initAstExpr(ast, %exprValueArray, pos)\n\u0009\u0009do ast.values :: #list<\\ast@AstExpr>\n\u0009\u0009do c :: @readChar()\n\u0009\u0009if(c <> \']\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009var expr: \\ast@AstExpr :: @parseExpr()\n\u0009\u0009\u0009\u0009if(expr <>& null)\n\u0009\u0009\u0009\u0009\u0009do ast.values.add(expr)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \']\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c <> \',\')\n\u0009\u0009\u0009\u0009\u0009do @nextCharErr(\',\', c)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009end if\n\u0009\u0009ret ast\n\u0009case \'%\'\n\u0009\u0009var id: []char :: @readIdentifier(false, false)\n\u0009\u0009var expr: \\ast@AstExprValueEnumElement :: #\\ast@AstExprValueEnumElement\n\u0009\u0009do @initAstExpr(expr, %exprValueEnumElement, pos)\n\u0009\u0009block\n\u0009\u0009\u0009var type: \\ast@AstTypeEnumElement :: #\\ast@AstTypeEnumElement\n\u0009\u0009\u0009do @initAst(type, %typeEnumElement, pos, null, false)\n\u0009\u0009\u0009do expr.type :: type\n\u0009\u0009end block\n\u0009\u0009do expr.identifier :: id\n\u0009\u0009ret expr\n\u0009default\n\u0009\u0009if(\'0\' <= c & c <= \'9\')\n\u0009\u0009\u0009ret @parseExprNumber(row, col, c)\n\u0009\u0009end if\n\u0009\u0009if(\'a\' <= c & c <= \'z\' | \'A\' <= c & c <= \'Z\' | c = \'_\' | c = \'@\' | c = \'\\\\\')\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009var id: []char :: @readIdentifier(true, true)\n\u0009\u0009\u0009switch(id)\n\u0009\u0009\u0009case \"false\"\n\u0009\u0009\u0009\u0009ret @makePrimValue(pos, %bool_, 0b64)\n\u0009\u0009\u0009case \"true\"\n\u0009\u0009\u0009\u0009ret @makePrimValue(pos, %bool_, 1b64)\n\u0009\u0009\u0009case \"inf\"\n\u0009\u0009\u0009\u0009ret @makeFloatValue(pos, inf)\n\u0009\u0009\u0009case \"null\"\n\u0009\u0009\u0009\u0009var ast: \\ast@AstExprValue :: #\\ast@AstExprValue\n\u0009\u0009\u0009\u0009do @initAstExpr(ast, %exprValue, pos)\n\u0009\u0009\u0009\u0009block\n\u0009\u0009\u0009\u0009\u0009var type: \\ast@AstTypeNull :: #\\ast@AstTypeNull\n\u0009\u0009\u0009\u0009\u0009do @initAst(type, %typeNull, pos, null, false)\n\u0009\u0009\u0009\u0009\u0009do ast.type :: type\n\u0009\u0009\u0009\u0009end block\n\u0009\u0009\u0009\u0009ret ast\n\u0009\u0009\u0009case \"dbg\"\n\u0009\u0009\u0009\u0009ret @makePrimValue(pos, %bool_, \\option@rls ?(0b64, 1b64))\n\u0009\u0009\u0009case \"env\"\n\u0009\u0009\u0009\u0009ret @makePrimValue(pos, %int_, \\option@env_ $ bit64)\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009var ast: \\ast@AstExpr :: #\\ast@AstExpr\n\u0009\u0009\u0009\u0009do @initAstExpr(ast, %exprRef, pos)\n\u0009\u0009\u0009\u0009do @addScopeRefeds(ast, id)\n\u0009\u0009\u0009\u0009ret ast\n\u0009\u0009\u0009end switch\n\u0009\u0009end if\n\u0009end switch\n\u0009do @fileBuf :: c\n\u0009ret null\nend func\n\nfunc parseExprNumber(row: int, col: int, c: char): \\ast@AstExpr\n\u0009var ast: \\ast@AstExprValue\n\u0009var pos: \\pos@Pos :: \\pos@make(@srcName, row, col)\n\u0009var buf: []char :: #[1024]char\n\u0009var len: int :: 0\n\u0009var base: int :: 10\n\u0009var changeBase: bool :: false\n\u0009var floatType: bool :: false\n\u0009var byteSize: int :: 0 {The size for bit types.}\n\u0009while loop(true)\n\u0009\u0009switch(c)\n\u0009\u0009case \'x\'\n\u0009\u0009\u0009if(changeBase | floatType)\n\u0009\u0009\u0009\u0009do \\err@err(%wrongNumericLiteral, pos, [\"x\"])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(len <> 1 | buf[0] <> \'0\')\n\u0009\u0009\u0009\u0009do \\err@err(%wrongHexadecimalLiteral, pos, null)\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do len :: 0\n\u0009\u0009\u0009do base :: 16\n\u0009\u0009\u0009do changeBase :: true\n\u0009\u0009case \'.\'\n\u0009\u0009\u0009if(changeBase | floatType)\n\u0009\u0009\u0009\u0009do \\err@err(%wrongNumericLiteral, pos, [\".\"])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009do \\err@err(%tooLongNumericLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf[len] :: c\n\u0009\u0009\u0009do len :+ 1\n\u0009\u0009\u0009do floatType :: true\n\u0009\u0009case \'0\' to \'9\', \'A\' to \'F\'\n\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009do \\err@err(%tooLongNumericLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf[len] :: c\n\u0009\u0009\u0009do len :+ 1\n\u0009\u0009default\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009break loop\n\u0009\u0009end switch\n\u0009\u0009do c :: @read()\n\u0009end while\n\u0009if(len = 0 | buf[len - 1] = \'.\')\n\u0009\u0009do \\err@err(%wrongNumericLiteral, pos, [\".\"])\n\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009ret null\n\u0009end if\n\u0009if(floatType)\n\u0009\u0009do c :: @read()\n\u0009\u0009if(c = \'e\')\n\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009do \\err@err(%tooLongNumericLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf[len] :: c\n\u0009\u0009\u0009do len :+ 1\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009if(c <> \'+\' & c <> \'-\')\n\u0009\u0009\u0009\u0009do \\err@err(%wrongExponentialNotationLiteral, pos, null)\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009do \\err@err(%tooLongNumericLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf[len] :: c\n\u0009\u0009\u0009do len :+ 1\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009if(!(\'0\' <= c & c <= \'9\'))\n\u0009\u0009\u0009\u0009do \\err@err(%wrongExponentialNotationLiteral, pos, null)\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009while(\'0\' <= c & c <= \'9\', skip)\n\u0009\u0009\u0009\u0009if(len = 1024)\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%tooLongNumericLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do buf[len] :: c\n\u0009\u0009\u0009\u0009do len :+ 1\n\u0009\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009end while\n\u0009\u0009end if\n\u0009\u0009do @fileBuf :: c\n\u0009\u0009block\n\u0009\u0009\u0009var success: bool\n\u0009\u0009\u0009var value: float :: buf.sub(0, len).toFloat(&success)\n\u0009\u0009\u0009if(!success)\n\u0009\u0009\u0009\u0009do \\err@err(%wrongFloatingPointLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009var ast2: \\ast@AstExprValueFloat :: #\\ast@AstExprValueFloat\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprValueFloat, pos)\n\u0009\u0009\u0009do ast2.value :: value\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009end block\n\u0009else\n\u0009\u0009do c :: @read()\n\u0009\u0009if(c = \'b\')\n\u0009\u0009\u0009do c :: @read()\n\u0009\u0009\u0009switch(c)\n\u0009\u0009\u0009case \'8\'\n\u0009\u0009\u0009\u0009do byteSize :: 1\n\u0009\u0009\u0009case \'1\'\n\u0009\u0009\u0009\u0009do @assertNextChar(\'6\', false)\n\u0009\u0009\u0009\u0009do byteSize :: 2\n\u0009\u0009\u0009case \'3\'\n\u0009\u0009\u0009\u0009do @assertNextChar(\'2\', false)\n\u0009\u0009\u0009\u0009do byteSize :: 4\n\u0009\u0009\u0009case \'6\'\n\u0009\u0009\u0009\u0009do @assertNextChar(\'4\', false)\n\u0009\u0009\u0009\u0009do byteSize :: 8\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do \\err@err(%wrongBitTypeLiteral, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(c)\n\u0009\u0009\u0009end switch\n\u0009\u0009else\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009block\n\u0009\u0009\u0009var value: bit64\n\u0009\u0009\u0009var success: bool\n\u0009\u0009\u0009if(base = 10)\n\u0009\u0009\u0009\u0009do value :: buf.sub(0, len).toBit64(&success)\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009assert base = 16\n\u0009\u0009\u0009\u0009do value :: (\"0x\" ~ buf.sub(0, len)).toBit64(&success)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!success)\n\u0009\u0009\u0009\u0009do \\err@err(%integerLiteralOverflowed, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(byteSize = 1 & value > 0xFFb64 | byteSize = 2 & value > 0xFFFFb64 | byteSize = 4 & value > 0xFFFFFFFFb64 | byteSize = 0 & value > lib@intMax $ bit64)\n\u0009\u0009\u0009\u0009do \\err@err(%integerLiteralOverflowed, pos, [buf.sub(0, len)])\n\u0009\u0009\u0009\u0009do @readUntilRet(@read())\n\u0009\u0009\u0009\u0009ret null\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009\n\u0009\u0009\u0009var ast2: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009\u0009\u0009do @initAstExpr(ast2, %exprValuePrim, pos)\n\u0009\u0009\u0009do ast2.value :: value\n\u0009\u0009\u0009do ast :: ast2\n\u0009\u0009end block\n\u0009end if\n\u0009if(byteSize = 0)\n\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009do @initAst(type, %typePrim, pos, null, false)\n\u0009\u0009if(floatType)\n\u0009\u0009\u0009do type.kind :: %float_\n\u0009\u0009else\n\u0009\u0009\u0009do type.kind :: %int_\n\u0009\u0009end if\n\u0009\u0009do ast.type :: type\n\u0009else\n\u0009\u0009var type: \\ast@AstTypeBit :: #\\ast@AstTypeBit\n\u0009\u0009do @initAst(type, %typeBit, pos, null, false)\n\u0009\u0009do type.size :: byteSize\n\u0009\u0009do ast.type :: type\n\u0009end if\n\u0009ret ast\nend func\n\nfunc makePos(): \\pos@Pos\n\u0009ret \\pos@make(@srcName, @row, @col)\nend func\n\nfunc initAst(ast: \\ast@Ast, typeId: \\ast@TypeId, pos: \\pos@Pos, name: []char, setParent: bool)\n\u0009assert ast <>$ \\ast@AstExpr\n\u0009do @initAstImpl(ast, typeId, pos, name, setParent)\nend func\n\nfunc initAstExpr(ast: \\ast@AstExpr, typeId: \\ast@TypeId, pos: \\pos@Pos)\n\u0009assert ast =$ \\ast@AstExpr\n\u0009do @initAstImpl(ast, typeId, pos, null, false)\n\u0009do ast.type :: null\n\u0009do ast.varKind :: %unknown\nend func\n\nfunc initAstImpl(ast: \\ast@Ast, typeId: \\ast@TypeId, pos: \\pos@Pos, name: []char, setParent: bool)\n\u0009do ast.typeId :: typeId\n\u0009do ast.pos :: pos\n\u0009do ast.name :: name\n\u0009do ast.scopeParent :: null\n\u0009do ast.scopeChildren :: null\n\u0009do ast.refName :: null\n\u0009do ast.refItem :: null\n\u0009do ast.extra :: null\n\u0009do ast.publicInSrc :: false\n\u0009if(ast.name <>& null)\n\u0009\u0009do @addScopeName(ast, true)\n\u0009end if\n\u0009if(setParent)\n\u0009\u0009do ast.scopeParent :: @scope.peek()\n\u0009end if\nend func\n\nfunc addScopeName(ast: \\ast@Ast, refuseReserved: bool)\n\u0009assert ast.name <>& null\n\u0009if(refuseReserved & @isReserved(ast.name))\n\u0009\u0009do \\err@err(%sameIdentifierInSameScope, @makePos(), [ast.name])\n\u0009\u0009ret\n\u0009end if\n\u0009var scope: \\ast@Ast :: @scope.peek()\n\u0009if(scope.scopeChildren.get(ast.name, &) <>& null)\n\u0009\u0009do \\err@err(%sameIdentifierInSameScope, @makePos(), [ast.name])\n\u0009end if\n\u0009\n\u0009var parent: \\ast@Ast :: scope\n\u0009var overFunc: bool :: false\n\u0009while loop(true)\n\u0009\u0009if(parent.scopeParent =& null)\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009if(parent.name <>& null & parent.name = ast.name & !((parent.typeId = %func_ & parent.refName <>& null)))\n\u0009\u0009\u0009do \\err@err(%sameIdentifierInUpperScope, @makePos(), [ast.name])\n\u0009\u0009\u0009ret\n\u0009\u0009end if\n\u0009\u0009var child: \\ast@Ast :: parent.scopeChildren.get(ast.name, &)\n\u0009\u0009if(child <>& null)\n\u0009\u0009\u0009var flag: bool :: false\n\u0009\u0009\u0009if(overFunc)\n\u0009\u0009\u0009\u0009if(child.typeId = %arg)\n\u0009\u0009\u0009\u0009\u0009var kind: \\ast@AstArgKind :: (child $ \\ast@AstArg).kind\n\u0009\u0009\u0009\u0009\u0009if(kind = %member | kind = %localVar | kind = %localArg)\n\u0009\u0009\u0009\u0009\u0009\u0009do flag :: true\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(!flag & child.typeId.and(%statBreakable) = %statBreakable)\n\u0009\u0009\u0009\u0009\u0009do flag :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!flag & child.typeId = %func_ & child.refName <>& null)\n\u0009\u0009\u0009\u0009do flag :: true\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!flag)\n\u0009\u0009\u0009\u0009do \\err@err(%sameIdentifierInUpperScope, @makePos(), [ast.name])\n\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009if(parent.typeId = %func_)\n\u0009\u0009\u0009do overFunc :: true\n\u0009\u0009end if\n\u0009\u0009do parent :: parent.scopeParent\n\u0009end while\n\u0009do scope.scopeChildren.add(ast.name, ast)\nend func\n\nfunc isReserved(name: []char): bool\n\u0009if(@reserved =& null)\n\u0009\u0009do @reserved :: [\n\u0009\u0009|\"alias\",\n\u0009\u0009|\"assert\",\n\u0009\u0009|\"bit16\",\n\u0009\u0009|\"bit32\",\n\u0009\u0009|\"bit64\",\n\u0009\u0009|\"bit8\",\n\u0009\u0009|\"block\",\n\u0009\u0009|\"bool\",\n\u0009\u0009|\"break\",\n\u0009\u0009|\"case\",\n\u0009\u0009|\"catch\",\n\u0009\u0009|\"char\",\n\u0009\u0009|\"class\",\n\u0009\u0009|\"const\",\n\u0009\u0009|\"dbg\",\n\u0009\u0009|\"default\",\n\u0009\u0009|\"dict\",\n\u0009\u0009|\"do\",\n\u0009\u0009|\"elif\",\n\u0009\u0009|\"else\",\n\u0009\u0009|\"end\",\n\u0009\u0009|\"enum\",\n\u0009\u0009|\"env\",\n\u0009\u0009|\"false\",\n\u0009\u0009|\"finally\",\n\u0009\u0009|\"float\",\n\u0009\u0009|\"for\",\n\u0009\u0009|\"func\",\n\u0009\u0009|\"if\",\n\u0009\u0009|\"include\",\n\u0009\u0009|\"inf\",\n\u0009\u0009|\"int\",\n\u0009\u0009|\"list\",\n\u0009\u0009|\"me\",\n\u0009\u0009|\"null\",\n\u0009\u0009|\"queue\",\n\u0009\u0009|\"ret\",\n\u0009\u0009|\"skip\",\n\u0009\u0009|\"stack\",\n\u0009\u0009|\"super\",\n\u0009\u0009|\"switch\",\n\u0009\u0009|\"throw\",\n\u0009\u0009|\"to\",\n\u0009\u0009|\"true\",\n\u0009\u0009|\"try\",\n\u0009\u0009|\"var\",\n\u0009\u0009|\"while\"]\n\u0009\u0009\n\u0009\u0009if(dbg)\n\u0009\u0009\u0009for i(0, ^@reserved - 2)\n\u0009\u0009\u0009\u0009assert @reserved[i] < @reserved[i + 1]\n\u0009\u0009\u0009end for\n\u0009\u0009end if\n\u0009end if\n\u0009ret @reserved.findBin(name) <> -1\nend func\n\nfunc readChar(): char\n\u0009while loop(true)\n\u0009\u0009var c: char :: @read()\n\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009do c :: @readChar()\n\u0009\u0009\u0009switch(c)\n\u0009\u0009\u0009case \'\\n\'\n\u0009\u0009\u0009\u0009ret \'\\n\'\n\u0009\u0009\u0009case \';\'\n\u0009\u0009\u0009\u0009while(c <> \'\\n\', skip)\n\u0009\u0009\u0009\u0009\u0009do c :: @readBuf()\n\u0009\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009\u0009ret \'\\0\'\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009case \'|\'\n\u0009\u0009\u0009\u0009ret @readChar()\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009do @fileBufTmp :: c\n\u0009\u0009\u0009ret \'\\n\'\n\u0009\u0009end if\n\u0009\u0009if(c <> \' \')\n\u0009\u0009\u0009ret c\n\u0009\u0009end if\n\u0009end while\nend func\n\nfunc read(): char\n\u0009var c: char :: @readBuf()\n\u0009switch(c)\n\u0009case \'{\'\n\u0009\u0009do @readComment()\n\u0009\u0009ret \' \'\n\u0009case \'\\t\'\n\u0009\u0009ret \' \'\n\u0009end switch\n\u0009ret c\nend func\n\nfunc readBuf(): char\n\u0009var c: char\n\u0009if(@fileBuf = \'\\0\')\n\u0009\u0009if(@fileBufTmp = \'\\0\')\n\u0009\u0009\u0009while(c = \'\\u000D\', skip)\n\u0009\u0009\u0009\u0009do c :: @filePtr.term() ?(\'\\0\', @filePtr.readLetter())\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009\u0009do @row :+ 1\n\u0009\u0009\u0009\u0009do @col :: 0\n\u0009\u0009\u0009elif(c = \'\\0\')\n\u0009\u0009\u0009\u0009if(!@fileLast)\n\u0009\u0009\u0009\u0009\u0009do @fileLast :: true\n\u0009\u0009\u0009\u0009\u0009do c :: \'\\n\'\n\u0009\u0009\u0009\u0009\u0009do @row :+ 1\n\u0009\u0009\u0009\u0009\u0009do @col :: 0\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @col :+ 1\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009do c :: @fileBufTmp\n\u0009\u0009\u0009do @fileBufTmp :: \'\\0\'\n\u0009\u0009end if\n\u0009else\n\u0009\u0009do c :: @fileBuf\n\u0009\u0009do @fileBuf :: \'\\0\'\n\u0009end if\n\u0009ret c\nend func\n\nfunc readComment()\n\u0009var row: int :: @row\n\u0009var col: int :: @col\n\u0009var c: char\n\u0009while(c <> \'}\', skip)\n\u0009\u0009do c :: @read()\n\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009do \\err@err(%noBrace, \\pos@make(@srcName, row, col), null)\n\u0009\u0009\u0009ret\n\u0009\u0009end if\n\u0009\u0009if(c = \'\"\')\n\u0009\u0009\u0009var esc: bool :: false\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009do c :: @readInStr()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%noBrace, \\pos@make(@srcName, row, col), null)\n\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(esc)\n\u0009\u0009\u0009\u0009\u0009if(c = \'{\')\n\u0009\u0009\u0009\u0009\u0009\u0009do @readComment()\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do esc :: false\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \'\"\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \'\\\\\')\n\u0009\u0009\u0009\u0009\u0009do esc :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009elif(c = \'\\\'\')\n\u0009\u0009\u0009var esc: bool :: false\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009do c :: @readInStr()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%noBrace, \\pos@make(@srcName, row, col), null)\n\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(esc)\n\u0009\u0009\u0009\u0009\u0009do esc :: false\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \'\\\'\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \'\\\\\')\n\u0009\u0009\u0009\u0009\u0009do esc :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009elif(c = \';\')\n\u0009\u0009\u0009while loop(true)\n\u0009\u0009\u0009\u0009do c :: @readBuf()\n\u0009\u0009\u0009\u0009if(c = \'\\0\')\n\u0009\u0009\u0009\u0009\u0009do \\err@err(%noBrace, \\pos@make(@srcName, row, col), null)\n\u0009\u0009\u0009\u0009\u0009ret\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end while\n\u0009\u0009end if\n\u0009end while\nend func\n\nfunc readInStr(): char\n\u0009while loop(true)\n\u0009\u0009var c: char :: @readBuf()\n\u0009\u0009switch(c)\n\u0009\u0009case \'\\t\'\n\u0009\u0009\u0009do \\err@err(%tabInStr, @makePos(), null)\n\u0009\u0009\u0009skip loop\n\u0009\u0009case \'\\n\'\n\u0009\u0009\u0009do \\err@err(%lineBreakInStr, @makePos(), null)\n\u0009\u0009end switch\n\u0009\u0009ret c\n\u0009end while\nend func\n\nfunc readIdentifier(skipSpaces: bool, refName: bool): []char\n\u0009var c: char :: skipSpaces ?(@readChar(), @read())\n\u0009if(!(\'a\' <= c & c <= \'z\' | \'A\' <= c & c <= \'Z\' | c = \'_\' | refName & (c = \'@\' | c = \'\\\\\')))\n\u0009\u0009do @fileBuf :: c\n\u0009\u0009do \\err@err(%wrongCharacterInIdentifier, @makePos(), [@charToStr(c)])\n\u0009\u0009ret \"\"\n\u0009end if\n\u0009\n\u0009var buf: []char :: #[128]char\n\u0009var pos: int :: 0\n\u0009var at: bool :: false\n\u0009while(\'a\' <= c & c <= \'z\' | \'A\' <= c & c <= \'Z\' | c = \'_\' | \'0\' <= c & c <= \'9\' | refName & (c = \'@\' | c = \'\\\\\'), skip)\n\u0009\u0009switch(c)\n\u0009\u0009case \'@\'\n\u0009\u0009\u0009if(at)\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009do \\err@err(%wrongAtInIdentifier, @makePos(), null)\n\u0009\u0009\u0009\u0009ret \"\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(pos <> 0)\n\u0009\u0009\u0009\u0009var srcName: []char :: buf.sub(0, pos)\n\u0009\u0009\u0009\u0009for i(0, ^srcName - 1)\n\u0009\u0009\u0009\u0009\u0009var c2: char :: srcName[i]\n\u0009\u0009\u0009\u0009\u0009if(\'A\' <= c2 & c2 <= \'Z\')\n\u0009\u0009\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009\u0009\u0009do \\err@err(%uppercaseFileName, @makePos(), [srcName])\n\u0009\u0009\u0009\u0009\u0009\u0009ret \"\"\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end for\n\u0009\u0009\u0009\u0009do @addSrc(srcName)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do at :: true\n\u0009\u0009case \'\\\\\'\n\u0009\u0009\u0009if(at)\n\u0009\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009\u0009do \\err@err(%wrongBackslashInIdentifier, @makePos(), null)\n\u0009\u0009\u0009\u0009ret \"\"\n\u0009\u0009\u0009end if\n\u0009\u0009end switch\n\u0009\u0009if(pos = 128)\n\u0009\u0009\u0009do @fileBuf :: c\n\u0009\u0009\u0009do \\err@err(%tooLongIdentifier, @makePos(), [buf])\n\u0009\u0009\u0009ret \"\"\n\u0009\u0009end if\n\u0009\u0009do buf[pos] :: c\n\u0009\u0009do pos :+ 1\n\u0009\u0009do c :: @read()\n\u0009end while\n\u0009do @fileBuf :: c\n\u0009ret buf.sub(0, pos)\nend func\n\nfunc readUntilRet(c: char)\n\u0009while(c <> \'\\n\' & c <> \'\\0\')\n\u0009\u0009do c :: @read()\n\u0009end while\n\u0009do @fileBuf :: c\nend func\n\nfunc readFuncAttr(): []char\n\u0009var c: char :: @readChar()\n\u0009if(!(\'a\' <= c & c <= \'z\' | \'A\' <= c & c <= \'Z\' | \'0\' <= c & c <= \'9\' | c = \'_\' | c = \'.\'))\n\u0009\u0009do \\err@err(%wrongCharacterInFuncAttr, @makePos(), [@charToStr(c)])\n\u0009\u0009ret \"\"\n\u0009end if\n\u0009\n\u0009var buf: []char :: #[128]char\n\u0009var pos: int :: 0\n\u0009while(\'a\' <= c & c <= \'z\' | \'A\' <= c & c <= \'Z\' | \'0\' <= c & c <= \'9\' | c = \'_\' | c = \'.\', skip)\n\u0009\u0009if(pos = 128)\n\u0009\u0009\u0009do \\err@err(%tooLongFuncAttr, @makePos(), [buf])\n\u0009\u0009\u0009ret \"\"\n\u0009\u0009end if\n\u0009\u0009do buf[pos] :: c\n\u0009\u0009do pos :+ 1\n\u0009\u0009do c :: @read()\n\u0009end while\n\u0009do @fileBuf :: c\n\u0009ret buf.sub(0, pos)\nend func\n\nfunc addSrc(name: []char)\n\u0009if(@srcesNext.get(name, &) =& null)\n\u0009\u0009do @srcesNext.add(name, null)\n\u0009end if\nend func\n\nfunc nextCharErr(c: char, c2: char)\n\u0009do \\err@err(%charShouldBeWritten, @makePos(), [@charToStr(c), @charToStr(c2)])\n\u0009do @readUntilRet(c2)\nend func\n\nfunc assertNextChar(c: char, skipSpaces: bool)\n\u0009var c2: char :: skipSpaces ?(@readChar(), @read())\n\u0009if(c <> c2)\n\u0009\u0009do @nextCharErr(c, c2)\n\u0009\u0009do @fileBuf :: c2\n\u0009end if\nend func\n\nfunc addScopeRefeds(ast: \\ast@Ast, name: []char)\n\u0009; \'RefName\' added here will be resolved later.\n\u0009do ast.refName :: name\n\u0009var scopeRefedItem: \\ast@ScopeRefedItem :: #\\ast@ScopeRefedItem\n\u0009do scopeRefedItem.def :: ast\n\u0009do scopeRefedItem.scope :: @scope.peek()\n\u0009do @scopeRefedItems.add(scopeRefedItem)\nend func\n\nfunc charToStr(c: char): []char\n\u0009switch(c)\n\u0009case \'\\0\'\n\u0009\u0009ret \" \"\n\u0009case \'\\u000D\'\n\u0009\u0009assert false\n\u0009case \'\\n\'\n\u0009\u0009ret \"(RETURN)\"\n\u0009case \'\\t\', \' \'\n\u0009\u0009ret \"(SPACE)\"\n\u0009end switch\n\u0009ret c.toStr()\nend func\n\nfunc obtainBlockName(ast: \\ast@Ast)\n\u0009var c: char :: @readChar()\n\u0009if(c <> \'(\')\n\u0009\u0009do @fileBuf :: c\n\u0009\u0009do ast.name :: @readIdentifier(true, false)\n\u0009\u0009do @addScopeName(ast, true)\n\u0009\u0009do @assertNextChar(\'(\', true)\n\u0009else\n\u0009\u0009do ast.name :: \"$\"\n\u0009end if\nend func\n\nfunc pushDummyScope(ast: \\ast@Ast)\n\u0009var dummy: \\ast@Ast :: #\\ast@Ast\n\u0009do @initAst(dummy, %none, null, null, true)\n\u0009do @scope.peek().scopeChildren.add(\"$\" ~ @uniqueCnt.toStr(), dummy)\n\u0009do @uniqueCnt :+ 1\n\u0009\n\u0009do dummy.scopeChildren :: #dict<[]char, \\ast@Ast>\n\u0009do @scope.add(dummy)\n\u0009\n\u0009do ast.scopeParent :: dummy\nend func\n\nfunc parseDummyBlock(outStat: &\\ast@AstStat, outTypeId: &\\ast@TypeId, typeId: \\ast@TypeId, block_: \\ast@Ast): \\ast@AstStatBlock\n\u0009var ast: \\ast@AstStatBlock :: #\\ast@AstStatBlock\n\u0009do @initAst(ast, %statBlock, @makePos(), null, false)\n\u0009do ast.blockVar :: null\n\u0009do ast.stats :: #list<\\ast@AstStat>\n\u0009do @pushDummyScope(ast)\n\u0009do ast.name :: \"$\"\n\u0009\n\u0009while loop(true)\n\u0009\u0009var stat: \\ast@AstStat :: @parseStat(block_)\n\u0009\u0009if(stat =& null)\n\u0009\u0009\u0009if(@fileLast)\n\u0009\u0009\u0009\u0009do outStat :: null\n\u0009\u0009\u0009\u0009do outTypeId :: %statEnd\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009var endFlag: bool :: false\n\u0009\u0009switch(typeId)\n\u0009\u0009case %statIf\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statElIf, %statElse, %statEnd\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statElIf\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statElIf, %statElse, %statEnd\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statElse\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statElIf, %statElse\n\u0009\u0009\u0009\u0009do \\err@err(%elifOrElseAfterElse, @makePos(), null)\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009case %statEnd\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statCase\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statCase, %statDefault, %statEnd\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statDefault\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statCase, %statDefault\n\u0009\u0009\u0009\u0009do \\err@err(%caseOrDefaultAfterDefault, @makePos(), null)\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009case %statEnd\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statTry\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statCatch, %statFinally\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statCatch\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statCatch, %statFinally, %statElIf\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009case %statFinally\n\u0009\u0009\u0009switch(stat.typeId)\n\u0009\u0009\u0009case %statCatch, %statFinally\n\u0009\u0009\u0009\u0009do \\err@err(%catchOrFinallyAfterFinally, @makePos(), null)\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009case %statEnd\n\u0009\u0009\u0009\u0009do endFlag :: true\n\u0009\u0009\u0009end switch\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009if(endFlag)\n\u0009\u0009\u0009do outStat :: stat\n\u0009\u0009\u0009do outTypeId :: stat.typeId\n\u0009\u0009\u0009break loop\n\u0009\u0009end if\n\u0009\u0009do ast.stats.add(stat)\n\u0009end while\n\u0009\n\u0009do @scope.get()\n\u0009ret ast\nend func\n\nfunc makePrimValue(pos: \\pos@Pos, kind: \\ast@AstTypePrimKind, value: bit64): \\ast@AstExprValuePrim\n\u0009var expr: \\ast@AstExprValuePrim :: #\\ast@AstExprValuePrim\n\u0009do @initAstExpr(expr, %exprValuePrim, pos)\n\u0009block\n\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009do @initAst(type, %typePrim, pos, null, false)\n\u0009\u0009do type.kind :: kind\n\u0009\u0009do expr.type :: type\n\u0009end block\n\u0009do expr.value :: value\n\u0009ret expr\nend func\n\nfunc makeStrValue(pos: \\pos@Pos, value: []char): \\ast@AstExprValueStr\n\u0009var expr: \\ast@AstExprValueStr :: #\\ast@AstExprValueStr\n\u0009do @initAstExpr(expr, %exprValueStr, pos)\n\u0009block\n\u0009\u0009var type: \\ast@AstTypeArray :: #\\ast@AstTypeArray\n\u0009\u0009do @initAst(type, %typeArray, pos, null, false)\n\u0009\u0009block\n\u0009\u0009\u0009var type2: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009\u0009do @initAst(type2, %typePrim, pos, null, false)\n\u0009\u0009\u0009do type2.kind :: %char_\n\u0009\u0009\u0009do type.itemType :: type2\n\u0009\u0009end block\n\u0009\u0009do expr.type :: type\n\u0009end block\n\u0009do expr.value :: value\n\u0009ret expr\nend func\n\nfunc makeFloatValue(pos: \\pos@Pos, value: float): \\ast@AstExprValueFloat\n\u0009var expr: \\ast@AstExprValueFloat :: #\\ast@AstExprValueFloat\n\u0009do @initAstExpr(expr, %exprValueFloat, pos)\n\u0009block\n\u0009\u0009var type: \\ast@AstTypePrim :: #\\ast@AstTypePrim\n\u0009\u0009do @initAst(type, %typePrim, pos, null, false)\n\u0009\u0009do type.kind :: %float_\n\u0009\u0009do expr.type :: type\n\u0009end block\n\u0009do expr.value :: value\n\u0009ret expr\nend func\n\nfunc makeBlockVar(pos: \\pos@Pos): \\ast@AstArg\n\u0009var arg: \\ast@AstArg :: #\\ast@AstArg\n\u0009do @initAst(arg, %arg, pos, null, false)\n\u0009do arg.kind :: %localVar\n\u0009do arg.refVar :: false\n\u0009do arg.type :: null\n\u0009do arg.expr :: null\n\u0009ret arg\nend func\n\nfunc escChar(c: char): char\n\u0009switch(c)\n\u0009case \'\"\', \'\\\'\', \'\\\\\'\n\u0009\u0009ret c\n\u0009case \'0\'\n\u0009\u0009ret \'\\0\'\n\u0009case \'n\'\n\u0009\u0009ret \'\\n\'\n\u0009case \'t\'\n\u0009\u0009ret \'\\t\'\n\u0009case \'u\'\n\u0009\u0009var buf: []char :: #[6]char\n\u0009\u0009do buf[0] :: \'0\'\n\u0009\u0009do buf[1] :: \'x\'\n\u0009\u0009for i(0, 3)\n\u0009\u0009\u0009do c :: @readInStr()\n\u0009\u0009\u0009if(!(\'0\' <= c & c <= \'9\' | \'A\' <= c & c <= \'F\'))\n\u0009\u0009\u0009\u0009do \\err@err(%wrongCharCodeRepresentation, @makePos(), null)\n\u0009\u0009\u0009\u0009ret \'u\'\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf[2 + i] :: c\n\u0009\u0009end for\n\u0009\u0009ret buf.toInt(&) $ char\n\u0009default\n\u0009\u0009do \\err@err(%wrongEscSequence, @makePos(), [@charToStr(c)])\n\u0009\u0009ret c\n\u0009end switch\nend func\n":true;
else if(p==="res/pos.kn")
return f?"+class Pos()\n\u0009+var srcName: []char\n\u0009+var row: int\n\u0009+var col: int\nend class\n\n+func make(srcName: []char, row: int, col: int): @Pos\n\u0009var pos: @Pos :: #@Pos\n\u0009do pos.srcName :: srcName\n\u0009do pos.row :: row\n\u0009do pos.col :: col\n\u0009ret pos\nend func\n":true;
else if(p==="res/sys/")
return f?null:true;
else if(p==="res/sys/common.h")
return f?"#include <chrono>\n#include <codecvt>\n#include <cstdarg>\n#include <cstdint>\n#include <cstring>\n#include <fstream>\n#include <iomanip>\n#include <iostream>\n#include <list>\n#include <map>\n#include <queue>\n#include <sstream>\n#include <stack>\n#include <type_traits>\n#include <vector>\n\nclass Ref_;\ntemplate<typename T> class Array_;\ntemplate<typename T> class List_;\ntemplate<typename T> class Stack_;\ntemplate<typename T> class Queue_;\ntemplate<typename T1, typename T2> class dictImpl_;\ntemplate<typename T1, typename T2> class Dict_;\nclass Class_;\n\n#if _MSC_VER >= 1900\nstatic std::string utf16ToUtf8_(const std::u16string& s)\n{\n\u0009const int16_t* p = reinterpret_cast<const int16_t*>(s.data());\n\u0009return std::wstring_convert<std::codecvt_utf8_utf16<int16_t>, int16_t>{}.to_bytes(p, p + s.size());\n}\nstatic std::u16string utf8ToUtf16_(const std::string& s)\n{\n\u0009const auto t = std::wstring_convert<std::codecvt_utf8_utf16<int16_t>, int16_t>{}.from_bytes(s);\n\u0009return std::u16string(reinterpret_cast<const char16_t*>(t.data()), t.size());\n}\n#else\nstatic std::string utf16ToUtf8_(const std::u16string& s)\n{\n\u0009return std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t>{}.to_bytes(s);\n}\nstatic std::u16string utf8ToUtf16_(const std::string& s)\n{\n\u0009return std::wstring_convert<std::codecvt_utf8_utf16<char16_t>, char16_t>{}.from_bytes(s);\n}\n#endif\n\n#if defined(_WIN32)\n\n#define STRICT\n#define _WIN32_DCOM\n\n#include <Windows.h>\n\n#undef min\n#undef far\n#undef max\n#undef near\n\nconst char newLine_[] = { \'\\r\', \'\\n\' };\n\nstatic bool setCurDir_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::SetCurrentDirectoryA(t.c_str()) != 0;\n}\nstatic bool makeDir_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::CreateDirectoryA(t.c_str(), 0) != 0;\n}\nstatic bool delDir_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::RemoveDirectoryA(t.c_str()) != 0;\n}\nstatic bool delFile_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::DeleteFileA(t.c_str()) != 0;\n}\nstatic bool copyDir_(const char16_t* d, const char16_t* s)\n{\n\u0009std::u16string s1 = d;\n\u0009const std::string& t1 = utf16ToUtf8_(s1);\n\u0009std::u16string s2 = s;\n\u0009const std::string& t2 = utf16ToUtf8_(s2);\n\u0009return ::CreateDirectoryExA(t2.c_str(), t1.c_str(), 0) != 0;\n}\nstatic bool copyFile_(const char16_t* d, const char16_t* s)\n{\n\u0009std::u16string s1 = d;\n\u0009const std::string& t1 = utf16ToUtf8_(s1);\n\u0009std::u16string s2 = s;\n\u0009const std::string& t2 = utf16ToUtf8_(s2);\n\u0009return ::CopyFileA(t2.c_str(), t1.c_str(), false) != 0;\n}\nstatic bool moveFile_(const char16_t* d, const char16_t* s)\n{\n\u0009std::u16string s1 = d;\n\u0009const std::string& t1 = utf16ToUtf8_(s1);\n\u0009std::u16string s2 = s;\n\u0009const std::string& t2 = utf16ToUtf8_(s2);\n\u0009return ::MoveFileExA(t2.c_str(), t1.c_str(), MOVEFILE_REPLACE_EXISTING | MOVEFILE_COPY_ALLOWED) != 0;\n}\n\n#else\n\nconst char newLine_[] = { \'\\n\' };\n\nstatic bool setCurDir_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::chdir(t.c_str()) == 0;\n}\nstatic bool makeDir_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::mkdir(t.c_str(), S_IRWXU | S_IRWXG | S_IRWXO) == 0;\n}\nstatic bool delDir_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::rmdir(t.c_str()) == 0;\n}\nstatic bool delFile_(const char16_t* p)\n{\n\u0009std::u16string s = p;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009return ::unlink(t.c_str()) == 0;\n}\nstatic bool copyDir_(const char16_t* d, const char16_t* s)\n{\n\u0009std::u16string s1 = d;\n\u0009const std::string& t1 = utf16ToUtf8_(s1);\n\u0009std::u16string s2 = s;\n\u0009const std::string& t2 = utf16ToUtf8_(s2);\n\u0009struct stat f;\n\u0009return !(::stat(t2.c_str(), &f) != 0 || ::mkdir(t1.c_str(), f.st_mode) != 0);\n}\nstatic bool copyFile_(const char16_t* d, const char16_t* s)\n{\n\u0009std::u16string s1 = d;\n\u0009const std::string& t1 = utf16ToUtf8_(s1);\n\u0009std::u16string s2 = s;\n\u0009const std::string& t2 = utf16ToUtf8_(s2);\n\u0009int i = ::open(t2.c_str(), O_RDONLY);\n\u0009if (i < 0)\n\u0009\u0009return false;\n\u0009struct stat f;\n\u0009if (::stat(t2.c_str(), &f) != 0)\n\u0009{\n\u0009\u0009::close(i);\n\u0009\u0009return false;\n\u0009}\n\u0009int o = ::open(t1.c_str(), O_CREAT | O_WRONLY | O_TRUNC, f.st_mode);\n\u0009if (o < 0)\n\u0009{\n\u0009\u0009::close(i);\n\u0009\u0009return false;\n\u0009}\n\u0009size_t r = 1;\n\u0009char* buf = new char[65536];\n\u0009while (r > 0 && (r = ::read(i, buf.get(), 65536)) > 0)\n\u0009{\n\u0009\u0009size_t z, w = 0;\n\u0009\u0009do\n\u0009\u0009{\n\u0009\u0009\u0009if ((z = ::write(o, buf.get() + w, r - w)) < 0)\n\u0009\u0009\u0009{\n\u0009\u0009\u0009\u0009r = z;\n\u0009\u0009\u0009\u0009break;\n\u0009\u0009\u0009}\n\u0009\u0009\u0009w += z;\n\u0009\u0009} while (w < r);\n\u0009}\n\u0009if (::close(i) < 0)\n\u0009\u0009r = -1;\n\u0009if (::close(o) < 0)\n\u0009\u0009r = -1;\n\u0009delete[] buf;\n\u0009return r >= 0;\n}\nstatic bool moveFile_(const char16_t* d, const char16_t* s)\n{\n\u0009std::u16string s1 = d;\n\u0009const std::string& t1 = utf16ToUtf8_(s1);\n\u0009std::u16string s2 = s;\n\u0009const std::string& t2 = utf16ToUtf8_(s2);\n\u0009return ::rename(t2.c_str(), t1.c_str()) == 0;\n}\n\n#   define BOOST_COPY_FILE(F,T,FailIfExistsBool)\n#   define BOOST_MOVE_FILE(OLD,NEW)()\n#endif\n\ntemplate<typename T>\nstatic size_t bufLen_() noexcept { return 0; }\ntemplate<>\nstatic size_t bufLen_<char16_t>() noexcept { return 1; }\n\ntemplate<typename T>\nstatic void* newArrayRec_(int64_t n, int64_t x, const int64_t* b) noexcept\n{\n\u0009if (x == n - 1)\n\u0009{\n\u0009\u0009Array_<T>* r = new Array_<T>();\n\u0009\u0009r->L = b[x];\n\u0009\u0009size_t s = static_cast<size_t>(b[x] + bufLen_<T>());\n\u0009\u0009r->B = new T[s];\n\u0009\u0009memset(r->B, 0, sizeof(T) * s);\n\u0009\u0009return r;\n\u0009}\n\u0009{\n\u0009\u0009Array_<void*>* r = new Array_<void*>();\n\u0009\u0009r->L = b[x];\n\u0009\u0009r->B = reinterpret_cast<void**>(new T[static_cast<size_t>(b[x])]);\n\u0009\u0009for (int64_t i = 0; i < b[x]; i++)\n\u0009\u0009\u0009r->B[i] = newArrayRec_<T>(n, x + 1, b);\n\u0009\u0009return r;\n\u0009}\n}\n\ntemplate<typename T, typename R>\nstatic R newArray_(int64_t n, ...) noexcept\n{\n\u0009if (n > 64)\n\u0009\u0009return nullptr;\n\u0009int64_t b[64];\n\u0009va_list l;\n\u0009va_start(l, n);\n\u0009for (int64_t i = 0; i < n; i++)\n\u0009{\n\u0009\u0009b[i] = va_arg(l, int64_t);\n\u0009}\n\u0009va_end(l);\n\u0009return static_cast<R>(newArrayRec_<T>(n, 0, b));\n}\n\ntemplate<typename T>\nstatic Array_<T>* copy_(Array_<T>* t) noexcept\n{\n\u0009if (t == nullptr)\n\u0009\u0009return nullptr;\n\u0009Array_<T>* r = new Array_<T>();\n\u0009r->L = t->L;\n\u0009r->B = new T[static_cast<size_t>(t->L) + bufLen_<T>()];\n\u0009for (int64_t i = 0; i < t->L + static_cast<int64_t>(bufLen_<T>()); i++)\n\u0009\u0009r->B[i] = copy_(t->B[i]);\n\u0009return r;\n}\ntemplate<typename T>\nstatic List_<T>* copy_(List_<T>* t) noexcept\n{\n\u0009if (t == nullptr)\n\u0009\u0009return nullptr;\n\u0009// TODO:\n\u0009return nullptr;\n}\ntemplate<typename T>\nstatic Stack_<T>* copy_(Stack_<T>* t) noexcept\n{\n\u0009if (t == nullptr)\n\u0009\u0009return nullptr;\n\u0009// TODO:\n\u0009return nullptr;\n}\ntemplate<typename T>\nstatic Queue_<T>* copy_(Queue_<T>* t) noexcept\n{\n\u0009if (t == nullptr)\n\u0009\u0009return nullptr;\n\u0009// TODO:\n\u0009return nullptr;\n}\ntemplate<typename T1, typename T2>\nstatic Dict_<T1, T2>* copy_(Dict_<T1, T2>* t) noexcept\n{\n\u0009if (t == nullptr)\n\u0009\u0009return nullptr;\n\u0009// TODO:\n\u0009return nullptr;\n}\ntemplate<typename T>\nstatic T* copy_(T* t) noexcept\n{\n\u0009if (t == nullptr)\n\u0009\u0009return nullptr;\n\u0009return static_cast<T*>((new T())->copy_(t));\n}\nstatic int64_t copy_(int64_t t) noexcept { return t; }\nstatic char16_t copy_(char16_t t) noexcept { return t; }\nstatic bool copy_(bool t) noexcept { return t; }\nstatic double copy_(double t) noexcept { return t; }\nstatic uint8_t copy_(uint8_t t) noexcept { return t; }\nstatic uint16_t copy_(uint16_t t) noexcept { return t; }\nstatic uint32_t copy_(uint32_t t) noexcept { return t; }\nstatic uint64_t copy_(uint64_t t) noexcept { return t; }\n\nclass Ref_\n{\npublic:\n\u0009Ref_() noexcept : R(0LL)\n\u0009{\n\u0009}\n\n\u0009bool EqAddr(const Ref_* t) noexcept\n\u0009{\n\u0009\u0009return this == t;\n\u0009}\n\n\u0009int64_t R;\n};\n\ntemplate<typename T>\nclass Array_ : public Ref_\n{\npublic:\n\u0009Array_() noexcept : Ref_(), L(), B()\n\u0009{\n\u0009}\n\n\u0009explicit Array_(int64_t n, ...) noexcept : Ref_()\n\u0009{\n\u0009\u0009L = n;\n\u0009\u0009B = new T[static_cast<size_t>(n + bufLen_<T>())];\n\u0009\u0009va_list l;\n\u0009\u0009va_start(l, n);\n\u0009\u0009for (int64_t i = 0; i < n; i++)\n\u0009\u0009{\n\u0009\u0009\u0009B[i] = va_arg(l, T);\n\u0009\u0009}\n\u0009\u0009va_end(l);\n\u0009\u0009if (bufLen_<T>() > 0)\n\u0009\u0009\u0009B[n] = 0;\n\u0009}\n\n\u0009Array_<T>* Cat(const Array_<T>* t) noexcept\n\u0009{\n\u0009\u0009Array_<T>* r = new Array_<T>();\n\u0009\u0009r->B = new T[static_cast<size_t>(L + t->L + bufLen_<T>())];\n\u0009\u0009memcpy(r->B, B, sizeof(T) * static_cast<size_t>(L));\n\u0009\u0009memcpy(r->B + L, t->B, sizeof(T) * static_cast<size_t>(t->L + bufLen_<T>()));\n\u0009\u0009r->L = L + t->L;\n\u0009\u0009return r;\n\u0009}\n\n\u0009int64_t Len() noexcept\n\u0009{\n\u0009\u0009return L;\n\u0009}\n\n\u0009T& At(int64_t n) noexcept\n\u0009{\n\u0009\u0009return B[n];\n\u0009}\n\n\u0009bool operator<(const Ref_& t) const\n\u0009{\n\u0009\u0009return cmp_<Array_<T>*>(this, &t);\n\u0009}\n\n\u0009int64_t L;\n\u0009T* B;\n};\n\ntemplate<typename T>\nclass List_ : public Ref_\n{\npublic:\n\u0009List_() noexcept : Ref_(), B(), I(B.end())\n\u0009{\n\u0009}\n\n\u0009int64_t Len() noexcept\n\u0009{\n\u0009\u0009return static_cast<int64_t>(B.size());\n\u0009}\n\n\u0009std::list<T> B;\n\u0009typename std::list<T>::iterator I;\n};\n\ntemplate<typename T>\nclass Stack_ : public Ref_\n{\npublic:\n\u0009Stack_() noexcept : Ref_(), B()\n\u0009{\n\u0009}\n\n\u0009int64_t Len() noexcept\n\u0009{\n\u0009\u0009return static_cast<int64_t>(B.size());\n\u0009}\n\n\u0009std::stack<T> B;\n};\n\ntemplate<typename T>\nclass Queue_ : public Ref_\n{\npublic:\n\u0009Queue_() noexcept : Ref_(), B()\n\u0009{\n\u0009}\n\n\u0009int64_t Len() noexcept\n\u0009{\n\u0009\u0009return static_cast<int64_t>(B.size());\n\u0009}\n\n\u0009std::queue<T> B;\n};\n\ntemplate<typename T1, typename T2>\nclass Dict_ : public Ref_\n{\npublic:\n\u0009Dict_() noexcept : Ref_(), L(0LL), B(nullptr)\n\u0009{\n\u0009}\n\n\u0009int64_t Len() noexcept\n\u0009{\n\u0009\u0009return L;\n\u0009}\n\n\u0009void Add(T1 k, T2 v) noexcept\n\u0009{\n\u0009\u0009bool a;\n\u0009\u0009B = dictAdd_<T1, T2>(B, k, v, &a);\n\u0009\u0009if (a)\n\u0009\u0009\u0009L++;\n\u0009}\n\n\u0009int64_t L;\n\u0009dictImpl_<T1, T2>* B;\n};\n\nclass Class_ : public Ref_\n{\npublic:\n\u0009Class_() noexcept : Ref_(), Y(0LL)\n\u0009{\n\u0009}\n\n\u0009virtual int64_t cmp_(Class_* t) = 0;\n\n\u0009virtual Class_* copy_(Class_* t) = 0;\n\n\u0009int64_t Y;\n};\n\nstatic Array_<char16_t>* toStr_(int64_t v)\n{\n\u0009std::stringstream s;\n\u0009s << v;\n\u0009const std::string& t = s.str();\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(char16_t v)\n{\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(1);\n\u0009r->B = new char16_t[2];\n\u0009r->B[0] = v;\n\u0009r->B[1] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(bool v)\n{\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009if (v)\n\u0009{\n\u0009\u0009r->L = static_cast<int64_t>(4);\n\u0009\u0009r->B = new char16_t[5];\n\u0009\u0009r->B[0] = \'t\';\n\u0009\u0009r->B[1] = \'r\';\n\u0009\u0009r->B[2] = \'u\';\n\u0009\u0009r->B[3] = \'e\';\n\u0009\u0009r->B[4] = 0;\n\u0009}\n\u0009else\n\u0009{\n\u0009\u0009r->L = static_cast<int64_t>(5);\n\u0009\u0009r->B = new char16_t[6];\n\u0009\u0009r->B[0] = \'f\';\n\u0009\u0009r->B[1] = \'a\';\n\u0009\u0009r->B[2] = \'l\';\n\u0009\u0009r->B[3] = \'s\';\n\u0009\u0009r->B[4] = \'e\';\n\u0009\u0009r->B[5] = 0;\n\u0009}\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(double v)\n{\n\u0009std::stringstream s;\n\u0009s << v;\n\u0009const std::string& t = s.str();\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(uint8_t v)\n{\n\u0009std::stringstream s;\n\u0009s << \"0x\" << std::uppercase << std::setfill(\'0\') << std::setw(2) << std::hex << static_cast<uint16_t>(v);\n\u0009const std::string& t = s.str();\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(uint16_t v)\n{\n\u0009std::stringstream s;\n\u0009s << \"0x\" << std::uppercase << std::setfill(\'0\') << std::setw(4) << std::hex << v;\n\u0009const std::string& t = s.str();\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(uint32_t v)\n{\n\u0009std::stringstream s;\n\u0009s << \"0x\" << std::uppercase << std::setfill(\'0\') << std::setw(8) << std::hex << v;\n\u0009const std::string& t = s.str();\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(uint64_t v)\n{\n\u0009std::stringstream s;\n\u0009s << \"0x\" << std::uppercase << std::setfill(\'0\') << std::setw(16) << std::hex << v;\n\u0009const std::string& t = s.str();\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\nstatic Array_<char16_t>* toStr_(Array_<char16_t>* v)\n{\n\u0009std::u16string s = v->B;\n\u0009const std::string& t = utf16ToUtf8_(s);\n\u0009Array_<char16_t>* r = new Array_<char16_t>();\n\u0009r->L = static_cast<int64_t>(t.size());\n\u0009r->B = new char16_t[t.size() + 1];\n\u0009int64_t p = 0;\n\u0009for (char c : t)\n\u0009\u0009r->B[p++] = c;\n\u0009r->B[t.size()] = 0;\n\u0009return r;\n}\n\nstatic int64_t cmp_(Array_<char16_t>* a, Array_<char16_t>* b)\n{\n\u0009int64_t p = 0;\n\u0009while (p < a->L && p < b->L)\n\u0009{\n\u0009\u0009if (a->B[p] != b->B[p])\n\u0009\u0009\u0009return a->B[p] > b->B[p] ? 1 : (a->B[p] < b->B[p] ? -1 : 0);\n\u0009\u0009p++;\n\u0009}\n\u0009return a->L > b->L ? 1 : (a->L < b->L ? -1 : 0);\n}\nstatic int64_t cmp_(Class_* a, Class_* b) noexcept\n{\n\u0009return a->cmp_(b);\n}\nstatic int64_t cmp_(int64_t a, int64_t b) noexcept { return a - b; }\nstatic int64_t cmp_(char16_t a, char16_t b) noexcept { return static_cast<int64_t>(a) - static_cast<int64_t>(b); }\nstatic int64_t cmp_(double a, double b) noexcept { return a > b ? 1LL : (a < b ? -1LL : 0LL); }\nstatic int64_t cmp_(uint8_t a, uint8_t b) noexcept { return static_cast<int64_t>(a) - static_cast<int64_t>(b); }\nstatic int64_t cmp_(uint16_t a, uint16_t b) noexcept { return static_cast<int64_t>(a) - static_cast<int64_t>(b); }\nstatic int64_t cmp_(uint32_t a, uint32_t b) noexcept { return static_cast<int64_t>(a) - static_cast<int64_t>(b); }\nstatic int64_t cmp_(uint64_t a, uint64_t b) noexcept { return a > b ? 1LL : (a < b ? -1LL : 0LL); }\n\ntemplate<typename T>\nstatic Array_<uint8_t>* toBin_(T t)\n{\n\u0009// TODO:\n\u0009return nullptr;\n}\n\ntemplate<typename T>\nstatic T fromBin_(Array_<uint8_t>* t, int64_t o)\n{\n\u0009// TODO:\n\u0009return (T)0;\n}\n\ntemplate<typename T>\nstatic Array_<T>* sub_(Array_<T>* a, int64_t start, int64_t len)\n{\n\u0009if (len == -1)\n\u0009\u0009len = a->L - start;\n\u0009if (start < 0 || len < 0 || start + len > a->L)\n\u0009\u0009return nullptr;\n\u0009Array_<T>* r = new Array_<T>();\n\u0009r->L = len;\n\u0009r->B = new T[static_cast<size_t>(len + bufLen_<T>())];\n\u0009for (int64_t i = 0; i < len; i++)\n\u0009\u0009r->B[i] = a->B[start + i];\n\u0009if (bufLen_<T>() > 0)\n\u0009\u0009r->B[len] = 0;\n\u0009return r;\n}\n\ntemplate<typename T>\nstatic T* as_(const int64_t* y, Class_* c, int64_t o) noexcept\n{\n\u0009if (c == nullptr)\n\u0009\u0009return nullptr;\n\u0009int64_t m = c->Y;\n\u0009for (; ; )\n\u0009{\n\u0009\u0009if (m == o)\n\u0009\u0009\u0009return reinterpret_cast<T*>(c);\n\u0009\u0009if (m == 0)\n\u0009\u0009\u0009return nullptr;\n\u0009\u0009m = y[m];\n\u0009}\n}\n\nstatic bool is_(const int64_t* y, Class_* c, int64_t o) noexcept\n{\n\u0009int64_t m = c->Y;\n\u0009for (; ; )\n\u0009{\n\u0009\u0009if (m == o)\n\u0009\u0009\u0009return true;\n\u0009\u0009if (m == 0)\n\u0009\u0009\u0009return false;\n\u0009\u0009m = y[m];\n\u0009}\n}\n\nstatic bool eqAddr_(const Ref_* a, const Ref_* b) noexcept\n{\n\u0009return a == b;\n}\n\nstatic uint32_t rX_, rY_, rZ_, rW_;\n\nstatic uint32_t xs128_() noexcept\n{\n\u0009uint32_t t = rX_ ^ (rX_ << 11);\n\u0009rX_ = rY_;\n\u0009rY_ = rZ_;\n\u0009rZ_ = rW_;\n\u0009return rW_ = (rW_ ^ (rW_ >> 19)) ^ (t ^ (t >> 8));\n}\n\nstatic int64_t rnd_(int64_t a, int64_t b) noexcept\n{\n\u0009uint64_t n = (uint64_t)(b - a + 1);\n\u0009uint64_t m = 0 - ((0 - n) % n);\n\u0009uint64_t r;\n\u0009if (m == 0)\n\u0009\u0009r = (static_cast<uint64_t>(xs128_()) << 32) | static_cast<uint64_t>(xs128_());\n\u0009else\n\u0009{\n\u0009\u0009do\n\u0009\u0009{\n\u0009\u0009\u0009r = (static_cast<uint64_t>(xs128_()) << 32) | static_cast<uint64_t>(xs128_());\n\u0009\u0009} while (m <= r);\n\u0009}\n\u0009return static_cast<int64_t>(r % n) + a;\n}\n\nstatic double rndFloat_(double a, double b) noexcept\n{\n\u0009return (double)((static_cast<uint64_t>(xs128_()) << 32) | static_cast<uint64_t>(xs128_())) / 18446744073709551616.0 * (b - a) + a;\n}\n\ntemplate<typename T1, typename T2>\nclass dictImpl_\n{\npublic:\n\u0009dictImpl_(T1 k, T2 v) noexcept : K(k), V(v), CL(nullptr), CR(nullptr), R(true)\n\u0009{\n\u0009}\n\n\u0009T1 K;\n\u0009T2 V;\n\u0009dictImpl_* CL;\n\u0009dictImpl_* CR;\n\u0009bool R;\n};\n\ntemplate<typename T1, typename T2>\nstatic dictImpl_<T1, T2>* dictAdd_(dictImpl_<T1, T2>* r, T1 k, T2 v, bool* a) noexcept\n{\n\u0009*a = false;\n\u0009dictImpl_<T1, T2>* n = dictAddRec_(r, k, v, a);\n\u0009n->R = false;\n\u0009return n;\n}\n\ntemplate<typename T1, typename T2>\nstatic T2 dictSearch_(dictImpl_<T1, T2>* r, T1 k, bool* f) noexcept\n{\n\u0009dictImpl_<T1, T2>* n = r;\n\u0009while (n != nullptr)\n\u0009{\n\u0009\u0009int64_t c = cmp_(k, n->K);\n\u0009\u0009if (c == 0)\n\u0009\u0009{\n\u0009\u0009\u0009*f = true;\n\u0009\u0009\u0009return n->V;\n\u0009\u0009}\n\u0009\u0009if (c < 0)\n\u0009\u0009\u0009n = n->CL;\n\u0009\u0009else\n\u0009\u0009\u0009n = n->CR;\n\u0009}\n\u0009*f = false;\n\u0009return (T2)0;\n}\n\ntemplate<typename T1, typename T2>\nstatic bool dictForEach_(dictImpl_<T1, T2>* r, bool(*f)(T1, T2, Class_*), Class_* p)\n{\n\u0009if (r == nullptr)\n\u0009\u0009return true;\n\u0009if (!dictForEach_<T1, T2>(r->CL, f, p))\n\u0009\u0009return false;\n\u0009if (!f(r->K, r->V, p))\n\u0009\u0009return false;\n\u0009if (!dictForEach_<T1, T2>(r->CR, f, p))\n\u0009\u0009return false;\n\u0009return true;\n}\n\ntemplate<typename T1, typename T2>\nstatic dictImpl_<T1, T2>* dictAddRec_(dictImpl_<T1, T2>* n, T1 k, T2 v, bool* a) noexcept\n{\n\u0009if (n == nullptr)\n\u0009{\n\u0009\u0009*a = true;\n\u0009\u0009return new dictImpl_<T1, T2>(k, v);\n\u0009}\n\u0009{\n\u0009\u0009int64_t c = cmp_(k, n->K);\n\u0009\u0009if (c == 0)\n\u0009\u0009{\n\u0009\u0009\u0009n->V = v;\n\u0009\u0009\u0009return n;\n\u0009\u0009}\n\u0009\u0009if (c < 0)\n\u0009\u0009\u0009n->CL = dictAddRec_<T1, T2>(n->CL, k, v, a);\n\u0009\u0009else\n\u0009\u0009\u0009n->CR = dictAddRec_<T1, T2>(n->CR, k, v, a);\n\u0009}\n\u0009if (n->CR != nullptr && n->CR->R)\n\u0009{\n\u0009\u0009dictImpl_<T1, T2>* r = n->CR;\n\u0009\u0009n->CR = r->CL;\n\u0009\u0009r->CL = n;\n\u0009\u0009r->R = n->R;\n\u0009\u0009n->R = true;\n\u0009\u0009n = r;\n\u0009}\n\u0009if (n->CL != nullptr && n->CL->R && n->CL->CL != nullptr && n->CL->CL->R)\n\u0009{\n\u0009\u0009dictImpl_<T1, T2>* l = n->CL;\n\u0009\u0009n->CL = l->CR;\n\u0009\u0009l->CR = n;\n\u0009\u0009l->R = n->R;\n\u0009\u0009n->R = true;\n\u0009\u0009n = l;\n\u0009\u0009n->R = true;\n\u0009\u0009n->CL->R = false;\n\u0009\u0009n->CR->R = false;\n\u0009}\n\u0009return n;\n}\n\nstatic int64_t powI_(int64_t a, int64_t b) noexcept\n{\n\u0009switch (b)\n\u0009{\n\u0009case 0LL:\n\u0009\u0009return 1LL;\n\u0009case 1LL:\n\u0009\u0009return a;\n\u0009case 2LL:\n\u0009\u0009return a * a;\n\u0009}\n\u0009if (a == 1LL)\n\u0009\u0009return 1LL;\n\u0009if (a == -1LL)\n\u0009\u0009return std::abs(b) % 2LL == 0LL ? 1LL : -1LL;\n\u0009if (b < 0LL)\n\u0009\u0009return 0LL;\n\u0009int64_t r = 1LL;\n\u0009for (; ; )\n\u0009{\n\u0009\u0009if ((b & 1LL) == 1LL)\n\u0009\u0009\u0009r *= a;\n\u0009\u0009b >>= 1LL;\n\u0009\u0009if (b == 0LL)\n\u0009\u0009\u0009break;\n\u0009\u0009a *= a;\n\u0009}\n\u0009return r;\n}\n\nclass reader_\n{\npublic:\n\u0009reader_() noexcept : F(new std::ifstream())\n\u0009{\n\u0009}\n\n\u0009std::ifstream* F;\n};\n\nclass writer_\n{\npublic:\n\u0009writer_() noexcept : F(new std::ofstream())\n\u0009{\n\u0009}\n\n\u0009std::ofstream* F;\n};\n\nstatic char16_t readUtf8_(std::ifstream* f)\n{\n\u0009char c;\n\u0009int64_t l;\n\u0009uint64_t u;\n\u0009if (!f->get(c))\n\u0009\u0009return 0xffff;\n\u0009if ((c & 0xc0) == 0x80)\n\u0009\u0009return 0xffff;\n\u0009if ((c & 0x80) == 0x00)\n\u0009\u0009l = 0;\n\u0009else if ((c & 0xe0) == 0xc0)\n\u0009\u0009l = 1, c &= 0x1f;\n\u0009else if ((c & 0xf0) == 0xe0)\n\u0009\u0009l = 2, c &= 0x0f;\n\u0009else if ((c & 0xf8) == 0xf0)\n\u0009\u0009l = 3, c &= 0x07;\n\u0009else if ((c & 0xfc) == 0xf8)\n\u0009\u0009l = 4, c &= 0x03;\n\u0009else if ((c & 0xfe) == 0xfc)\n\u0009\u0009l = 5, c &= 0x01;\n\u0009else\n\u0009\u0009return 0xffff;\n\u0009u = static_cast<uint64_t>(c);\n\u0009for (int64_t i = 0; i < l; i++)\n\u0009{\n\u0009\u0009if (!f->get(c) || (c & 0xc0) != 0x80)\n\u0009\u0009\u0009return 0xffff;\n\u0009\u0009u = (u << 6) | static_cast<uint64_t>(c & 0x3f);\n\u0009}\n\u0009if (0x00010000 <= u && u <= 0x0010ffff)\n\u0009\u0009u = 0x20;\n\u0009return static_cast<char16_t>(u);\n}\n\nstatic void writeUtf8_(std::ofstream* f, char16_t c)\n{\n\u0009uint64_t u;\n\u0009size_t size;\n\u0009if ((c >> 7) == 0)\n\u0009\u0009u = c, size = 1;\n\u0009else\n\u0009{\n\u0009\u0009u = static_cast<uint64_t>(0x80 | (c & 0x3f)) << 8;\n\u0009\u0009c >>= 6;\n\u0009\u0009if ((c >> 5) == 0)\n\u0009\u0009\u0009u |= 0xc0 | c, size = 2;\n\u0009\u0009else\n\u0009\u0009{\n\u0009\u0009\u0009u = (u | 0x80 | (c & 0x3f)) << 8;\n\u0009\u0009\u0009c >>= 6;\n\u0009\u0009\u0009if ((c >> 4) == 0)\n\u0009\u0009\u0009\u0009u |= 0xe0 | c, size = 3;\n\u0009\u0009\u0009else\n\u0009\u0009\u0009{\n\u0009\u0009\u0009\u0009u = (u | 0x80 | (c & 0x3f)) << 8;\n\u0009\u0009\u0009\u0009c >>= 6;\n\u0009\u0009\u0009\u0009if ((c >> 3) == 0)\n\u0009\u0009\u0009\u0009\u0009u |= 0xf0 | c, size = 4;\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009{\n\u0009\u0009\u0009\u0009\u0009u = (u | 0x80 | (c & 0x3f)) << 8;\n\u0009\u0009\u0009\u0009\u0009c >>= 6;\n\u0009\u0009\u0009\u0009\u0009if ((c >> 2) == 0)\n\u0009\u0009\u0009\u0009\u0009\u0009u |= 0xf8 | c, size = 5;\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009{\n\u0009\u0009\u0009\u0009\u0009\u0009u = (u | 0x80 | (c & 0x3f)) << 8;\n\u0009\u0009\u0009\u0009\u0009\u0009c >>= 6;\n\u0009\u0009\u0009\u0009\u0009\u0009if ((c >> 1) == 0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009u |= 0xfc | c, size = 6;\n\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009return;\n\u0009\u0009\u0009\u0009\u0009}\n\u0009\u0009\u0009\u0009}\n\u0009\u0009\u0009}\n\u0009\u0009}\n\u0009}\n\u0009if (size == 1 && u == 0x0a)\n\u0009\u0009f->write(newLine_, static_cast<std::streamsize>(sizeof(newLine_)));\n\u0009else\n\u0009\u0009f->write(reinterpret_cast<char*>(&u), static_cast<std::streamsize>(size));\n}\n\nstatic void init_()\n{\n\u0009uint32_t t = static_cast<uint32_t>(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());\n\u0009rX_ = 123456789;\n\u0009rY_ = 362436069;\n\u0009rZ_ = 521288629 * t;\n\u0009rW_ = 88675123 * (rZ_ >> 1);\n}\n":true;
else if(p==="res/sys/cui.kn")
return f?"func [d0002.knd, _init] _init()\nend func\n\nfunc [d0002.knd] _fin()\nend func\n\n+func [d0002.knd, _delimiter] delimiter(delimiters: []char)\nend func\n\n+func [__raw, cui_print] print(str: []char)\nend func\n\n+func [d0002.knd, _inputLetter] inputLetter(): char\nend func\n\n+func [d0002.knd, _inputInt] inputInt(): int\nend func\n\n+func [d0002.knd, _inputFloat] inputFloat(): float\nend func\n\n+func [d0002.knd, _inputChar] inputChar(): char\nend func\n\n+func [d0002.knd, _inputStr] inputStr(): []char\nend func\n\n+func [d0002.knd, _input] input(): []char\nend func\n":true;
else if(p==="res/sys/dbg.kn")
return f?"+func [d0000.knd, _dbgPrint] print(str: []char)\nend func\n":true;
else if(p==="res/sys/excpt.kn")
return f?"+const userMin: int :: 0x00000001\n+const userMax: int :: 0x0000FFFF\n+const accessViolation: int :: 0xC0000005\n+const noMem: int :: 0xC0000017\n+const floatInvalidOperation: int :: 0xC0000090\n+const intDivideByZero: int :: 0xC0000094\n+const stackOverflow: int :: 0xC00000FD\n+const ctrlCExit: int :: 0xC000013A\n+const dbgAssertFailed: int :: 0xE9170000\n+const classCastFailed: int :: 0xE9170001\n+const dbgArrayIdxOutOfRange: int :: 0xE9170002\n+const dbgIntOverflow: int :: 0xE9170003\n+const invalidCmp: int :: 0xE9170004\n+const dbgArgOutDomain: int :: 0xE9170006\n+const fileReadFailed: int :: 0xE9170007\n+const invalidDataFmt: int :: 0xE9170008\n+const deviceInitFailed: int :: 0xE9170009\n+const dbgInoperableState: int :: 0xE917000A\n":true;
else if(p==="res/sys/file.kn")
return f?"+enum Origin\n\u0009head\n\u0009cur\n\u0009tail\nend enum\n\n+class Reader()\n\u0009*func [d0000.knd, _readerDtor, __frc] _dtor()\n\u0009end func\n\n\u0009+func [__raw, file_readerFin] fin()\n\u0009end func\n\n\u0009+func [__raw, file_readerSetPos] setPos(origin: @Origin, pos: int)\n\u0009end func\n\n\u0009+func [__raw, file_readerGetPos] getPos(): int\n\u0009end func\n\n\u0009+func [d0000.knd, _readerDelimiter] delimiter(delimiters: []char)\n\u0009end func\n\n\u0009+func [d0000.knd, _readerRead] read(size: int): []bit8\n\u0009end func\n\n\u0009+func [__raw, file_readerReadLetter] readLetter(): char\n\u0009end func\n\n\u0009+func [d0000.knd, _readerReadInt] readInt(): int\n\u0009end func\n\n\u0009+func [d0000.knd, _readerReadFloat] readFloat(): float\n\u0009end func\n\n\u0009+func [d0000.knd, _readerReadChar] readChar(): char\n\u0009end func\n\n\u0009+func [d0000.knd, _readerReadStr] readStr(): []char\n\u0009end func\n\n\u0009+func readLine(): []char\n\u0009\u0009var buf: []char :: \"\"\n\u0009\u0009while loop(!me.term())\n\u0009\u0009\u0009var c: char :: me.readLetter()\n\u0009\u0009\u0009if(c = \'\\u000D\')\n\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(c = \'\\n\')\n\u0009\u0009\u0009\u0009break loop\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do buf :~ c.toStr()\n\u0009\u0009end while\n\u0009\u0009ret buf\n\u0009end func\n\n\u0009+func [d0000.knd, _readerFileSize] fileSize(): int\n\u0009end func\n\n\u0009+func [__raw, file_readerTerm] term(): bool\n\u0009end func\n\n\u0009var handle: int\n\u0009var delimiterNum: int\n\u0009var delimiters: int\n\u0009var fileSize_: int\nend class\n\n+class Writer()\n\u0009*func [d0000.knd, _writerDtor, __frc] _dtor()\n\u0009end func\n\n\u0009+func [__raw, file_writerFin] fin()\n\u0009end func\n\n\u0009+func [__raw, file_writerSetPos] setPos(origin: @Origin, pos: int)\n\u0009end func\n\n\u0009+func [__raw, file_writerGetPos] getPos(): int\n\u0009end func\n\n\u0009+func [__raw, file_writerWrite] write(bin: []bit8)\n\u0009end func\n\n\u0009+func writeInt(n: int)\n\u0009\u0009var s: []char :: n.toStr()\n\u0009\u0009for i(0, ^s - 1)\n\u0009\u0009\u0009do me.writeChar(s[i])\n\u0009\u0009end for\n\u0009end func\n\n\u0009+func writeFloat(n: float)\n\u0009\u0009var s: []char :: n.toStr()\n\u0009\u0009for i(0, ^s - 1)\n\u0009\u0009\u0009do me.writeChar(s[i])\n\u0009\u0009end for\n\u0009end func\n\n\u0009+func [__raw, file_writerWriteChar] writeChar(n: char)\n\u0009end func\n\n\u0009+func writeStr(n: []char)\n\u0009\u0009for i(0, ^n - 1)\n\u0009\u0009\u0009do me.writeChar(n[i])\n\u0009\u0009end for\n\u0009end func\n\n\u0009var handle: int\nend class\n\n+func [__mki, __raw, file_makeReader] makeReader(me2: @Reader, path: []char): @Reader\nend func\n\n+func [__mki, __raw, file_makeWriter] makeWriter(me2: @Writer, path: []char, append: bool): @Writer\nend func\n\n+enum SysDir\n\u0009desktop :: 0x00\n\u0009fonts :: 0x14\n\u0009appData :: 0x1A\n\u0009windows :: 0x24\n\u0009system32 :: 0x25\n\u0009programFiles :: 0x26\nend enum\n\n+func [d0000.knd, _makeDir] makeDir(path: []char): bool\nend func\n\n+func [__raw, file_forEach] forEach(path: []char, recursion: bool, callback: func<([]char, bool, kuin@Class): bool>, data: kuin@Class): bool\nend func\n\n+func [__raw, file_exist] exist(path: []char): bool\nend func\n\n+func [d0000.knd, _delDir] delDir(path: []char): bool\nend func\n\n+func [d0000.knd, _delFile] delFile(path: []char): bool\nend func\n\n+func [d0000.knd, _copyDir] copyDir(dst: []char, src: []char): bool\nend func\n\n+func [__raw, file_copyFile] copyFile(dst: []char, src: []char): bool\nend func\n\n+func [d0000.knd, _moveDir] moveDir(dst: []char, src: []char): bool\nend func\n\n+func [d0000.knd, _moveFile] moveFile(dst: []char, src: []char): bool\nend func\n\n+func dir(path: []char): []char\n\u0009assert path <>& null\n\u0009var p: int :: ^path - 1\n\u0009while(p >= 0 & path[p] <> \'/\' & path[p] <> \'\\\\\')\n\u0009\u0009do p :- 1\n\u0009end while\n\u0009if(p < 0)\n\u0009\u0009ret \"./\"\n\u0009else\n\u0009\u0009var r: []char :: #[p + 1]char\n\u0009\u0009for i(0, p)\n\u0009\u0009\u0009do r[i] :: path[i] = \'\\\\\' ?(\'/\', path[i])\n\u0009\u0009end for\n\u0009\u0009ret r\n\u0009end if\nend func\n\n+func ext(path: []char): []char\n\u0009assert path <>& null\n\u0009var p: int :: ^path - 1\n\u0009while(p >= 0 & path[p] <> \'/\' & path[p] <> \'\\\\\' & path[p] <> \'.\')\n\u0009\u0009do p :- 1\n\u0009end while\n\u0009if(path[p] <> \'.\')\n\u0009\u0009ret \"\"\n\u0009else\n\u0009\u0009do p :+ 1\n\u0009\u0009var r: []char :: #[^path - p]char\n\u0009\u0009for i(0, ^path - p - 1)\n\u0009\u0009\u0009do r[i] :: path[p + i]\n\u0009\u0009end for\n\u0009\u0009ret r\n\u0009end if\nend func\n\n+func fileName(path: []char): []char\n\u0009assert path <>& null\n\u0009var p: int :: ^path - 1\n\u0009while(p >= 0 & path[p] <> \'/\' & path[p] <> \'\\\\\')\n\u0009\u0009do p :- 1\n\u0009end while\n\u0009if(p < 0)\n\u0009\u0009ret path\n\u0009end if\n\u0009do p :+ 1\n\u0009var r: []char :: #[^path - p]char\n\u0009for i(0, ^path - p - 1)\n\u0009\u0009do r[i] :: path[p + i]\n\u0009end for\n\u0009ret r\nend func\n\n+func [d0000.knd, _fullPath] fullPath(path: []char): []char\nend func\n\n+func delExt(path: []char): []char\n\u0009assert path <>& null\n\u0009var p: int :: ^path - 1\n\u0009while(p >= 0 & path[p] <> \'/\' & path[p] <> \'\\\\\' & path[p] <> \'.\')\n\u0009\u0009do p :- 1\n\u0009end while\n\u0009if(p < 0 | path[p] <> \'.\')\n\u0009\u0009ret path\n\u0009end if\n\u0009var r: []char :: #[p]char\n\u0009for i(0, p - 1)\n\u0009\u0009do r[i] :: path[i] = \'\\\\\' ?(\'/\', path[i])\n\u0009end for\n\u0009ret r\nend func\n\n+func [d0000.knd, _sysDir] sysDir(kind: @SysDir): []char\nend func\n\n+func [d0000.knd, _exeDir] exeDir(): []char\nend func\n\n+func [d0000.knd, _fileSize] fileSize(path: []char): int\nend func\n\n+func [d0000.knd, _setCurDir] setCurDir(path: []char)\nend func\n\n+func [d0000.knd, _getCurDir] getCurDir(): []char\nend func\n":true;
else if(p==="res/sys/kuin.kn")
return f?"+const envCui: bit64 :: 0b64\n+const envWnd: bit64 :: 1b64\n+const envWeb: bit64 :: 2b64\n+const envCpp: bit64 :: 3b64\n\n+class Class()\n\u0009func ctor()\n\u0009end func\n\n\u0009func _dtor()\n\u0009end func\n\n\u0009+func cmp(t: @Class): int\n\u0009\u0009throw 0xE9170004\n\u0009end func\n\n\u0009func _copy(): @Class\n\u0009end func\n\n\u0009func _toBin(): []bit8\n\u0009end func\n\n\u0009func _fromBin(bin: []bit8, idx: &int): @Class\n\u0009end func\n\n\u0009+func toStr(): []char\n\u0009\u0009ret \"\"\n\u0009end func\nend class\n\nfunc _init()\nend func\n\nfunc _fin()\nend func\n\nfunc _err(excpt: int)\nend func\n\nfunc _initVars()\nend func\n\nfunc _finVars()\nend func\n\nfunc [__any, __raw, toStr] _toStr(me_: int, type: []int): []char\nend func\n\nfunc [d0000.knd] _toStrFmtInt(me_: int, fmt: []char): []char\nend func\n\nfunc [d0000.knd] _toStrFmtFloat(me_: float, fmt: []char): []char\nend func\n\nfunc _absInt(me_: int): int\n\u0009ret me_ >= 0 ?(me_, -me_)\nend func\n\nfunc _absFloat(me_: float): float\n\u0009ret me_ >= 0.0 ?(me_, -me_)\nend func\n\nfunc _signInt(me_: int): int\n\u0009ret me_ > 0 ?(1, me_ < 0 ?(-1, 0))\nend func\n\nfunc _signFloat(me_: float): float\n\u0009ret me_ > 0.0 ?(1.0, me_ < 0.0 ?(-1.0, 0.0))\nend func\n\nfunc _clampInt(me_: int, min: int, max: int): int\n\u0009ret me_ > max ?(max, me_ < min ?(min, me_))\nend func\n\nfunc _clampFloat(me_: float, min: float, max: float): float\n\u0009ret me_ > max ?(max, me_ < min ?(min, me_))\nend func\n\nfunc _clampMinInt(me_: int, min: int): int\n\u0009ret me_ < min ?(min, me_)\nend func\n\nfunc _clampMinFloat(me_: float, min: float): float\n\u0009ret me_ < min ?(min, me_)\nend func\n\nfunc _clampMaxInt(me_: int, max: int): int\n\u0009ret me_ > max ?(max, me_)\nend func\n\nfunc _clampMaxFloat(me_: float, max: float): float\n\u0009ret me_ > max ?(max, me_)\nend func\n\nfunc _offset(me_: char, n: int): char\n\u0009ret (me_ $ bit64 + n $ bit64) $ char\nend func\n\nfunc [__any, __tme, __rme, __raw, or] _or(me_: int, type: []int, n: int): int\nend func\n\nfunc [__any, __tme, __rme, __raw, and] _and(me_: int, type: []int, n: int): int\nend func\n\nfunc [__any, __tme, __rme] _xor(me_: int, type: []int, n: int): int\nend func\n\nfunc [__any, __rme] _not(me_: int, type: []int): int\nend func\n\nfunc [__any, __rme] _shl(me_: int, type: []int, n: int): int\nend func\n\nfunc [__any, __rme] _shr(me_: int, type: []int, n: int): int\nend func\n\nfunc [__any, __rme] _sar(me_: int, type: []int, n: int): int\nend func\n\nfunc [__any, __rme] _endian(me_: int, type: []int): int\nend func\n\nfunc [__any, __rme, __raw, sub] _sub(me_: int, type: []int, start: int, len: int): int\nend func\n\nfunc [__any] _reverse(me_: int, type: []int)\nend func\n\nfunc [__any] _shuffle(me_: int, type: []int)\nend func\n\nfunc [__any] _sortArray(me_: int, type: []int)\nend func\n\nfunc [__any] _sortDescArray(me_: int, type: []int)\nend func\n\nfunc [__any] _sortList(me_: int, type: []int)\nend func\n\nfunc [__any] _sortDescList(me_: int, type: []int)\nend func\n\nfunc [__any, __tch, __raw, findArray] _findArray(me_: int, type: []int, item: int, start: int): int\nend func\n\nfunc [__any, __tch] _findList(me_: int, type: []int, item: int): bool\nend func\n\nfunc [__any, __tch] _findLastArray(me_: int, type: []int, item: int, start: int): int\nend func\n\nfunc [__any, __tch] _findLastList(me_: int, type: []int, item: int): bool\nend func\n\nfunc [__any, __tch, __raw, findBin] _findBin(me_: int, type: []int, item: int): int\nend func\n\nfunc [__any, __tch, __raw, fill] _fill(me_: int, type: []int, value: int)\nend func\n\nfunc [__any, __rch] _min(me_: int, type: []int): int\nend func\n\nfunc [__any, __rch] _max(me_: int, type: []int): int\nend func\n\nfunc [__any, __rme] _repeat(me_: int, type: []int, len: int): int\nend func\n\nfunc [__raw, toInt] _toInt(me_: []char, success: &bool): int\nend func\n\nfunc [__raw, toFloat] _toFloat(me_: []char, success: &bool): float\nend func\n\nfunc [__raw, toBit64] _toBit64(me_: []char, success: &bool): bit64\nend func\n\nfunc _lower(me_: []char): []char\n\u0009assert me_ <>& null\n\u0009for i(0, ^me_ - 1)\n\u0009\u0009if(\'A\' <= me_[i] & me_[i] <= \'Z\')\n\u0009\u0009\u0009do me_[i] :: (me_[i] $ bit64 - 0x41b64 + 0x61b64) $ char\n\u0009\u0009end if\n\u0009end for\nend func\n\nfunc _upper(me_: []char): []char\n\u0009assert me_ <>& null\n\u0009for i(0, ^me_ - 1)\n\u0009\u0009if(\'a\' <= me_[i] & me_[i] <= \'z\')\n\u0009\u0009\u0009do me_[i] :: (me_[i] $ bit64 - 0x61b64 + 0x41b64) $ char\n\u0009\u0009end if\n\u0009end for\nend func\n\nfunc _trim(me_: []char): []char\n\u0009assert me_ <>& null\n\u0009var f: int :: -1\n\u0009for i(0, ^me_ - 1)\n\u0009\u0009var c: bit64 :: me_[i] $ bit64\n\u0009\u0009if(!(0x09b64 <= c & c <= 0x0Db64 | c = 0x20b64 | c = 0xA0b64))\n\u0009\u0009\u0009do f :: i\n\u0009\u0009\u0009break i\n\u0009\u0009end if\n\u0009end for\n\u0009if(f = -1)\n\u0009\u0009ret me_\n\u0009end if\n\u0009var l: int :: -1\n\u0009for i(^me_ - 1, 0, -1)\n\u0009\u0009var c: bit64 :: me_[i] $ bit64\n\u0009\u0009if(!(0x09b64 <= c & c <= 0x0Db64 | c = 0x20b64 | c = 0xA0b64))\n\u0009\u0009\u0009do l :: i\n\u0009\u0009\u0009break i\n\u0009\u0009end if\n\u0009end for\n\u0009var r: []char :: #[l - f + 1]char\n\u0009for i(0, l - f)\n\u0009\u0009do r[i] :: me_[f + i]\n\u0009end for\n\u0009ret r\nend func\n\nfunc _trimLeft(me_: []char): []char\n\u0009assert me_ <>& null\n\u0009var f: int :: -1\n\u0009for i(0, ^me_ - 1)\n\u0009\u0009var c: bit64 :: me_[i] $ bit64\n\u0009\u0009if(!(0x09b64 <= c & c <= 0x0Db64 | c = 0x20b64 | c = 0xA0b64))\n\u0009\u0009\u0009do f :: i\n\u0009\u0009\u0009break i\n\u0009\u0009end if\n\u0009end for\n\u0009if(f = -1)\n\u0009\u0009ret me_\n\u0009end if\n\u0009var r: []char :: #[^me_ - f]char\n\u0009for i(0, ^me_ - f - 1)\n\u0009\u0009do r[i] :: me_[f + i]\n\u0009end for\n\u0009ret r\nend func\n\nfunc _trimRight(me_: []char): []char\n\u0009var l: int :: -1\n\u0009for i(^me_ - 1, 0, -1)\n\u0009\u0009var c: bit64 :: me_[i] $ bit64\n\u0009\u0009if(!(0x09b64 <= c & c <= 0x0Db64 | c = 0x20b64 | c = 0xA0b64))\n\u0009\u0009\u0009do l :: i\n\u0009\u0009\u0009break i\n\u0009\u0009end if\n\u0009end for\n\u0009if(l = -1)\n\u0009\u0009ret me_\n\u0009end if\n\u0009var r: []char :: #[l + 1]char\n\u0009for i(0, l)\n\u0009\u0009do r[i] :: me_[i]\n\u0009end for\n\u0009ret r\nend func\n\nfunc [d0000.knd] _split(me_: []char, delimiter: []char): [][]char\nend func\n\nfunc _join(me_: [][]char, delimiter: []char): []char\n\u0009var t: int :: ^delimiter * (^me_ - 1)\n\u0009for i(0, ^me_ - 1)\n\u0009\u0009do t :+ ^me_[i]\n\u0009end for\n\u0009var r: []char :: #[t]char\n\u0009var p: int :: 0\n\u0009for i(0, ^me_ - 1)\n\u0009\u0009if(i <> 0)\n\u0009\u0009\u0009for j(0, ^delimiter - 1)\n\u0009\u0009\u0009\u0009do r[p] :: delimiter[j]\n\u0009\u0009\u0009\u0009do p :+ 1\n\u0009\u0009\u0009end for\n\u0009\u0009end if\n\u0009\u0009var s: []char :: me_[i]\n\u0009\u0009for j(0, ^s - 1)\n\u0009\u0009\u0009do r[p] :: s[j]\n\u0009\u0009\u0009do p :+ 1\n\u0009\u0009end for\n\u0009end for\n\u0009ret r\nend func\n\nfunc [d0000.knd] _replace(me_: []char, old: []char, new: []char): []char\nend func\n\nfunc [d0000.knd] _findStr(me_: []char, pattern: []char, start: int): int\nend func\n\nfunc [d0000.knd] _findStrLast(me_: []char, pattern: []char, start: int): int\nend func\n\nfunc [d0000.knd] _findStrEx(me_: []char, pattern: []char, start: int, fromLast: bool, ignoreCase: bool, wholeWord: bool): int\nend func\n\nfunc [__any, __tch, __raw, addList] _addList(me_: int, type: []int, item: int)\nend func\n\nfunc [__any, __tch, __raw, addStack] _addStack(me_: int, type: []int, item: int)\nend func\n\nfunc [__any, __tch, __raw, addQueue] _addQueue(me_: int, type: []int, item: int)\nend func\n\nfunc [__any, __tkv, __raw, addDict] _addDict(me_: int, type: []int, key: int, item: int)\nend func\n\nfunc [__any, __rch, __raw, getList] _getList(me_: int, type: []int): int\nend func\n\nfunc [__any, __rch, __raw, getStack] _getStack(me_: int, type: []int): int\nend func\n\nfunc [__any, __rch, __raw, getQueue] _getQueue(me_: int, type: []int): int\nend func\n\nfunc [__any, __tch, __rch, __raw, getDict] _getDict(me_: int, type: []int, key: int, existed: &bool): int\nend func\n\nfunc [__any, __rch] _getOffset(me_: int, type: []int, offset: int): int\nend func\n\nfunc [__any, __raw, head] _head(me_: int, type: []int)\nend func\n\nfunc [__any, __raw, moveOffset] _moveOffset(me_: int, type: []int, offset: int)\nend func\n\nfunc [__any, __raw, tail] _tail(me_: int, type: []int)\nend func\n\nfunc [__any, __raw, next] _next(me_: int, type: []int)\nend func\n\nfunc [__any] _prev(me_: int, type: []int)\nend func\n\nfunc [__any, __raw, term] _term(me_: int, type: []int): bool\nend func\n\nfunc [__any] _termOffset(me_: int, type: []int, offset: int): bool\nend func\n\nfunc [__any, __raw, del] _del(me_: int, type: []int)\nend func\n\nfunc [__any] _delNext(me_: int, type: []int)\nend func\n\nfunc [__any, __tch, __raw, ins] _ins(me_: int, type: []int, item: int)\nend func\n\nfunc [__any, __rac] _toArray(me_: int, type: []int): int\nend func\n\nfunc [__any, __rak] _toArrayKey(me_: int, type: []int): int\nend func\n\nfunc [__any, __rav] _toArrayValue(me_: int, type: []int): int\nend func\n\nfunc [__any, __rch, __raw, peekQueue] _peekQueue(me_: int, type: []int): int\nend func\n\nfunc [__any, __rch, __raw, peekStack] _peekStack(me_: int, type: []int): int\nend func\n\nfunc [__any, __tch] _exist(me_: int, type: []int, key: int): bool\nend func\n\nfunc [__any, __kvf, __raw, forEach] _forEach(me_: int, type: []int, callback: int, data: @Class): bool\nend func\n\nfunc [__any, __tch] _delDict(me_: int, type: []int, key: int)\nend func\n\nfunc [__any, __raw, idx] _idx(me_: int, type: []int): int\nend func\n":true;
else if(p==="res/sys/lib.kn")
return f?"+const pi: float :: 3.14159265358979323846\n+const e: float :: 2.71828182845904523536\n+const intMin: int :: -9223372036854775807 - 1\n+const intMax: int :: 9223372036854775807\n\n+func [__raw, cmdLine] cmdLine(): [][]char\nend func\n\n+func [_exit_code] exitCode(code: int)\n\u0009if(dbg)\n\u0009\u0009if(code < 0 | 0xFFFFFFFF < code)\n\u0009\u0009\u0009throw excpt@dbgArgOutDomain\n\u0009\u0009end if\n\u0009end if\nend func\n\n+class Rnd()\n\u0009*func [d0000.knd, _rndDtor, __frc] _dtor()\n\u0009end func\n\n\u0009+func [d0000.knd, _rndRnd] rnd(min: int, max: int): int\n\u0009end func\n\n\u0009+func [d0000.knd, _rndRndFloat] rndFloat(min: float, max: float): float\n\u0009end func\n\n\u0009+func [d0000.knd, _rndRndBit64] rndBit64(): bit64\n\u0009end func\n\n\u0009var rndState: int\nend class\n\n+func [d0000.knd, _makeRnd, __mki] makeRnd(me2: @Rnd, seed: int): @Rnd\nend func\n\n+func [__raw, rnd] rnd(min: int, max: int): int\nend func\n\n+func [__raw, rndFloat] rndFloat(min: float, max: float): float\nend func\n\n+func [d0000.knd, _rndBit64] rndBit64(): bit64\nend func\n\n+func [d0000.knd, _rndUuid] rndUuid(): []char\nend func\n\n+func [d0000.knd, _cos] cos(x: float): float\nend func\n\n+func [d0000.knd, _sin] sin(x: float): float\nend func\n\n+func [d0000.knd, _tan] tan(x: float): float\nend func\n\n+func [d0000.knd, _acos] acos(x: float): float\nend func\n\n+func [d0000.knd, _asin] asin(x: float): float\nend func\n\n+func [d0000.knd, _atan] atan(x: float): float\nend func\n\n+func [d0000.knd, _cosh] cosh(x: float): float\nend func\n\n+func [d0000.knd, _sinh] sinh(x: float): float\nend func\n\n+func [d0000.knd, _tanh] tanh(x: float): float\nend func\n\n+func [d0000.knd, _acosh] acosh(x: float): float\nend func\n\n+func [d0000.knd, _asinh] asinh(x: float): float\nend func\n\n+func [d0000.knd, _atanh] atanh(x: float): float\nend func\n\n+func [d0000.knd, _sqrt] sqrt(x: float): float\nend func\n\n+func [d0000.knd, _exp] exp(x: float): float\nend func\n\n+func [d0000.knd, _ln] ln(x: float): float\nend func\n\n+func [d0000.knd, _log] log(base: float, x: float): float\nend func\n\n+func [d0000.knd, _floor] floor(x: float): float\nend func\n\n+func [d0000.knd, _ceil] ceil(x: float): float\nend func\n\n+func [d0000.knd, _round] round(x: float, precision: int): float\nend func\n\n+func [d0000.knd, _rot] rot(x: &float, y: &float, centerX: float, centerY: float, angle: float)\nend func\n\n+func [d0000.knd, _invRot] invRot(x: float, y: float, centerX: float, centerY: float): float\nend func\n\n+func [d0000.knd, _dist] dist(x: float, y: float, centerX: float, centerY: float): float\nend func\n\n+func [d0000.knd, _chase] chase(x: &float, target: float, vel: float): bool\nend func\n\n+func [d0000.knd, _same] same(n1: float, n2: float): bool\nend func\n\n+func [d0000.knd, _toRad] toRad(degree: float): float\nend func\n\n+func [d0000.knd, _toDegree] toDegree(rad: float): float\nend func\n\n+func cmp(s1: []char, s2: []char): int\n\u0009var p: int :: 0\n\u0009while(p < ^s1 & p < ^s2)\n\u0009\u0009if(s1[p] <> s2[p])\n\u0009\u0009\u0009ret s1[p] > s2[p] ?(1, s1[p] < s2[p] ?(-1, 0))\n\u0009\u0009end if\n\u0009\u0009do p :+ 1\n\u0009end while\n\u0009ret ^s1 > ^s2 ?(1, ^s1 < ^s2 ?(-1, 0))\nend func\n\n+func [d0000.knd, _cmpEx] cmpEx(s1: []char, s2: []char, len: int, ignoreCase: bool): int\nend func\n\n+func min(n1: int, n2: int): int\n\u0009ret n1 <= n2 ?(n1, n2)\nend func\n\n+func minFloat(n1: float, n2: float): float\n\u0009ret n1 <= n2 ?(n1, n2)\nend func\n\n+func max(n1: int, n2: int): int\n\u0009ret n1 >= n2 ?(n1, n2)\nend func\n\n+func maxFloat(n1: float, n2: float): float\n\u0009ret n1 >= n2 ?(n1, n2)\nend func\n\n+func [d0000.knd, _levenshtein] levenshtein(s1: []char, s2: []char): int\nend func\n\n+func [d0000.knd, _lerp] lerp(first: float, last: float, rate: float): float\nend func\n\n+func [d0000.knd, _qerp] qerp(first: float, last: float, easeIn: bool, rate: float): float\nend func\n\n+func [d0000.knd, _cerp] cerp(first: float, last: float, rate: float): float\nend func\n\n+func [d0000.knd, _hermite] hermite(pos: []float, rate: float): float\nend func\n\n+class BmSearch()\n\u0009*func [d0000.knd, _bmSearchDtor, __frc] _dtor()\n\u0009end func\n\n\u0009+func [d0000.knd, _bmSearchFind] find(text: []char, start: int): int\n\u0009end func\n\n\u0009var pattern: int\n\u0009var dists: int\n\u0009var len: int\nend class\n\n+func [d0000.knd, _makeBmSearch, __mki] makeBmSearch(me2: @BmSearch, pattern: []char): @BmSearch\nend func\n\n+func [d0000.knd, _hash] hash(data: []bit8): []bit8\nend func\n\n+func [d0000.knd, _encrypt] encrypt(data: []bit8, key: []bit8): []bit8\nend func\n\n+func [d0000.knd, _decrypt] decrypt(data: []bit8, key: []bit8): []bit8\nend func\n\n+func [__raw, sysTime] sysTime(): int\nend func\n\n+func [d0000.knd, _now] now(): int\nend func\n\n+func [d0000.knd, _intToDate] intToDate(time: int, year: &int, month: &int, day: &int, hour: &int, minute: &int, second: &int): int\nend func\n\n+func [d0000.knd, _dateToInt] dateToInt(year: int, month: int, day: int, hour: int, minute: int, second: int): int\nend func\n\n+func [d0000.knd, _intToLocalDate] intToLocalDate(time: int, year: &int, month: &int, day: &int, hour: &int, minute: &int, second: &int): int\nend func\n\n+func [d0000.knd, _localDateToInt] localDateToInt(year: int, month: int, day: int, hour: int, minute: int, second: int): int\nend func\n\n+func [d0000.knd] sleep(ms: int)\nend func\n\n+func [d0000.knd, _countUp] countUp(min: int, max: int): []int\nend func\n\n+func [__raw, addr] addr(class_: kuin@Class): bit64\nend func\n\n+class Int()\n\u0009+*func cmp(t: @Int): int\n\u0009\u0009ret (me.value - t.value).sign()\n\u0009end func\n\n\u0009+*func toStr(): []char\n\u0009\u0009ret me.value.toStr()\n\u0009end func\n\n\u0009+var value: int\nend class\n\n+class Float()\n\u0009+*func cmp(t: @Float): int\n\u0009\u0009ret (me.value - t.value).sign() $ int\n\u0009end func\n\n\u0009+*func toStr(): []char\n\u0009\u0009ret me.value.toStr()\n\u0009end func\n\n\u0009+var value: float\nend class\n\n+class Bool()\n\u0009+*func cmp(t: @Bool): int\n\u0009\u0009ret (me.value $ int - t.value $ int).sign()\n\u0009end func\n\n\u0009+*func toStr(): []char\n\u0009\u0009ret me.value.toStr()\n\u0009end func\n\n\u0009+var value: bool\nend class\n\n+class Char()\n\u0009+*func cmp(t: @Char): int\n\u0009\u0009ret (me.value $ int - t.value $ int).sign()\n\u0009end func\n\n\u0009+*func toStr(): []char\n\u0009\u0009ret me.value.toStr()\n\u0009end func\n\n\u0009+var value: char\nend class\n\n+class Str()\n\u0009+*func cmp(t: @Str): int\n\u0009\u0009ret @cmp(me.value, t.value)\n\u0009end func\n\n\u0009+*func toStr(): []char\n\u0009\u0009ret me.value\n\u0009end func\n\n\u0009+var value: []char\nend class\n":true;
else if(p==="res/sys/preset00_cui.knp")
return f?"func main()\n\u0009do cui@print(\"Hello, world!\")\nend func\n":true;
else if(p==="res/sys/preset00_wnd.knp")
return f?"func main()\n\u0009var wndMain: wnd@Wnd :: wnd@makeWnd(null, %normal, 1024, 768, \"\")\n\u0009var editLog: wnd@EditMulti :: wnd@makeEditMulti(wndMain, 12, 12, 1000, 744, %scale, %scale)\n\u0009do editLog.readonly(true)\n\u0009do editLog.setText(\"Hello, world!\")\n\n\u0009while(wnd@act())\n\u0009end while\nend func\n":true;
else if(p==="res/sys/preset01_cui.knp")
return f?"func main()\n\u0009do cui@print(\"q\")\nend func\n":true;
else if(p==="res/sys/preset01_wnd.knp")
return f?"func main()\n\u0009var wndMain: wnd@Wnd :: wnd@makeWnd(null, %normal, 1024, 768, \"\")\n\u0009var editLog: wnd@EditMulti :: wnd@makeEditMulti(wndMain, 12, 12, 1000, 744, %scale, %scale)\n\u0009do editLog.readonly(true)\n\u0009do editLog.setText(\"q\")\n\n\u0009while(wnd@act())\n\u0009end while\nend func\n":true;
else if(p==="res/sys/preset02_cui.knp")
return f?"func main()\n\u0009for i(1, 100)\n\u0009\u0009if(i % 15 = 0)\n\u0009\u0009\u0009do cui@print(\"FizzBuzz\\n\")\n\u0009\u0009elif(i % 3 = 0)\n\u0009\u0009\u0009do cui@print(\"Fizz\\n\")\n\u0009\u0009elif(i % 5 = 0)\n\u0009\u0009\u0009do cui@print(\"Buzz\\n\")\n\u0009\u0009else\n\u0009\u0009\u0009do cui@print(i.toStr() ~ \"\\n\")\n\u0009\u0009end if\n\u0009end for\nend func\n":true;
else if(p==="res/sys/preset02_wnd.knp")
return f?"func main()\n\u0009var wndMain: wnd@Wnd :: wnd@makeWnd(null, %normal, 1024, 768, \"\")\n\u0009var editLog: wnd@EditMulti :: wnd@makeEditMulti(wndMain, 12, 12, 1000, 744, %scale, %scale)\n\u0009do editLog.readonly(true)\n\u0009do editLog.setText(\"\")\n\u0009for i(1, 100)\n\u0009\u0009if(i % 15 = 0)\n\u0009\u0009\u0009do editLog.setText(editLog.getText() ~ \"FizzBuzz\\n\")\n\u0009\u0009elif(i % 3 = 0)\n\u0009\u0009\u0009do editLog.setText(editLog.getText() ~ \"Fizz\\n\")\n\u0009\u0009elif(i % 5 = 0)\n\u0009\u0009\u0009do editLog.setText(editLog.getText() ~ \"Buzz\\n\")\n\u0009\u0009else\n\u0009\u0009\u0009do editLog.setText(editLog.getText() ~ (i.toStr() ~ \"\\n\"))\n\u0009\u0009end if\n\u0009end for\n\n\u0009while(wnd@act())\n\u0009end while\nend func\n":true;
else if(p==="res/sys/preset03_cui.knp")
return f?"func main()\n\u0009for i(99, 2, -1)\n\u0009\u0009do cui@print(i.toStr() ~ \" bottles of beer on the wall, \" ~ i.toStr() ~ \" bottles of beer.\\n\")\n\u0009\u0009do cui@print(\"Take one down, pass it around, \" ~ (i - 1).toStr() ~ \" bottles of beer on the wall.\\n\")\n\u0009end for\n\u0009do cui@print(\"2 bottles of beer on the wall, 2 bottles of beer.\\n\")\n\u0009do cui@print(\"Take one down, pass it around, 1 bottle of beer on the wall.\\n\")\n\u0009do cui@print(\"1 bottle of beer on the wall, 1 bottle of beer.\\n\")\n\u0009do cui@print(\"Take one down, pass it around, no more bottles of beer on the wall.\\n\")\n\u0009do cui@print(\"No more bottles of beer on the wall, no more bottles of beer.\\n\")\n\u0009do cui@print(\"Go to the store and buy some more, 99 bottles of beer on the wall.\\n\")\nend func\n":true;
else if(p==="res/sys/preset03_wnd.knp")
return f?"func main()\n\u0009var wndMain: wnd@Wnd :: wnd@makeWnd(null, %normal, 1024, 768, \"\")\n\u0009var editLog: wnd@EditMulti :: wnd@makeEditMulti(wndMain, 12, 12, 1000, 744, %scale, %scale)\n\u0009do editLog.readonly(true)\n\u0009do editLog.setText(\"\")\n\u0009for i(99, 2, -1)\n\u0009\u0009do editLog.setText(editLog.getText() ~ (i.toStr() ~ \" bottles of beer on the wall, \" ~ i.toStr() ~ \" bottles of beer.\\n\"))\n\u0009\u0009do editLog.setText(editLog.getText() ~ (\"Take one down, pass it around, \" ~ (i - 1).toStr() ~ \" bottles of beer on the wall.\\n\"))\n\u0009end for\n\u0009do editLog.setText(editLog.getText() ~ \"2 bottles of beer on the wall, 2 bottles of beer.\\n\")\n\u0009do editLog.setText(editLog.getText() ~ \"Take one down, pass it around, 1 bottle of beer on the wall.\\n\")\n\u0009do editLog.setText(editLog.getText() ~ \"1 bottle of beer on the wall, 1 bottle of beer.\\n\")\n\u0009do editLog.setText(editLog.getText() ~ \"Take one down, pass it around, no more bottles of beer on the wall.\\n\")\n\u0009do editLog.setText(editLog.getText() ~ \"No more bottles of beer on the wall, no more bottles of beer.\\n\")\n\u0009do editLog.setText(editLog.getText() ~ \"Go to the store and buy some more, 99 bottles of beer on the wall.\\n\")\n\n\u0009while(wnd@act())\n\u0009end while\nend func\n":true;
else if(p==="res/sys/wnd.kn")
return f?"func [d0001.knd, _init] _init()\nend func\n\nfunc [d0001.knd] _fin()\nend func\n\n+func [d0001.knd, _act] act(): bool\nend func\n\n+enum WndStyle\n\u0009normal\n\u0009fix\n\u0009aspect\n\u0009popup\n\u0009dialog\n\u0009layered :: 0x10000\n\u0009noMinimize :: 0x20000\nend enum\n\n+enum Anchor\n\u0009fix\n\u0009move\n\u0009scale\nend enum\n\n+class WndBase()\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseGetPos] getPos(x: &int, y: &int, width: &int, height: &int)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseGetPosScreen] getPosScreen(x: &int, y: &int, width: &int, height: &int)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseFocus] focus()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseFocused] focused(): bool\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseSetEnabled] setEnabled(isEnabled: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseGetEnabled] getEnabled(): bool\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseSetPos] setPos(x: int, y: int, width: int, height: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseSetRedraw] setRedraw(isEnabled: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseSetVisible] setVisible(isVisible: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseGetVisible] getVisible(): bool\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseClientToScreen] clientToScreen(screenX: &int, screenY: &int, clientX: int, clientY: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndBaseScreenToClient] screenToClient(clientX: &int, clientY: &int, screenX: int, screenY: int)\n\u0009end func\n\n\u0009+func addChild(child: kuin@Class)\n\u0009\u0009do me.children.add(child)\n\u0009end func\n\n\u0009+func find(name: []char): @WndBase\n\u0009\u0009if(dbg)\n\u0009\u0009\u0009if(name =& null)\n\u0009\u0009\u0009\u0009throw 0xE9170006\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009\u0009ret findRecursion(me, name)\n\n\u0009\u0009func findRecursion(wnd: @WndBase, name: []char): @WndBase\n\u0009\u0009\u0009if(wnd.name <>& null & wnd.name = name)\n\u0009\u0009\u0009\u0009ret wnd\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do wnd.children.head()\n\u0009\u0009\u0009while(!wnd.children.term())\n\u0009\u0009\u0009\u0009var child: kuin@Class :: wnd.children.get()\n\u0009\u0009\u0009\u0009if(child =$ @WndBase)\n\u0009\u0009\u0009\u0009\u0009var result: @WndBase :: findRecursion(child $ @WndBase, name)\n\u0009\u0009\u0009\u0009\u0009if(result <>& null)\n\u0009\u0009\u0009\u0009\u0009\u0009ret result\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do wnd.children.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009ret null\n\u0009\u0009end func\n\u0009end func\n\n\u0009+var name: []char\n\u0009var kind: int\n\u0009var handle: int\n\u0009var defaultWndProc: int\n\u0009var ctrlFlag: int\n\u0009var defaultRect: int\n\u0009var redrawEnabled: int\n\u0009+var children: list<kuin@Class>\nend class\n\n+class Wnd(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetText] getText(): []char\n\u0009end func\n\n\u0009+func [d0001.knd, _wndClose] close()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndExit] exit()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndMinMax] minMax(minWidth: int, minHeight: int, maxWidth: int, maxHeight: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetMenu] setMenu(menu: @Menu)\n\u0009\u0009if(menu <>& null)\n\u0009\u0009\u0009do me.addChild(menu)\n\u0009\u0009end if\n\u0009end func\n\n\u0009+func [d0001.knd, _wndActivate] activate()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndActivated] activated(): bool\n\u0009end func\n\n\u0009+func [d0001.knd, _wndFocusedWnd] focusedWnd(): bool\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetAlpha] setAlpha(alpha: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetAlpha] getAlpha(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _wndAcceptDraggedFiles] acceptDraggedFiles(isAccepted: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndUpdateMenu] updateMenu()\n\u0009end func\n\n\u0009+func modal()\n\u0009\u0009do me.setModalLock()\n\u0009\u0009while(@act() & me.modalLock)\n\u0009\u0009end while\n\u0009end func\n\n\u0009func [d0001.knd, _wndSetModalLock] setModalLock()\n\u0009end func\n\n\u0009var minMaxRect: int\n\u0009+var onClose: func<(@WndBase): bool>\n\u0009+var onActivate: func<(@WndBase, bool, bool)>\n\u0009+var onPushMenu: func<(@WndBase, int)>\n\u0009+var onDropFiles: func<(@WndBase, [][]char)>\n\u0009+var onResize: func<(@WndBase)>\n\u0009var modalLock: bool\nend class\n\n+enum ShiftCtrl\n\u0009none\n\u0009shift :: 0x01\n\u0009ctrl :: 0x02\nend enum\n\n+class Draw(@WndBase)\n\u0009*func [d0001.knd, _drawDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _drawPaint] paint()\n\u0009end func\n\n\u0009+func [d0001.knd, _drawShowCaret] showCaret(height: int, font: draw@Font)\n\u0009end func\n\n\u0009+func [d0001.knd, _drawHideCaret] hideCaret()\n\u0009end func\n\n\u0009+func [d0001.knd, _drawMoveCaret] moveCaret(x: int, y: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _drawMouseCapture] mouseCapture(enabled: bool)\n\u0009end func\n\n\u0009var equalMagnification: int\n\u0009var drawBuf: int\n\u0009+var onPaint: func<(@WndBase, int, int)>\n\u0009+var onMouseDownL: func<(@WndBase, int, int)>\n\u0009+var onMouseDownR: func<(@WndBase, int, int)>\n\u0009+var onMouseDownM: func<(@WndBase, int, int)>\n\u0009+var onMouseDoubleClick: func<(@WndBase, int, int)>\n\u0009+var onMouseUpL: func<(@WndBase, int, int)>\n\u0009+var onMouseUpR: func<(@WndBase, int, int)>\n\u0009+var onMouseUpM: func<(@WndBase, int, int)>\n\u0009+var onMouseMove: func<(@WndBase, int, int)>\n\u0009+var onMouseEnter: func<(@WndBase, int, int)>\n\u0009+var onMouseLeave: func<(@WndBase)>\n\u0009+var onMouseWheelX: func<(@WndBase, int)>\n\u0009+var onMouseWheelY: func<(@WndBase, int)>\n\u0009+var onFocus: func<(@WndBase, bool)>\n\u0009+var onKeyDown: func<(@WndBase, @Key, @ShiftCtrl)>\n\u0009+var onKeyUp: func<(@WndBase, @Key, @ShiftCtrl)>\n\u0009+var onKeyChar: func<(@WndBase, char)>\n\u0009+var onScrollX: func<(@WndBase, int)>\n\u0009+var onScrollY: func<(@WndBase, int)>\n\u0009+var onSetMouseImg: func<(@WndBase): @MouseImg>\nend class\n\n+class DrawEditable(@Draw)\n\u0009*func [d0001.knd, _drawDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Btn(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetText] getText(): []char\n\u0009end func\n\n\u0009+var onPush: func<(@WndBase)>\nend class\n\n+class Chk(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetText] getText(): []char\n\u0009end func\n\n\u0009+func [d0001.knd, _btnSetChk] setChk(value: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _btnGetChk] getChk(): bool\n\u0009end func\n\n\u0009+var onPush: func<(@WndBase)>\nend class\n\n+class Radio(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetText] getText(): []char\n\u0009end func\n\n\u0009+func [d0001.knd, _btnSetChk] setChk(value: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _btnGetChk] getChk(): bool\n\u0009end func\n\n\u0009+var onPush: func<(@WndBase)>\nend class\n\n+class EditBase(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [__raw,  wnd_editBaseGetText] getText(): []char\n\u0009end func\n\n\u0009+func [d0001.knd, _editReadonly] readonly(enabled: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _editSetSel] setSel(start: int, len: int)\n\u0009end func\n\n\u0009+var onChange: func<(@WndBase)>\n\u0009+var onFocus: func<(@WndBase, bool)>\nend class\n\n+class Edit(@EditBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _editRightAligned] rightAligned(enabled: bool)\n\u0009end func\nend class\n\n+class EditMulti(@EditBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _editMultiAddText] addText(text: []char)\n\u0009end func\nend class\n\n+class List(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _listClear] clear()\n\u0009end func\n\n\u0009+func [d0001.knd, _listAdd] add(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _listIns] ins(idx: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _listDel] del(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listLen] len(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _listSetSel] setSel(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listGetSel] getSel(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _listSetText] setText(idx: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _listGetText] getText(idx: int): []char\n\u0009end func\n\n\u0009+var onSel: func<(@WndBase)>\n\u0009+var onMouseDoubleClick: func<(@WndBase)>\nend class\n\n+class Combo(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _comboClear] clear()\n\u0009end func\n\n\u0009+func [d0001.knd, _comboAdd] add(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _comboIns] ins(idx: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _comboDel] del(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _comboLen] len(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _comboSetSel] setSel(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _comboGetSel] getSel(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _comboSetText] setText(idx: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _comboGetText] getText(idx: int): []char\n\u0009end func\nend class\n\n+class Label(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetText] getText(): []char\n\u0009end func\nend class\n\n+class Group(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _wndSetText] setText(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _wndGetText] getText(): []char\n\u0009end func\nend class\n\n+class Calendar(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Progress(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Rebar(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Status(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Toolbar(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Trackbar(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class LabelLink(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+enum ListViewStyle\n\u0009large\n\u0009report\n\u0009small\n\u0009list_\n\u0009chk\n\u0009hideHeader :: 0x4000\nend enum\n\n+class ListView(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewClear] clear()\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewAdd] add(text: []char, img: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewIns] ins(idx: int, text: []char, img: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewDel] del(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewLen] len(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewAddColumn] addColumn(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewInsColumn] insColumn(column: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewDelColumn] delColumn(column: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewLenColumn] lenColumn(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewClearAll] clearAll()\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewSetText] setText(idx: int, column: int, text: []char, img: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewGetText] getText(img: &int, idx: int, column: int): []char\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewAdjustWidth] adjustWidth()\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewSetSel] setSel(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewGetSel] getSel(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewSetSelMulti] setSelMulti(idx: int, value: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewGetSelMulti] getSelMulti(idx: int): bool\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewStyle] style(listViewStyle: @ListViewStyle)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewDraggable] draggable(enabled: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewSetChk] setChk(idx: int, value: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _listViewGetChk] getChk(idx: int): bool\n\u0009end func\n\n\u0009+var onSel: func<(@WndBase)>\n\u0009+var onMouseDoubleClick: func<(@WndBase)>\n\u0009+var onMouseClick: func<(@WndBase)>\n\u0009+var onMoveNode: func<(@WndBase)>\n\u0009var draggable_: int\n\u0009var draggingImage: int\nend class\n\n+class Pager(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Tab(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _tabAdd] add(text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _tabLen] len(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _tabSetSel] setSel(idx: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _tabGetSel] getSel(): int\n\u0009end func\n\n\u0009+func [d0001.knd, _tabGetPosInner] getPosInner(x: &int, y: &int, width: &int, height: &int)\n\u0009end func\n\n\u0009+var onSel: func<(@WndBase)>\nend class\n\n+class Tree(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _treeClear] clear()\n\u0009end func\n\n\u0009+func [d0001.knd, _treeExpand] expand(expand_: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _treeRoot, _make_instance] root(me2: @TreeNode): @TreeNode\n\u0009end func\n\n\u0009+func [d0001.knd, _treeDraggable] draggable(enabled: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _treeAllowDraggingToRoot] allowDraggingToRoot(enabled: bool)\n\u0009end func\n\n\u0009+func [d0001.knd, _treeSetSel] setSel(node: @TreeNode)\n\u0009end func\n\n\u0009+func [d0001.knd, _treeGetSel, _make_instance] getSel(me2: @TreeNode): @TreeNode\n\u0009end func\n\n\u0009var draggable_: int\n\u0009var draggingItem: int\n\u0009+var onSel: func<(@WndBase)>\n\u0009+var onMoveNode: func<(@WndBase)>\nend class\n\n+class TreeNode()\n\u0009+*func cmp(t: @TreeNode): int\n\u0009\u0009ret me.item - t.item\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeAddChild, _make_instance] addChild(me2: @TreeNode, name: []char): @TreeNode\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeInsChild, _make_instance] insChild(me2: @TreeNode, node: @TreeNode, name: []char): @TreeNode\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeDelChild] delChild(node: @TreeNode)\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeFirstChild, _make_instance] firstChild(me2: @TreeNode): @TreeNode\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeGetName] getName(): []char\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeNext, _make_instance] next(me2: @TreeNode): @TreeNode\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodePrev, _make_instance] prev(me2: @TreeNode): @TreeNode\n\u0009end func\n\n\u0009+func [d0001.knd, _treeNodeParent, _make_instance] parent(me2: @TreeNode): @TreeNode\n\u0009end func\n\n\u0009var wndHandle: int\n\u0009+var item: int\nend class\n\nclass SplitBase(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class SplitX(@SplitBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class SplitY(@SplitBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\nclass ScrollBase(@WndBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _scrollSetState] setState(min: int, max: int, page: int, pos: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _scrollSetScrollPos] setScrollPos(pos: int)\n\u0009end func\nend class\n\n+class ScrollX(@ScrollBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class ScrollY(@ScrollBase)\n\u0009*func [d0001.knd, _wndBaseDtor, _force] _dtor()\n\u0009end func\nend class\n\n+enum MsgBoxIcon\n\u0009none\n\u0009err :: 0x10\n\u0009question :: 0x20\n\u0009warn :: 0x30\n\u0009info :: 0x40\nend enum\n\n+enum MsgBoxBtn\n\u0009ok\n\u0009okCancel\n\u0009abortRetryIgnore\n\u0009yesNoCancel\n\u0009yesNo\n\u0009retryCancel\n\u0009cancelAgainContinue\nend enum\n\n+enum MsgBoxResult\n\u0009ok :: 1\n\u0009cancel\n\u0009abort\n\u0009retry\n\u0009ignore\n\u0009yes\n\u0009no\n\u0009again :: 10\n\u0009continue\nend enum\n\n+func [d0001.knd, _setOnKeyPress] setOnKeyPress(onKeyPressFunc: func<(@Key, @ShiftCtrl): bool>)\nend func\n\n+func [d0001.knd, _getOnKeyPress] getOnKeyPress(): func<(@Key, @ShiftCtrl): bool>\nend func\n\n+func [d0001.knd, _msgBox] msgBox(parent: @Wnd, text: []char, title: []char, icon: @MsgBoxIcon, btn: @MsgBoxBtn): @MsgBoxResult\nend func\n\n+func [d0001.knd, _openFileDialog] openFileDialog(parent: @Wnd, filter: [][]char, defaultFilter: int): []char\nend func\n\n+func [d0001.knd, _saveFileDialog] saveFileDialog(parent: @Wnd, filter: [][]char, defaultFilter: int, defaultExt: []char): []char\nend func\n\n+func [d0001.knd, _fileDialogDir] fileDialogDir(defaultDir: []char)\nend func\n\n+func [d0001.knd, _colorDialog] colorDialog(parent: @Wnd, defaultColor: int): int\nend func\n\n+func [d0001.knd, _setClipboardStr] setClipboardStr(str: []char)\nend func\n\n+func [d0001.knd, _getClipboardStr] getClipboardStr(): []char\nend func\n\n+func [d0001.knd, _getCaretPos] getCaretPos(x: &int, y: &int)\nend func\n\n+func [d0001.knd, _screenSize] screenSize(width: &int, height: &int)\nend func\n\n+func [d0001.knd, _makeWnd, _make_instance] makeWnd(me2: @Wnd, parent: @Wnd, style: @WndStyle, width: int, height: int, text: []char): @Wnd\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeDraw, _make_instance] makeDraw(me2: @Draw, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, equalMagnification: bool): @Draw\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeDrawReduced, _make_instance] makeDrawReduced(me2: @Draw, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, equalMagnification: bool, split: int): @Draw\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeDrawEditable, _make_instance] makeDrawEditable(me2: @DrawEditable, parent: @WndBase, x: int, y: int, width: int, height: int): @DrawEditable\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeBtn, _make_instance] makeBtn(me2: @Btn, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, text: []char): @Btn\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeChk, _make_instance] makeChk(me2: @Chk, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, text: []char): @Chk\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeRadio, _make_instance] makeRadio(me2: @Radio, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, text: []char): @Radio\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeEdit, _make_instance] makeEdit(me2: @Edit, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Edit\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [__mki, __raw, wnd_makeEditMulti] makeEditMulti(me2: @EditMulti, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @EditMulti\nend func\n\n+func [d0001.knd, _makeList, _make_instance] makeList(me2: @List, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @List\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeCombo, _make_instance] makeCombo(me2: @Combo, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Combo\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeLabel, _make_instance] makeLabel(me2: @Label, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, text: []char): @Label\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeGroup, _make_instance] makeGroup(me2: @Group, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, text: []char): @Group\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeCalendar, _make_instance] makeCalendar(me2: @Calendar, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Calendar\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeProgress, _make_instance] makeProgress(me2: @Progress, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Progress\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeRebar, _make_instance] makeRebar(me2: @Rebar, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Rebar\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeStatus, _make_instance] makeStatus(me2: @Status, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Status\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeToolbar, _make_instance] makeToolbar(me2: @Toolbar, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Toolbar\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeTrackbar, _make_instance] makeTrackbar(me2: @Trackbar, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Trackbar\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeLabelLink, _make_instance] makeLabelLink(me2: @LabelLink, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @LabelLink\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeListView, _make_instance] makeListView(me2: @ListView, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor, multiSel: bool, smallImgs: [][]char, largeImgs: [][]char): @ListView\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makePager, _make_instance] makePager(me2: @Pager, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Pager\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeTab, _make_instance] makeTab(me2: @Tab, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Tab\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeTree, _make_instance] makeTree(me2: @Tree, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @Tree\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeSplitX, _make_instance] makeSplitX(me2: @SplitX, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @SplitX\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeSplitY, _make_instance] makeSplitY(me2: @SplitY, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @SplitY\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeScrollX, _make_instance] makeScrollX(me2: @ScrollX, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @ScrollX\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+func [d0001.knd, _makeScrollY, _make_instance] makeScrollY(me2: @ScrollY, parent: @WndBase, x: int, y: int, width: int, height: int, anchorX: @Anchor, anchorY: @Anchor): @ScrollY\n\u0009if(parent <>& null)\n\u0009\u0009do parent.addChild(me2)\n\u0009end if\nend func\n\n+class MenuBase()\n\u0009*func [d0001.knd, _menuDtor, _force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _menuAdd] add(id: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _menuAddLine] addLine()\n\u0009end func\n\n\u0009+func [d0001.knd, _menuAddPopup] addPopup(text: []char, popup: @Popup)\n\u0009\u0009do me.children.add(popup)\n\u0009end func\n\n\u0009+func [d0001.knd, _menuIns] ins(targetId: int, id: int, text: []char)\n\u0009end func\n\n\u0009+func [d0001.knd, _menuInsPopup] insPopup(target: @Popup, text: []char, popup: @Popup)\n\u0009\u0009do me.children.add(popup)\n\u0009end func\n\n\u0009+func [d0001.knd, _menuDel] del(id: int)\n\u0009end func\n\n\u0009+func [d0001.knd, _menuDelPopup] delPopup(popup: @Popup)\n\u0009end func\n\n\u0009var handle: int\n\u0009var children: list<kuin@Class>\nend class\n\n+class Menu(@MenuBase)\n\u0009*func [d0001.knd, _menuDtor, _force] _dtor()\n\u0009end func\nend class\n\n+class Popup(@MenuBase)\n\u0009*func [d0001.knd, _menuDtor, _force] _dtor()\n\u0009end func\nend class\n\n+func [d0001.knd, _makeMenu, _make_instance] makeMenu(me2: @Menu): @Menu\nend func\n\n+func [d0001.knd, _makePopup, _make_instance] makePopup(me2: @Popup): @Popup\nend func\n\n+class TabOrder()\n\u0009*func [_force] _dtor()\n\u0009end func\n\n\u0009+func [d0001.knd, _tabOrderChk] chk(key: @Key, shiftCtrl: @ShiftCtrl): bool\n\u0009end func\n\n\u0009var ctrls: []@WndBase\nend class\n\n+func [d0001.knd, _makeTabOrder, _make_instance] makeTabOrder(me2: @TabOrder, ctrls: []@WndBase): @TabOrder\nend func\n\n+func [d0001.knd, _key] key(key_: @Key): bool\nend func\n\n+enum Key\n\u0009mouseL :: 0x01\n\u0009mouseR\n\u0009mouseM :: 0x04\n\u0009bs :: 0x08\n\u0009tab\n\u0009enter :: 0x0D\n\u0009shift :: 0x10\n\u0009ctrl\n\u0009alt\n\u0009pause\n\u0009esc :: 0x1B\n\u0009space :: 0x20\n\u0009pageUp\n\u0009pageDown\n\u0009end_\n\u0009home\n\u0009left\n\u0009up\n\u0009right\n\u0009down\n\u0009ins :: 0x2D\n\u0009del\n\u0009_0 :: 0x30\n\u0009_1\n\u0009_2\n\u0009_3\n\u0009_4\n\u0009_5\n\u0009_6\n\u0009_7\n\u0009_8\n\u0009_9\n\u0009a :: 0x41\n\u0009b\n\u0009c\n\u0009d\n\u0009e\n\u0009f\n\u0009g\n\u0009h\n\u0009i\n\u0009j\n\u0009k\n\u0009l\n\u0009m\n\u0009n\n\u0009o\n\u0009p\n\u0009q\n\u0009r\n\u0009s\n\u0009t\n\u0009u\n\u0009v\n\u0009w\n\u0009x\n\u0009y\n\u0009z\n\u0009f1 :: 0x70\n\u0009f2\n\u0009f3\n\u0009f4\n\u0009f5\n\u0009f6\n\u0009f7\n\u0009f8\n\u0009f9\n\u0009f10\n\u0009f11\n\u0009f12\n\u0009plus :: 0xBB\n\u0009comma\n\u0009minus\n\u0009period\nend enum\n\n+enum MouseImg\n\u0009arrow :: 32512\n\u0009ibeam\n\u0009wait\n\u0009cross\n\u0009upArrow\n\u0009resizeLTRB :: 32642\n\u0009resizeRTLB\n\u0009resizeH\n\u0009resizeV\n\u0009move\n\u0009no :: 32648\n\u0009link\n\u0009arrowWait\n\u0009arrowHelp\nend enum\n":true;
else if(p==="res/test.kn")
return f?"func main()\n\u0009do @test1()\nend func\n\nfunc test1()\n\u0009do cui@print(\"Kuin\" ~ \" Test \" ~ \"Program\\n\")\n\u0009\n\u0009block\n\u0009\u0009var a: int :: (7 + 7) / 7 - 7 * 7 + 7 + 7 + 7 + 7 + 7 + 7 + 7 + 7 + 7 + 7 + (+7) + (-7) {23}\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ (23 % 7).toStr() ~ \", \" ~ (7 ^ 7).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: int :: 7\n\u0009\u0009var b: int :: (n + n) / n - n * n + n + n + n + n + n + n + n + n + n + n + (+n) + (-n) {23}\n\u0009\u0009do cui@print(b.toStr() ~ \", \" ~ (b % n).toStr() ~ \", \" ~ (n ^ n).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c: int :: -2\n\u0009\u0009do cui@print((c ^ 0).toStr() ~ \", \" ~ (c ^ 1).toStr() ~ \", \" ~ (c ^ 2).toStr() ~ \", \" ~ (c ^ 3).toStr() ~ \", \" ~ (c ^ 4).toStr() ~ \", \" ~ (c ^ 5).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: float :: (7.0 + 7.0) / 7.0 - 7.0 * 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + 7.0 + (+7.0) + (-7.0) {23.0}\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ (23.00 % 7.0).toStr() ~ \", \" ~ (7 ^ 7).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: float :: 7.0\n\u0009\u0009var b: float :: (n + n) / n - n * n + n + n + n + n + n + n + n + n + n + n + (+n) + (-n) {23.0}\n\u0009\u0009do cui@print(b.toStr() ~ \", \" ~ (b % n).toStr() ~ \", \" ~ (n ^ n).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c: float :: -2.0\n\u0009\u0009do cui@print((c ^ 0.0).toStr() ~ \", \" ~ (c ^ 1.0).toStr() ~ \", \" ~ (c ^ 2.0).toStr() ~ \", \" ~ (c ^ 3.0).toStr() ~ \", \" ~ (c ^ 4.0).toStr() ~ \", \" ~ (c ^ 5.0).toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: bit8 :: (7b8 + 7b8) / 7b8 - 7b8 * 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + 7b8 + (+7b8) + ((-7) $ bit8) {23}\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ (23b8 % 7b8).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: bit8 :: 7b8\n\u0009\u0009var b: bit8 :: (n + n) / n - n * n + n + n + n + n + n + n + n + n + n + n + (+n) + (0b8 - n) {23}\n\u0009\u0009do cui@print(b.toStr() ~ \", \" ~ (b % n).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c1: bit8 :: 255b8 + 2b8\n\u0009\u0009var c2: bit8 :: (-1) $ bit8\n\u0009\u0009var d1: bit8 :: 255b8\n\u0009\u0009var d2: bit8 :: 1b8\n\u0009\u0009do d1 :+ 2b8\n\u0009\u0009do d2 :: 0b8 - d2\n\u0009\u0009do cui@print(c1.toStr() ~ \", \" ~ d1.toStr() ~ \", \" ~ c2.toStr() ~ \", \" ~ d2.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: bit16 :: (7b16 + 7b16) / 7b16 - 7b16 * 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + 7b16 + (+7b16) + ((-7) $ bit16) {23}\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ (23b16 % 7b16).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: bit16 :: 7b16\n\u0009\u0009var b: bit16 :: (n + n) / n - n * n + n + n + n + n + n + n + n + n + n + n + (+n) + (0b16 - n) {23}\n\u0009\u0009do cui@print(b.toStr() ~ \", \" ~ (b % n).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c1: bit16 :: 65535b16 + 2b16\n\u0009\u0009var c2: bit16 :: (-1) $ bit16\n\u0009\u0009var d1: bit16 :: 65535b16\n\u0009\u0009var d2: bit16 :: 1b16\n\u0009\u0009do d1 :+ 2b16\n\u0009\u0009do d2 :: 0b16 - d2\n\u0009\u0009do cui@print(c1.toStr() ~ \", \" ~ d1.toStr() ~ \", \" ~ c2.toStr() ~ \", \" ~ d2.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: bit32 :: (7b32 + 7b32) / 7b32 - 7b32 * 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + 7b32 + (+7b32) + ((-7) $ bit32) {23}\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ (23b32 % 7b32).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: bit32 :: 7b32\n\u0009\u0009var b: bit32 :: (n + n) / n - n * n + n + n + n + n + n + n + n + n + n + n + (+n) + (0b32 - n) {23}\n\u0009\u0009do cui@print(b.toStr() ~ \", \" ~ (b % n).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c1: bit32 :: 0xFFFFFFFFb32 + 2b32\n\u0009\u0009var c2: bit32 :: (-1) $ bit32\n\u0009\u0009var d1: bit32 :: 0xFFFFFFFFb32\n\u0009\u0009var d2: bit32 :: 1b32\n\u0009\u0009do d1 :+ 2b32\n\u0009\u0009do d2 :: 0b32 - d2\n\u0009\u0009do cui@print(c1.toStr() ~ \", \" ~ d1.toStr() ~ \", \" ~ c2.toStr() ~ \", \" ~ d2.toStr() ~ \"\\n\")\n\u0009end block\n\u0009\n\u0009block\n\u0009\u0009var a: bit64 :: (7b64 + 7b64) / 7b64 - 7b64 * 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + 7b64 + (+7b64) + ((-7) $ bit64) {23}\n\u0009\u0009do cui@print(a.toStr() ~ \", \" ~ (23b64 % 7b64).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var n: bit64 :: 7b64\n\u0009\u0009var b: bit64 :: (n + n) / n - n * n + n + n + n + n + n + n + n + n + n + n + (+n) + (0b64 - n) {23}\n\u0009\u0009do cui@print(b.toStr() ~ \", \" ~ (b % n).toStr() ~ \"\\n\")\n\u0009\u0009\n\u0009\u0009var c1: bit64 :: 0xFFFFFFFFFFFFFFFFb64 + 2b64\n\u0009\u0009var c2: bit64 :: (-1) $ bit64\n\u0009\u0009var d1: bit64 :: 0xFFFFFFFFFFFFFFFFb64\n\u0009\u0009var d2: bit64 :: 1b64\n\u0009\u0009do d1 :+ 2b64\n\u0009\u0009do d2 :: 0b64 - d2\n\u0009\u0009do cui@print(c1.toStr() ~ \", \" ~ d1.toStr() ~ \", \" ~ c2.toStr() ~ \", \" ~ d2.toStr() ~ \"\\n\")\n\u0009end block\nend func\n":true;
else if(p==="res/web/")
return f?null:true;
else if(p==="res/web/output.kn")
return f?"const classTableItemSize: int :: 2\n\nvar funcs: queue<\\ast@AstFunc>\nvar classes: queue<\\ast@AstClass>\n\nvar uniqueId: []char\nvar codes: list<[]char>\nvar tmpVars: list<@TmpVar>\nvar globalVars: list<\\ast@AstArg>\nvar localVars: list<\\ast@AstArg>\n\n+class WebInfo(\\ast@HasType)\n\u0009+var id: []char\n\u0009+var breakSkipLabel: []char\n\u0009+var alreadyWritten: bool\nend class\n\nclass TmpVar()\n\u0009+var identifier: []char\n\u0009+var type: \\ast@AstType\nend class\n\n+func output(entry: \\ast@AstFunc, resFiles: list<[]char>): bool\n\u0009do @funcs :: #queue<\\ast@AstFunc>\n\u0009do @funcs.add(entry)\n\u0009do @classes :: #queue<\\ast@AstClass>\n\u0009\n\u0009do @uniqueId :: \"a\"\n\u0009do @codes :: #list<[]char>\n\u0009do @tmpVars :: #list<@TmpVar>\n\u0009do @globalVars :: #list<\\ast@AstArg>\n\u0009do @localVars :: #list<\\ast@AstArg>\n\u0009\n\u0009while(^@funcs > 0 | ^@classes > 0)\n\u0009\u0009while(^@funcs > 0)\n\u0009\u0009\u0009var func_: \\ast@AstFunc :: @funcs.get()\n\u0009\u0009\u0009do @buildFunc(func_)\n\u0009\u0009end while\n\u0009\u0009while(^@classes > 0)\n\u0009\u0009\u0009var class_: \\ast@AstClass :: @classes.get()\n\u0009\u0009\u0009do @buildClass(class_)\n\u0009\u0009end while\n\u0009end while\n\u0009\n\u0009do @write(resFiles)\n\u0009\n\u0009ret true\nend func\n\nfunc buildFunc(ast: \\ast@AstFunc)\n\u0009var info: @WebInfo :: @getInfo(ast)\n\u0009if(info.alreadyWritten)\n\u0009\u0009ret\n\u0009end if\n\u0009do info.alreadyWritten :: true\n\u0009\n\u0009var arg: []char :: \"\"\n\u0009block\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstArg :: items.get()\n\u0009\u0009\u0009var info2: @WebInfo :: @getInfo(item)\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do arg :~ \",\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do arg :~ \"\\{info2.id}\"\n\u0009\u0009\u0009if(item.name <>& null)\n\u0009\u0009\u0009\u0009do arg :~ \" /*\\{item.name}*/\"\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009\n\u0009if(ast.name <>& null)\n\u0009\u0009do @codes.add(\"// \\{ast.name}\\n\")\n\u0009end if\n\u0009do @codes.add(\"function \\{info.id}(\\{arg}){\\n\")\n\u0009\n\u0009if(ast.funcOption.and(%raw) = %raw)\n\u0009\u0009if(^ast.funcAttr = 1)\n\u0009\u0009\u0009do ast.funcAttr.head()\n\u0009\u0009\u0009var hasMembers: bool :: false\n\u0009\u0009\u0009if(^ast.args > 0)\n\u0009\u0009\u0009\u0009do ast.args.head()\n\u0009\u0009\u0009\u0009var arg2: \\ast@AstArg :: ast.args.get()\n\u0009\u0009\u0009\u0009if(arg2.type.refItem <>& null & arg2.type.refItem.typeId = %class_)\n\u0009\u0009\u0009\u0009\u0009var members: list<\\ast@AstClassItem> :: (arg2.type.refItem $ \\ast@AstClass).items\n\u0009\u0009\u0009\u0009\u0009do \\web\\raw_funcs@write(@codes, ast.funcAttr.get(), ast.args, members)\n\u0009\u0009\u0009\u0009\u0009do hasMembers :: true\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(!hasMembers)\n\u0009\u0009\u0009\u0009do \\web\\raw_funcs@write(@codes, ast.funcAttr.get(), ast.args, null)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009end if\n\u0009else\n\u0009\u0009do @codes.tail()\n\u0009\u0009var localVarPos: int :: @codes.idx()\n\u0009\u0009\n\u0009\u0009do @buildStats(ast.stats)\n\u0009\u0009\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\n\u0009\u0009do @codes.head()\n\u0009\u0009do @codes.moveOffset(localVarPos)\n\u0009\u0009do @codes.next()\n\u0009\u0009do @localVars.head()\n\u0009\u0009while(!@localVars.term())\n\u0009\u0009\u0009var localVar: \\ast@AstArg :: @localVars.get()\n\u0009\u0009\u0009var info2: @WebInfo :: @getInfo(localVar)\n\u0009\u0009\u0009if(localVar.name =& null)\n\u0009\u0009\u0009\u0009do @codes.ins(\"let \\{info2.id}=\\{@getDefaultValue(localVar.type)};\\n\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.ins(\"let \\{info2.id}=\\{@getDefaultValue(localVar.type)}; // \\{localVar.name}\\n\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @localVars.del()\n\u0009\u0009end while\n\u0009\u0009do @tmpVars.head()\n\u0009\u0009while(!@tmpVars.term())\n\u0009\u0009\u0009var tmpVar: @TmpVar :: @tmpVars.get()\n\u0009\u0009\u0009do @codes.ins(\"let \\{tmpVar.identifier}=\\{@getDefaultValue(tmpVar.type)};\\n\")\n\u0009\u0009\u0009do @tmpVars.del()\n\u0009\u0009end while\n\u0009end if\nend func\n\nfunc buildClass(ast: \\ast@AstClass)\n\u0009var parentId: []char :: null\n\u0009if(ast.refItem <>& null)\n\u0009\u0009do parentId :: @refClass(ast.refItem $ \\ast@AstClass)\n\u0009end if\n\u0009if(parentId =& null)\n\u0009\u0009do parentId :: \"Object\"\n\u0009end if\n\u0009var info: @WebInfo :: @getInfo(ast)\n\u0009if(ast.name <>& null)\n\u0009\u0009do @codes.add(\"// \\{ast.name}\\n\")\n\u0009end if\n\u0009block\n\u0009\u0009var ctor: \\ast@AstFunc :: findFunc(ast, \"ctor\")\n\u0009\u0009do @codes.add(\"function \\{info.id}(){\\n\")\n\u0009\u0009do @codes.add(\"\\{parentId}.call(this);\\n\")\n\u0009\u0009if(ctor <>& null)\n\u0009\u0009\u0009var ctorInfo: @WebInfo :: @getInfo(ctor)\n\u0009\u0009\u0009do @codes.add(\"\\{ctorInfo.id}(this);\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009end block\n\u0009do @codes.add(\"\\{info.id}.prototype = Object.create(\\{parentId}.prototype);\\n\")\n\u0009block\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item.def.typeId = %func_)\n\u0009\u0009\u0009\u0009do @funcs.add(item.def $ \\ast@AstFunc)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009; TODO: Destructor.\n\u0009\n\u0009func findFunc(ast: \\ast@AstClass, name: []char): \\ast@AstFunc\n\u0009\u0009var items: list<\\ast@AstClassItem> :: ast.items\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstClassItem :: items.get()\n\u0009\u0009\u0009if(item.def.typeId = %func_ & item.def.name = name)\n\u0009\u0009\u0009\u0009ret item.def $ \\ast@AstFunc\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009ret null\n\u0009end func\nend func\n\nfunc buildStats(stats: list<\\ast@AstStat>)\n\u0009do stats.head()\n\u0009while(!stats.term())\n\u0009\u0009var stat: \\ast@AstStat :: stats.get()\n\u0009\u0009switch(stat.typeId)\n\u0009\u0009case %statIf\n\u0009\u0009\u0009do @buildIf(stat $ \\ast@AstStatIf)\n\u0009\u0009case %statSwitch\n\u0009\u0009\u0009do @buildSwitch(stat $ \\ast@AstStatSwitch)\n\u0009\u0009case %statWhile\n\u0009\u0009\u0009do @buildWhile(stat $ \\ast@AstStatWhile)\n\u0009\u0009case %statFor\n\u0009\u0009\u0009do @buildFor(stat $ \\ast@AstStatFor)\n\u0009\u0009case %statTry\n\u0009\u0009\u0009do @buildTry(stat $ \\ast@AstStatTry)\n\u0009\u0009case %statThrow\n\u0009\u0009\u0009do @buildThrow(stat $ \\ast@AstStatThrow)\n\u0009\u0009case %statBlock\n\u0009\u0009\u0009do @buildBlock(stat $ \\ast@AstStatBlock)\n\u0009\u0009case %statRet\n\u0009\u0009\u0009do @buildRet(stat $ \\ast@AstStatRet)\n\u0009\u0009case %statDo\n\u0009\u0009\u0009do @buildDo(stat $ \\ast@AstStatDo)\n\u0009\u0009case %statBreak\n\u0009\u0009\u0009do @buildBreak(stat $ \\ast@AstStat)\n\u0009\u0009case %statSkip\n\u0009\u0009\u0009do @buildSkip(stat $ \\ast@AstStat)\n\u0009\u0009case %statAssert\n\u0009\u0009\u0009do @buildAssert(stat $ \\ast@AstStatAssert)\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009do stats.next()\n\u0009end while\nend func\n\nfunc buildIf(ast: \\ast@AstStatIf)\n\u0009var infoMe: @WebInfo :: @getInfo(ast)\n\u0009if(ast.cond =& null)\n\u0009\u0009; Optimized code.\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:{\\n\")\n\u0009\u0009end if\n\u0009\u0009do @buildBlock(ast.statBlock)\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009end if\n\u0009\u0009ret\n\u0009end if\n\u0009\n\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009end if\n\u0009do @codes.add(\"if(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\"){\\n\")\n\u0009do @buildBlock(ast.statBlock)\n\u0009do @codes.add(\"}\\n\")\n\u0009block\n\u0009\u0009var items: list<\\ast@AstStatElIf> :: ast.elIfs\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatElIf :: items.get()\n\u0009\u0009\u0009do @codes.add(\"else if(\")\n\u0009\u0009\u0009do @buildExpr(item.cond)\n\u0009\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009\u0009do @buildBlock(item.statBlock)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009if(ast.elseStatBlock <>& null)\n\u0009\u0009do @codes.add(\"else{\\n\")\n\u0009\u0009do @buildBlock(ast.elseStatBlock)\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009end if\nend func\n\nfunc buildSwitch(ast: \\ast@AstStatSwitch)\n\u0009var infoMe: @WebInfo :: @getInfo(ast)\n\u0009var info: @WebInfo :: @getInfo(ast.blockVar)\n\u0009if(!info.alreadyWritten)\n\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009do @localVars.add(ast.blockVar)\n\u0009end if\n\u0009var useSwitch: bool :: false\n\u0009if chk(\\ast@isInt(ast.cond.type) | \\ast@isChar(ast.cond.type) | \\ast@isEnum(ast.cond.type) | ast.cond.type.typeId = %typeBit)\n\u0009\u0009do useSwitch :: true\n\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009if(exprs.expr0.typeId.and(%exprValue) <> %exprValue | exprs.expr1 <>& null)\n\u0009\u0009\u0009\u0009\u0009do useSwitch :: false\n\u0009\u0009\u0009\u0009\u0009break chk\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end if\n\u0009if(useSwitch)\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"switch(\")\n\u0009\u0009do @buildExpr(ast.cond)\n\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009block\n\u0009\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009\u0009assert exprs.expr1 =& null\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"case \")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\":\\n\")\n\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @buildBlock(item.statBlock)\n\u0009\u0009\u0009\u0009do @codes.add(\"break;\\n\")\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009if(ast.defaultStatBlock <>& null)\n\u0009\u0009\u0009do @codes.add(\"default:\\n\")\n\u0009\u0009\u0009do @buildBlock(ast.defaultStatBlock)\n\u0009\u0009\u0009do @codes.add(\"break;\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009else\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:{\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"\\{info.id}=\")\n\u0009\u0009do @buildExpr(ast.cond)\n\u0009\u0009do @codes.add(\";\\n\")\n\u0009\u0009block\n\u0009\u0009\u0009var first: bool :: true\n\u0009\u0009\u0009var items: list<\\ast@AstStatCase> :: ast.cases\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstStatCase :: items.get()\n\u0009\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"if(\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"else if(\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009var first2: bool :: true\n\u0009\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009\u0009if(first2)\n\u0009\u0009\u0009\u0009\u0009\u0009do first2 :: false\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"||\")\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009if(exprs.expr1 =& null)\n\u0009\u0009\u0009\u0009\u0009\u0009if(\\ast@isStr(ast.cond.type))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"\\{info.id}.S===(\")\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009\u0009\u0009\u0009\u0009elif(\\ast@isRef(ast.cond.type))\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"cmp_(\\{info.id},(\")\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"))==0\")\n\u0009\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"\\{info.id}===(\")\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\")<=\\{info.id}&&\\{info.id}<=(\")\n\u0009\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr1)\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009\u0009\u0009do @buildBlock(item.statBlock)\n\u0009\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009if(ast.defaultStatBlock <>& null)\n\u0009\u0009\u0009do @codes.add(\"else{\")\n\u0009\u0009\u0009do @buildBlock(ast.defaultStatBlock)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009end if\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009end if\n\u0009end if\nend func\n\nfunc buildWhile(ast: \\ast@AstStatWhile)\n\u0009var infoMe: @WebInfo :: @getInfo(ast)\n\u0009if(ast.cond =& null)\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"for(;;){\\n\")\n\u0009\u0009do @buildStats(ast.stats)\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009ret\n\u0009end if\n\u0009if(ast.skip_)\n\u0009\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"do{\\n\")\n\u0009\u0009do @buildStats(ast.stats)\n\u0009\u0009do @codes.add(\"}while(\")\n\u0009\u0009do @buildExpr(ast.cond)\n\u0009\u0009do @codes.add(\");\\n\")\n\u0009\u0009ret\n\u0009end if\n\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009end if\n\u0009do @codes.add(\"while(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\"){\\n\")\n\u0009do @buildStats(ast.stats)\n\u0009do @codes.add(\"}\\n\")\nend func\n\nfunc buildFor(ast: \\ast@AstStatFor)\n\u0009var infoMe: @WebInfo :: @getInfo(ast)\n\u0009var info: @WebInfo :: @getInfo(ast.blockVar)\n\u0009if(!info.alreadyWritten)\n\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009do @localVars.add(ast.blockVar)\n\u0009end if\n\u0009var endId: []char :: @addTmpVar(ast.cond.type)\n\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009end if\n\u0009do @codes.add(\"for(\\{info.id}=(\")\n\u0009do @buildExpr(ast.start)\n\u0009do @codes.add(\"),\\{endId}=(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\");\\{info.id}\")\n\u0009assert ast.step.typeId = %exprValuePrim & \\ast@isInt(ast.cond.type)\n\u0009var step: int :: (ast.step $ \\ast@AstExprValuePrim).value $ int\n\u0009if(step > 0)\n\u0009\u0009do @codes.add(\"<=\")\n\u0009else\n\u0009\u0009do @codes.add(\">=\")\n\u0009end if\n\u0009do @codes.add(\"\\{endId};\\{info.id}\")\n\u0009if(step > 0)\n\u0009\u0009do @codes.add(\"+=(\")\n\u0009else\n\u0009\u0009do @codes.add(\"-=(\")\n\u0009end if\n\u0009do @buildExpr(ast.step)\n\u0009do @codes.add(\")){\\n\")\n\u0009do @buildStats(ast.stats)\n\u0009do @codes.add(\"}\\n\")\nend func\n\nfunc buildTry(ast: \\ast@AstStatTry)\n\u0009var infoMe: @WebInfo :: @getInfo(ast)\n\u0009var info: @WebInfo :: @getInfo(ast.blockVar)\n\u0009if(!info.alreadyWritten)\n\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009do @localVars.add(ast.blockVar)\n\u0009end if\n\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:\\n\")\n\u0009end if\n\u0009do @codes.add(\"try{\\n\")\n\u0009do @buildBlock(ast.statBlock)\n\u0009do @codes.add(\"}catch(\\{info.id}){\\n\")\n\u0009block\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstStatCatch> :: ast.catches\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstStatCatch :: items.get()\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009do @codes.add(\"if(\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"else if(\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009var first2: bool :: true\n\u0009\u0009\u0009var items2: list<\\ast@ExprPair> :: item.conds\n\u0009\u0009\u0009do items2.head()\n\u0009\u0009\u0009while(!items2.term())\n\u0009\u0009\u0009\u0009var exprs: \\ast@ExprPair :: items2.get()\n\u0009\u0009\u0009\u0009if(first2)\n\u0009\u0009\u0009\u0009\u0009do first2 :: false\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"||\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009if(exprs.expr1 =& null)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"\\{info.id}===(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr0)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")<=\\{info.id}&&\\{info.id}<=(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(exprs.expr1)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do items2.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do @codes.add(\"){\\n\")\n\u0009\u0009\u0009do @buildBlock(item.statBlock)\n\u0009\u0009\u0009do @codes.add(\"}\\n\")\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009\u0009if(first)\n\u0009\u0009\u0009do @codes.add(\"{\\n\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"else{\\n\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"throw \\{info.id};\\n}\\n\")\n\u0009end block\n\u0009do @codes.add(\"}\\n\")\n\u0009if(ast.finallyStatBlock <>& null)\n\u0009\u0009do @codes.add(\"finally{\\n\")\n\u0009\u0009do @buildBlock(ast.finallyStatBlock)\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009end if\nend func\n\nfunc buildThrow(ast: \\ast@AstStatThrow)\n\u0009do @codes.add(\"throw \")\n\u0009do @buildExpr(ast.code)\n\u0009do @codes.add(\";\\n\")\nend func\n\nfunc buildBlock(ast: \\ast@AstStatBlock)\n\u0009var infoMe: @WebInfo :: @getInfo(ast)\n\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009do @codes.add(\"\\{infoMe.breakSkipLabel}:{\\n\")\n\u0009end if\n\u0009do @buildStats(ast.stats)\n\u0009if(infoMe.breakSkipLabel <>& null)\n\u0009\u0009do @codes.add(\"}\\n\")\n\u0009end if\nend func\n\nfunc buildRet(ast: \\ast@AstStatRet)\n\u0009if(ast.value =& null)\n\u0009\u0009do @codes.add(\"return;\\n\")\n\u0009else\n\u0009\u0009do @codes.add(\"return \")\n\u0009\u0009do @buildExpr(ast.value)\n\u0009\u0009do @codes.add(\";\\n\")\n\u0009end if\nend func\n\nfunc buildDo(ast: \\ast@AstStatDo)\n\u0009do @buildExpr(ast.expr)\n\u0009do @codes.add(\";\\n\")\nend func\n\nfunc buildBreak(ast: \\ast@AstStat)\n\u0009assert ast.refItem.typeId.and(%statBreakable) = %statBreakable\n\u0009var info: @WebInfo :: @getInfo(ast.refItem)\n\u0009do @codes.add(\"break \\{info.breakSkipLabel};\\n\")\nend func\n\nfunc buildSkip(ast: \\ast@AstStat)\n\u0009assert ast.refItem.typeId.and(%statSkipable) = %statSkipable\n\u0009var info: @WebInfo :: @getInfo(ast.refItem)\n\u0009do @codes.add(\"continue \\{info.breakSkipLabel};\\n\")\nend func\n\nfunc buildAssert(ast: \\ast@AstStatAssert)\n\u0009do @codes.add(\"if(!(\")\n\u0009do @buildExpr(ast.cond)\n\u0009do @codes.add(\")){throw \\{excpt@dbgAssertFailed $ bit32};}\\n\")\nend func\n\nfunc buildExpr(ast: \\ast@AstExpr)\n\u0009switch(ast.typeId)\n\u0009case %expr1\n\u0009\u0009do @buildExpr1(ast $ \\ast@AstExpr1)\n\u0009case %expr2\n\u0009\u0009do @buildExpr2(ast $ \\ast@AstExpr2)\n\u0009case %expr3\n\u0009\u0009do @buildExpr3(ast $ \\ast@AstExpr3)\n\u0009case %exprNew\n\u0009\u0009do @buildExprNew(ast $ \\ast@AstExprNew)\n\u0009case %exprNewArray\n\u0009\u0009do @buildExprNewArray(ast $ \\ast@AstExprNewArray)\n\u0009case %exprAs\n\u0009\u0009do @buildExprAs(ast $ \\ast@AstExprAs)\n\u0009case %exprToBin\n\u0009\u0009do @buildExprToBin(ast $ \\ast@AstExprToBin)\n\u0009case %exprFromBin\n\u0009\u0009do @buildExprFromBin(ast $ \\ast@AstExprFromBin)\n\u0009case %exprCall\n\u0009\u0009do @buildExprCall(ast $ \\ast@AstExprCall)\n\u0009case %exprArray\n\u0009\u0009do @buildExprArray(ast $ \\ast@AstExprArray)\n\u0009case %exprDot\n\u0009\u0009do @buildExprDot(ast $ \\ast@AstExprDot)\n\u0009case %exprValue\n\u0009\u0009do @buildExprValue(ast $ \\ast@AstExprValue)\n\u0009case %exprValuePrim\n\u0009\u0009do @buildExprValuePrim(ast $ \\ast@AstExprValuePrim)\n\u0009case %exprValueStr\n\u0009\u0009do @buildExprValueStr(ast $ \\ast@AstExprValueStr)\n\u0009case %exprValueFloat\n\u0009\u0009do @buildExprValueFloat(ast $ \\ast@AstExprValueFloat)\n\u0009case %exprValueArray\n\u0009\u0009do @buildExprValueArray(ast $ \\ast@AstExprValueArray)\n\u0009case %exprRef\n\u0009\u0009do @buildExprRef(ast $ \\ast@AstExpr)\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExpr1(ast: \\ast@AstExpr1)\n\u0009assert ast.varKind <> %unknown\n\u0009switch(ast.kind)\n\u0009case %plus\n\u0009\u0009do @buildExpr(ast.child)\n\u0009case %minus\n\u0009\u0009do @codes.add(\"-(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %not\n\u0009\u0009do @codes.add(\"!(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %copy\n\u0009\u0009var typeId: []char :: @makeTypeId(ast.child.type)\n\u0009\u0009do @codes.add(\"C_(\\{typeId},(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\"))\")\n\u0009case %len\n\u0009\u0009var type: \\ast@AstType :: ast.child.type\n\u0009\u0009if(type.typeId = %typeGen)\n\u0009\u0009\u0009switch((type $ \\ast@AstTypeGen).kind)\n\u0009\u0009\u0009case %list_\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009do @codes.add(\").L\")\n\u0009\u0009\u0009case %stack_\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009do @codes.add(\").length\")\n\u0009\u0009\u0009case %queue_\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009do @codes.add(\").length\")\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009elif(type.typeId = %typeDict)\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009do @codes.add(\").size\")\n\u0009\u0009else\n\u0009\u0009\u0009assert type.typeId = %typeArray\n\u0009\u0009\u0009if(\\ast@isChar((type $ \\ast@AstTypeArray).itemType))\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009do @codes.add(\").S.length\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009do @codes.add(\").length\")\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExpr2(ast: \\ast@AstExpr2)\n\u0009assert ast.varKind <> %unknown\n\u0009var type: \\ast@AstType :: ast.children0.type\n\u0009switch(ast.kind)\n\u0009case %assign\n\u0009\u0009if(ast.children0.typeId = %exprArray & \\ast@isChar((ast.children0 $ \\ast@AstExprArray).type))\n\u0009\u0009\u0009var ast2: \\ast@AstExprArray :: ast.children0 $ \\ast@AstExprArray\n\u0009\u0009\u0009var tmpIdx: []char :: @addTmpVar(ast2.idx.type)\n\u0009\u0009\u0009var tmpChar: []char :: @addTmpVar(ast2.type)\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast2.var_)\n\u0009\u0009\u0009do @codes.add(\").S=(\\{tmpIdx}=(\")\n\u0009\u0009\u0009do @buildExpr(ast2.idx)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast2.var_)\n\u0009\u0009\u0009do @codes.add(\").S.slice(0,\\{tmpIdx})+String.fromCharCode(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")+(\")\n\u0009\u0009\u0009do @buildExpr(ast2.var_)\n\u0009\u0009\u0009do @codes.add(\").S.slice(\\{tmpIdx}+1))\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")=(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %or\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")||(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %and\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")&&(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %lt\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S<(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009elif(\\ast@isRef(type))\n\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))<0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")<(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %gt\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S>(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009elif(\\ast@isRef(type))\n\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))>0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")>(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %le\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S<=(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009elif(\\ast@isRef(type))\n\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))<=0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")<=(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %ge\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S>=(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009elif(\\ast@isRef(type))\n\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))>=0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")>=(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %eq\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S===(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009elif(\\ast@isRef(type))\n\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))==0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")===(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %nEq\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S!==(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S\")\n\u0009\u0009elif(\\ast@isRef(type))\n\u0009\u0009\u0009; TODO:\n\u0009\u0009\u0009do @codes.add(\"cmp_((\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\"))!=0\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\")!==(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %eqRef\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")===(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %nEqRef\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")!==(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %cat\n\u0009\u0009if(\\ast@isStr(type))\n\u0009\u0009\u0009do @codes.add(\"{S:(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").S+(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\").S}\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009\u0009do @codes.add(\").concat(\")\n\u0009\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %add\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")+(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %sub\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")-(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %mul\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")*(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %div\n\u0009\u0009if(!\\ast@isFloat(type))\n\u0009\u0009\u0009do @codes.add(\"~~(\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")/(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009if(!\\ast@isFloat(type))\n\u0009\u0009\u0009do @codes.add(\"))\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009end if\n\u0009case %mod\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")%(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %pow\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")**(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")\")\n\u0009case %swap\n\u0009\u0009var tmpVar: []char :: @addTmpVar(type)\n\u0009\u0009do @codes.add(\"\\{tmpVar}=(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009do @buildExpr(ast.children0)\n\u0009\u0009do @codes.add(\")=(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\"),(\")\n\u0009\u0009do @buildExpr(ast.children1)\n\u0009\u0009do @codes.add(\")=(\\{tmpVar})\")\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExpr3(ast: \\ast@AstExpr3)\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"(\")\n\u0009do @buildExpr(ast.children0)\n\u0009do @codes.add(\")?(\")\n\u0009do @buildExpr(ast.children1)\n\u0009do @codes.add(\"):(\")\n\u0009do @buildExpr(ast.children2)\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprNew(ast: \\ast@AstExprNew)\n\u0009assert ast.varKind <> %unknown\n\u0009if(\\ast@isClass(ast.itemType))\n\u0009\u0009var class_: \\ast@AstClass :: ast.itemType.refItem $ \\ast@AstClass\n\u0009\u0009var id: []char :: @refClass(class_)\n\u0009\u0009do @codes.add(\"new \\{id}()\")\n\u0009else\n\u0009\u0009if(ast.itemType.typeId = %typeGen)\n\u0009\u0009\u0009var gen: \\ast@AstTypeGen :: ast.itemType $ \\ast@AstTypeGen\n\u0009\u0009\u0009switch(gen.kind)\n\u0009\u0009\u0009case %list_\n\u0009\u0009\u0009\u0009do @codes.add(\"{L:0,H:null,T:null,P:null}\")\n\u0009\u0009\u0009case %stack_\n\u0009\u0009\u0009\u0009do @codes.add(\"[]\")\n\u0009\u0009\u0009case %queue_\n\u0009\u0009\u0009\u0009do @codes.add(\"[]\")\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009assert false\n\u0009\u0009\u0009end switch\n\u0009\u0009else\n\u0009\u0009\u0009assert ast.itemType.typeId = %typeDict\n\u0009\u0009\u0009do @codes.add(\"new Map()\")\n\u0009\u0009end if\n\u0009end if\nend func\n\nfunc buildExprNewArray(ast: \\ast@AstExprNewArray)\n\u0009assert ast.varKind <> %unknown\n\u0009block\n\u0009\u0009var items: list<\\ast@AstExpr> :: ast.idces\n\u0009\u0009do items.head()\n\u0009\u0009if(\\ast@isChar(ast.itemType))\n\u0009\u0009\u0009if(^items = 1)\n\u0009\u0009\u0009\u0009do @codes.add(\"{S:\\\"\\\\0\\\".repeat(\")\n\u0009\u0009\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009\u0009\u0009do @codes.add(\")}\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"(function A_(n){if(n.length===1)return{S:\\\"\\\\0\\\".repeat(\\{@getDefaultValue(ast.itemType)})}else{let a=new Array(n[0]),m=n.shift(),i;for(i=0;i<n[0];i++)a[i]=A_(m);return a}})([\")\n\u0009\u0009\u0009\u0009var first: bool :: true\n\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\",(\")\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @codes.add(\"])\")\n\u0009\u0009\u0009end if\n\u0009\u0009else\n\u0009\u0009\u0009if(^items = 1)\n\u0009\u0009\u0009\u0009do @codes.add(\"new Array(\")\n\u0009\u0009\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009\u0009\u0009do @codes.add(\").fill(\\{@getDefaultValue(ast.itemType)})\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\"(function A_(n){if(n.length===1)return new Array(n[0]).fill(\\{@getDefaultValue(ast.itemType)})else{let a=new Array(n[0]),m=n.shift(),i;for(i=0;i<n[0];i++)a[i]=A_(m);return a}})([\")\n\u0009\u0009\u0009\u0009var first: bool :: true\n\u0009\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009\u0009do @codes.add(\",(\")\n\u0009\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009do @codes.add(\"])\")\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009end block\nend func\n\nfunc buildExprAs(ast: \\ast@AstExprAs)\n\u0009assert ast.varKind <> %unknown\n\u0009switch(ast.kind)\n\u0009case %as\n\u0009\u0009var t1: \\ast@AstType :: ast.child.type\n\u0009\u0009var t2: \\ast@AstType :: ast.childType\n\u0009\u0009if(\\ast@isClass(t1))\n\u0009\u0009\u0009assert \\ast@isClass(t2)\n\u0009\u0009\u0009do @refClass(t2.refItem $ \\ast@AstClass)\n\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009else\n\u0009\u0009\u0009if(t1.typeId = %typeBit | \\ast@isInt(t1) | \\ast@isChar(t1) | \\ast@isEnum(t1))\n\u0009\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2) | \\ast@isChar(t2) | \\ast@isEnum(t2) | \\ast@isFloat(t2))\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert \\ast@isBool(t2)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")!=0\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009elif(\\ast@isFloat(t1))\n\u0009\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2))\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"~~(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert \\ast@isFloat(t2)\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009assert \\ast@isBool(t1)\n\u0009\u0009\u0009\u0009if(t2.typeId = %typeBit | \\ast@isInt(t2))\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")?1:0\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009assert \\ast@isBool(t2)\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009case %is\n\u0009\u0009do @refClass(ast.childType.refItem $ \\ast@AstClass)\n\u0009\u0009var info: @WebInfo :: @getInfo(ast.childType.refItem)\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")instanceof \\{info.id}\")\n\u0009case %nIs\n\u0009\u0009do @refClass(ast.childType.refItem $ \\ast@AstClass)\n\u0009\u0009var info: @WebInfo :: @getInfo(ast.childType.refItem)\n\u0009\u0009do @codes.add(\"!((\")\n\u0009\u0009do @buildExpr(ast.child)\n\u0009\u0009do @codes.add(\")instanceof \\{info.id})\")\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc buildExprToBin(ast: \\ast@AstExprToBin)\n\u0009; TODO:\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"toBin_(\")\n\u0009do @buildExpr(ast.child)\n\u0009do @codes.add(\")\")\nend func\n\nfunc buildExprFromBin(ast: \\ast@AstExprFromBin)\n\u0009; TODO:\n\u0009assert ast.varKind <> %unknown\n\u0009do @codes.add(\"fromBin_((\")\n\u0009do @buildExpr(ast.child)\n\u0009do @codes.add(\"),(\")\n\u0009do @buildExpr(ast.offset)\n\u0009do @codes.add(\"))\")\nend func\n\nfunc buildExprCall(ast: \\ast@AstExprCall)\n\u0009assert ast.varKind <> %unknown\n\u0009var funcType: \\ast@AstTypeFunc :: ast.func_.type $ \\ast@AstTypeFunc\n\u0009var meTypeId: []char :: null\n\u0009if(funcType <>& null & funcType.funcOption.and(%any) = %any)\n\u0009\u0009var items: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009do meTypeId :: @makeTypeId(items.get().arg.type)\n\u0009end if\n\u0009var refNum: int :: 0\n\u0009block\n\u0009\u0009var items: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009if(items.get().refVar)\n\u0009\u0009\u0009\u0009do refNum :+ 1\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009var resultVar: []char :: null\n\u0009var refVar: [][]char :: null\n\u0009if(refNum > 0)\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009if(ast.type <>& null)\n\u0009\u0009\u0009do resultVar :: @addTmpVar(ast.type)\n\u0009\u0009\u0009do @codes.add(\"\\{resultVar}=\")\n\u0009\u0009end if\n\u0009\u0009do refVar :: #[refNum][]char\n\u0009end if\n\u0009do @codes.add(\"(\")\n\u0009do @buildExpr(ast.func_)\n\u0009do @codes.add(\")(\")\n\u0009block\n\u0009\u0009var idx: int :: 0\n\u0009\u0009var refCnt: int :: 0\n\u0009\u0009var first: bool :: true\n\u0009\u0009var items: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009do items.head()\n\u0009\u0009while(!items.term())\n\u0009\u0009\u0009var item: \\ast@AstExprCallArg :: items.get()\n\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @codes.add(\",(\")\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009if(meTypeId <>& null & idx = 1)\n\u0009\u0009\u0009\u0009do @codes.add(meTypeId)\n\u0009\u0009\u0009elif(item.refVar)\n\u0009\u0009\u0009\u0009do refVar[refCnt] :: @addTmpVar(item.arg.type)\n\u0009\u0009\u0009\u0009do @codes.add(\"\\{refVar[refCnt]}={$:(\")\n\u0009\u0009\u0009\u0009do @buildExpr(item.arg)\n\u0009\u0009\u0009\u0009do @codes.add(\")},\\{refVar[refCnt]}\")\n\u0009\u0009\u0009\u0009do refCnt :+ 1\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do @buildExpr(item.arg)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do @codes.add(\")\")\n\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009\u0009do items.next()\n\u0009\u0009end while\n\u0009end block\n\u0009do @codes.add(\")\")\n\u0009if(refNum > 0)\n\u0009\u0009block\n\u0009\u0009\u0009var idx: int :: 0\n\u0009\u0009\u0009var refCnt: int :: 0\n\u0009\u0009\u0009var items: list<\\ast@AstExprCallArg> :: ast.args\n\u0009\u0009\u0009do items.head()\n\u0009\u0009\u0009while(!items.term())\n\u0009\u0009\u0009\u0009var item: \\ast@AstExprCallArg :: items.get()\n\u0009\u0009\u0009\u0009if(meTypeId <>& null & idx = 1)\n\u0009\u0009\u0009\u0009\u0009; Do nothing.\n\u0009\u0009\u0009\u0009elif(item.refVar)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\",(\")\n\u0009\u0009\u0009\u0009\u0009do @buildExpr(item.arg)\n\u0009\u0009\u0009\u0009\u0009do @codes.add(\")=\\{refVar[refCnt]}.$\")\n\u0009\u0009\u0009\u0009\u0009do refCnt :+ 1\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do idx :+ 1\n\u0009\u0009\u0009\u0009do items.next()\n\u0009\u0009\u0009end while\n\u0009\u0009end block\n\u0009\u0009if(ast.type <>& null)\n\u0009\u0009\u0009do @codes.add(\",\\{resultVar}\")\n\u0009\u0009end if\n\u0009\u0009do @codes.add(\")\")\n\u0009end if\n\u0009\n\u0009block\n\u0009\u0009var type: \\ast@AstType :: ast.type\n\u0009\u0009if(type <>& null)\n\u0009\u0009\u0009if(\\ast@isClass(type))\n\u0009\u0009\u0009\u0009do @refClass(type.refItem $ \\ast@AstClass)\n\u0009\u0009\u0009end if\n\u0009\u0009end if\n\u0009end block\nend func\n\nfunc buildExprArray(ast: \\ast@AstExprArray)\n\u0009assert ast.varKind <> %unknown\n\u0009if(\\ast@isChar(ast.type))\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.var_)\n\u0009\u0009do @codes.add(\").S.charCodeAt(\")\n\u0009\u0009do @buildExpr(ast.idx)\n\u0009\u0009do @codes.add(\")\")\n\u0009else\n\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009do @buildExpr(ast.var_)\n\u0009\u0009do @codes.add(\")[\")\n\u0009\u0009do @buildExpr(ast.idx)\n\u0009\u0009do @codes.add(\"]\")\n\u0009end if\nend func\n\nfunc buildExprDot(ast: \\ast@AstExprDot)\n\u0009assert ast.varKind <> %unknown\n\u0009if(\\ast@isClass(ast.var_.type))\n\u0009\u0009var classItem: \\ast@AstClassItem :: ast.classItem\n\u0009\u0009assert classItem <>& null\n\u0009\u0009do @refClass(ast.var_.type.refItem $ \\ast@AstClass)\n\u0009\u0009var info: @WebInfo\n\u0009\u0009if(classItem.def.typeId = %var_)\n\u0009\u0009\u0009do info :: @getInfo((classItem.def $ \\ast@AstVar).arg)\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009\u0009do @buildExpr(ast.var_)\n\u0009\u0009\u0009do @codes.add(\").\\{info.id}\")\n\u0009\u0009else\n\u0009\u0009\u0009assert classItem.def.typeId = %func_\n\u0009\u0009\u0009do info :: @getInfo(classItem.def)\n\u0009\u0009\u0009; \'ast.var_\' is calculated elsewhere.\n\u0009\u0009\u0009do @codes.add(\"\\{info.id}\")\n\u0009\u0009end if\n\u0009else\n\u0009\u0009assert ast.refItem.typeId = %exprRef\n\u0009\u0009do @buildExprRef(ast.refItem $ \\ast@AstExpr)\n\u0009end if\nend func\n\nfunc buildExprValue(ast: \\ast@AstExprValue)\n\u0009assert ast.type.typeId = %typeNull\n\u0009do @codes.add(\"null\")\nend func\n\nfunc buildExprValuePrim(ast: \\ast@AstExprValuePrim)\n\u0009var type: \\ast@AstType :: ast.type\n\u0009if(\\ast@isInt(type) | \\ast@isEnum(type))\n\u0009\u0009do @codes.add((ast.value $ int).toStr())\n\u0009elif(\\ast@isChar(type))\n\u0009\u0009do @codes.add((ast.value $ bit16).toStr())\n\u0009elif(\\ast@isBool(type))\n\u0009\u0009do @codes.add(ast.value = 0b64 ?(\"false\", \"true\"))\n\u0009elif(type.typeId = %typeBit)\n\u0009\u0009switch((type $ \\ast@AstTypeBit).size)\n\u0009\u0009case 1\n\u0009\u0009\u0009do @codes.add((ast.value $ bit8).toStr())\n\u0009\u0009case 2\n\u0009\u0009\u0009do @codes.add((ast.value $ bit16).toStr())\n\u0009\u0009case 4\n\u0009\u0009\u0009do @codes.add((ast.value $ bit32).toStr())\n\u0009\u0009case 8\n\u0009\u0009\u0009do @codes.add((ast.value $ bit64).toStr())\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009else\n\u0009\u0009assert false\n\u0009end if\nend func\n\nfunc buildExprValueStr(ast: \\ast@AstExprValueStr)\n\u0009var value: []char :: ast.value\n\u0009var s: []char :: \"{S:\\\"\"\n\u0009for i(0, ^value - 1)\n\u0009\u0009do s :~ @escapeChar(value[i])\n\u0009end for\n\u0009do s :~ \"\\\"}\"\n\u0009do @codes.add(s)\nend func\n\nfunc buildExprValueFloat(ast: \\ast@AstExprValueFloat)\n\u0009var value: []char :: ast.value.toStr()\n\u0009if(value = \"inf\")\n\u0009\u0009do @codes.add(\"Infinity\")\n\u0009else\n\u0009\u0009do @codes.add(value)\n\u0009end if\nend func\n\nfunc buildExprValueArray(ast: \\ast@AstExprValueArray)\n\u0009; Note that constant string values are handled by \'ExprValueStr\'.\n\u0009do @codes.add(\"[\")\n\u0009var first: bool :: true\n\u0009var items: list<\\ast@AstExpr> :: ast.values\n\u0009do items.head()\n\u0009while(!items.term())\n\u0009\u0009if(first)\n\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009do @codes.add(\"(\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(\",(\")\n\u0009\u0009end if\n\u0009\u0009do @buildExpr(items.get())\n\u0009\u0009do @codes.add(\")\")\n\u0009\u0009do items.next()\n\u0009end while\n\u0009do @codes.add(\"]\")\nend func\n\nfunc buildExprRef(ast: \\ast@AstExpr)\n\u0009var ast2: \\ast@Ast :: ast.refItem\n\u0009var info: @WebInfo :: @getInfo(ast2)\n\u0009if(ast2.typeId = %func_)\n\u0009\u0009do @funcs.add(ast2 $ \\ast@AstFunc)\n\u0009\u0009do @codes.add(info.id)\n\u0009else\n\u0009\u0009assert ast2.typeId = %arg\n\u0009\u0009var arg: \\ast@AstArg :: ast2 $ \\ast@AstArg\n\u0009\u0009switch(arg.kind)\n\u0009\u0009case %global\n\u0009\u0009\u0009if(!info.alreadyWritten)\n\u0009\u0009\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009\u0009\u0009do @globalVars.add(arg)\n\u0009\u0009\u0009end if\n\u0009\u0009case %localArg\n\u0009\u0009\u0009; Do nothing.\n\u0009\u0009case %localVar\n\u0009\u0009\u0009if(!info.alreadyWritten)\n\u0009\u0009\u0009\u0009do info.alreadyWritten :: true\n\u0009\u0009\u0009\u0009do @localVars.add(arg)\n\u0009\u0009\u0009end if\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009\u0009if(arg.refVar)\n\u0009\u0009\u0009do @codes.add(\"\\{info.id}.$\")\n\u0009\u0009else\n\u0009\u0009\u0009do @codes.add(info.id)\n\u0009\u0009end if\n\u0009end if\nend func\n\nfunc write(resFiles: list<[]char>)\n\u0009var writer: file@Writer\n\u0009if(\\option@extra.get(\"merge\", &))\n\u0009\u0009var fileName: []char :: file@fileName(\\option@outputFile)\n\u0009\u0009do writer :: file@makeWriter(\\option@outputFile ~ \".html\", false)\n\u0009\u0009do writer.writeStr(\"<!DOCTYPE html>\\n\")\n\u0009\u0009do writer.writeStr(\"<html>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t<head>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t\\t<meta charset=\\\"utf-8\\\" />\\n\")\n\u0009\u0009do writer.writeStr(\"\\t\\t<title>\\{fileName}</title>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t\\t<script type=\\\"text/javascript\\\">\\n\")\n\u0009\u0009do writeJs(writer, resFiles)\n\u0009\u0009do writer.writeStr(\"\\t\\t</script>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t</head>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t<body>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t</body>\\n\")\n\u0009\u0009do writer.writeStr(\"</html>\\n\")\n\u0009\u0009do writer.fin()\n\u0009else\n\u0009\u0009do writer :: file@makeWriter(\\option@outputFile ~ \".js\", false)\n\u0009\u0009do writeJs(writer, resFiles)\n\u0009\u0009do writer.fin()\n\u0009\u0009\n\u0009\u0009var fileName: []char :: file@fileName(\\option@outputFile)\n\u0009\u0009do writer :: file@makeWriter(\\option@outputFile ~ \".html\", false)\n\u0009\u0009do writer.writeStr(\"<!DOCTYPE html>\\n\")\n\u0009\u0009do writer.writeStr(\"<html>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t<head>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t\\t<meta charset=\\\"utf-8\\\" />\\n\")\n\u0009\u0009do writer.writeStr(\"\\t\\t<script src=\\\"\\{fileName}.js\\\" type=\\\"text/javascript\\\"></script>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t\\t<title>\\{fileName}</title>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t</head>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t<body>\\n\")\n\u0009\u0009do writer.writeStr(\"\\t</body>\\n\")\n\u0009\u0009do writer.writeStr(\"</html>\\n\")\n\u0009\u0009do writer.fin()\n\u0009end if\n\u0009\n\u0009func writeJs(writer: file@Writer, resFiles: list<[]char>)\n\u0009\u0009var static: bool :: \\option@extra.get(\"static\", &)\n\u0009\u0009if(static)\n\u0009\u0009\u0009do writer.writeStr(\"\\\"use strict\\\";function \\{file@fileName(\\option@outputFile)}(O_){\\n\")\n\u0009\u0009else\n\u0009\u0009\u0009do writer.writeStr(\"\\\"use strict\\\";!function(f){let d=document;function h(){d.removeEventListener(\\\"DOMContentLoaded\\\",h);removeEventListener(\\\"load\\\",h);f()}\\\"complete\\\"===d.readyState||\\\"loading\\\"!==d.readyState&&!d.documentElement.doScroll?setTimeout(f):(d.addEventListener(\\\"DOMContentLoaded\\\",h),addEventListener(\\\"load\\\",h))}(function(){\\n\")\n\u0009\u0009\u0009do writer.writeStr(\"let O_;\\n\")\n\u0009\u0009end if\n\u0009\u0009\n\u0009\u0009do @globalVars.head()\n\u0009\u0009while(!@globalVars.term())\n\u0009\u0009\u0009var globalVar: \\ast@AstArg :: @globalVars.get()\n\u0009\u0009\u0009var info: @WebInfo :: @getInfo(globalVar)\n\u0009\u0009\u0009do writer.writeStr(\"let \\{info.id}=\\{@getDefaultValue(globalVar.type)};\\n\")\n\u0009\u0009\u0009do @globalVars.next()\n\u0009\u0009end while\n\u0009\u0009do @codes.head()\n\u0009\u0009while(!@codes.term())\n\u0009\u0009\u0009do writer.writeStr(@codes.get())\n\u0009\u0009\u0009do @codes.next()\n\u0009\u0009end while\n\u0009\u0009\n\u0009\u0009do writer.writeStr(\"function C_(t,v){\\n\")\n\u0009\u0009do writer.writeStr(\"switch(t[0]){\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%int_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%float_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%char_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%bool_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%bit8_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%bit16_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%bit32_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%bit64_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%func_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%enum_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"return v;\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%array $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do writer.writeStr(\"if(t[1]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do writer.writeStr(\"return v===null?null:{S:v.S};\\n\")\n\u0009\u0009do writer.writeStr(\"else{\\n\")\n\u0009\u0009do writer.writeStr(\"let a=new Array(v.length);\\n\")\n\u0009\u0009do writer.writeStr(\"for(let i=0;i<v.length;i++)a[i]=C_(t.slice(1),v[i]);\\n\")\n\u0009\u0009do writer.writeStr(\"return a;\\n\")\n\u0009\u0009do writer.writeStr(\"}\\n\")\n\u0009\u0009do writer.writeStr(\"case \\{%list_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do writer.writeStr(\"case \\{%stack_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do writer.writeStr(\"case \\{%queue_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do writer.writeStr(\"case \\{%dict_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do writer.writeStr(\"case \\{%class_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do writer.writeStr(\"}\\n\")\n\u0009\u0009do writer.writeStr(\"}\\n\")\n\u0009\u0009\n\u0009\u0009do writer.writeStr(\"function F_(p,f){\\n\")\n\u0009\u0009block\n\u0009\u0009\u0009var first: bool :: true\n\u0009\u0009\u0009do resFiles.head()\n\u0009\u0009\u0009while(!resFiles.term())\n\u0009\u0009\u0009\u0009var resFile: []char :: resFiles.get()\n\u0009\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(\"if(p===\\\"\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(\"else if(p===\\\"\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009for i(^\\option@inputDir, ^resFile - 1)\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(@escapeChar(resFile[i]))\n\u0009\u0009\u0009\u0009end for\n\u0009\u0009\u0009\u0009do writer.writeStr(\"\\\")\\n\")\n\u0009\u0009\u0009\u0009if(resFile[^resFile - 1] = \'/\')\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(\"return f?null:true;\\n\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(\"return f?\\\"\")\n\u0009\u0009\u0009\u0009\u0009var reader: file@Reader :: file@makeReader(resFile)\n\u0009\u0009\u0009\u0009\u0009while(!reader.term())\n\u0009\u0009\u0009\u0009\u0009\u0009var line: []char :: reader.readLine()\n\u0009\u0009\u0009\u0009\u0009\u0009for i(0, ^line - 1)\n\u0009\u0009\u0009\u0009\u0009\u0009\u0009do writer.writeStr(@escapeChar(line[i]))\n\u0009\u0009\u0009\u0009\u0009\u0009end for\n\u0009\u0009\u0009\u0009\u0009\u0009do writer.writeStr(\"\\\\n\")\n\u0009\u0009\u0009\u0009\u0009end while\n\u0009\u0009\u0009\u0009\u0009do reader.fin()\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(\"\\\":true;\\n\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009do resFiles.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009if(^resFiles > 0)\n\u0009\u0009\u0009\u0009do writer.writeStr(\"else return f?null:false;\\n\")\n\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009do writer.writeStr(\"return f?null:false;\\n\")\n\u0009\u0009\u0009end if\n\u0009\u0009end block\n\u0009\u0009do writer.writeStr(\"}\\n\")\n\u0009\u0009\n\u0009\u0009block\n\u0009\u0009\u0009do writer.writeStr(\"function FF_(){return[\")\n\u0009\u0009\u0009var first: bool :: true\n\u0009\u0009\u0009do resFiles.head()\n\u0009\u0009\u0009while(!resFiles.term())\n\u0009\u0009\u0009\u0009var resFile: []char :: resFiles.get()\n\u0009\u0009\u0009\u0009if(first)\n\u0009\u0009\u0009\u0009\u0009do first :: false\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(\"\\\"\")\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(\",\\\"\")\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009\u0009for i(^\\option@inputDir, ^resFile - 1)\n\u0009\u0009\u0009\u0009\u0009do writer.writeStr(@escapeChar(resFile[i]))\n\u0009\u0009\u0009\u0009end for\n\u0009\u0009\u0009\u0009do writer.writeStr(\"\\\"\")\n\u0009\u0009\u0009\u0009do resFiles.next()\n\u0009\u0009\u0009end while\n\u0009\u0009\u0009do writer.writeStr(\"];}\\n\")\n\u0009\u0009end block\n\u0009\u0009\n\u0009\u0009do writer.writeStr(\"a();\\n\")\n\u0009\u0009if(static)\n\u0009\u0009\u0009do writer.writeStr(\"}\\n\")\n\u0009\u0009else\n\u0009\u0009\u0009do writer.writeStr(\"})\\n\")\n\u0009\u0009end if\n\u0009end func\nend func\n\nfunc getId(): []char\n\u0009var curId: []char :: @uniqueId\n\u0009var newId: []char :: ##@uniqueId\n\u0009while loop2(true)\n\u0009\u0009var idx: int :: ^newId - 1\n\u0009\u0009while loop(true)\n\u0009\u0009\u0009switch(newId[idx])\n\u0009\u0009\u0009case \'z\'\n\u0009\u0009\u0009\u0009do newId[idx] :: idx = 0 ?(\'A\', \'0\')\n\u0009\u0009\u0009case \'9\'\n\u0009\u0009\u0009\u0009do newId[idx] :: \'A\'\n\u0009\u0009\u0009case \'Z\'\n\u0009\u0009\u0009\u0009if(idx = 0)\n\u0009\u0009\u0009\u0009\u0009do newId :: #[^newId + 1]char\n\u0009\u0009\u0009\u0009\u0009do newId.fill(\'a\')\n\u0009\u0009\u0009\u0009else\n\u0009\u0009\u0009\u0009\u0009do newId[idx] :: \'a\'\n\u0009\u0009\u0009\u0009\u0009do idx :- 1\n\u0009\u0009\u0009\u0009\u0009skip loop\n\u0009\u0009\u0009\u0009end if\n\u0009\u0009\u0009default\n\u0009\u0009\u0009\u0009do newId[idx] :: newId[idx].offset(1)\n\u0009\u0009\u0009end switch\n\u0009\u0009\u0009break loop\n\u0009\u0009end while\n\u0009\u0009switch(^newId)\n\u0009\u0009case 2\n\u0009\u0009\u0009switch(newId)\n\u0009\u0009\u0009case \"do\", \"if\", \"in\"\n\u0009\u0009\u0009\u0009skip loop2\n\u0009\u0009\u0009end switch\n\u0009\u0009case 3\n\u0009\u0009\u0009switch(newId)\n\u0009\u0009\u0009case \"for\", \"let\", \"new\", \"try\", \"var\", \"Map\", \"NaN\", \"Set\"\n\u0009\u0009\u0009\u0009skip loop2\n\u0009\u0009\u0009end switch\n\u0009\u0009case 4\n\u0009\u0009\u0009switch(newId)\n\u0009\u0009\u0009case \"case\", \"else\", \"enum\", \"eval\", \"name\", \"null\", \"this\", \"true\", \"void\", \"with\", \"Date\", \"Intl\", \"JSON\", \"Math\"\n\u0009\u0009\u0009\u0009skip loop2\n\u0009\u0009\u0009end switch\n\u0009\u0009end switch\n\u0009\u0009break loop2\n\u0009end while\n\u0009do @uniqueId :: newId\n\u0009ret curId\nend func\n\n+func getInfo(ast: \\ast@Ast): @WebInfo\n\u0009if(ast.extra =& null | ast.extra.typeId <> %info)\n\u0009\u0009var info: @WebInfo :: #@WebInfo\n\u0009\u0009do info.typeId :: %info\n\u0009\u0009do info.id :: @getId()\n\u0009\u0009if(ast.typeId.and(%statBreakable) = %statBreakable & ast.name <>& null & ast.name <> \"$\")\n\u0009\u0009\u0009do info.breakSkipLabel :: @getId()\n\u0009\u0009else\n\u0009\u0009\u0009do info.breakSkipLabel :: null\n\u0009\u0009end if\n\u0009\u0009do info.alreadyWritten :: false\n\u0009\u0009do ast.extra :: info\n\u0009end if\n\u0009ret ast.extra $ @WebInfo\nend func\n\nfunc addTmpVar(type: \\ast@AstType): []char\n\u0009var tmpVar: @TmpVar :: #@TmpVar\n\u0009do tmpVar.identifier :: @getId()\n\u0009do tmpVar.type :: type\n\u0009do @tmpVars.add(tmpVar)\n\u0009ret tmpVar.identifier\nend func\n\nfunc refClass(ast: \\ast@AstClass): []char\n\u0009var info: @WebInfo :: @getInfo(ast)\n\u0009if(info.alreadyWritten)\n\u0009\u0009ret info.id\n\u0009end if\n\u0009do info.alreadyWritten :: true\n\u0009if(ast.refItem <>& null)\n\u0009\u0009do @refClass(ast.refItem $ \\ast@AstClass)\n\u0009end if\n\u0009do @classes.add(ast)\n\u0009ret info.id\nend func\n\nfunc getDefaultValue(type: \\ast@AstType): []char\n\u0009if(\\ast@isNullable(type))\n\u0009\u0009ret \"null\"\n\u0009end if\n\u0009switch(type.typeId)\n\u0009case %typeUser\n\u0009\u0009assert \\ast@isEnum(type)\n\u0009\u0009ret \"0\"\n\u0009case %typeBit\n\u0009\u0009ret \"0\"\n\u0009case %typePrim\n\u0009\u0009switch((type $ \\ast@AstTypePrim).kind)\n\u0009\u0009case %int_, %char_\n\u0009\u0009\u0009ret \"0\"\n\u0009\u0009case %float_\n\u0009\u0009\u0009ret \"0\"\n\u0009\u0009case %bool_\n\u0009\u0009\u0009ret \"false\"\n\u0009\u0009default\n\u0009\u0009\u0009assert false\n\u0009\u0009end switch\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\nend func\n\nfunc makeTypeId(type: \\ast@AstType): []char\n\u0009var result: []char :: \"[\"\n\u0009var first: bool :: true\n\u0009var items: list<int> :: \\convert@getTypeId(type)\n\u0009do items.head()\n\u0009while(!items.term())\n\u0009\u0009if(first)\n\u0009\u0009\u0009do first :: false\n\u0009\u0009else\n\u0009\u0009\u0009do result :~ \",\"\n\u0009\u0009end if\n\u0009\u0009do result :~ items.get().toStr()\n\u0009\u0009do items.next()\n\u0009end while\n\u0009do result :~ \"]\"\n\u0009ret result\nend func\n\nfunc escapeChar(c: char): []char\n\u0009switch(c)\n\u0009case \'\"\'\n\u0009\u0009ret \"\\\\\\\"\"\n\u0009case \'\\\'\'\n\u0009\u0009ret \"\\\\\'\"\n\u0009case \'\\\\\'\n\u0009\u0009ret \"\\\\\\\\\"\n\u0009case \' \' to \'~\'\n\u0009\u0009ret c.toStr()\n\u0009default\n\u0009\u0009ret \"\\\\u\\{(c $ bit16).toStr().sub(2, -1)}\"\n\u0009end switch\nend func\n":true;
else if(p==="res/web/raw_funcs.kn")
return f?"+func write(codes: list<[]char>, attr: []char, args: list<\\ast@AstArg>, members: list<\\ast@AstClassItem>)\n\u0009switch(attr)\n\u0009case \"addr\"\n\u0009\u0009; TODO:\n\u0009case \"addDict\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var key: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{meType.id}[1]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[2]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.set(\\{key.id}.S, \\{item.id});\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.set(\\{key.id}, \\{item.id});\\n\")\n\u0009case \"addList\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let n_={P:null,N:null,I:\\{item.id}};\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}.H===null){\\{me_.id}.H=n_;\\{me_.id}.T=n_}else{n_.P=\\{me_.id}.T;\\{me_.id}.T.N=n_;\\{me_.id}.T=n_}\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.L++;\\n\")\n\u0009case \"addQueue\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}.push(\\{item.id});\\n\")\n\u0009case \"addStack\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}.push(\\{item.id});\\n\")\n\u0009case \"and\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}&\\{n.id};\\n\")\n\u0009case \"cmdLine\"\n\u0009\u0009do codes.add(\"let r_=(O_&&O_.cmdLine)?O_.cmdLine:location.search.slice(1).split(\\\"&\\\");\\n\")\n\u0009\u0009do codes.add(\"if(r_.length===1&&r_[0]===\\\"\\\")return[];\\n\")\n\u0009\u0009do codes.add(\"for(let i_=0;i_<r_.length;i_++)\\n\")\n\u0009\u0009do codes.add(\"r_[i_]={S:r_[i_]};\\n\")\n\u0009\u0009do codes.add(\"return r_;\\n\")\n\u0009case \"del\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let p_=\\{me_.id}.P;\\n\")\n\u0009\u0009do codes.add(\"if(p_.P===null)\\{me_.id}.H=p_.N;else p_.P.N=p_.N;\\n\")\n\u0009\u0009do codes.add(\"if(p_.N===null)\\{me_.id}.T=p_.P;else p_.N.P=p_.P;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.P=p_.N;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.L--;\\n\")\n\u0009case \"fill\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var value: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{meType.id}[0]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[1]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.S=String.fromCharCode(\\{value.id}).repeat(\\{me_.id}.S.length);\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.fill(\\{value.id});\\n\")\n\u0009case \"findArray\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var start: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{meType.id}[0]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[1]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.S.indexOf(String.fromCharCode(\\{item.id}),\\{start.id}===-1?0:\\{start.id});\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.indexOf(\\{item.id},\\{start.id}===-1?0:\\{start.id});\\n\")\n\u0009case \"findBin\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let a_=0,b_=\\{me_.id}.length-1,c_,m_,f_;\\n\")\n\u0009\u0009do codes.add(\"switch(\\{meType.id}[0]){\\n\")\n\u0009\u0009do codes.add(\"case \\{%int_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%float_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%char_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit8_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit16_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit32_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit64_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%enum_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"f_=function(a,b){return a>b?1:a<b?-1:0};\\n\")\n\u0009\u0009do codes.add(\"break;\\n\")\n\u0009\u0009do codes.add(\"case \\{%array $ \\convert@runtimeTypeId $ int}:\\n\") {TODO:}\n\u0009\u0009do codes.add(\"f_=function(a,b){return a.S>b.S?1:a.S<b.S?-1:0};\\n\")\n\u0009\u0009do codes.add(\"break;\\n\")\n\u0009\u0009do codes.add(\"default:\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"break;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"while (a_<=b_){\\n\")\n\u0009\u0009do codes.add(\"c_=~~((a_+b_)/2);\\n\")\n\u0009\u0009do codes.add(\"m_=f_(\\{item.id},\\{me_.id}[c_]);\\n\")\n\u0009\u0009do codes.add(\"if(m_<0)b_=c_-1;\\n\")\n\u0009\u0009do codes.add(\"else if(m_>0)a_=c_+1;\\n\")\n\u0009\u0009do codes.add(\"else return c_;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return -1;\\n\")\n\u0009case \"forEach\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var callback: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var data: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let D_={F:\\{callback.id},D:\\{data.id},C:true};\\n\")\n\u0009\u0009do codes.add(\"if(\\{meType.id}[1]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[2]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.forEach(function(V_,K_){if(this.C)this.C=this.F({S:K_},V_,this.D)},D_);\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.forEach(function(V_,K_){if(this.C)this.C=this.F(K_,V_,this.D)},D_);\\n\")\n\u0009\u0009do codes.add(\"return D_.C;\\n\")\n\u0009case \"getDict\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var key: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var existed: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let r_;\\n\")\n\u0009\u0009do codes.add(\"if(\\{meType.id}[1]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[2]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"r_=\\{me_.id}.get(\\{key.id}.S);\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"r_=\\{me_.id}.get(\\{key.id});\\n\")\n\u0009\u0009do codes.add(\"if(!(\\{existed.id}.$=r_!==undefined)){\\n\")\n\u0009\u0009do codes.add(\"switch(\\{meType.id}){\\n\")\n\u0009\u0009do codes.add(\"case \\{%int_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%float_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%char_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit8_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit16_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit32_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit64_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%enum_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return 0;\\n\")\n\u0009\u0009do codes.add(\"case \\{%bool_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return false;\\n\")\n\u0009\u0009do codes.add(\"default:\\n\")\n\u0009\u0009do codes.add(\"return null;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return r_;\\n\")\n\u0009case \"getList\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}.P.I;\\n\")\n\u0009case \"getQueue\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}.shift();\\n\")\n\u0009case \"getStack\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}.pop();\\n\")\n\u0009case \"head\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}.P=\\{me_.id}.H;\\n\")\n\u0009case \"idx\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let p_=\\{me_.id}.H,i_=0;\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}.P===null)return -1;\\n\")\n\u0009\u0009do codes.add(\"while(p_!==null){\\n\")\n\u0009\u0009do codes.add(\"if(p_===\\{me_.id}.P)return i_\\n\")\n\u0009\u0009do codes.add(\"i_++;\\n\")\n\u0009\u0009do codes.add(\"p_=p_.N;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return -1;\\n\")\n\u0009case \"ins\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var item: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let p_=\\{me_.id}.P;\\n\")\n\u0009\u0009do codes.add(\"let n_={P:p_.P,N:p_,I:\\{item.id}}\\n\")\n\u0009\u0009do codes.add(\"if(p_.P===null)\\{me_.id}.H=n_;else p_.P.N=n_;\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}.T===null)\\{me_.id}.T=n_;\\n\")\n\u0009\u0009do codes.add(\"p_.P=n_;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.L++;\\n\")\n\u0009case \"moveOffset\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var offset: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{offset.id}>=0){\\n\")\n\u0009\u0009do codes.add(\"for(let i_=0;i_<\\{offset.id};i_++){\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}.P===null)break;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.P=\\{me_.id}.P.N;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"for(let i_=0;i_>\\{offset.id};i_--){\\n\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}.P===null)break;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.P=\\{me_.id}.P.P;\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"next\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}.P=\\{me_.id}.P.N;\\n\")\n\u0009case \"or\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}|\\{n.id};\\n\")\n\u0009case \"peekQueue\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}[0];\\n\")\n\u0009case \"peekStack\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}[\\{me_.id}.length-1];\\n\")\n\u0009case \"rnd\"\n\u0009\u0009do args.head()\n\u0009\u0009var min: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var max: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return ~~(Math.random()*(\\{max.id}-\\{min.id}+1))+\\{min.id};\\n\")\n\u0009case \"rndFloat\"\n\u0009\u0009do args.head()\n\u0009\u0009var min: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var max: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return Math.random()*(\\{max.id}-\\{min.id})+\\{min.id};\\n\")\n\u0009case \"sub\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var meType: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var start: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var len: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{meType.id}[0]===\\{%array $ \\convert@runtimeTypeId $ int}&&\\{meType.id}[1]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"return {S:\\{len.id}===-1?\\{me_.id}.S.slice(\\{start.id}):\\{me_.id}.S.slice(\\{start.id},\\{start.id}+\\{len.id})};\\n\")\n\u0009\u0009do codes.add(\"else\\n\")\n\u0009\u0009do codes.add(\"return \\{len.id}===-1?\\{me_.id}.slice(\\{start.id}):\\{me_.id}.slice(\\{start.id},\\{start.id}+\\{len.id});\\n\")\n\u0009case \"sysTime\"\n\u0009\u0009do codes.add(\"return new Date().getTime();\\n\")\n\u0009case \"tail\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"\\{me_.id}.P=\\{me_.id}.T;\\n\")\n\u0009case \"term\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"return \\{me_.id}.P===null;\\n\")\n\u0009case \"toBit64\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var success: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{me_.id}.S.length>=2&&\\{me_.id}.S[0]===\\\"0\\\"&&\\{me_.id}.S[1]===\\\"x\\\"){\\n\")\n\u0009\u0009do codes.add(\"let s_=\\{me_.id}.S.slice(2),r_=Number(\\{me_.id}.S);\\n\")\n\u0009\u0009do codes.add(\"\\{success.id}.$=!isNaN(r_);\\n\")\n\u0009\u0009do codes.add(\"return parseInt(s_,16);\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"let r_=Number(\\{me_.id}.S);\\n\")\n\u0009\u0009do codes.add(\"\\{success.id}.$=!isNaN(r_);\\n\")\n\u0009\u0009do codes.add(\"return parseInt(\\{me_.id}.S,10);\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"toFloat\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var success: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let r_=Number(\\{me_.id}.S);\\n\")\n\u0009\u0009do codes.add(\"\\{success.id}.$=!isNaN(r_);\\n\")\n\u0009\u0009do codes.add(\"return r_;\\n\")\n\u0009case \"toInt\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var success: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(\\{me_.id}.S.length>=2&&\\{me_.id}.S[0]===\\\"0\\\"&&\\{me_.id}.S[1]===\\\"x\\\"){\\n\")\n\u0009\u0009do codes.add(\"let s_=\\{me_.id}.S.slice(2),r_=Number(\\{me_.id}.S);\\n\")\n\u0009\u0009do codes.add(\"\\{success.id}.$=!isNaN(r_);\\n\")\n\u0009\u0009do codes.add(\"return parseInt(s_,16);\\n\")\n\u0009\u0009do codes.add(\"}else{\\n\")\n\u0009\u0009do codes.add(\"let r_=Number(\\{me_.id}.S);\\n\")\n\u0009\u0009do codes.add(\"\\{success.id}.$=!isNaN(r_);\\n\")\n\u0009\u0009do codes.add(\"return parseInt(\\{me_.id}.S,10);\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"toStr\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var type: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let n_;\\n\")\n\u0009\u0009do codes.add(\"switch(\\{type.id}[0]){\\n\")\n\u0009\u0009do codes.add(\"case \\{%int_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%float_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"case \\{%enum_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return{S:\\{me_.id}.toString(10)};\\n\")\n\u0009\u0009do codes.add(\"case \\{%char_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return{S:String.fromCharCode(\\{me_.id})};\\n\")\n\u0009\u0009do codes.add(\"case \\{%bool_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"return{S:\\{me_.id}?\\\"true\\\":\\\"false\\\"};\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit8_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"n_=\\{me_.id}>=0?~~\\{me_.id}&0xFF:0xFF-(~\\{me_.id}&0xFF);\\n\")\n\u0009\u0009do codes.add(\"return{S:\\\"0x\\\"+(\\\"00\\\"+n_.toString(16)).slice(-2).toUpperCase()};\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit16_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"n_=\\{me_.id}>=0?~~\\{me_.id}&0xFFFF:0xFFFF-(~\\{me_.id}&0xFFFF);\\n\")\n\u0009\u0009do codes.add(\"return{S:\\\"0x\\\"+(\\\"0000\\\"+n_.toString(16)).slice(-4).toUpperCase()};\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit32_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"n_=\\{me_.id}>>>0;\\n\")\n\u0009\u0009do codes.add(\"return{S:\\\"0x\\\"+(\\\"00000000\\\"+n_.toString(16)).slice(-8).toUpperCase()};\\n\")\n\u0009\u0009do codes.add(\"case \\{%bit64_ $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"n_=\\{me_.id}>>>0;\\n\")\n\u0009\u0009do codes.add(\"return{S:\\\"0x\\\"+((\\{me_.id}>=0?\\\"0000000000000000\\\":\\\"FFFFFFFFFFFFFFFF\\\")+n_.toString(16)).slice(-16).toUpperCase()};\\n\")\n\u0009\u0009do codes.add(\"case \\{%array $ \\convert@runtimeTypeId $ int}:\\n\")\n\u0009\u0009do codes.add(\"if(\\{type.id}[1]===\\{%char_ $ \\convert@runtimeTypeId $ int})\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id};\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009case \"cui_print\"\n\u0009\u0009do args.head()\n\u0009\u0009var str: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"if(O_&&O_.print){O_.print(\\{str.id}.S);return;}\\n\")\n\u0009\u0009do codes.add(\"console.log(\\{str.id}.S);\\n\")\n\u0009case \"file_copyFile\"\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"return false;\\n\")\n\u0009case \"file_exist\"\n\u0009\u0009do args.head()\n\u0009\u0009var path: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let f_=false,p_=\\{path.id}.S;\\n\")\n\u0009\u0009do codes.add(\"if(O_&&O_.readFile)f_=O_.readFile(p_)!==null;\\n\")\n\u0009\u0009do codes.add(\"if(f_===false){\\n\")\n\u0009\u0009do codes.add(\"if(p_.length>=4&&p_[0]===\\\"r\\\"&&p_[1]===\\\"e\\\"&&p_[2]===\\\"s\\\"&&p_[3]===\\\"/\\\")\\n\")\n\u0009\u0009do codes.add(\"f_=F_(p_,false);\\n\")\n\u0009\u0009do codes.add(\"else{\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return f_;\\n\")\n\u0009case \"file_forEach\"\n\u0009\u0009do args.head()\n\u0009\u0009var path: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var recursion: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var callback: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var data: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do codes.add(\"let f_,p_=\\{path.id}.S;\\n\")\n\u0009\u0009do codes.add(\"if(p_.length>=4&&p_[0]===\\\"r\\\"&&p_[1]===\\\"e\\\"&&p_[2]===\\\"s\\\"&&p_[3]===\\\"/\\\")\\n\")\n\u0009\u0009do codes.add(\"f_=FF_();\\n\")\n\u0009\u0009do codes.add(\"for(let i_=0;i_<f_.length;i_++){\\n\")\n\u0009\u0009do codes.add(\"if(f_[i_].slice(0,p_.length)===p_&&(\\{recursion.id}||f_[i_].slice(p_.length).indexOf(\\\"/\\\")===-1)){\\n\")\n\u0009\u0009do codes.add(\"if(!\\{callback.id}({S:f_[i_]},f_[i_][f_[i_].length-1]===\'/\',\\{data.id}))return false\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"return true;\\n\")\n\u0009case \"file_makeReader\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var path: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"let f_=null,p_=\\{path.id}.S;\\n\")\n\u0009\u0009do codes.add(\"if(O_&&O_.readFile)f_=O_.readFile(p_);\\n\")\n\u0009\u0009do codes.add(\"if(f_===null){\\n\")\n\u0009\u0009do codes.add(\"if(p_.length>=4&&p_[0]===\\\"r\\\"&&p_[1]===\\\"e\\\"&&p_[2]===\\\"s\\\"&&p_[3]===\\\"/\\\")\\n\")\n\u0009\u0009do codes.add(\"f_=F_(p_,true);\\n\")\n\u0009\u0009do codes.add(\"else{\\n\")\n\u0009\u0009; TODO:\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"if(f_===null)return null;\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}={F:f_,I:0};\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id};\\n\")\n\u0009case \"file_makeWriter\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var path: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var append: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}={F:\\\"\\\",I:0,P:\\{path.id}.S};\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id};\\n\")\n\u0009case \"file_readerFin\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.F=null;\\n\")\n\u0009case \"file_readerGetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.\\{handle.id}.I;\\n\")\n\u0009case \"file_readerReadLetter\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.\\{handle.id}.F.charCodeAt(\\{me_.id}.\\{handle.id}.I++);\\n\")\n\u0009case \"file_readerSetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var origin: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var pos: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.I=\\{pos.id};\\n\")\n\u0009case \"file_readerTerm\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.\\{handle.id}.I>=\\{me_.id}.\\{handle.id}.F.length;\\n\")\n\u0009case \"file_writerFin\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"var d_=\\{me_.id}.\\{handle.id}.F.replace(\\\"\\\\n\\\", \\\"\\\\u000D\\\\n\\\");\\n\")\n\u0009\u0009do codes.add(\"if(O_&&O_.writeFile){O_.writeFile(\\{me_.id}.\\{handle.id}.P,d_);return;}\\n\")\n\u0009\u0009do codes.add(\"let b_=new Blob([d_]);\\n\")\n\u0009\u0009do codes.add(\"let l_=document.createElement(\\\"a\\\");\\n\")\n\u0009\u0009do codes.add(\"l_.download=\\{me_.id}.\\{handle.id}.P;\\n\")\n\u0009\u0009do codes.add(\"l_.href=(URL||webkitURL).createObjectURL(b_);\\n\")\n\u0009\u0009do codes.add(\"l_.setAttribute(\\\"style\\\",\\\"display:none\\\");\\n\")\n\u0009\u0009do codes.add(\"document.body.appendChild(l_);\\n\")\n\u0009\u0009do codes.add(\"l_.click();\\n\")\n\u0009\u0009do codes.add(\"document.body.removeChild(l_);\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.F=null;\\n\")\n\u0009case \"file_writerGetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.\\{handle.id}.I;\\n\")\n\u0009case \"file_writerSetPos\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var origin: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var pos: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.I=\\{pos.id};\\n\")\n\u0009case \"file_writerWrite\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009; TODO:\n\u0009case \"file_writerWriteChar\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var n: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"if(\\{me_.id}.\\{handle.id}.I<\\{me_.id}.\\{handle.id}.F.length)\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.F=\\{me_.id}.\\{handle.id}.F.slice(0,\\{me_.id}.\\{handle.id}.I)+String.fromCharCode(\\{n.id})+\\{me_.id}.\\{handle.id}.F.slice(\\{me_.id}.\\{handle.id}.I+1);\\n\")\n\u0009\u0009do codes.add(\"else{\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.F+=String.fromCharCode(\\{n.id});\\n\")\n\u0009\u0009do codes.add(\"}\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}.I++;\\n\")\n\u0009case \"wnd_editBaseGetText\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"return \\{me_.id}.\\{handle.id}.H.value;\\n\")\n\u0009case \"wnd_makeEditMulti\"\n\u0009\u0009do args.head()\n\u0009\u0009var me_: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var parent: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var x: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var y: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var width: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var height: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var anchorX: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009do args.next()\n\u0009\u0009var anchorY: \\web\\output@WebInfo :: \\web\\output@getInfo(args.get())\n\u0009\u0009var handle: \\web\\output@WebInfo :: search(members, \"handle\")\n\u0009\u0009do codes.add(\"let h_=document.createElement(\\\"textarea\\\");\\n\")\n\u0009\u0009do codes.add(\"h_.setAttribute(\\\"cols\\\",\\\"\\{width.id}\\\");\\n\")\n\u0009\u0009do codes.add(\"h_.setAttribute(\\\"rows\\\",\\\"\\{height.id}\\\");\\n\")\n\u0009\u0009do codes.add(\"document.body.appendChild(c_);\\n\")\n\u0009\u0009do codes.add(\"\\{me_.id}.\\{handle.id}={C:c_};\\n\")\n\u0009\u0009do codes.add(\"return \\{me_.id};\\n\")\n\u0009default\n\u0009\u0009assert false\n\u0009end switch\n\u0009\n\u0009func search(members: list<\\ast@AstClassItem>, name: []char): \\web\\output@WebInfo\n\u0009\u0009do members.head()\n\u0009\u0009while(!members.term())\n\u0009\u0009\u0009var def: \\ast@Ast :: members.get().def\n\u0009\u0009\u0009if(def.typeId = %var_ & (def $ \\ast@AstVar).arg.name <>& null & (def $ \\ast@AstVar).arg.name = name)\n\u0009\u0009\u0009\u0009ret \\web\\output@getInfo((def $ \\ast@AstVar).arg)\n\u0009\u0009\u0009end if\n\u0009\u0009\u0009do members.next()\n\u0009\u0009end while\n\u0009\u0009assert false\n\u0009\u0009ret null\n\u0009end func\nend func\n":true;
else return f?null:false;
}
function FF_(){return["res/","res/analyze.kn","res/ast.kn","res/builtin_func.kn","res/convert.kn","res/cpp/","res/cpp/output.kn","res/cpp/raw_funcs.kn","res/err.kn","res/main.kn","res/msg.kn","res/option.kn","res/parse.kn","res/pos.kn","res/sys/","res/sys/common.h","res/sys/cui.kn","res/sys/dbg.kn","res/sys/excpt.kn","res/sys/file.kn","res/sys/kuin.kn","res/sys/lib.kn","res/sys/preset00_cui.knp","res/sys/preset00_wnd.knp","res/sys/preset01_cui.knp","res/sys/preset01_wnd.knp","res/sys/preset02_cui.knp","res/sys/preset02_wnd.knp","res/sys/preset03_cui.knp","res/sys/preset03_wnd.knp","res/sys/wnd.kn","res/test.kn","res/web/","res/web/output.kn","res/web/raw_funcs.kn"];}
a();
}
