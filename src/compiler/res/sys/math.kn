func [d0003.knd, _init] _init()
end func

+func gcd(a: int, b: int): int
	if(a = 0)
		ret b
	end if
	if(b = 0)
		ret a
	end if
	if(a < 0)
		do a :: -a
	end if
	if(b < 0)
		do b :: -b
	end if
	var r: int :: 0
	while loop(true)
		do r :: a % b
		if(r = 0)
			ret b
		end if
		do a :: b
		do b :: r
	end while
end func

+func lcm(a: int, b: int): int
	var g: int :: @gcd(a,b)
	if(g = 0)
		ret 0
	end if
	ret a/g*b
end func

+func modPow(value: int, exponent: int, modulus: int): int
	if(value < 0)
		throw excpt@dbgArgOutDomain
	end if
	if(exponent < 0)
		throw excpt@dbgArgOutDomain
	end if
	if(modulus < 0)
		throw excpt@dbgArgOutDomain
	end if
	var result: int :: 1
	while loop(exponent > 0)
		if(exponent%2 <> 0)
			do result :: @modMul(result,value,modulus)
		end if
		do value :: @modMul(value,value,modulus)
		do exponent :/ 2
	end while
	ret result
end func

+func modMul(a: int, b: int, modulus: int): int
	if(a < 0)
		throw excpt@dbgArgOutDomain
	end if
	if(b < 0)
		throw excpt@dbgArgOutDomain
	end if
	if(modulus < 0)
		throw excpt@dbgArgOutDomain
	end if
	var result: int :: 0
	while loop(a <> 0)
		if(a%2 <> 0)
			do result :: (result+b)%modulus
		end if
		do a :/ 2
		do b :: (b*2)%modulus
	end while
	ret result
end func

+func [__raw, math_prime] prime(n: int): bool
end func

+func [__raw, math_primeFactors] primeFactors(n: int): []int
end func

+func [__raw, math_gamma] gamma(n: float): float
end func

+func fact(n: float): float
	ret @gamma(n+1.0)
end func

+func factInt(n: int): int
	if(n < 0)
		throw excpt@dbgArgOutDomain
	end if
	if(n > 20)
		throw excpt@dbgIntOverflow
	end if
	var result: int :: 1
	for i(1..n)
		result :* i
	end for
	ret result
end func

+func fibonacci(n: int): int
	if(n < 0)
		throw excpt@dbgArgOutDomain
	end if
	if(n > 92)
		throw excpt@dbgIntOverflow
	end if
	var a: int :: 0
	var b: int :: 1
	for i(1..n)
		var t: int :: a+b
		do a :: b
		do b :: t
	end for
	ret b
end func

+func [__raw, math_knapsack] knapsack(weights: []int, values: []int, maxWeight: int, reuse: bool): int
end func

+func [__raw, math_dijkstra] dijkstra(nodeNum: int, fromNodes: []int, toNodes: []int, values: []int, beginNode: int): []int
end func

+func [__raw, math_bellmanFord] bellmanFord(nodeNum: int, fromNodes: []int, toNodes: []int, values: []int, beginNode: int): []int
end func

+func [d0003.knd, _floydWarshall] floydWarshall(nodeNum: int, fromNodes: []int, toNodes: []int, values: []int): [][]int
end func

{
+class Mat()
	*func [d0003.knd, _matDtor, _force] _dtor()
	end func

	var row: int
	var col: int
	var buf: int
end class

+func [d0003.knd, _makeMat, _make_instance] makeMat(me2: @Mat, row: int, col: int): @Mat
end func
}
