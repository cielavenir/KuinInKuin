func [d0003.knd, _init] _init()
end func

+func gcd(a: int, b: int): int
	if(a = 0)
		ret b
	end if
	if(b = 0)
		ret a
	end if
	if(a < 0)
		do a :: -a
	end if
	if(b < 0)
		do b :: -b
	end if
	var r: int :: 0
	while loop(true)
		do r :: a % b
		if(r = 0)
			ret b
		end if
		do a :: b
		do b :: r
	end while
end func

+func lcm(a: int, b: int): int
	var g: int :: @gcd(a,b)
	if(g = 0)
		ret 0
	end if
	ret a/g*b
end func

+func [__raw, math_modPow] modPow(value: int, exponent: int, modulus: int): int
end func

+func [__raw, math_modMul] modMul(a: int, b: int, modulus: int): int
end func

+func [__raw, math_prime] prime(n: int): bool
end func

+func [__raw, math_primeFactors] primeFactors(n: int): []int
end func

+func [__raw, math_gamma] gamma(n: float): float
end func

+func fact(n: float): float
	return @gamma(n+1.0)
end func

+func [__raw, math_factInt] factInt(n: int): int
end func

+func [__raw, math_fibonacci] fibonacci(n: int): int
end func

+func [__raw, math_knapsack] knapsack(weights: []int, values: []int, maxWeight: int, reuse: bool): int
end func

+func [__raw, math_dijkstra] dijkstra(nodeNum: int, fromNodes: []int, toNodes: []int, values: []int, beginNode: int): []int
end func

+func [__raw, math_bellmanFord] bellmanFord(nodeNum: int, fromNodes: []int, toNodes: []int, values: []int, beginNode: int): []int
end func

+func [d0003.knd, _floydWarshall] floydWarshall(nodeNum: int, fromNodes: []int, toNodes: []int, values: []int): [][]int
end func

{
+class Mat()
	*func [d0003.knd, _matDtor, _force] _dtor()
	end func

	var row: int
	var col: int
	var buf: int
end class

+func [d0003.knd, _makeMat, _make_instance] makeMat(me2: @Mat, row: int, col: int): @Mat
end func
}
