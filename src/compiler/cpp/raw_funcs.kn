+func write(codes: list<[]char>, attr: []char, args: list<\ast@AstArg>, members: list<\ast@AstClassItem>)
	switch(attr)
	case "addr"
		do args.head()
		var class_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return reinterpret_cast<uint64_t>(\{class_.id});\n")
	case "addDict"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		do args.next()
		var key: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->Add(\{key.id}, \{item.id});\n")
	case "addList"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->B.push_back(\{item.id});\n")
	case "addQueue"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->B.push(\{item.id});\n")
	case "addStack"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->B.push(\{item.id});\n")
	case "and"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id} & \{n.id};\n")
	case "del"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("auto& i_ = \{me_.id}->I++;\n")
		do codes.add("\{me_.id}->B.erase(i_);\n")
	case "fill"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var value: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("for(int64_t i_ = 0; i_ < \{me_.id}->L; i_++) \{me_.id}->B[i_] = \{value.id};\n")
	case "findArray"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var start: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("if(\{start.id} == -1) \{start.id} = 0;\n")
		do codes.add("if(\{start.id} < 0) return -1;\n")
		do codes.add("for(int64_t i_ = \{start.id}; i_ < \{me_.id}->L; i_++){\n")
		do codes.add("if(\{me_.id}->B[i_] == \{item.id}) return i_;\n")
		do codes.add("}\n")
		do codes.add("return -1;\n")
	case "findBin"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("int64_t a_ = 0, b_ = \{me_.id}->L - 1;\n")
		do codes.add("while (a_ <= b_) {\n")
		do codes.add("int64_t c_ = (a_ + b_) / 2;\n")
		do codes.add("int64_t m_ = cmp_(\{item.id}, \{me_.id}->B[c_]);\n")
		do codes.add("if(m_ < 0) b_ = c_ - 1;\n")
		do codes.add("else if(m_ > 0) a_ = c_ + 1;\n")
		do codes.add("else return c_;\n")
		do codes.add("}\n")
		do codes.add("return -1;\n")
	case "forEach"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var callback: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var data: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return dictForEach_(\{me_.id}->B, static_cast<bool(*)(K_, V_, Class_*)>(\{callback.id}), \{data.id});\n")
	case "getDict"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var key: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var existed: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return dictSearch_(\{me_.id}->B, \{key.id}, \{existed.id});\n")
	case "getList"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return *\{me_.id}->I;\n")
	case "getQueue"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("R_ r_ = \{me_.id}->B.front();\n")
		do codes.add("\{me_.id}->B.pop();\n")
		do codes.add("return r_;\n")
	case "getStack"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("R_ r_ = \{me_.id}->B.top();\n")
		do codes.add("\{me_.id}->B.pop();\n")
		do codes.add("return r_;\n")
	case "head"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->I = \{me_.id}->B.begin();\n")
	case "idx"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("int64_t i_ = 0;\n")
		do codes.add("for(auto& t_ = \{me_.id}->B.begin(); t_ != \{me_.id}->B.end(); ++t_){\n")
		do codes.add("if(t_ == \{me_.id}->I) return i_;\n")
		do codes.add("i_++;\n")
		do codes.add("}\n")
		do codes.add("return -1;\n")
	case "ins"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var item: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->B.insert(\{me_.id}->I, \{item.id});\n")
	case "moveOffset"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var offset: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("for(int64_t i_ = 0; i_ < \{offset.id}; i_++){\n")
		do codes.add("if(\{me_.id}->I == \{me_.id}->B.end()) break;\n")
		do codes.add("++\{me_.id}->I;\n")
		do codes.add("}\n")
	case "next"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("++\{me_.id}->I;\n")
	case "or"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id} | \{n.id};\n")
	case "peekQueue"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id}->B.front();\n")
	case "peekStack"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id}->B.top();\n")
	case "rnd"
		do args.head()
		var min: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var max: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return rnd_(\{min.id}, \{max.id});\n")
	case "rndFloat"
		do args.head()
		var min: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var max: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return rndFloat_(\{min.id}, \{max.id});\n")
	case "sub"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		do args.next()
		var start: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var len: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return sub_(\{me_.id}, \{start.id}, \{len.id});\n")
	case "sysTime"
		do codes.add("return static_cast<int64_t>(std::chrono::duration_cast<std::chrono::milliseconds>(std::chrono::system_clock::now().time_since_epoch()).count());\n")
	case "tail"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("\{me_.id}->I = \{me_.id}->B.end();\n")
		do codes.add("--\{me_.id}->I;\n")
	case "term"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return \{me_.id}->I == \{me_.id}->B.end();\n")
	case "toBit64"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var success: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("std::u16string s_ = \{me_.id}->B;\n")
		do codes.add("const std::string& t_ = utf16ToUtf8_(s_);\n")
		do codes.add("try{\n")
		do codes.add("size_t s_;\n")
		do codes.add("uint64_t v_ = t_.size() > 2 && t_[0] == '0' && t_[1] == 'x' ? std::stoull(t_, &s_, 16) : std::stoull(t_, &s_);\n")
		do codes.add("if(s_ == t_.size()){\n")
		do codes.add("*\{success.id} = true;\n")
		do codes.add("return v_;\n")
		do codes.add("}else{\n")
		do codes.add("*\{success.id} = false;\n")
		do codes.add("return 0;\n")
		do codes.add("}\n")
		do codes.add("}catch(...){\n")
		do codes.add("*\{success.id} = false;\n")
		do codes.add("return 0;\n")
		do codes.add("}\n")
	case "toFloat"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var success: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("std::u16string s_ = \{me_.id}->B;\n")
		do codes.add("const std::string& t_ = utf16ToUtf8_(s_);\n")
		do codes.add("try{\n")
		do codes.add("size_t s_;\n")
		do codes.add("double v_ = std::stod(t_, &s_);\n")
		do codes.add("if(s_ == t_.size()){\n")
		do codes.add("*\{success.id} = true;\n")
		do codes.add("return v_;\n")
		do codes.add("}else{\n")
		do codes.add("*\{success.id} = false;\n")
		do codes.add("return 0;\n")
		do codes.add("}\n")
		do codes.add("}catch(...){\n")
		do codes.add("*\{success.id} = false;\n")
		do codes.add("return 0;\n")
		do codes.add("}\n")
	case "toInt"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var success: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("std::u16string s_ = \{me_.id}->B;\n")
		do codes.add("const std::string& t_ = utf16ToUtf8_(s_);\n")
		do codes.add("try{\n")
		do codes.add("size_t s_;\n")
		do codes.add("int64_t v_ = t_.size() > 2 && t_[0] == '0' && t_[1] == 'x' ? std::stoll(t_, &s_, 16) : std::stoull(t_, &s_);\n")
		do codes.add("if(s_ == t_.size()){\n")
		do codes.add("*\{success.id} = true;\n")
		do codes.add("return v_;\n")
		do codes.add("}else{\n")
		do codes.add("*\{success.id} = false;\n")
		do codes.add("return 0;\n")
		do codes.add("}\n")
		do codes.add("}catch(...){\n")
		do codes.add("*\{success.id} = false;\n")
		do codes.add("return 0;\n")
		do codes.add("}\n")
	case "toStr"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return toStr_(\{me_.id});\n")
	case "cui_print"
		do args.head()
		var str: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("std::u16string s_ = \{str.id}->B;\n")
		do codes.add("const std::string& t_ = utf16ToUtf8_(s_);\n")
		do codes.add("std::cout << t_ << std::flush;\n")
	case "file_copyFile"
		do args.head()
		var dst: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var src: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do codes.add("return copyFile_(\{dst.id}->B, \{src.id}->B);\n")
	case "file_makeReader"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var path: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("\{me_.id}->\{handle.id} = reinterpret_cast<int64_t>(new reader_());\n")
		do codes.add("std::u16string s_ = \{path.id}->B;\n")
		do codes.add("const std::string& t_ = utf16ToUtf8_(s_);\n")
		do codes.add("reader_* r_ = reinterpret_cast<reader_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("r_->F = new std::ifstream(t_.c_str(), std::ios::in | std::ios::binary);\n")
		do codes.add("if(!*r_->F) return nullptr;\n")
		do codes.add("return \{me_.id};\n")
	case "file_makeWriter"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var path: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var append: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("\{me_.id}->\{handle.id} = reinterpret_cast<int64_t>(new writer_());\n")
		do codes.add("std::u16string s_ = \{path.id}->B;\n")
		do codes.add("const std::string& t_ = utf16ToUtf8_(s_);\n")
		do codes.add("writer_* r_ = reinterpret_cast<writer_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("r_->F = new std::ofstream(t_.c_str(), std::ios::out | std::ios::binary | (\{append.id} ? std::ios::app : std::ios::trunc));\n")
		do codes.add("if(!*r_->F) return nullptr;\n")
		do codes.add("return \{me_.id};\n")
	case "file_readerFin"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("reader_* r_ = reinterpret_cast<reader_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("r_->F->close();\n")
	case "file_readerGetPos"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("reader_* r_ = reinterpret_cast<reader_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("return static_cast<int64_t>(r_->F->tellg());\n")
	case "file_readerReadLetter"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("reader_* r_ = reinterpret_cast<reader_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("return readUtf8_(r_->F);\n")
	case "file_readerSetPos"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var origin: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var pos: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("reader_* r_ = reinterpret_cast<reader_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("std::ios_base::seekdir o_ = std::ios_base::beg;\n")
		do codes.add("switch(\{origin.id}){\n")
		do codes.add("case 0: o_ = std::ios_base::beg; break;\n")
		do codes.add("case 1: o_ = std::ios_base::cur; break;\n")
		do codes.add("case 2: o_ = std::ios_base::end; break;\n")
		do codes.add("}\n")
		do codes.add("r_->F->seekg(\{pos.id}, o_);\n")
	case "file_readerTerm"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("reader_* r_ = reinterpret_cast<reader_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("char c_;\n")
		do codes.add("if(r_->F->get(c_)) {\n")
		do codes.add("r_->F->seekg(-1, std::ios_base::cur);\n")
		do codes.add("return false;\n")
		do codes.add("}\n")
		do codes.add("return true;\n")
	case "file_writerFin"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("writer_* r_ = reinterpret_cast<writer_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("r_->F->close();\n")
	case "file_writerGetPos"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("writer_* r_ = reinterpret_cast<writer_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("return static_cast<int64_t>(r_->F->tellp());\n")
	case "file_writerSetPos"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var origin: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var pos: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("writer_* r_ = reinterpret_cast<writer_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("std::ios_base::seekdir o_ = std::ios_base::beg;\n")
		do codes.add("switch(\{origin.id}){\n")
		do codes.add("case 0: o_ = std::ios_base::beg; break;\n")
		do codes.add("case 1: o_ = std::ios_base::cur; break;\n")
		do codes.add("case 2: o_ = std::ios_base::end; break;\n")
		do codes.add("}\n")
		do codes.add("r_->F->seekp(\{pos.id}, o_);\n")
	case "file_writerWrite"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("writer_* r_ = reinterpret_cast<writer_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("r_->F->write(reinterpret_cast<char*>(\{n.id}->B), \{n.id}->L);\n")
	case "file_writerWriteChar"
		do args.head()
		var me_: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		do args.next()
		var n: \cpp\output@CppInfo :: \cpp\output@getInfo(args.get())
		var handle: \cpp\output@CppInfo :: search(members, "handle")
		do codes.add("writer_* r_ = reinterpret_cast<writer_*>(\{me_.id}->\{handle.id});\n")
		do codes.add("writeUtf8_(r_->F, \{n.id});\n")
	default
		assert false
	end switch
	
	func search(members: list<\ast@AstClassItem>, name: []char): \cpp\output@CppInfo
		do members.head()
		while(!members.term())
			var def: \ast@Ast :: members.get().def
			if(def.typeId = %var_ & (def $ \ast@AstVar).arg.name <>& null & (def $ \ast@AstVar).arg.name = name)
				ret \cpp\output@getInfo((def $ \ast@AstVar).arg)
			end if
			do members.next()
		end while
		assert false
		ret null
	end func
end func
