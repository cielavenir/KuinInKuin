const classTableItemSize: int :: 2

var funcs: queue<\ast@AstFunc>
var classes: queue<\ast@AstClass>

var uniqueId: []char
var codes: list<[]char>
var tmpVars: list<@TmpVar>
var globalVars: list<\ast@AstArg>
var localVars: list<\ast@AstArg>

+class WebInfo(\ast@HasType)
	+var id: []char
	+var breakSkipLabel: []char
	+var alreadyWritten: bool
end class

class TmpVar()
	+var identifier: []char
	+var type: \ast@AstType
end class

+func output(entry: \ast@AstFunc, resFiles: list<[]char>): bool
	do @funcs :: #queue<\ast@AstFunc>
	do @funcs.add(entry)
	do @classes :: #queue<\ast@AstClass>
	
	do @uniqueId :: "a"
	do @codes :: #list<[]char>
	do @tmpVars :: #list<@TmpVar>
	do @globalVars :: #list<\ast@AstArg>
	do @localVars :: #list<\ast@AstArg>
	
	while(^@funcs > 0 | ^@classes > 0)
		while(^@funcs > 0)
			var func_: \ast@AstFunc :: @funcs.get()
			do @buildFunc(func_)
		end while
		while(^@classes > 0)
			var class_: \ast@AstClass :: @classes.get()
			do @buildClass(class_)
		end while
	end while
	
	do @write(resFiles)
	
	ret true
end func

func buildFunc(ast: \ast@AstFunc)
	var info: @WebInfo :: @getInfo(ast)
	if(info.alreadyWritten)
		ret
	end if
	do info.alreadyWritten :: true
	
	var arg: []char :: ""
	block
		var first: bool :: true
		var items: list<\ast@AstArg> :: ast.args
		do items.head()
		while(!items.term())
			var item: \ast@AstArg :: items.get()
			var info2: @WebInfo :: @getInfo(item)
			if(first)
				do first :: false
			else
				do arg :~ ","
			end if
			do arg :~ "\{info2.id}"
			if(item.name <>& null)
				do arg :~ " /*\{item.name}*/"
			end if
			do items.next()
		end while
	end block
	
	if(ast.name <>& null)
		do @codes.add("// \{ast.name}\n")
	end if
	do @codes.add("function \{info.id}(\{arg}){\n")
	
	if(ast.funcOption.and(%raw) = %raw)
		if(^ast.funcAttr = 1)
			do ast.funcAttr.head()
			var hasMembers: bool :: false
			if(^ast.args > 0)
				do ast.args.head()
				var arg2: \ast@AstArg :: ast.args.get()
				if(arg2.type.refItem <>& null & arg2.type.refItem.typeId = %class_)
					var members: list<\ast@AstClassItem> :: (arg2.type.refItem $ \ast@AstClass).items
					do \web\raw_funcs@write(@codes, ast.funcAttr.get(), ast.args, members)
					do hasMembers :: true
				end if
			end if
			if(!hasMembers)
				do \web\raw_funcs@write(@codes, ast.funcAttr.get(), ast.args, null)
			end if
			do @codes.add("}\n")
		end if
	else
		do @codes.tail()
		var localVarPos: int :: @codes.idx()
		
		do @buildStats(ast.stats)
		
		do @codes.add("}\n")
		
		do @codes.head()
		do @codes.moveOffset(localVarPos)
		do @codes.next()
		do @localVars.head()
		while(!@localVars.term())
			var localVar: \ast@AstArg :: @localVars.get()
			var info2: @WebInfo :: @getInfo(localVar)
			if(localVar.name =& null)
				do @codes.ins("let \{info2.id}=\{@getDefaultValue(localVar.type)};\n")
			else
				do @codes.ins("let \{info2.id}=\{@getDefaultValue(localVar.type)}; // \{localVar.name}\n")
			end if
			do @localVars.del()
		end while
		do @tmpVars.head()
		while(!@tmpVars.term())
			var tmpVar: @TmpVar :: @tmpVars.get()
			do @codes.ins("let \{tmpVar.identifier}=\{@getDefaultValue(tmpVar.type)};\n")
			do @tmpVars.del()
		end while
	end if
end func

func buildClass(ast: \ast@AstClass)
	var parentId: []char :: null
	if(ast.refItem <>& null)
		do parentId :: @refClass(ast.refItem $ \ast@AstClass)
	end if
	if(parentId =& null)
		do parentId :: "Object"
	end if
	var info: @WebInfo :: @getInfo(ast)
	if(ast.name <>& null)
		do @codes.add("// \{ast.name}\n")
	end if
	block
		var ctor: \ast@AstFunc :: findFunc(ast, "ctor")
		do @codes.add("function \{info.id}(){\n")
		do @codes.add("\{parentId}.call(this);\n")
		if(ctor <>& null)
			var ctorInfo: @WebInfo :: @getInfo(ctor)
			do @codes.add("\{ctorInfo.id}(this);\n")
		end if
		do @codes.add("}\n")
	end block
	do @codes.add("\{info.id}.prototype = Object.create(\{parentId}.prototype);\n")
	block
		var items: list<\ast@AstClassItem> :: ast.items
		do items.head()
		while(!items.term())
			var item: \ast@AstClassItem :: items.get()
			if(item.def.typeId = %func_)
				do @funcs.add(item.def $ \ast@AstFunc)
			end if
			do items.next()
		end while
	end block
	; TODO: Destructor.
	
	func findFunc(ast: \ast@AstClass, name: []char): \ast@AstFunc
		var items: list<\ast@AstClassItem> :: ast.items
		do items.head()
		while(!items.term())
			var item: \ast@AstClassItem :: items.get()
			if(item.def.typeId = %func_ & item.def.name = name)
				ret item.def $ \ast@AstFunc
			end if
			do items.next()
		end while
		ret null
	end func
end func

func buildStats(stats: list<\ast@AstStat>)
	do stats.head()
	while(!stats.term())
		var stat: \ast@AstStat :: stats.get()
		switch(stat.typeId)
		case %statIf
			do @buildIf(stat $ \ast@AstStatIf)
		case %statSwitch
			do @buildSwitch(stat $ \ast@AstStatSwitch)
		case %statWhile
			do @buildWhile(stat $ \ast@AstStatWhile)
		case %statFor
			do @buildFor(stat $ \ast@AstStatFor)
		case %statTry
			do @buildTry(stat $ \ast@AstStatTry)
		case %statThrow
			do @buildThrow(stat $ \ast@AstStatThrow)
		case %statBlock
			do @buildBlock(stat $ \ast@AstStatBlock)
		case %statRet
			do @buildRet(stat $ \ast@AstStatRet)
		case %statDo
			do @buildDo(stat $ \ast@AstStatDo)
		case %statBreak
			do @buildBreak(stat $ \ast@AstStat)
		case %statSkip
			do @buildSkip(stat $ \ast@AstStat)
		case %statAssert
			do @buildAssert(stat $ \ast@AstStatAssert)
		default
			assert false
		end switch
		do stats.next()
	end while
end func

func buildIf(ast: \ast@AstStatIf)
	var infoMe: @WebInfo :: @getInfo(ast)
	if(ast.cond =& null)
		; Optimized code.
		if(infoMe.breakSkipLabel <>& null)
			do @codes.add("\{infoMe.breakSkipLabel}:{\n")
		end if
		do @buildBlock(ast.statBlock)
		if(infoMe.breakSkipLabel <>& null)
			do @codes.add("}\n")
		end if
		ret
	end if
	
	if(infoMe.breakSkipLabel <>& null)
		do @codes.add("\{infoMe.breakSkipLabel}:\n")
	end if
	do @codes.add("if(")
	do @buildExpr(ast.cond)
	do @codes.add("){\n")
	do @buildBlock(ast.statBlock)
	do @codes.add("}\n")
	block
		var items: list<\ast@AstStatElIf> :: ast.elIfs
		do items.head()
		while(!items.term())
			var item: \ast@AstStatElIf :: items.get()
			do @codes.add("else if(")
			do @buildExpr(item.cond)
			do @codes.add("){\n")
			do @buildBlock(item.statBlock)
			do @codes.add("}\n")
			do items.next()
		end while
	end block
	if(ast.elseStatBlock <>& null)
		do @codes.add("else{\n")
		do @buildBlock(ast.elseStatBlock)
		do @codes.add("}\n")
	end if
end func

func buildSwitch(ast: \ast@AstStatSwitch)
	var infoMe: @WebInfo :: @getInfo(ast)
	var info: @WebInfo :: @getInfo(ast.blockVar)
	if(!info.alreadyWritten)
		do info.alreadyWritten :: true
		do @localVars.add(ast.blockVar)
	end if
	var useSwitch: bool :: false
	if chk(\ast@isInt(ast.cond.type) | \ast@isChar(ast.cond.type) | \ast@isEnum(ast.cond.type) | ast.cond.type.typeId = %typeBit)
		do useSwitch :: true
		var items: list<\ast@AstStatCase> :: ast.cases
		do items.head()
		while(!items.term())
			var item: \ast@AstStatCase :: items.get()
			var items2: list<\ast@ExprPair> :: item.conds
			do items2.head()
			while(!items2.term())
				var exprs: \ast@ExprPair :: items2.get()
				if(exprs.expr0.typeId.and(%exprValue) <> %exprValue | exprs.expr1 <>& null)
					do useSwitch :: false
					break chk
				end if
				do items2.next()
			end while
			do items.next()
		end while
	end if
	if(useSwitch)
		if(infoMe.breakSkipLabel <>& null)
			do @codes.add("\{infoMe.breakSkipLabel}:\n")
		end if
		do @codes.add("switch(")
		do @buildExpr(ast.cond)
		do @codes.add("){\n")
		block
			var items: list<\ast@AstStatCase> :: ast.cases
			do items.head()
			while(!items.term())
				var item: \ast@AstStatCase :: items.get()
				var items2: list<\ast@ExprPair> :: item.conds
				do items2.head()
				while(!items2.term())
					var exprs: \ast@ExprPair :: items2.get()
					assert exprs.expr1 =& null
					do @codes.add("case ")
					do @buildExpr(exprs.expr0)
					do @codes.add(":\n")
					do items2.next()
				end while
				do @buildBlock(item.statBlock)
				do @codes.add("break;\n")
				do items.next()
			end while
		end block
		if(ast.defaultStatBlock <>& null)
			do @codes.add("default:\n")
			do @buildBlock(ast.defaultStatBlock)
			do @codes.add("break;\n")
		end if
		do @codes.add("}\n")
	else
		if(infoMe.breakSkipLabel <>& null)
			do @codes.add("\{infoMe.breakSkipLabel}:{\n")
		end if
		do @codes.add("\{info.id}=")
		do @buildExpr(ast.cond)
		do @codes.add(";\n")
		block
			var first: bool :: true
			var items: list<\ast@AstStatCase> :: ast.cases
			do items.head()
			while(!items.term())
				var item: \ast@AstStatCase :: items.get()
				if(first)
					do first :: false
					do @codes.add("if(")
				else
					do @codes.add("else if(")
				end if
				var first2: bool :: true
				var items2: list<\ast@ExprPair> :: item.conds
				do items2.head()
				while(!items2.term())
					var exprs: \ast@ExprPair :: items2.get()
					if(first2)
						do first2 :: false
					else
						do @codes.add("||")
					end if
					if(exprs.expr1 =& null)
						if(\ast@isStr(ast.cond.type))
							do @codes.add("\{info.id}.S===(")
							do @buildExpr(exprs.expr0)
							do @codes.add(").S")
						elif(\ast@isRef(ast.cond.type))
							; TODO:
							do @codes.add("cmp_(\{info.id},(")
							do @buildExpr(exprs.expr0)
							do @codes.add("))==0")
						else
							do @codes.add("\{info.id}===(")
							do @buildExpr(exprs.expr0)
							do @codes.add(")")
						end if
					else
						do @codes.add("(")
						do @buildExpr(exprs.expr0)
						do @codes.add(")<=\{info.id}&&\{info.id}<=(")
						do @buildExpr(exprs.expr1)
						do @codes.add(")")
					end if
					do items2.next()
				end while
				do @codes.add("){\n")
				do @buildBlock(item.statBlock)
				do @codes.add("}\n")
				do items.next()
			end while
		end block
		if(ast.defaultStatBlock <>& null)
			do @codes.add("else{")
			do @buildBlock(ast.defaultStatBlock)
			do @codes.add("}\n")
		end if
		if(infoMe.breakSkipLabel <>& null)
			do @codes.add("}\n")
		end if
	end if
end func

func buildWhile(ast: \ast@AstStatWhile)
	var infoMe: @WebInfo :: @getInfo(ast)
	if(ast.cond =& null)
		if(infoMe.breakSkipLabel <>& null)
			do @codes.add("\{infoMe.breakSkipLabel}:\n")
		end if
		do @codes.add("for(;;){\n")
		do @buildStats(ast.stats)
		do @codes.add("}\n")
		ret
	end if
	if(ast.skip_)
		if(infoMe.breakSkipLabel <>& null)
			do @codes.add("\{infoMe.breakSkipLabel}:\n")
		end if
		do @codes.add("do{\n")
		do @buildStats(ast.stats)
		do @codes.add("}while(")
		do @buildExpr(ast.cond)
		do @codes.add(");\n")
		ret
	end if
	if(infoMe.breakSkipLabel <>& null)
		do @codes.add("\{infoMe.breakSkipLabel}:\n")
	end if
	do @codes.add("while(")
	do @buildExpr(ast.cond)
	do @codes.add("){\n")
	do @buildStats(ast.stats)
	do @codes.add("}\n")
end func

func buildFor(ast: \ast@AstStatFor)
	var infoMe: @WebInfo :: @getInfo(ast)
	var info: @WebInfo :: @getInfo(ast.blockVar)
	if(!info.alreadyWritten)
		do info.alreadyWritten :: true
		do @localVars.add(ast.blockVar)
	end if
	var endId: []char :: @addTmpVar(ast.cond.type)
	if(infoMe.breakSkipLabel <>& null)
		do @codes.add("\{infoMe.breakSkipLabel}:\n")
	end if
	do @codes.add("for(\{info.id}=(")
	do @buildExpr(ast.start)
	do @codes.add("),\{endId}=(")
	do @buildExpr(ast.cond)
	do @codes.add(");\{info.id}")
	assert ast.step.typeId = %exprValuePrim & \ast@isInt(ast.cond.type)
	var step: int :: (ast.step $ \ast@AstExprValuePrim).value $ int
	if(step > 0)
		do @codes.add("<=")
	else
		do @codes.add(">=")
	end if
	do @codes.add("\{endId};\{info.id}")
	if(step > 0)
		do @codes.add("+=(")
	else
		do @codes.add("-=(")
	end if
	do @buildExpr(ast.step)
	do @codes.add(")){\n")
	do @buildStats(ast.stats)
	do @codes.add("}\n")
end func

func buildTry(ast: \ast@AstStatTry)
	var infoMe: @WebInfo :: @getInfo(ast)
	var info: @WebInfo :: @getInfo(ast.blockVar)
	if(!info.alreadyWritten)
		do info.alreadyWritten :: true
		do @localVars.add(ast.blockVar)
	end if
	if(infoMe.breakSkipLabel <>& null)
		do @codes.add("\{infoMe.breakSkipLabel}:\n")
	end if
	do @codes.add("try{\n")
	do @buildBlock(ast.statBlock)
	do @codes.add("}catch(\{info.id}){\n")
	block
		var first: bool :: true
		var items: list<\ast@AstStatCatch> :: ast.catches
		do items.head()
		while(!items.term())
			var item: \ast@AstStatCatch :: items.get()
			if(first)
				do first :: false
				do @codes.add("if(")
			else
				do @codes.add("else if(")
			end if
			var first2: bool :: true
			var items2: list<\ast@ExprPair> :: item.conds
			do items2.head()
			while(!items2.term())
				var exprs: \ast@ExprPair :: items2.get()
				if(first2)
					do first2 :: false
				else
					do @codes.add("||")
				end if
				if(exprs.expr1 =& null)
					do @codes.add("\{info.id}===(")
					do @buildExpr(exprs.expr0)
					do @codes.add(")")
				else
					do @codes.add("(")
					do @buildExpr(exprs.expr0)
					do @codes.add(")<=\{info.id}&&\{info.id}<=(")
					do @buildExpr(exprs.expr1)
					do @codes.add(")")
				end if
				do items2.next()
			end while
			do @codes.add("){\n")
			do @buildBlock(item.statBlock)
			do @codes.add("}\n")
			do items.next()
		end while
		if(first)
			do @codes.add("{\n")
		else
			do @codes.add("else{\n")
		end if
		do @codes.add("throw \{info.id};\n}\n")
	end block
	do @codes.add("}\n")
	if(ast.finallyStatBlock <>& null)
		do @codes.add("finally{\n")
		do @buildBlock(ast.finallyStatBlock)
		do @codes.add("}\n")
	end if
end func

func buildThrow(ast: \ast@AstStatThrow)
	do @codes.add("throw ")
	do @buildExpr(ast.code)
	do @codes.add(";\n")
end func

func buildBlock(ast: \ast@AstStatBlock)
	var infoMe: @WebInfo :: @getInfo(ast)
	if(infoMe.breakSkipLabel <>& null)
		do @codes.add("\{infoMe.breakSkipLabel}:{\n")
	end if
	do @buildStats(ast.stats)
	if(infoMe.breakSkipLabel <>& null)
		do @codes.add("}\n")
	end if
end func

func buildRet(ast: \ast@AstStatRet)
	if(ast.value =& null)
		do @codes.add("return;\n")
	else
		do @codes.add("return ")
		do @buildExpr(ast.value)
		do @codes.add(";\n")
	end if
end func

func buildDo(ast: \ast@AstStatDo)
	do @buildExpr(ast.expr)
	do @codes.add(";\n")
end func

func buildBreak(ast: \ast@AstStat)
	assert ast.refItem.typeId.and(%statBreakable) = %statBreakable
	var info: @WebInfo :: @getInfo(ast.refItem)
	do @codes.add("break \{info.breakSkipLabel};\n")
end func

func buildSkip(ast: \ast@AstStat)
	assert ast.refItem.typeId.and(%statSkipable) = %statSkipable
	var info: @WebInfo :: @getInfo(ast.refItem)
	do @codes.add("continue \{info.breakSkipLabel};\n")
end func

func buildAssert(ast: \ast@AstStatAssert)
	do @codes.add("if(!(")
	do @buildExpr(ast.cond)
	do @codes.add(")){throw \{excpt@dbgAssertFailed $ bit32};}\n")
end func

func buildExpr(ast: \ast@AstExpr)
	switch(ast.typeId)
	case %expr1
		do @buildExpr1(ast $ \ast@AstExpr1)
	case %expr2
		do @buildExpr2(ast $ \ast@AstExpr2)
	case %expr3
		do @buildExpr3(ast $ \ast@AstExpr3)
	case %exprNew
		do @buildExprNew(ast $ \ast@AstExprNew)
	case %exprNewArray
		do @buildExprNewArray(ast $ \ast@AstExprNewArray)
	case %exprAs
		do @buildExprAs(ast $ \ast@AstExprAs)
	case %exprToBin
		do @buildExprToBin(ast $ \ast@AstExprToBin)
	case %exprFromBin
		do @buildExprFromBin(ast $ \ast@AstExprFromBin)
	case %exprCall
		do @buildExprCall(ast $ \ast@AstExprCall)
	case %exprArray
		do @buildExprArray(ast $ \ast@AstExprArray)
	case %exprDot
		do @buildExprDot(ast $ \ast@AstExprDot)
	case %exprValue
		do @buildExprValue(ast $ \ast@AstExprValue)
	case %exprValuePrim
		do @buildExprValuePrim(ast $ \ast@AstExprValuePrim)
	case %exprValueStr
		do @buildExprValueStr(ast $ \ast@AstExprValueStr)
	case %exprValueFloat
		do @buildExprValueFloat(ast $ \ast@AstExprValueFloat)
	case %exprValueArray
		do @buildExprValueArray(ast $ \ast@AstExprValueArray)
	case %exprRef
		do @buildExprRef(ast $ \ast@AstExpr)
	default
		assert false
	end switch
end func

func buildExpr1(ast: \ast@AstExpr1)
	assert ast.varKind <> %unknown
	switch(ast.kind)
	case %plus
		do @buildExpr(ast.child)
	case %minus
		do @codes.add("-(")
		do @buildExpr(ast.child)
		do @codes.add(")")
	case %not
		do @codes.add("!(")
		do @buildExpr(ast.child)
		do @codes.add(")")
	case %copy
		var typeId: []char :: @makeTypeId(ast.child.type)
		do @codes.add("C_(\{typeId},(")
		do @buildExpr(ast.child)
		do @codes.add("))")
	case %len
		var type: \ast@AstType :: ast.child.type
		if(type.typeId = %typeGen)
			switch((type $ \ast@AstTypeGen).kind)
			case %list_
				do @codes.add("(")
				do @buildExpr(ast.child)
				do @codes.add(").L")
			case %stack_
				do @codes.add("(")
				do @buildExpr(ast.child)
				do @codes.add(").length")
			case %queue_
				do @codes.add("(")
				do @buildExpr(ast.child)
				do @codes.add(").length")
			default
				assert false
			end switch
		elif(type.typeId = %typeDict)
			do @codes.add("(")
			do @buildExpr(ast.child)
			do @codes.add(").size")
		else
			assert type.typeId = %typeArray
			if(\ast@isChar((type $ \ast@AstTypeArray).itemType))
				do @codes.add("(")
				do @buildExpr(ast.child)
				do @codes.add(").S.length")
			else
				do @codes.add("(")
				do @buildExpr(ast.child)
				do @codes.add(").length")
			end if
		end if
	default
		assert false
	end switch
end func

func buildExpr2(ast: \ast@AstExpr2)
	assert ast.varKind <> %unknown
	var type: \ast@AstType :: ast.children0.type
	switch(ast.kind)
	case %assign
		if(ast.children0.typeId = %exprArray & \ast@isChar((ast.children0 $ \ast@AstExprArray).type))
			var ast2: \ast@AstExprArray :: ast.children0 $ \ast@AstExprArray
			var tmpIdx: []char :: @addTmpVar(ast2.idx.type)
			var tmpChar: []char :: @addTmpVar(ast2.type)
			do @codes.add("(")
			do @buildExpr(ast2.var_)
			do @codes.add(").S=(\{tmpIdx}=(")
			do @buildExpr(ast2.idx)
			do @codes.add("),(")
			do @buildExpr(ast2.var_)
			do @codes.add(").S.slice(0,\{tmpIdx})+String.fromCharCode(")
			do @buildExpr(ast.children1)
			do @codes.add(")+(")
			do @buildExpr(ast2.var_)
			do @codes.add(").S.slice(\{tmpIdx}+1))")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(")=(")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %or
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")||(")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %and
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")&&(")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %lt
		if(\ast@isStr(type))
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(").S<(")
			do @buildExpr(ast.children1)
			do @codes.add(").S")
		elif(\ast@isRef(type))
			; TODO:
			do @codes.add("cmp_((")
			do @buildExpr(ast.children0)
			do @codes.add("),(")
			do @buildExpr(ast.children1)
			do @codes.add("))<0")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(")<(")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %gt
		if(\ast@isStr(type))
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(").S>(")
			do @buildExpr(ast.children1)
			do @codes.add(").S")
		elif(\ast@isRef(type))
			; TODO:
			do @codes.add("cmp_((")
			do @buildExpr(ast.children0)
			do @codes.add("),(")
			do @buildExpr(ast.children1)
			do @codes.add("))>0")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(")>(")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %le
		if(\ast@isStr(type))
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(").S<=(")
			do @buildExpr(ast.children1)
			do @codes.add(").S")
		elif(\ast@isRef(type))
			; TODO:
			do @codes.add("cmp_((")
			do @buildExpr(ast.children0)
			do @codes.add("),(")
			do @buildExpr(ast.children1)
			do @codes.add("))<=0")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(")<=(")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %ge
		if(\ast@isStr(type))
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(").S>=(")
			do @buildExpr(ast.children1)
			do @codes.add(").S")
		elif(\ast@isRef(type))
			; TODO:
			do @codes.add("cmp_((")
			do @buildExpr(ast.children0)
			do @codes.add("),(")
			do @buildExpr(ast.children1)
			do @codes.add("))>=0")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(")>=(")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %eq
		if(\ast@isStr(type))
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(").S===(")
			do @buildExpr(ast.children1)
			do @codes.add(").S")
		elif(\ast@isRef(type))
			; TODO:
			do @codes.add("cmp_((")
			do @buildExpr(ast.children0)
			do @codes.add("),(")
			do @buildExpr(ast.children1)
			do @codes.add("))==0")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(")===(")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %nEq
		if(\ast@isStr(type))
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(").S!==(")
			do @buildExpr(ast.children1)
			do @codes.add(").S")
		elif(\ast@isRef(type))
			; TODO:
			do @codes.add("cmp_((")
			do @buildExpr(ast.children0)
			do @codes.add("),(")
			do @buildExpr(ast.children1)
			do @codes.add("))!=0")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(")!==(")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %eqRef
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")===(")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %nEqRef
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")!==(")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %cat
		if(\ast@isStr(type))
			do @codes.add("{S:(")
			do @buildExpr(ast.children0)
			do @codes.add(").S+(")
			do @buildExpr(ast.children1)
			do @codes.add(").S}")
		else
			do @codes.add("(")
			do @buildExpr(ast.children0)
			do @codes.add(").concat(")
			do @buildExpr(ast.children1)
			do @codes.add(")")
		end if
	case %add
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")+(")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %sub
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")-(")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %mul
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")*(")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %div
		if(!\ast@isFloat(type))
			do @codes.add("~~(")
		end if
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")/(")
		do @buildExpr(ast.children1)
		if(!\ast@isFloat(type))
			do @codes.add("))")
		else
			do @codes.add(")")
		end if
	case %mod
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")%(")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %pow
		do @codes.add("(")
		do @buildExpr(ast.children0)
		do @codes.add(")**(")
		do @buildExpr(ast.children1)
		do @codes.add(")")
	case %swap
		var tmpVar: []char :: @addTmpVar(type)
		do @codes.add("\{tmpVar}=(")
		do @buildExpr(ast.children0)
		do @codes.add("),(")
		do @buildExpr(ast.children0)
		do @codes.add(")=(")
		do @buildExpr(ast.children1)
		do @codes.add("),(")
		do @buildExpr(ast.children1)
		do @codes.add(")=(\{tmpVar})")
	default
		assert false
	end switch
end func

func buildExpr3(ast: \ast@AstExpr3)
	assert ast.varKind <> %unknown
	do @codes.add("(")
	do @buildExpr(ast.children0)
	do @codes.add(")?(")
	do @buildExpr(ast.children1)
	do @codes.add("):(")
	do @buildExpr(ast.children2)
	do @codes.add(")")
end func

func buildExprNew(ast: \ast@AstExprNew)
	assert ast.varKind <> %unknown
	if(\ast@isClass(ast.itemType))
		var class_: \ast@AstClass :: ast.itemType.refItem $ \ast@AstClass
		var id: []char :: @refClass(class_)
		do @codes.add("new \{id}()")
	else
		if(ast.itemType.typeId = %typeGen)
			var gen: \ast@AstTypeGen :: ast.itemType $ \ast@AstTypeGen
			switch(gen.kind)
			case %list_
				do @codes.add("{L:0,H:null,T:null,P:null}")
			case %stack_
				do @codes.add("[]")
			case %queue_
				do @codes.add("[]")
			default
				assert false
			end switch
		else
			assert ast.itemType.typeId = %typeDict
			do @codes.add("new Map()")
		end if
	end if
end func

func buildExprNewArray(ast: \ast@AstExprNewArray)
	assert ast.varKind <> %unknown
	block
		var items: list<\ast@AstExpr> :: ast.idces
		do items.head()
		if(\ast@isChar(ast.itemType))
			if(^items = 1)
				do @codes.add("{S:\"\\0\".repeat(")
				do @buildExpr(items.get())
				do @codes.add(")}")
			else
				do @codes.add("(function A_(n){if(n.length===1)return{S:\"\\0\".repeat(\{@getDefaultValue(ast.itemType)})}else{let a=new Array(n[0]),m=n.shift(),i;for(i=0;i<n[0];i++)a[i]=A_(m);return a}})([")
				var first: bool :: true
				while(!items.term())
					if(first)
						do first :: false
					else
						do @codes.add(",(")
					end if
					do @buildExpr(items.get())
					do @codes.add(")")
					do items.next()
				end while
				do @codes.add("])")
			end if
		else
			if(^items = 1)
				do @codes.add("new Array(")
				do @buildExpr(items.get())
				do @codes.add(").fill(\{@getDefaultValue(ast.itemType)})")
			else
				do @codes.add("(function A_(n){if(n.length===1)return new Array(n[0]).fill(\{@getDefaultValue(ast.itemType)})else{let a=new Array(n[0]),m=n.shift(),i;for(i=0;i<n[0];i++)a[i]=A_(m);return a}})([")
				var first: bool :: true
				while(!items.term())
					if(first)
						do first :: false
					else
						do @codes.add(",(")
					end if
					do @buildExpr(items.get())
					do @codes.add(")")
					do items.next()
				end while
				do @codes.add("])")
			end if
		end if
	end block
end func

func buildExprAs(ast: \ast@AstExprAs)
	assert ast.varKind <> %unknown
	switch(ast.kind)
	case %as
		var t1: \ast@AstType :: ast.child.type
		var t2: \ast@AstType :: ast.childType
		if(\ast@isClass(t1))
			assert \ast@isClass(t2)
			do @refClass(t2.refItem $ \ast@AstClass)
			do @buildExpr(ast.child)
		else
			if(t1.typeId = %typeBit | \ast@isInt(t1) | \ast@isChar(t1) | \ast@isEnum(t1))
				if(t2.typeId = %typeBit | \ast@isInt(t2) | \ast@isChar(t2) | \ast@isEnum(t2) | \ast@isFloat(t2))
					do @buildExpr(ast.child)
				else
					assert \ast@isBool(t2)
					do @codes.add("(")
					do @buildExpr(ast.child)
					do @codes.add(")!=0")
				end if
			elif(\ast@isFloat(t1))
				if(t2.typeId = %typeBit | \ast@isInt(t2))
					do @codes.add("~~(")
					do @buildExpr(ast.child)
					do @codes.add(")")
				else
					assert \ast@isFloat(t2)
					do @buildExpr(ast.child)
				end if
			else
				assert \ast@isBool(t1)
				if(t2.typeId = %typeBit | \ast@isInt(t2))
					do @codes.add("(")
					do @buildExpr(ast.child)
					do @codes.add(")?1:0")
				else
					assert \ast@isBool(t2)
					do @buildExpr(ast.child)
				end if
			end if
		end if
	case %is
		do @refClass(ast.childType.refItem $ \ast@AstClass)
		var info: @WebInfo :: @getInfo(ast.childType.refItem)
		do @codes.add("(")
		do @buildExpr(ast.child)
		do @codes.add(")instanceof \{info.id}")
	case %nIs
		do @refClass(ast.childType.refItem $ \ast@AstClass)
		var info: @WebInfo :: @getInfo(ast.childType.refItem)
		do @codes.add("!((")
		do @buildExpr(ast.child)
		do @codes.add(")instanceof \{info.id})")
	default
		assert false
	end switch
end func

func buildExprToBin(ast: \ast@AstExprToBin)
	; TODO:
	assert ast.varKind <> %unknown
	do @codes.add("toBin_(")
	do @buildExpr(ast.child)
	do @codes.add(")")
end func

func buildExprFromBin(ast: \ast@AstExprFromBin)
	; TODO:
	assert ast.varKind <> %unknown
	do @codes.add("fromBin_((")
	do @buildExpr(ast.child)
	do @codes.add("),(")
	do @buildExpr(ast.offset)
	do @codes.add("))")
end func

func buildExprCall(ast: \ast@AstExprCall)
	assert ast.varKind <> %unknown
	var funcType: \ast@AstTypeFunc :: ast.func_.type $ \ast@AstTypeFunc
	var meTypeId: []char :: null
	if(funcType <>& null & funcType.funcOption.and(%any) = %any)
		var items: list<\ast@AstExprCallArg> :: ast.args
		do items.head()
		do meTypeId :: @makeTypeId(items.get().arg.type)
	end if
	var refNum: int :: 0
	block
		var items: list<\ast@AstExprCallArg> :: ast.args
		do items.head()
		while(!items.term())
			if(items.get().refVar)
				do refNum :+ 1
			end if
			do items.next()
		end while
	end block
	var resultVar: []char :: null
	var refVar: [][]char :: null
	if(refNum > 0)
		do @codes.add("(")
		if(ast.type <>& null)
			do resultVar :: @addTmpVar(ast.type)
			do @codes.add("\{resultVar}=")
		end if
		do refVar :: #[refNum][]char
	end if
	do @codes.add("(")
	do @buildExpr(ast.func_)
	do @codes.add(")(")
	block
		var idx: int :: 0
		var refCnt: int :: 0
		var first: bool :: true
		var items: list<\ast@AstExprCallArg> :: ast.args
		do items.head()
		while(!items.term())
			var item: \ast@AstExprCallArg :: items.get()
			if(first)
				do first :: false
				do @codes.add("(")
			else
				do @codes.add(",(")
			end if
			if(meTypeId <>& null & idx = 1)
				do @codes.add(meTypeId)
			elif(item.refVar)
				do refVar[refCnt] :: @addTmpVar(item.arg.type)
				do @codes.add("\{refVar[refCnt]}={$:(")
				do @buildExpr(item.arg)
				do @codes.add(")},\{refVar[refCnt]}")
				do refCnt :+ 1
			else
				do @buildExpr(item.arg)
			end if
			do @codes.add(")")
			do idx :+ 1
			do items.next()
		end while
	end block
	do @codes.add(")")
	if(refNum > 0)
		block
			var idx: int :: 0
			var refCnt: int :: 0
			var items: list<\ast@AstExprCallArg> :: ast.args
			do items.head()
			while(!items.term())
				var item: \ast@AstExprCallArg :: items.get()
				if(meTypeId <>& null & idx = 1)
					; Do nothing.
				elif(item.refVar)
					do @codes.add(",(")
					do @buildExpr(item.arg)
					do @codes.add(")=\{refVar[refCnt]}.$")
					do refCnt :+ 1
				end if
				do idx :+ 1
				do items.next()
			end while
		end block
		if(ast.type <>& null)
			do @codes.add(",\{resultVar}")
		end if
		do @codes.add(")")
	end if
	
	block
		var type: \ast@AstType :: ast.type
		if(type <>& null)
			if(\ast@isClass(type))
				do @refClass(type.refItem $ \ast@AstClass)
			end if
		end if
	end block
end func

func buildExprArray(ast: \ast@AstExprArray)
	assert ast.varKind <> %unknown
	if(\ast@isChar(ast.type))
		do @codes.add("(")
		do @buildExpr(ast.var_)
		do @codes.add(").S.charCodeAt(")
		do @buildExpr(ast.idx)
		do @codes.add(")")
	else
		do @codes.add("(")
		do @buildExpr(ast.var_)
		do @codes.add(")[")
		do @buildExpr(ast.idx)
		do @codes.add("]")
	end if
end func

func buildExprDot(ast: \ast@AstExprDot)
	assert ast.varKind <> %unknown
	if(\ast@isClass(ast.var_.type))
		var classItem: \ast@AstClassItem :: ast.classItem
		assert classItem <>& null
		do @refClass(ast.var_.type.refItem $ \ast@AstClass)
		var info: @WebInfo
		if(classItem.def.typeId = %var_)
			do info :: @getInfo((classItem.def $ \ast@AstVar).arg)
			do @codes.add("(")
			do @buildExpr(ast.var_)
			do @codes.add(").\{info.id}")
		else
			assert classItem.def.typeId = %func_
			do info :: @getInfo(classItem.def)
			; 'ast.var_' is calculated elsewhere.
			do @codes.add("\{info.id}")
		end if
	else
		assert ast.refItem.typeId = %exprRef
		do @buildExprRef(ast.refItem $ \ast@AstExpr)
	end if
end func

func buildExprValue(ast: \ast@AstExprValue)
	assert ast.type.typeId = %typeNull
	do @codes.add("null")
end func

func buildExprValuePrim(ast: \ast@AstExprValuePrim)
	var type: \ast@AstType :: ast.type
	if(\ast@isInt(type) | \ast@isEnum(type))
		do @codes.add((ast.value $ int).toStr())
	elif(\ast@isChar(type))
		do @codes.add((ast.value $ bit16).toStr())
	elif(\ast@isBool(type))
		do @codes.add(ast.value = 0b64 ?("false", "true"))
	elif(type.typeId = %typeBit)
		switch((type $ \ast@AstTypeBit).size)
		case 1
			do @codes.add((ast.value $ bit8).toStr())
		case 2
			do @codes.add((ast.value $ bit16).toStr())
		case 4
			do @codes.add((ast.value $ bit32).toStr())
		case 8
			do @codes.add((ast.value $ bit64).toStr())
		default
			assert false
		end switch
	else
		assert false
	end if
end func

func buildExprValueStr(ast: \ast@AstExprValueStr)
	var value: []char :: ast.value
	var s: []char :: "{S:\""
	for i(0, ^value - 1)
		do s :~ @escapeChar(value[i])
	end for
	do s :~ "\"}"
	do @codes.add(s)
end func

func buildExprValueFloat(ast: \ast@AstExprValueFloat)
	var value: []char :: ast.value.toStr()
	if(value = "inf")
		do @codes.add("Infinity")
	else
		do @codes.add(value)
	end if
end func

func buildExprValueArray(ast: \ast@AstExprValueArray)
	; Note that constant string values are handled by 'ExprValueStr'.
	do @codes.add("[")
	var first: bool :: true
	var items: list<\ast@AstExpr> :: ast.values
	do items.head()
	while(!items.term())
		if(first)
			do first :: false
			do @codes.add("(")
		else
			do @codes.add(",(")
		end if
		do @buildExpr(items.get())
		do @codes.add(")")
		do items.next()
	end while
	do @codes.add("]")
end func

func buildExprRef(ast: \ast@AstExpr)
	var ast2: \ast@Ast :: ast.refItem
	var info: @WebInfo :: @getInfo(ast2)
	if(ast2.typeId = %func_)
		do @funcs.add(ast2 $ \ast@AstFunc)
		do @codes.add(info.id)
	else
		assert ast2.typeId = %arg
		var arg: \ast@AstArg :: ast2 $ \ast@AstArg
		switch(arg.kind)
		case %global
			if(!info.alreadyWritten)
				do info.alreadyWritten :: true
				do @globalVars.add(arg)
			end if
		case %localArg
			; Do nothing.
		case %localVar
			if(!info.alreadyWritten)
				do info.alreadyWritten :: true
				do @localVars.add(arg)
			end if
		default
			assert false
		end switch
		if(arg.refVar)
			do @codes.add("\{info.id}.$")
		else
			do @codes.add(info.id)
		end if
	end if
end func

func write(resFiles: list<[]char>)
	var writer: file@Writer
	do writer :: file@makeWriter(\option@outputFile ~ ".js", false)
	var static: bool :: \option@extra.get("static", &)
	if(static)
		do writer.writeStr("\"use strict\";function \{file@fileName(\option@outputFile)}(O_){\n")
	else
		do writer.writeStr("\"use strict\";!function(f){let d=document;function h(){d.removeEventListener(\"DOMContentLoaded\",h);removeEventListener(\"load\",h);f()}\"complete\"===d.readyState||\"loading\"!==d.readyState&&!d.documentElement.doScroll?setTimeout(f):(d.addEventListener(\"DOMContentLoaded\",h),addEventListener(\"load\",h))}(function(){\n")
		do writer.writeStr("let O_;\n")
	end if
	
	do @globalVars.head()
	while(!@globalVars.term())
		var globalVar: \ast@AstArg :: @globalVars.get()
		var info: @WebInfo :: @getInfo(globalVar)
		do writer.writeStr("let \{info.id}=\{@getDefaultValue(globalVar.type)};\n")
		do @globalVars.next()
	end while
	do @codes.head()
	while(!@codes.term())
		do writer.writeStr(@codes.get())
		do @codes.next()
	end while
	
	do writer.writeStr("function C_(t,v){\n")
	do writer.writeStr("switch(t[0]){\n")
	do writer.writeStr("case \{%int_ $ \convert@runtimeTypeId $ int}:\n")
	do writer.writeStr("case \{%float_ $ \convert@runtimeTypeId $ int}:\n")
	do writer.writeStr("case \{%char_ $ \convert@runtimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bool_ $ \convert@runtimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bit8_ $ \convert@runtimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bit16_ $ \convert@runtimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bit32_ $ \convert@runtimeTypeId $ int}:\n")
	do writer.writeStr("case \{%bit64_ $ \convert@runtimeTypeId $ int}:\n")
	do writer.writeStr("case \{%func_ $ \convert@runtimeTypeId $ int}:\n")
	do writer.writeStr("case \{%enum_ $ \convert@runtimeTypeId $ int}:\n")
	do writer.writeStr("return v;\n")
	do writer.writeStr("case \{%array $ \convert@runtimeTypeId $ int}:\n")
	do writer.writeStr("if(t[1]===\{%char_ $ \convert@runtimeTypeId $ int})\n")
	do writer.writeStr("return v===null?null:{S:v.S};\n")
	do writer.writeStr("else{\n")
	do writer.writeStr("let a=new Array(v.length);\n")
	do writer.writeStr("for(let i=0;i<v.length;i++)a[i]=C_(t.slice(1),v[i]);\n")
	do writer.writeStr("return a;\n")
	do writer.writeStr("}\n")
	do writer.writeStr("case \{%list_ $ \convert@runtimeTypeId $ int}:\n")
	; TODO:
	do writer.writeStr("case \{%stack_ $ \convert@runtimeTypeId $ int}:\n")
	; TODO:
	do writer.writeStr("case \{%queue_ $ \convert@runtimeTypeId $ int}:\n")
	; TODO:
	do writer.writeStr("case \{%dict_ $ \convert@runtimeTypeId $ int}:\n")
	; TODO:
	do writer.writeStr("case \{%class_ $ \convert@runtimeTypeId $ int}:\n")
	; TODO:
	do writer.writeStr("}\n")
	do writer.writeStr("}\n")
	
	do writer.writeStr("function F_(p){\n")
	block
		var first: bool :: true
		do resFiles.head()
		while(!resFiles.term())
			var resFile: []char :: resFiles.get()
			var reader: file@Reader :: file@makeReader(resFile)
			if(first)
				do first :: false
				do writer.writeStr("if(p===\"")
			else
				do writer.writeStr("else if(p===\"")
			end if
			for i(^\option@inputDir, ^resFile - 1)
				do writer.writeStr(@escapeChar(resFile[i]))
			end for
			do writer.writeStr("\")\n")
			do writer.writeStr("return \"")
			while(!reader.term())
				var line: []char :: reader.readLine()
				for i(0, ^line - 1)
					do writer.writeStr(@escapeChar(line[i]))
				end for
				do writer.writeStr("\\n")
			end while
			do writer.writeStr("\";\n")
			do reader.fin()
			do resFiles.next()
		end while
		if(^resFiles > 0)
			do writer.writeStr("else return null;\n")
		else
			do writer.writeStr("return null;\n")
		end if
	end block
	do writer.writeStr("}\n")
	do writer.writeStr("a();\n")
	if(static)
		do writer.writeStr("}\n")
	else
		do writer.writeStr("})\n")
	end if
	do writer.fin()
	
	var fileName: []char :: file@fileName(\option@outputFile)
	do writer :: file@makeWriter(\option@outputFile ~ ".html", false)
	do writer.writeStr("<!DOCTYPE html>\n")
	do writer.writeStr("<html>\n")
	do writer.writeStr("\t<head>\n")
	do writer.writeStr("\t\t<meta charset=\"utf-8\" />\n")
	do writer.writeStr("\t\t<script src=\"\{fileName}.js\" type=\"text/javascript\"></script>\n")
	do writer.writeStr("\t\t<title>\{fileName}</title>\n")
	do writer.writeStr("\t</head>\n")
	do writer.writeStr("\t<body>\n")
	do writer.writeStr("\t</body>\n")
	do writer.writeStr("</html>\n")
	do writer.fin()
end func

func getId(): []char
	var curId: []char :: @uniqueId
	var newId: []char :: ##@uniqueId
	while loop2(true)
		var idx: int :: ^newId - 1
		while loop(true)
			switch(newId[idx])
			case 'z'
				do newId[idx] :: idx = 0 ?('A', '0')
			case '9'
				do newId[idx] :: 'A'
			case 'Z'
				if(idx = 0)
					do newId :: #[^newId + 1]char
					do newId.fill('a')
				else
					do newId[idx] :: 'a'
					do idx :- 1
					skip loop
				end if
			default
				do newId[idx] :: newId[idx].offset(1)
			end switch
			break loop
		end while
		switch(^newId)
		case 2
			switch(newId)
			case "do", "if", "in"
				skip loop2
			end switch
		case 3
			switch(newId)
			case "for", "let", "new", "try", "var", "Map", "NaN", "Set"
				skip loop2
			end switch
		case 4
			switch(newId)
			case "case", "else", "enum", "eval", "name", "null", "this", "true", "void", "with", "Date", "Intl", "JSON", "Math"
				skip loop2
			end switch
		end switch
		break loop2
	end while
	do @uniqueId :: newId
	ret curId
end func

+func getInfo(ast: \ast@Ast): @WebInfo
	if(ast.extra =& null | ast.extra.typeId <> %info)
		var info: @WebInfo :: #@WebInfo
		do info.typeId :: %info
		do info.id :: @getId()
		if(ast.typeId.and(%statBreakable) = %statBreakable & ast.name <>& null & ast.name <> "$")
			do info.breakSkipLabel :: @getId()
		else
			do info.breakSkipLabel :: null
		end if
		do info.alreadyWritten :: false
		do ast.extra :: info
	end if
	ret ast.extra $ @WebInfo
end func

func addTmpVar(type: \ast@AstType): []char
	var tmpVar: @TmpVar :: #@TmpVar
	do tmpVar.identifier :: @getId()
	do tmpVar.type :: type
	do @tmpVars.add(tmpVar)
	ret tmpVar.identifier
end func

func refClass(ast: \ast@AstClass): []char
	var info: @WebInfo :: @getInfo(ast)
	if(info.alreadyWritten)
		ret info.id
	end if
	do info.alreadyWritten :: true
	if(ast.refItem <>& null)
		do @refClass(ast.refItem $ \ast@AstClass)
	end if
	do @classes.add(ast)
	ret info.id
end func

func getDefaultValue(type: \ast@AstType): []char
	if(\ast@isNullable(type))
		ret "null"
	end if
	switch(type.typeId)
	case %typeUser
		assert \ast@isEnum(type)
		ret "0"
	case %typeBit
		ret "0"
	case %typePrim
		switch((type $ \ast@AstTypePrim).kind)
		case %int_, %char_
			ret "0"
		case %float_
			ret "0"
		case %bool_
			ret "false"
		default
			assert false
		end switch
	default
		assert false
	end switch
end func

func makeTypeId(type: \ast@AstType): []char
	var result: []char :: "["
	var first: bool :: true
	var items: list<int> :: \convert@getTypeId(type)
	do items.head()
	while(!items.term())
		if(first)
			do first :: false
		else
			do result :~ ","
		end if
		do result :~ items.get().toStr()
		do items.next()
	end while
	do result :~ "]"
	ret result
end func

func escapeChar(c: char): []char
	switch(c)
	case '"'
		ret "\\\""
	case '\''
		ret "\\'"
	case '\\'
		ret "\\\\"
	case ' ' to '~'
		ret c.toStr()
	default
		ret "\\u\{(c $ bit16).toStr().sub(2, -1)}"
	end switch
end func
